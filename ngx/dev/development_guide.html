<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="nginx," />










<meta name="description" content="dev,development_guide">
<meta name="keywords" content="nginx">
<meta property="og:type" content="article">
<meta property="og:title" content="dev&#x2F;development_guide-nginx中文手册">
<meta property="og:url" content="http://nginx.im/ngx/dev/development_guide.html">
<meta property="og:site_name" content="IM.NGINX">
<meta property="og:description" content="dev,development_guide">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-22T02:27:04.288Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dev&#x2F;development_guide-nginx中文手册">
<meta name="twitter:description" content="dev,development_guide">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://nginx.im/ngx/dev/development_guide.html"/>





  <title>dev/development_guide-nginx中文手册 | IM.NGINX</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8ff19561e3a0e2a31ba9fffe98d8fc00";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IM.NGINX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">运维实践</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://nginx.im/ngx/dev/development_guide.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="IM.NGINX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IM.NGINX">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">dev/development_guide-nginx中文手册</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T10:27:47+08:00">
                2018年12月22日
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nginx中文手册/" itemprop="url" rel="index">
                    <span itemprop="name">nginx中文手册</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>dev,development_guide<br><a id="more"></a></p>
<h2 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h2><td align="left" class="notranslate"> <a href="#introduction">Introduction</a> <br>     <a href="#code_layout">Code layout</a> <br>     <a href="#include_files">Include files</a> <br>     <a href="#integers">Integers</a> <br>     <a href="#common_return_codes">Common return codes</a> <br>     <a href="#error_handling">Error handling</a> <br> <a href="#strings">Strings</a> <br>     <a href="#overview">Overview</a> <br>     <a href="#formatting">Formatting</a> <br>     <a href="#numeric_conversion">Numeric conversion</a> <br>     <a href="#regex">Regular expressions</a> <br> <a href="#time">Time</a> <br> <a href="#containers">Containers</a> <br>     <a href="#array">Array</a> <br>     <a href="#list">List</a> <br>     <a href="#queue">Queue</a> <br>     <a href="#red_black_tree">Red-Black tree</a> <br>     <a href="#hash">Hash</a> <br> <a href="#memory_management">Memory management</a> <br>     <a href="#heap">Heap</a> <br>     <a href="#pool">Pool</a> <br>     <a href="#shared_memory">Shared memory</a> <br> <a href="#logging">Logging</a> <br> <a href="#cycle">Cycle</a> <br> <a href="#buffer">Buffer</a> <br> <a href="#networking">Networking</a> <br>     <a href="#connection">Connection</a> <br> <a href="#events">Events</a> <br>     <a href="#event">Event</a> <br>     <a href="#i_o_events">I/O events</a> <br>     <a href="#timer_events">Timer events</a> <br>     <a href="#posted_events">Posted events</a> <br>     <a href="#event_loop">Event loop</a> <br> <a href="#processes">Processes</a> <br> <a href="#threads">Threads</a> <br> <a href="#Modules">Modules</a> <br>     <a href="#adding_new_modules">Adding new modules</a> <br>     <a href="#core_modules">Core Modules</a> <br>     <a href="#config_directives">Configuration Directives</a> <br> <a href="#http">HTTP</a> <br>     <a href="#http_connection">Connection</a> <br>     <a href="#http_request">Request</a> <br>     <a href="#http_conf">Configuration</a> <br>     <a href="#http_phases">Phases</a> <br>     <a href="#http_variables">Variables</a> <br>     <a href="#http_complex_values">Complex values</a> <br>     <a href="#http_request_redirection">Request redirection</a> <br>     <a href="#http_subrequests">Subrequests</a> <br>     <a href="#http_request_finalization">Request finalization</a> <br>     <a href="#http_request_body">Request body</a> <br>     <a href="#http_response">Response</a> <br>     <a href="#http_response_body">Response body</a> <br>     <a href="#http_body_filters">Body filters</a> <br>     <a href="#http_building_filter_modules">Building filter modules</a> <br>     <a href="#http_body_buffers_reuse">Buffer reuse</a> <br>     <a href="#http_load_balancing">Load balancing</a> <br> <a href="#examples">Examples</a> <br> <a href="#code_style">Code style</a> <br>     <a href="#code_style_general_rules">General rules</a> <br>     <a href="#code_style_files">Files</a> <br>     <a href="#code_style_comments">Comments</a> <br>     <a href="#code_style_preprocessor">Preprocessor</a> <br>     <a href="#code_style_types">Types</a> <br>     <a href="#code_style_variables">Variables</a> <br>     <a href="#code_style_functions">Functions</a> <br>     <a href="#code_style_expressions">Expressions</a> <br>     <a href="#code_style_conditionals_and_loops">Conditionals and Loops</a> <br>     <a href="#code_style_labels">Labels</a> <br></td>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h4 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h4><ul>
<li><p><code>auto</code> - 构建脚本 -  <code>src</code> <ul class="compact"> <li>   <code>core</code> - 基本类型和函数 - 字符串，数组，日志，池等。 -    <code>event</code> - 事件核心 <ul class="compact"><li>   <code>modules</code> - 事件通知模块： <code>epoll</code> ， <code>kqueue</code> ， <code>select</code>等。 -    <code>modules</code> - 其他HTTP模块 -    <code>v2</code> -  HTTP / 2 -  <code>unix</code>  -  <code>win32</code>  </li></ul></li></ul></p>
<h4 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h4><p>以下两个<code>#include</code>语句必须出现在每个nginx文件的开头： </p>
</li>
</ul>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
</pre>

<p>  除此之外，HTTP代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_http.h&gt;
</pre>

<p>  邮件代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_mail.h&gt;
</pre>

<p>  流代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_stream.h&gt;
</pre>

<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>  出于一般目的，nginx代码使用两种整数类型， <code>ngx_int_t</code>和<code>ngx_uint_t</code> ，它们分别是<code>intptr_t</code>和<code>uintptr_t</code> typedef。 </p>
<h4 id="常见的返回码"><a href="#常见的返回码" class="headerlink" title="常见的返回码"></a>常见的返回码</h4><p>   nginx中的大多数函数返回以下代码： </p>
<ul>
<li><p><code>NGX_OK</code> - 操作成功。 -    <code>NGX_ERROR</code> - 操作失败。 -    <code>NGX_AGAIN</code> - 操作不完整;  再次调用该函数。 -    <code>NGX_DECLINED</code> - 例如，操作被拒绝，因为它在配置中被禁用。  这绝不是一个错误。 -    <code>NGX_BUSY</code> - 资源不可用。 -    <code>NGX_DONE</code> - 操作完成或在其他地方继续。  也用作替代成功代码。 -    <code>NGX_ABORT</code> - 功能已中止。  也用作替代错误代码。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p><code>ngx_errno</code>宏返回上一个系统错误代码。  它映射到POSIX平台上的<code>errno</code>和Windows中的<code>GetLastError()</code>调用。   <code>ngx_socket_errno</code>宏返回最后一个套接字错误号。  与<code>ngx_errno</code>宏一样，它映射到POSIX平台上的<code>errno</code> 。  它映射到Windows上的<code>WSAGetLastError()</code>调用。   <code>ngx_socket_errno</code>多次访问<code>ngx_errno</code>或<code>ngx_socket_errno</code>的值可能会导致性能问题。  如果可能多次使用错误值，请将其存储在<code>ngx_err_t</code>类型的本地变量中。  要设置错误，请使用<code>ngx_set_errno(errno)</code>和<code>ngx_set_socket_errno(errno)</code>宏。 </p>
<p><code>ngx_errno</code>和<code>ngx_socket_errno</code>的值可以传递给日志函数<code>ngx_log_error()</code>和<code>ngx_log_debugX()</code> ，在这种情况下，系统错误文本将添加到日志消息中。 </p>
<p>使用<code>ngx_errno</code>示例： </p>
</li>
</ul>
<pre class="notranslate">void
ngx_my_kill(ngx_pid_t pid, ngx_log_t *log, int signo)
{
    ngx_err_t  err;

    if (kill(pid, signo) == -1) {
        err = ngx_errno;

        ngx_log_error(NGX_LOG_ALERT, log, err, "kill(%P, %d) failed", pid, signo);

        if (err == NGX_ESRCH) {
            return 2;
        }

        return 1;
    }

    return 0;
}
</pre>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p>  对于C字符串，nginx使用无符号字符类型指针<code>u_char *</code> 。 </p>
<p>   nginx字符串类型<code>ngx_str_t</code>定义如下： </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p>   <code>len</code>字段保存字符串长度， <code>data</code>保存字符串数据。  保存在<code>ngx_str_t</code>中的<code>ngx_str_t</code>在<code>len</code>字节之后可能会或可能不会以空值终止。  在大多数情况下，事实并非如此。  但是，在代码的某些部分（例如，在解析配置时），已知<code>ngx_str_t</code>对象以空值终止，这简化了字符串比较并使字符串更容易传递给系统调用。 </p>
<p>   nginx中的字符串操作在<code>src/core/ngx_string.h</code>中声明。其中一些是围绕标准C函数的包装器： </p>
<ul>
<li><code>ngx_strcmp()</code>  -  <code>ngx_strncmp()</code>  -  <code>ngx_strstr()</code>  -  <code>ngx_strlen()</code>  -  <code>ngx_strchr()</code>  -  <code>ngx_memcmp()</code>  -  <code>ngx_memset()</code>  -  <code>ngx_memcpy()</code>  -  <code>ngx_memmove()</code>  </li>
</ul>
<p>  其他字符串函数是特定于nginx的 </p>
<ul>
<li><code>ngx_memzero()</code> - 用零填充内存。 -    <code>ngx_explicit_memzero()</code> - 与<code>ngx_memzero()</code>相同，但编译器的死存储消除优化永远不会删除此调用。  此功能可用于清除密码和密钥等敏感数据。 -    <code>ngx_cpymem()</code> - 与<code>ngx_memcpy()</code>相同，但返回最终目标地址这个可以方便地连续添加多个字符串。 -    <code>ngx_movemem()</code> - 与<code>ngx_memmove()</code>相同，但返回最终目标地址。 -    <code>ngx_strlchr()</code> - 搜索字符串中的字符，由两个指针分隔。 </li>
</ul>
<p>  以下函数执行大小写转换和比较： </p>
<ul>
<li><code>ngx_tolower()</code>  -  <code>ngx_toupper()</code>  -  <code>ngx_strlow()</code>  -  <code>ngx_strcasecmp()</code>  -  <code>ngx_strncasecmp()</code>  </li>
</ul>
<p>  以下宏简化了字符串初始化： </p>
<ul>
<li><p><code>ngx_string(text)</code> - 来自C字符串文字<code>text</code>的<code>ngx_str_t</code>类型的静态初始值设定项 -    <code>ngx_null_string</code> - <code>ngx_str_t</code>类型的静态空字符串初始值设定项 -    <code>ngx_str_set(str, text)</code> - 使用C字符串文字<code>text</code>初始化<code>ngx_str_t *</code> type的字符串<code>str</code> -    <code>ngx_str_null(str)</code> - 使用空字符串初始化<code>ngx_str_t *</code> type的字符串<code>str</code> </p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>以下格式化函数支持特定于nginx的类型： </p>
</li>
</ul>
<ul>
<li><code>ngx_sprintf(buf, fmt, ...)</code>  -  <code>ngx_snprintf(buf, max, fmt, ...)</code>  -  <code>ngx_slprintf(buf, last, fmt, ...)</code>  -  <code>ngx_vslprintf(buf, last, fmt, args)</code>  -  <code>ngx_vsnprintf(buf, max, fmt, args)</code>  </li>
</ul>
<p>  这些函数支持的格式化选项的完整列表位于<code>src/core/ngx_string.c</code> 。  他们之中有一些是： </p>
<ul>
<li><p><code>%O</code> - <code>off_t</code> -    <code>%T</code> - <code>time_t</code> -    <code>%z</code> - <code>ssize_t</code> -    <code>%i</code> - <code>ngx_int_t</code> -    <code>%p</code> - <code>void *</code> -    <code>%V</code> - <code>ngx_str_t *</code> -    <code>%s</code> - <code>u_char *</code> （以null结尾） -    <code>%*s</code> - <code>size_t + u_char *</code><br>您可以在大多数类型上添加前缀以使其无符号。  要将输出转换为十六进制，请使用<code>X</code>或<code>x</code> 。 </p>
<p>例如： </p>
</li>
</ul>
<pre class="notranslate">u_char      buf[NGX_INT_T_LEN];
size_t      len;
ngx_uint_t  n;

/* set n here */

len = ngx_sprintf(buf, "%ui", n) — buf;
</pre>



<h4 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h4><p>  在nginx中实现了几个用于数值转换的函数。  前四个每个都将给定长度的字符串转换为指定类型的正整数。  它们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atoi(line, n)</code> - <code>ngx_int_t</code> -    <code>ngx_atosz(line, n)</code> - <code>ssize_t</code> -    <code>ngx_atoof(line, n)</code> - <code>off_t</code> -    <code>ngx_atotm(line, n)</code> - <code>time_t</code> </li>
</ul>
<p>  还有两个额外的数字转换函数。  与前四个一样，他们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atofp(line, n, point)</code> - 将给定长度的固定点浮点数转换为<code>ngx_int_t</code>类型的正整数。  结果左移小数点位置。  数字的字符串表示形式预计不会超过小数位数。  例如， <code>ngx_atofp(&quot;10.5&quot;, 4, 2)</code>返回<code>1050</code> 。 -    <code>ngx_hextoi(line, n)</code> - 将正整数的十六进制表示形式转换为<code>ngx_int_t</code> 。 </li>
</ul>
<h4 id="常用表达"><a href="#常用表达" class="headerlink" title="常用表达"></a>常用表达</h4><p>   nginx中的正则表达式接口是<a href="http://www.pcre.org" target="_blank" rel="noopener">PCRE</a>库的包装器。  相应的头文件是<code>src/core/ngx_regex.h</code> 。 </p>
<p>  要使用正则表达式进行字符串匹配，首先需要编译它，这通常在配置阶段完成。  请注意，由于PCRE支持是可选的，因此使用该接口的所有代码都必须受到周围<code>NGX_PCRE</code>宏的保护： </p>
<pre class="notranslate">#if (NGX_PCRE)
ngx_regex_t          *re;
ngx_regex_compile_t   rc;

u_char                errstr[NGX_MAX_CONF_ERRSTR];

ngx_str_t  value = ngx_string("message (\\d\\d\\d).*Codeword is '(?&lt;cw&gt;\\w+)'");

ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t));

rc.pattern = value;
rc.pool = cf-&gt;pool;
rc.err.len = NGX_MAX_CONF_ERRSTR;
rc.err.data = errstr;
/* rc.options are passed as is to pcre_compile() */

if (ngx_regex_compile(&amp;rc) != NGX_OK) {
    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &amp;rc.err);
    return NGX_CONF_ERROR;
}

re = rc.regex;
#endif
</pre>

<p>  编译成功后， <code>ngx_regex_compile_t</code>结构中的<code>ngx_regex_compile_t</code>和<code>named_captures</code>字段<code>ngx_regex_compile_t</code>包含正则表达式中的所有捕获和命名捕获的计数。 </p>
<p>  然后可以使用编译的正则表达式来匹配字符串： </p>
<pre class="notranslate">ngx_int_t  n;
int        captures[(1 + rc.captures) * 3];

ngx_str_t input = ngx_string("This is message 123. Codeword is 'foobar'.");

n = ngx_regex_exec(re, &amp;input, captures, (1 + rc.captures) * 3);
if (n &gt;= 0) {
    /* string matches expression */

} else if (n == NGX_REGEX_NO_MATCHED) {
    /* no match was found */

} else {
    /* some error */
    ngx_log_error(NGX_LOG_ALERT, log, 0, ngx_regex_exec_n " failed: %i", n);
}
</pre>

<p>   <code>ngx_regex_exec()</code>的参数是编译的正则表达式<code>re</code> ，匹配<code>s</code>的字符串，用于保存找到的任何<code>captures</code>的可选整数数组以及数组的<code>size</code> 。  根据<a href="http://www.pcre.org/original/doc/html/pcreapi.html" target="_blank" rel="noopener">PCRE API的</a>要求， <code>captures</code>数组的大小必须是三的倍数。  在该示例中，大小是根据匹配的字符串本身的总捕获数加<code>1</code> 。 </p>
<p>  如果有匹配，则可以按如下方式访问捕获： </p>
<pre class="notranslate">u_char     *p;
size_t      size;
ngx_str_t   name, value;

/* all captures */
for (i = 0; i &lt; n * 2; i += 2) {
    value.data = input.data + captures[i];
    value.len = captures[i + 1] — captures[i];
}

/* accessing named captures */

size = rc.name_size;
p = rc.names;

for (i = 0; i &lt; rc.named_captures; i++, p += size) {

    /* capture name */
    name.data = &amp;p[2];
    name.len = ngx_strlen(name.data);

    n = 2 * ((p[0] &lt;&lt; 8) + p[1]);

    /* captured value */
    value.data = &amp;input.data[captures[n]];
    value.len = captures[n + 1] — captures[n];
}
</pre>



<p>   <code>ngx_regex_exec_array()</code>函数接受<code>ngx_regex_elt_t</code>元素的数组（它们只是具有关联名称的已编译正则表达式），要匹配的字符串和日志。  该函数将表达式从数组应用到字符串，直到找到匹配或不再有表达式为止。  当匹配时返回值为<code>NGX_OK</code> ，否则<code>NGX_ERROR</code> ，如果出错则返回值为<code>NGX_OK</code> 。 </p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>   <code>ngx_time_t</code>结构表示具有三种不同类型的时间，包括秒，毫秒和GMT偏移量： </p>
<pre class="notranslate">typedef struct {
    time_t      sec;
    ngx_uint_t  msec;
    ngx_int_t   gmtoff;
} ngx_time_t;
</pre>

<p>   <code>ngx_tm_t</code>结构是UNIX平台上的<code>struct tm</code>和Windows上的<code>SYSTEMTIME</code>的别名。 </p>
<p>  要获得当前时间，通常可以访问其中一个可用的全局变量，表示所需格式的缓存时间值。 </p>
<p>  可用的字符串表示形式为： </p>
<ul>
<li><code>ngx_cached_err_log_time</code> - 用于错误日志条目： <code>&quot;1970/09/28 12:00:00&quot;</code> -    <code>ngx_cached_http_log_time</code> - 用于HTTP访问日志条目： <code>&quot;28/Sep/1970:12:00:00 +0600&quot;</code> -    <code>ngx_cached_syslog_time</code> - 用于syslog条目： <code>&quot;Sep 28 12:00:00&quot;</code> -    <code>ngx_cached_http_time</code> - 用于HTTP标头： <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> -    <code>ngx_cached_http_log_iso8601</code> -  ISO 8601标准格式： <code>&quot;1970-09-28T12:00:00+06:00&quot;</code> </li>
</ul>
<p>   <code>ngx_time()</code>和<code>ngx_timeofday()</code>宏以秒为单位返回当前时间值，是访问缓存时间值的首选方法。 </p>
<p>  要显式获取时间，请使用<code>ngx_gettimeofday()</code> ，它更新其参数（指向<code>struct timeval</code>指针）。  当nginx从系统调用返回到事件循环时，时间总是更新。  要立即更新时间，请在信号处理程序上下文中更新时间时调用<code>ngx_time_update()</code>或<code>ngx_time_sigsafe_update()</code> 。 </p>
<p>  以下函数将<code>time_t</code>转换为指示的细分时间表示。  每对中的第一个函数将<code>time_t</code>转换为<code>ngx_tm_t</code> ，将第二个函数（使用<code>_libc_</code> infix）转换为<code>struct tm</code> ： </p>
<ul>
<li><code>ngx_gmtime(), ngx_libc_gmtime()</code> - 以UTC表示的时间 -    <code>ngx_localtime(), ngx_libc_localtime()</code> - 相对于本地时区表示的时间<br><code>ngx_http_time(buf, time)</code>函数返回适合在HTTP头中使用的字符串表示（例如， <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> ）。   <code>ngx_http_cookie_time(buf, time)</code>返回一个字符串表示函数，返回一个适合HTTP cookie的字符串表示（ <code>&quot;Thu, 31-Dec-37 23:55:55 GMT&quot;</code> ）。 </li>
</ul>
<h4 id="集装箱"><a href="#集装箱" class="headerlink" title="集装箱"></a>集装箱</h4><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>   nginx数组类型<code>ngx_array_t</code>定义如下 </p>
<pre class="notranslate">typedef struct {
    void        *elts;
    ngx_uint_t   nelts;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *pool;
} ngx_array_t;
</pre>

<p>   <code>elts</code>字段中提供了数组的元素。   <code>nelts</code>字段包含元素的数量。   <code>size</code>字段保存单个元素的大小，并在初始化数组时设置。 </p>
<p>  使用<code>ngx_array_create(pool, n, size)</code>调用在池中创建数组，并使用<code>ngx_array_init(array, pool, n, size)</code>调用来初始化已分配的数组对象。 </p>
<pre class="notranslate">ngx_array_t  *a, b;

/* create an array of strings with preallocated memory for 10 elements */
a = ngx_array_create(pool, 10, sizeof(ngx_str_t));

/* initialize string array for 10 elements */
ngx_array_init(&amp;b, pool, 10, sizeof(ngx_str_t));
</pre>

<p>  使用以下函数将元素添加到数组： </p>
<ul>
<li><code>ngx_array_push(a)</code>添加一个尾部元素并返回指向它的指针 -    <code>ngx_array_push_n(a, n)</code>添加<code>n</code>尾部元素并返回指向第一个元素的指针 </li>
</ul>
<p>  如果当前分配的内存量不足以容纳新元素，则分配新的内存块并将现有元素复制到其中。  新内存块通常是现有内存块的两倍。 </p>
<pre class="notranslate">s = ngx_array_push(a);
ss = ngx_array_push_n(&amp;b, 3);
</pre>

<h4 id="名单"><a href="#名单" class="headerlink" title="名单"></a>名单</h4><p>  在nginx中，列表是一系列数组，针对插入可能大量的项进行了优化。   <code>ngx_list_t</code>列表类型定义如下： </p>
<pre class="notranslate">typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p>  实际项目存储在列表部分中，其定义如下： </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};
</pre>

<p>  在使用之前，必须通过调用<code>ngx_list_init(list, pool, n, size)</code>或通过调用<code>ngx_list_create(pool, n, size)</code>创建列表来初始化<code>ngx_list_init(list, pool, n, size)</code> 。  这两个函数都将单个项的大小和每个列表部分的项数作为参数。  要将项添加到列表，请使用<code>ngx_list_push(list)</code>函数。  要迭代这些项，请直接访问列表字段，如示例所示： </p>
<pre class="notranslate">ngx_str_t        *v;
ngx_uint_t        i;
ngx_list_t       *list;
ngx_list_part_t  *part;

list = ngx_list_create(pool, 100, sizeof(ngx_str_t));
if (list == NULL) { /* error */ }

/* add items to the list */

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "foo");

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "bar");

/* iterate over the list */

part = &amp;list-&gt;part;
v = part-&gt;elts;

for (i = 0; /* void */; i++) {

    if (i &gt;= part-&gt;nelts) {
        if (part-&gt;next == NULL) {
            break;
        }

        part = part-&gt;next;
        v = part-&gt;elts;
        i = 0;
    }

    ngx_do_smth(&amp;v[i]);
}
</pre>

<p>  列表主要用于HTTP输入和输出标头。 </p>
<p>  列表不支持删除项目。  但是，在需要时，项目可以在内部被标记为缺失，而不会实际从列表中删除。  例如，要将HTTP输出标头（存储为<code>ngx_table_elt_t</code>对象）标记为缺失，请将<code>ngx_table_elt_t</code>的<code>hash</code>字段设置为零。  迭代标题时，显式跳过以这种方式标记的项目。 </p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>  在nginx中，队列是一个侵入式双向链表，每个节点定义如下： </p>
<pre class="notranslate">typedef struct ngx_queue_s  ngx_queue_t;

struct ngx_queue_s {
    ngx_queue_t  *prev;
    ngx_queue_t  *next;
};
</pre>

<p>  头队列节点未与任何数据链接。  使用前，请使用<code>ngx_queue_init(q)</code>调用初始化列表头。  队列支持以下操作： </p>
<ul>
<li><code>ngx_queue_insert_head(h, x)</code> ， <code>ngx_queue_insert_tail(h, x)</code> - 插入新节点 -    <code>ngx_queue_remove(x)</code> - 删除队列节点 -    <code>ngx_queue_split(h, q, n)</code> - 在一个节点上拆分队列，将队列尾部返回到一个单独的队列中 -    <code>ngx_queue_add(h, n)</code> - 将第二个队列添加到第一个队列 -    <code>ngx_queue_head(h)</code> ， <code>ngx_queue_last(h)</code> - 获取第一个或最后一个队列节点 -    <code>ngx_queue_sentinel(h)</code> - 获取队列sentinel对象以结束迭代 -    <code>ngx_queue_data(q, type, link)</code> - 获取对队列节点数据结构开头的引用，考虑其中的队列字段偏移量 </li>
</ul>
<p>  一个例子： </p>
<pre class="notranslate">typedef struct {
    ngx_str_t    value;
    ngx_queue_t  queue;
} ngx_foo_t;

ngx_foo_t    *f;
ngx_queue_t   values, *q;

ngx_queue_init(&amp;values);

f = ngx_palloc(pool, sizeof(ngx_foo_t));
if (f == NULL) { /* error */ }
ngx_str_set(&amp;f-&gt;value, "foo");

ngx_queue_insert_tail(&amp;values, &amp;f-&gt;queue);

/* insert more nodes here */

for (q = ngx_queue_head(&amp;values);
     q != ngx_queue_sentinel(&amp;values);
     q = ngx_queue_next(q))
{
    f = ngx_queue_data(q, ngx_foo_t, queue);

    ngx_do_smth(&amp;f-&gt;value);
}
</pre>

<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>   <code>src/core/ngx_rbtree.h</code>头文件提供了对红黑树的有效实现的访问。 </p>
<pre class="notranslate">typedef struct {
    ngx_rbtree_t       rbtree;
    ngx_rbtree_node_t  sentinel;

    /* custom per-tree data here */
} my_tree_t;

typedef struct {
    ngx_rbtree_node_t  rbnode;

    /* custom per-node data */
    foo_t              val;
} my_node_t;
</pre>

<p>  要处理整个树，需要两个节点：root和sentinel。  通常，它们会添加到自定义结构中，允许您将数据组织到树中，其中树叶包含指向或嵌入数据的链接。 </p>
<p>  要初始化树： </p>
<pre class="notranslate">my_tree_t  root;

ngx_rbtree_init(&amp;root.rbtree, &amp;root.sentinel, insert_value_function);
</pre>

<p>  要遍历树并插入新值，请使用“ <code>insert_value</code> ”函数。  例如， <code>ngx_str_rbtree_insert_value</code>函数处理<code>ngx_str_t</code>类型。  它的参数是指向插入的根节点，要添加的新创建的节点以及树的标记的指针。 </p>
<pre class="notranslate">void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp,
                                 ngx_rbtree_node_t *node,
                                 ngx_rbtree_node_t *sentinel)
</pre>

<p>  遍历非常简单，可以使用以下查找函数模式进行演示： </p>
<pre class="notranslate">my_node_t *
my_rbtree_lookup(ngx_rbtree_t *rbtree, foo_t *val, uint32_t hash)
{
    ngx_int_t           rc;
    my_node_t          *n;
    ngx_rbtree_node_t  *node, *sentinel;

    node = rbtree-&gt;root;
    sentinel = rbtree-&gt;sentinel;

    while (node != sentinel) {

        n = (my_node_t *) node;

        if (hash != node-&gt;key) {
            node = (hash &lt; node-&gt;key) ? node-&gt;left : node-&gt;right;
            continue;
        }

        rc = compare(val, node-&gt;val);

        if (rc &lt; 0) {
            node = node-&gt;left;
            continue;
        }

        if (rc &gt; 0) {
            node = node-&gt;right;
            continue;
        }

        return n;
    }

    return NULL;
}
</pre>

<p>   <code>compare()</code>函数是一个经典的比较器函数，它返回一个小于，等于或大于零的值。  为了加速查找并避免比较可能很大的用户对象，使用整数哈希字段。 </p>
<p>  要将节点添加到树，请分配新节点，对其进行初始化并调用<code>ngx_rbtree_insert()</code> ： </p>
<pre class="notranslate">    my_node_t          *my_node;
    ngx_rbtree_node_t  *node;

    my_node = ngx_palloc(...);
    init_custom_data(&amp;my_node-&gt;val);

    node = &amp;my_node-&gt;rbnode;
    node-&gt;key = create_key(my_node-&gt;val);

    ngx_rbtree_insert(&amp;root-&gt;rbtree, node);
</pre>

<p>  要删除节点，请调用<code>ngx_rbtree_delete()</code>函数： </p>
<pre class="notranslate">ngx_rbtree_delete(&amp;root-&gt;rbtree, node);
</pre>

<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>  散列表函数在<code>src/core/ngx_hash.h</code> 。  支持精确匹配和通配符匹配。  后者需要额外的设置，并在下面的单独部分中描述。 </p>
<p>  在初始化哈希之前，您需要知道它将保留的元素数量，以便nginx可以最佳地构建它。  需要配置的两个参数是<code>max_size</code>和<code>bucket_size</code> ，详见单独的<a href="hash.html">文档</a> 。  它们通常可由用户配置。  散列初始化设置与<code>ngx_hash_init_t</code>类型一起存储，散列本身为<code>ngx_hash_t</code> ： </p>
<pre class="notranslate">ngx_hash_t       foo_hash;
ngx_hash_init_t  hash;

hash.hash = &amp;foo_hash;
hash.key = ngx_hash_key;
hash.max_size = 512;
hash.bucket_size = ngx_align(64, ngx_cacheline_size);
hash.name = "foo_hash";
hash.pool = cf-&gt;pool;
hash.temp_pool = cf-&gt;temp_pool;
</pre>

<p>   <code>key</code>是指向函数的指针，该函数从字符串创建哈希整数键。  有两个通用的密钥创建函数： <code>ngx_hash_key(data, len)</code>和<code>ngx_hash_key_lc(data, len)</code> 。  后者将字符串转换为全部小写字符，因此传递的字符串必须是可写的。  如果不是这样，将<code>NGX_HASH_READONLY_KEY</code>标志传递给函数，初始化密钥数组（见下文）。 </p>
<p>  散列键存储在<code>ngx_hash_keys_arrays_t</code> ，并使用<code>ngx_hash_keys_array_init(arr, type)</code>初始化：第二个参数（ <code>type</code> ）控制为散列预分配的资源量，可以是<code>NGX_HASH_SMALL</code>或<code>NGX_HASH_LARGE</code> 。  如果您希望散列包含数千个元素，则后者是合适的。 </p>
<pre class="notranslate">ngx_hash_keys_arrays_t  foo_keys;

foo_keys.pool = cf-&gt;pool;
foo_keys.temp_pool = cf-&gt;temp_pool;

ngx_hash_keys_array_init(&amp;foo_keys, NGX_HASH_SMALL);
</pre>



<p>  要将键插入哈希键数组，请使用<code>ngx_hash_add_key(keys_array, key, value, flags)</code>函数： </p>
<pre class="notranslate">ngx_str_t k1 = ngx_string("key1");
ngx_str_t k2 = ngx_string("key2");

ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;my_data_ptr_1, NGX_HASH_READONLY_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;my_data_ptr_2, NGX_HASH_READONLY_KEY);
</pre>



<p>  要构建哈希表，请调用<code>ngx_hash_init(hinit, key_names, nelts)</code>函数： </p>
<pre class="notranslate">ngx_hash_init(&amp;hash, foo_keys.keys.elts, foo_keys.keys.nelts);
</pre>

<p>  如果<code>max_size</code>或<code>bucket_size</code>参数不够大，则该函数失败。 </p>
<p>  构建哈希时，使用<code>ngx_hash_find(hash, key, name, len)</code>函数查找元素： </p>
<pre class="notranslate">my_data_t   *data;
ngx_uint_t   key;

key = ngx_hash_key(k1.data, k1.len);

data = ngx_hash_find(&amp;foo_hash, key, k1.data, k1.len);
if (data == NULL) {
    /* key not found */
}
</pre>



<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><p>  要创建使用通配符的哈希，请使用<code>ngx_hash_combined_t</code>类型。  它包括上面描述的散列类型，并有两个额外的键数组： <code>dns_wc_head</code>和<code>dns_wc_tail</code> 。  基本属性的初始化类似于常规哈希： </p>
<pre class="notranslate">ngx_hash_init_t      hash
ngx_hash_combined_t  foo_hash;

hash.hash = &amp;foo_hash.hash;
hash.key = ...;
</pre>



<p>  可以使用<code>NGX_HASH_WILDCARD_KEY</code>标志添加通配符键： </p>
<pre class="notranslate">/* k1 = ".example.org"; */
/* k2 = "foo.*";        */
ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;data1, NGX_HASH_WILDCARD_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;data2, NGX_HASH_WILDCARD_KEY);
</pre>

<p>  该函数识别通配符并将键添加到相应的数组中。  有关通配符语法和匹配算法的说明，请参阅<a href="http/ngx_http_map_module.html#map">映射</a>模块文档。 </p>
<p>  根据添加的键的内容，您可能需要初始化最多三个键阵列：一个用于精确匹配（如上所述），另外两个用于从字符串的头部或尾部开始匹配： </p>
<pre class="notranslate">if (foo_keys.dns_wc_head.nelts) {

    ngx_qsort(foo_keys.dns_wc_head.elts,
              (size_t) foo_keys.dns_wc_head.nelts,
              sizeof(ngx_hash_key_t),
              cmp_dns_wildcards);

    hash.hash = NULL;
    hash.temp_pool = pool;

    if (ngx_hash_wildcard_init(&amp;hash, foo_keys.dns_wc_head.elts,
                               foo_keys.dns_wc_head.nelts)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    foo_hash.wc_head = (ngx_hash_wildcard_t *) hash.hash;
}
</pre>

<p>  需要对keys数组进行排序，并且必须将初始化结果添加到组合哈希中。   <code>dns_wc_tail</code>数组的初始化类似地完成。 </p>
<p>  组合哈希中的查找由<code>ngx_hash_find_combined(chash, key, name, len)</code> ： </p>
<pre class="notranslate">/* key = "bar.example.org"; — will match ".example.org" */
/* key = "foo.example.com"; — will match "foo.*"        */

hkey = ngx_hash_key(key.data, key.len);
res = ngx_hash_find_combined(&amp;foo_hash, hkey, key.data, key.len);
</pre>



<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>  要从系统堆分配内存，请使用以下函数： </p>
<ul>
<li><code>ngx_alloc(size, log)</code> - 从系统堆分配内存。  这是<code>malloc()</code>的包装，具有日志记录支持。  分配错误和调试信息将记录到<code>log</code> 。 -    <code>ngx_calloc(size, log)</code> - 从系统堆分配内存，如<code>ngx_alloc()</code> ，但在分配后用零填充内存。 -    <code>ngx_memalign(alignment, size, log)</code> - 从系统堆中分配对齐的内存。  这是提供该功能的那些平台上<code>posix_memalign()</code>的包装器。  否则，实现将回<code>ngx_alloc()</code> ，它提供了最大的对齐。 -    <code>ngx_free(p)</code> - 免费分配的内存。  这是<code>free()</code>的包装器 </li>
</ul>
<h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>  大多数nginx分配都是在池中完成的。  当池被销毁时，nginx池中分配的内存将自动释放。  这提供了良好的分配性能并使内存控制变得容易。 </p>
<p>  池内部在连续的内存块中分配对象。  块已满后，将分配一个新块并将其添加到池内存块列表中。  当请求的分配太大而无法容纳到块中时，请求将被转发到系统分配器，并且返回的指针将存储在池中以进一步解除分配。 </p>
<p>   nginx池的类型是<code>ngx_pool_t</code> 。  支持以下操作： </p>
<ul>
<li><code>ngx_create_pool(size, log)</code> - 创建具有指定块大小的池。  返回的池对象也在池中分配。   <code>size</code>至少应为<code>NGX_MIN_POOL_SIZE</code>和<code>NGX_MIN_POOL_SIZE</code>的倍数。 -    <code>ngx_destroy_pool(pool)</code> - 释放所有池内存，包括池对象本身。 -    <code>ngx_palloc(pool, size)</code> - 从指定的池中分配对齐的内存。 -    <code>ngx_pcalloc(pool, size)</code> - 从指定的池中分配对齐的内存并用零填充它。 -    <code>ngx_pnalloc(pool, size)</code> - 从指定的池中分配未对齐的内存。  主要用于分配字符串。 -    <code>ngx_pfree(pool, p)</code> - 以前在指定池中分配的<code>ngx_pfree(pool, p)</code>内存。  只能释放由转发到系统分配器的请求产生的分配。 </li>
</ul>
<pre class="notranslate">u_char      *p;
ngx_str_t   *s;
ngx_pool_t  *pool;

pool = ngx_create_pool(1024, log);
if (pool == NULL) { /* error */ }

s = ngx_palloc(pool, sizeof(ngx_str_t));
if (s == NULL) { /* error */ }
ngx_str_set(s, "foo");

p = ngx_pnalloc(pool, 3);
if (p == NULL) { /* error */ }
ngx_memcpy(p, "foo", 3);
</pre>

<p>  链接（ <code>ngx_chain_t</code> ）在nginx中被主动使用，因此nginx池实现提供了重用它们的方法。   <code>ngx_pool_t</code>的<code>chain</code>字段保留了先前分配的链接列表，可以重用。  要在池中有效分配链路链接，请使用<code>ngx_alloc_chain_link(pool)</code>功能。  此函数在池列表中查找自由链链接，并在池列表为空时分配新的链链接。  要释放链接，请调用<code>ngx_free_chain(pool, cl)</code>函数。 </p>
<p>  清理处理程序可以在池中注册。  清理处理程序是一个带有参数的回调函数，该函数在销毁池时调用。  池通常绑定到特定的nginx对象（如HTTP请求），并在对象到达其生命周期结束时被销毁。  注册池清理是释放资源，关闭文件描述符或对与主对象关联的共享数据进行最终调整的便捷方式。 </p>
<p>  要注册池清理，请调用<code>ngx_pool_cleanup_add(pool, size)</code> ，它返回一个要由调用者填写的<code>ngx_pool_cleanup_t</code>指针。  使用<code>size</code>参数为清理处理程序分配上下文。 </p>
<pre class="notranslate">ngx_pool_cleanup_t  *cln;

cln = ngx_pool_cleanup_add(pool, 0);
if (cln == NULL) { /* error */ }

cln-&gt;handler = ngx_my_cleanup;
cln-&gt;data = "foo";

...

static void
ngx_my_cleanup(void *data)
{
    u_char  *msg = data;

    ngx_do_smth(msg);
}
</pre>

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>   nginx使用共享内存在进程之间共享公共数据。   <code>ngx_shared_memory_add(cf, name, size, tag)</code>函数将新的共享内存条目<code>ngx_shm_zone_t</code>到循环中。  该函数接收区域的<code>name</code>和<code>size</code> 。  每个共享区域必须具有唯一名称。  如果已存在具有提供的<code>name</code>和<code>tag</code>的共享区域条目，则重用现有区域条目。  如果具有相同名称的现有条目具有不同的标记，则该函数将失败并显示错误。  通常，模块结构的地址作为<code>tag</code>传递，从而可以在一个nginx模块中按名称重用共享区域。 </p>
<p>  共享内存条目结构<code>ngx_shm_zone_t</code>具有以下字段： </p>
<ul>
<li><code>init</code> - 初始化回调，在共享区域映射到实际内存后调用 -    <code>data</code> - 数据上下文，用于将任意数据传递给<code>init</code>回调 -    <code>noreuse</code> - 禁用旧循环重用共享区域的标志 -    <code>tag</code> - 共享区域标记 -    <code>shm</code> - 类型为<code>ngx_shm_t</code>的特定于平台的对象，至少包含以下字段： <ul class="compact"><li>   <code>addr</code> - 映射共享内存地址，最初为NULL -    <code>size</code> - 共享内存大小 -    <code>name</code> - 共享内存名称 -    <code>log</code> - 共享内存日志 -    <code>exists</code> - 表示共享内存的标志是从主进程继承的（特定于Windows） </li>
</ul>
<p>  解析配置后，共享区域条目将映射到<code>ngx_init_cycle()</code>实际内存。  在POSIX系统上， <code>mmap()</code> syscall用于创建共享匿名映射。  在Windows上，使用<code>CreateFileMapping()</code> / <code>MapViewOfFileEx()</code>对。 </p>
<p>  对于在共享内存中分配，nginx提供slab池<code>ngx_slab_pool_t</code>类型。  在每个nginx共享区域中自动创建用于分配内存的slab池。  该池位于共享区域的开头，可以通过表达式<code>(ngx_slab_pool_t *) shm_zone-&amp;gt;shm.addr</code> 。  要在共享区域中分配内存，请调用<code>ngx_slab_alloc(pool, size)</code>或<code>ngx_slab_calloc(pool, size)</code> 。  要释放内存，请调用<code>ngx_slab_free(pool, p)</code> 。 </p>
<p>   Slab池将所有共享区域划分为页面。  每个页面用于分配相同大小的对象。  指定的大小必须是2的幂，并且大于8字节的最小大小。  不合格的值被四舍五入。  每个页面的位掩码跟踪正在使用哪些块以及哪些块可以自由分配。  对于大于半页（通常为2048字节）的大小，一次分配整个页面 </p>
<p>  要保护共享内存中的数据不受并发访问影响，请使用<code>ngx_slab_pool_t</code>的<code>mutex</code>字段中提供的<code>mutex</code> 。  在分配和释放内存时，板块池最常使用互斥锁，但它可用于保护共享区域中分配的任何其他用户数据结构。  要锁定或解锁互斥锁，请分别调用<code>ngx_shmtx_lock(&amp;amp;shpool-&amp;gt;mutex)</code>或<code>ngx_shmtx_unlock(&amp;amp;shpool-&amp;gt;mutex)</code> 。 </p>
<pre class="notranslate">ngx_str_t        name;
ngx_foo_ctx_t   *ctx;
ngx_shm_zone_t  *shm_zone;

ngx_str_set(&amp;name, "foo");

/* allocate shared zone context */
ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_foo_ctx_t));
if (ctx == NULL) {
    /* error */
}

/* add an entry for 64k shared zone */
shm_zone = ngx_shared_memory_add(cf, &amp;name, 65536, &amp;ngx_foo_module);
if (shm_zone == NULL) {
    /* error */
}

/* register init callback and context */
shm_zone-&gt;init = ngx_foo_init_zone;
shm_zone-&gt;data = ctx;


...


static ngx_int_t
ngx_foo_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_foo_ctx_t  *octx = data;

    size_t            len;
    ngx_foo_ctx_t    *ctx;
    ngx_slab_pool_t  *shpool;

    value = shm_zone-&gt;data;

    if (octx) {
        /* reusing a shared zone from old cycle */
        ctx-&gt;value = octx-&gt;value;
        return NGX_OK;
    }

    shpool = (ngx_slab_pool_t *) shm_zone-&gt;shm.addr;

    if (shm_zone-&gt;shm.exists) {
        /* initialize shared zone context in Windows nginx worker */
        ctx-&gt;value = shpool-&gt;data;
        return NGX_OK;
    }

    /* initialize shared zone */

    ctx-&gt;value = ngx_slab_alloc(shpool, sizeof(ngx_uint_t));
    if (ctx-&gt;value == NULL) {
        return NGX_ERROR;
    }

    shpool-&gt;data = ctx-&gt;value;

    return NGX_OK;
}
</pre>

<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>  对于日志记录，nginx使用<code>ngx_log_t</code>对象。   nginx记录器支持几种类型的输出： </p>
<ul>
<li>stderr  - 记录到标准错误（stderr） -    file  - 记录到文件 -    syslog  - 记录到syslog -    memory  - 记录到内部存储器以用于开发目的;  稍后可以使用调试器访问内存 </li>
</ul>
<p>  记录器实例可以是记录器链，使用<code>next</code>字段相互链接。  在这种情况下，每条消息都写入链中的所有记录器。 </p>
<p>  对于每个记录器，严重性级别控制将哪些消息写入日志（仅记录分配了该级别或更高级别的事件）。  支持以下严重性级别： </p>
<ul>
<li><code>NGX_LOG_EMERG</code>  -  <code>NGX_LOG_ALERT</code>  -  <code>NGX_LOG_CRIT</code>  -  <code>NGX_LOG_ERR</code>  -  <code>NGX_LOG_WARN</code>  -  <code>NGX_LOG_NOTICE</code>  -  <code>NGX_LOG_INFO</code>  -  <code>NGX_LOG_DEBUG</code>  </li>
</ul>
<p>  对于调试日志记录，还会检查调试掩码。  调试掩码是： </p>
<ul>
<li><code>NGX_LOG_DEBUG_CORE</code>  -  <code>NGX_LOG_DEBUG_ALLOC</code>  -  <code>NGX_LOG_DEBUG_MUTEX</code>  -  <code>NGX_LOG_DEBUG_EVENT</code>  -  <code>NGX_LOG_DEBUG_HTTP</code>  -  <code>NGX_LOG_DEBUG_MAIL</code>  -  <code>NGX_LOG_DEBUG_STREAM</code>  </li>
</ul>
<p>  通常，记录器是由<code>error_log</code>指令中的现有nginx代码创建的，几乎在循环，配置，客户端连接和其他对象的每个处理阶段都可用。 </p>
<p>   Nginx提供以下日志记录宏： </p>
<ul>
<li><code>ngx_log_error(level, log, err, fmt, ...)</code> - 错误记录 -    <code>ngx_log_debug0(level, log, err, fmt)</code> ， <code>ngx_log_debug1(level, log, err, fmt, arg1)</code>等 - 使用最多八个支持的格式化参数调试日志记录 </li>
</ul>
<p>  日志消息在堆栈中的大小为<code>NGX_MAX_ERROR_STR</code> （当前为2048字节）的缓冲区中格式化。  该消息前面附有严重性级别，进程ID（PID），连接ID（存储在<code>log-&amp;gt;connection</code> ）和系统错误文本。  对于非调试消息，还调用<code>log-&amp;gt;handler</code>以将更多特定信息添加到日志消息中。   HTTP模块将<code>ngx_http_log_error()</code>函数设置为日志处理程序，以记录客户端和服务器地址，当前操作（存储在<code>log-&amp;gt;action</code> ），客户端请求行，服务器名称等。 </p>
<pre class="notranslate">/* specify what is currently done */
log-&gt;action = "sending mp4 to client";

/* error and debug log */
ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0, "client prematurely
              closed connection");

ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4-&gt;file.log, 0,
               "mp4 start:%ui, length:%ui", mp4-&gt;start, mp4-&gt;length);
</pre>

<p>  上面的示例导致日志条目如下： </p>
<pre class="notranslate">2016/09/16 22:08:52 [info] 17445#0: *1 client prematurely closed connection while
sending mp4 to client, client: 127.0.0.1, server: , request: "GET /file.mp4 HTTP/1.1"
2016/09/16 23:28:33 [debug] 22140#0: *1 mp4 start:0, length:10000
</pre>

<h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>  循环对象存储从特定配置创建的nginx运行时上下文。  它的类型是<code>ngx_cycle_t</code> 。  当前循环由<code>ngx_cycle</code>全局变量引用，并在nginx worker启动时继承。  每次重新加载nginx配置时，都会从新的nginx配置创建一个新的循环;  成功创建新循环后，通常会删除旧循环。 </p>
<p>  循环由<code>ngx_init_cycle()</code>函数创建，该函数将前一个循环作为其参数。  该函数定位上一个循环的配置文件，并从前一个循环继承尽可能多的资源。  称为“初始循环”的占位符循环创建为nginx启动，然后由从配置构建的实际循环替换。 </p>
<p>  该周期的成员包括： </p>
<ul>
<li><code>pool</code> - 自行车游泳池  为每个新周期创建。 -    <code>log</code> - 循环日志。  最初从旧循环继承，在读取配置后将其设置为指向<code>new_log</code> 。 -    <code>new_log</code> - 由配置创建的循环日志。  它受根范围<code>error_log</code>指令的影响。 -    <code>connections</code> ， <code>connection_n</code> - 类型为<code>ngx_connection_t</code>的连接数组，由事件模块在初始化每个nginx worker时创建。   nginx配置中的<code>worker_connections</code>指令设置连接数<code>connection_n</code> 。 -    <code>free_connections</code> ， <code>free_connection_n</code> - 当前可用连接的列表和数量。  如果没有可用的连接，则nginx工作程序拒绝接受新客户端或连接到上游服务器。 -    <code>files</code> ， <code>files_n</code> - 用于将文件描述符映射到nginx连接的数组。  该映射由具有<code>NGX_USE_FD_EVENT</code>标志的事件模块使用（当前，它是<code>poll</code>和<code>devpoll</code> ）。 -    <code>conf_ctx</code> - 核心模块配置数组。  在读取nginx配置文件期间创建并填充配置。 -    <code>modules</code> ， <code>modules_n</code> - 由当前配置加载的<code>ngx_module_t</code>类型的模块数组，包括静态和动态模块。 -    <code>listening</code> - <code>ngx_listening_t</code>类型的侦听对象数组。  通常通过调用<code>ngx_create_listening()</code>函数的不同模块的<code>listen</code>指令添加侦听对象。  侦听套接字是基于侦听对象创建的。 -    <code>paths</code> - <code>ngx_path_t</code>类型的路径数组。  通过从将在某些目录上运行的模块调用函数<code>ngx_add_path()</code>来添加路径。  这些目录是在读取配置后由nginx创建的，如果缺少的话。  此外，可以为每个路径添加两个处理程序： <ul class="compact"><li>   path loader  - 在启动或重新加载nginx后，仅在60秒内执行一次。  通常，加载程序读取目录并将数据存储在nginx共享内存中。  从专用的nginx进程“nginx缓存加载器”调用该处理程序。 -   路径管理器 - 定期执行。  通常，管理器从目录中删除旧文件并更新nginx内存以反映更改。  处理程序从专用的“nginx缓存管理器”进程调用。 </li>
</ul>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>  对于输入/输出操作，nginx提供缓冲区类型<code>ngx_buf_t</code> 。  通常，它用于保存要写入目标或从源读取的数据。  缓冲区可以引用内存或文件中的数据，从技术上讲，缓冲区可以同时引用这两个数据。  缓冲区的内存是单独分配的，与缓冲区结构<code>ngx_buf_t</code> 。 </p>
<p>   <code>ngx_buf_t</code>结构包含以下字段： </p>
<ul>
<li><code>start</code> ， <code>end</code> - 为缓冲区分配的内存块的边界。 -    <code>pos</code> ， <code>last</code> - 内存缓冲区的边界;  通常是一个<code>start</code>的子范围.. <code>end</code> 。 -    <code>file_pos</code> ， <code>file_last</code> - 文件缓冲区的边界，表示为从文件开头的偏移量。 -    <code>tag</code> - 用于区分缓冲区的唯一值;  由不同的nginx模块创建，通常用于缓冲区重用。 -    <code>file</code> - 文件对象。 -    <code>temporary</code> - 指示缓冲区引用可写内存的标志。 -    <code>memory</code> - 指示缓冲区引用只读<code>memory</code>标志。 -    <code>in_file</code> - 指示缓冲区引用文件中数据的标志。 -    <code>flush</code> - 表示需要刷新缓冲区之前的所有数据的标志。 -    <code>recycled</code> - 表示缓冲区可以重用并需要尽快使用的标志。 -    <code>sync</code> - 表示缓冲区不携带数据或<code>flush</code>或<code>last_buf</code>等特殊信号的<code>last_buf</code> 。  默认情况下，nginx认为这样的缓冲区是一个错误条件，但是这个标志告诉nginx跳过错误检查。 -    <code>last_buf</code> - 表示缓冲区是输出中的最后一个的标志。 -    <code>last_in_chain</code> - 表示请求或子请求中不再有数据缓冲区的标志。 -    <code>shadow</code> - 引用与当前缓冲区相关的另一个（“shadow”）缓冲区，通常是缓冲区使用阴影中的数据。  消耗缓冲区时，通常还将阴影缓冲区标记为已消耗。 -    <code>last_shadow</code> - 指示缓冲区是引用特定影子缓冲区的最后一个缓冲区的标志。 -    <code>temp_file</code> - 指示缓冲区位于临时文件中的标志。 </li>
</ul>
<p>  对于输入和输出操作，缓冲区链接在一起。  链是<code>ngx_chain_t</code>类型的链序列，定义如下： </p>
<pre class="notranslate">typedef struct ngx_chain_s  ngx_chain_t;

struct ngx_chain_s {
    ngx_buf_t    *buf;
    ngx_chain_t  *next;
};
</pre>

<p>  每个链节都保持对其缓冲区的引用和对下一个链节的引用。 </p>
<p>  使用缓冲区和链的示例： </p>
<pre class="notranslate">ngx_chain_t *
ngx_get_my_chain(ngx_pool_t *pool)
{
    ngx_buf_t    *b;
    ngx_chain_t  *out, *cl, **ll;

    /* first buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_calloc_buf(pool);
    if (b == NULL) { /* error */ }

    b-&gt;start = (u_char *) "foo";
    b-&gt;pos = b-&gt;start;
    b-&gt;end = b-&gt;start + 3;
    b-&gt;last = b-&gt;end;
    b-&gt;memory = 1; /* read-only memory */

    cl-&gt;buf = b;
    out = cl;
    ll = &amp;cl-&gt;next;

    /* second buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_create_temp_buf(pool, 3);
    if (b == NULL) { /* error */ }

    b-&gt;last = ngx_cpymem(b-&gt;last, "foo", 3);

    cl-&gt;buf = b;
    cl-&gt;next = NULL;
    *ll = cl;

    return out;
}
</pre>

<h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>  连接类型<code>ngx_connection_t</code>是套接字描述符的包装器。  它包括以下字段： </p>
<ul>
<li><code>fd</code> - 套接字描述符 -    <code>data</code> - 任意连接上下文。  通常，它是指向在连接之上构建的更高级别对象的指针，例如HTTP请求或Stream会话。 -    <code>read</code> ， <code>write</code> - 读取和写入连接事件。 -    <code>recv</code> ， <code>send</code> ， <code>recv_chain</code> ， <code>send_chain</code> - 连接的I / O操作。 -    <code>pool</code> - 连接池。 -    <code>log</code> - 连接日志。 -    <code>sockaddr</code> ， <code>socklen</code> ， <code>addr_text</code> - 二进制和文本形式的远程套接字地址。 -    <code>local_sockaddr</code> ， <code>local_socklen</code> - 二进制形式的本地套接字地址。  最初，这些字段为空。  使用<code>ngx_connection_local_sockaddr()</code>函数获取本地套接字地址。 -    <code>proxy_protocol_addr</code> ， <code>proxy_protocol_port</code> -  PROXY协议客户端地址和端口，如果为连接启用了PROXY协议。 -    <code>ssl</code> - 连接的SSL上下文。 -    <code>reusable</code> - 指示连接处于允许重用的状态的标志。 -    <code>close</code> - 表示正在重用连接并需要<code>close</code>标志。 </li>
</ul>
<p>   nginx连接可以透明地封装SSL层。  在这种情况下，连接的<code>ssl</code>字段包含指向<code>ngx_ssl_connection_t</code>结构的指针，保留连接的所有SSL相关数据，包括<code>SSL_CTX</code>和<code>SSL</code> 。   <code>recv</code> ， <code>send</code> ， <code>recv_chain</code>和<code>send_chain</code>处理程序也设置为启用SSL的函数。 </p>
<p>   nginx配置中的<code>worker_connections</code>指令限制了每个nginx worker的连接数。  当工人启动并存储在循环对象的<code>connections</code>字段中时，所有连接结构都是预先创建的。  要检索连接结构，请使用<code>ngx_get_connection(s, log)</code>函数。  它需要一个套接字描述符作为其参数，它需要包装在一个连接结构中。 </p>
<p> Because the number of connections per worker is limited, nginx provides a way to grab connections that are currently in use. To enable or disable reuse of a connection, call the <code>ngx_reusable_connection(c, reusable)</code> function. Calling <code>ngx_reusable_connection(c, 1)</code> sets the <code>reuse</code> flag in the connection structure and inserts the connection into the <code>reusable_connections_queue</code> of the cycle. Whenever <code>ngx_get_connection()</code> finds out there are no available connections in the cycle’s <code>free_connections</code> list, it calls <code>ngx_drain_connections()</code> to release a specific number of reusable connections. For each such connection, the <code>close</code> flag is set and its read handler is called which is supposed to free the connection by calling <code>ngx_close_connection(c)</code> and make it available for reuse. To exit the state when a connection can be reused <code>ngx_reusable_connection(c, 0)</code> is called. HTTP client connections are an example of reusable connections in nginx; they are marked as reusable until the first request byte is received from the client. </p>
<h4 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p> Event object <code>ngx_event_t</code> in nginx provides a mechanism for notification that a specific event has occurred. </p>
<p> Fields in <code>ngx_event_t</code> include: </p>
<ul>
<li><code>data</code> — Arbitrary event context used in event handlers, usually as pointer to a connection related to the event. -  <code>handler</code> — Callback function to be invoked when the event happens. -  <code>write</code> — Flag indicating a write event. Absence of the flag indicates a read event. -  <code>active</code> — Flag indicating that the event is registered for receiving I/O notifications, normally from notification mechanisms like <code>epoll</code> , <code>kqueue</code> , <code>poll</code> . -  <code>ready</code> — Flag indicating that the event has received an I/O notification. -  <code>delayed</code> — Flag indicating that I/O is delayed due to rate limiting. -  <code>timer</code> — Red-black tree node for inserting the event into the timer tree. -  <code>timer_set</code> — Flag indicating that the event timer is set and not yet expired. -  <code>timedout</code> — Flag indicating that the event timer has expired. -  <code>eof</code> — Flag indicating that EOF occurred while reading data. -  <code>pending_eof</code> — Flag indicating that EOF is pending on the socket, even though there may be some data available before it. The flag is delivered via the <code>EPOLLRDHUP</code> <code>epoll</code> event or <code>EV_EOF</code> <code>kqueue</code> flag. -  <code>error</code> — Flag indicating that an error occurred during reading (for a read event) or writing (for a write event). -  <code>cancelable</code> — Timer event flag indicating that the event should be ignored while shutting down the worker. Graceful worker shutdown is delayed until there are no non-cancelable timer events scheduled. -  <code>posted</code> — Flag indicating that the event is posted to a queue. -  <code>queue</code> — Queue node for posting the event to a queue. </li>
</ul>
<h4 id="I-O-events"><a href="#I-O-events" class="headerlink" title="I/O events"></a>I/O events</h4><p> Each connection obtained by calling the <code>ngx_get_connection()</code> function has two attached events, <code>c-&amp;gt;read</code> and <code>c-&amp;gt;write</code> , which are used for receiving notification that the socket is ready for reading or writing. All such events operate in Edge-Triggered mode, meaning that they only trigger notifications when the state of the socket changes. For example, doing a partial read on a socket does not make nginx deliver a repeated read notification until more data arrives on the socket. Even when the underlying I/O notification mechanism is essentially Level-Triggered ( <code>poll</code> , <code>select</code> etc), nginx converts the notifications to Edge-Triggered. To make nginx event notifications consistent across all notifications systems on different platforms, the functions <code>ngx_handle_read_event(rev, flags)</code> and <code>ngx_handle_write_event(wev, lowat)</code> must be called after handling an I/O socket notification or calling any I/O functions on that socket. Normally, the functions are called once at the end of each read or write event handler. </p>
<h4 id="Timer-events"><a href="#Timer-events" class="headerlink" title="Timer events"></a>Timer events</h4><p> An event can be set to send a notification when a timeout expires. The timer used by events counts milliseconds since some unspecified point in the past truncated to <code>ngx_msec_t</code> type. Its current value can be obtained from the <code>ngx_current_msec</code> variable. </p>
<p> The function <code>ngx_add_timer(ev, timer)</code> sets a timeout for an event, <code>ngx_del_timer(ev)</code> deletes a previously set timeout. The global timeout red-black tree <code>ngx_event_timer_rbtree</code> stores all timeouts currently set. The key in the tree is of type <code>ngx_msec_t</code> and is the time when the event occurs. The tree structure enables fast insertion and deletion operations, as well as access to the nearest timeouts, which nginx uses to find out how long to wait for I/O events and for expiring timeout events. </p>
<h4 id="Posted-events"><a href="#Posted-events" class="headerlink" title="Posted events"></a>Posted events</h4><p> An event can be posted which means that its handler will be called at some point later within the current event loop iteration. Posting events is a good practice for simplifying code and escaping stack overflows. Posted events are held in a post queue. The <code>ngx_post_event(ev, q)</code> mscro posts the event <code>ev</code> to the post queue <code>q</code> . The <code>ngx_delete_posted_event(ev)</code> macro deletes the event <code>ev</code> from the queue it’s currently posted in. Normally, events are posted to the <code>ngx_posted_events</code> queue, which is processed late in the event loop — after all I/O and timer events are already handled. The function <code>ngx_event_process_posted()</code> is called to process an event queue. It calls event handlers until the queue is not empty. This means that a posted event handler can post more events to be processed within the current event loop iteration. </p>
<p>  一个例子： </p>
<pre class="notranslate">void
ngx_my_connection_read(ngx_connection_t *c)
{
    ngx_event_t  *rev;

    rev = c-&gt;read;

    ngx_add_timer(rev, 1000);

    rev-&gt;handler = ngx_my_read_handler;

    ngx_my_read(rev);
}


void
ngx_my_read_handler(ngx_event_t *rev)
{
    ssize_t            n;
    ngx_connection_t  *c;
    u_char             buf[256];

    if (rev-&gt;timedout) { /* timeout expired */ }

    c = rev-&gt;data;

    while (rev-&gt;ready) {
        n = c-&gt;recv(c, buf, sizeof(buf));

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR) { /* error */ }

        /* process buf */
    }

    if (ngx_handle_read_event(rev, 0) != NGX_OK) { /* error */ }
}
</pre>

<h4 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h4><p> Except for the nginx master process, all nginx processes do I/O and so have an event loop. (The nginx master process instead spends most of its time in the <code>sigsuspend()</code> call waiting for signals to arrive.) The nginx event loop is implemented in the <code>ngx_process_events_and_timers()</code> function, which is called repeatedly until the process exits. </p>
<p> The event loop has the following stages: </p>
<ul>
<li>Find the timeout that is closest to expiring, by calling <code>ngx_event_find_timer()</code> . This function finds the leftmost node in the timer tree and returns the number of milliseconds until the node expires. -  Process I/O events by calling a handler, specific to the event notification mechanism, chosen by nginx configuration. This handler waits for at least one I/O event to happen, but only until the next timeout expires. When a read or write event occurs, the <code>ready</code> flag is set and the event’s handler is called. For Linux, the <code>ngx_epoll_process_events()</code> handler is normally used, which calls <code>epoll_wait()</code> to wait for I/O events. -  Expire timers by calling <code>ngx_event_expire_timers()</code> . The timer tree is iterated from the leftmost element to the right until an unexpired timeout is found. For each expired node the <code>timedout</code> event flag is set, the <code>timer_set</code> flag is reset, and the event handler is called -  Process posted events by calling <code>ngx_event_process_posted()</code> . The function repeatedly removes the first element from the posted events queue and calls the element’s handler, until the queue is empty. </li>
</ul>
<p> All nginx processes handle signals as well. Signal handlers only set global variables which are checked after the <code>ngx_process_events_and_timers()</code> call. </p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p> There are several types of processes in nginx. The type of a process is kept in the <code>ngx_process</code> global variable, and is one of the following: </p>
<ul>
<li><code>NGX_PROCESS_MASTER</code> — The master process, which reads the NGINX configuration, creates cycles, and starts and controls child processes. It does not perform any I/O and responds only to signals. Its cycle function is <code>ngx_master_process_cycle()</code> . -  <code>NGX_PROCESS_WORKER</code> — The worker process, which handles client connections. It is started by the master process and responds to its signals and channel commands as well. Its cycle function is <code>ngx_worker_process_cycle()</code> . There can be multiple worker processes, as configured by the <code>worker_processes</code> directive. -  <code>NGX_PROCESS_SINGLE</code> — The single process, which exists only in <code>master_process off</code> mode, and is the only process running in that mode. It creates cycles (like the master process does) and handles client connections (like the worker process does). Its cycle function is <code>ngx_single_process_cycle()</code> . -  <code>NGX_PROCESS_HELPER</code> — The helper process, of which currently there are two types: cache manager and cache loader. The cycle function for both is <code>ngx_cache_manager_process_cycle()</code> .<br>The nginx processes handle the following signals: </li>
<li><code>NGX_SHUTDOWN_SIGNAL</code> ( <code>SIGQUIT</code> on most systems) — Gracefully shutdown. Upon receiving this signal, the master process sends a shutdown signal to all child processes. When no child processes are left, the master destroys the cycle pool and exits. When a worker process receives this signal, it closes all listening sockets and waits until there are no non-cancelable events scheduled, then destroys the cycle pool and exits. When the cache manager or the cache loader process receives this signal, it exits immediately. The <code>ngx_quit</code> variable is set to <code>1</code> when a process receives this signal, and is immediately reset after being processed. The <code>ngx_exiting</code> variable is set to <code>1</code> while a worker process is in the shutdown state. -  <code>NGX_TERMINATE_SIGNAL</code> ( <code>SIGTERM</code> on most systems) — Terminate. Upon receiving this signal, the master process sends a terminate signal to all child processes. If a child process does not exit within 1 second, the master process sends the <code>SIGKILL</code> signal to kill it. When no child processes are left, the master process destroys the cycle pool and exits. When a worker process, the cache manager process or the cache loader process receives this signal, it destroys the cycle pool and exits. The variable <code>ngx_terminate</code> is set to <code>1</code> when this signal is received. -  <code>NGX_NOACCEPT_SIGNAL</code> ( <code>SIGWINCH</code> on most systems) - Shut down all worker and helper processes. Upon receiving this signal, the master process shuts down its child processes. If a previously started new nginx binary exits, the child processes of the old master are started again. When a worker process receives this signal, it shuts down in debug mode set by the <code>debug_points</code> directive. -  <code>NGX_RECONFIGURE_SIGNAL</code> ( <code>SIGHUP</code> on most systems) - Reconfigure. Upon receiving this signal, the master process re-reads the configuration and creates a new cycle based on it. If the new cycle is created successfully, the old cycle is deleted and new child processes are started. Meanwhile, the old child processes receive the <code>NGX_SHUTDOWN_SIGNAL</code> signal. In single-process mode, nginx creates a new cycle, but keeps the old one until there are no longer clients with active connections tied to it. The worker and helper processes ignore this signal. -  <code>NGX_REOPEN_SIGNAL</code> ( <code>SIGUSR1</code> on most systems) — Reopen files. The master process sends this signal to workers, which reopen all <code>open_files</code> related to the cycle. -  <code>NGX_CHANGEBIN_SIGNAL</code> ( <code>SIGUSR2</code> on most systems) — Change the nginx binary. The master process starts a new nginx binary and passes in a list of all listen sockets. The text-format list, passed in the <code>“NGINX”</code> environment variable, consists of descriptor numbers separated with semicolons. The new nginx binary reads the <code>“NGINX”</code> variable and adds the sockets to its init cycle. Other processes ignore this signal.<br>While all nginx worker processes are able to receive and properly handle POSIX signals, the master process does not use the standard <code>kill()</code> syscall to pass signals to workers and helpers. Instead, nginx uses inter-process socket pairs which allow sending messages between all nginx processes. Currently, however, messages are only sent from the master to its children. The messages carry the standard signals. </li>
</ul>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p> It is possible to offload into a separate thread tasks that would otherwise block the nginx worker process. For example, nginx can be configured to use threads to perform <a href="http/ngx_http_core_module.html#aio">file I/O</a> . Another use case is a library that doesn’t have asynchronous interface and thus cannot be normally used with nginx. Keep in mind that the threads interface is a helper for the existing asynchronous approach to processing client connections, and by no means intended as a replacement. </p>
<p> To deal with synchronization, the following wrappers over <code>pthreads</code> primitives are available: </p>
<ul>
<li><code>typedef pthread_mutex_t ngx_thread_mutex_t;</code> <ul class="compact"> <li> <code>ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>   -  <code>ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  </li>
</ul>
<p> Instead of creating a new thread for each task, nginx implements a <a href="ngx_core_module.html#thread_pool">thread_pool</a> strategy. Multiple thread pools may be configured for different purposes (for example, performing I/O on different sets of disks). Each thread pool is created at startup and contains a limited number of threads that process a queue of tasks. When a task is completed, a predefined completion handler is called. </p>
<p> The <code>src/core/ngx_thread_pool.h</code> header file contains relevant definitions: </p>
<pre class="notranslate">struct ngx_thread_task_s {
    ngx_thread_task_t   *next;
    ngx_uint_t           id;
    void                *ctx;
    void               (*handler)(void *data, ngx_log_t *log);
    ngx_event_t          event;
};

typedef struct ngx_thread_pool_s  ngx_thread_pool_t;

ngx_thread_pool_t *ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name);
ngx_thread_pool_t *ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name);

ngx_thread_task_t *ngx_thread_task_alloc(ngx_pool_t *pool, size_t size);
ngx_int_t ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task);

</pre>

<p> At configuration time, a module willing to use threads has to obtain a reference to a thread pool by calling <code>ngx_thread_pool_add(cf, name)</code> , which either creates a new thread pool with the given <code>name</code> or returns a reference to the pool with that name if it already exists. </p>
<p> To add a <code>task</code> into a queue of a specified thread pool <code>tp</code> at runtime, use the <code>ngx_thread_task_post(tp, task)</code> function. To execute a function in a thread, pass parameters and setup a completion handler using the <code>ngx_thread_task_t</code> structure: </p>
<pre class="notranslate">typedef struct {
    int    foo;
} my_thread_ctx_t;


static void
my_thread_func(void *data, ngx_log_t *log)
{
    my_thread_ctx_t *ctx = data;

    /* this function is executed in a separate thread */
}


static void
my_thread_completion(ngx_event_t *ev)
{
    my_thread_ctx_t *ctx = ev-&gt;data;

    /* executed in nginx event loop */
}


ngx_int_t
my_task_offload(my_conf_t *conf)
{
    my_thread_ctx_t    *ctx;
    ngx_thread_task_t  *task;

    task = ngx_thread_task_alloc(conf-&gt;pool, sizeof(my_thread_ctx_t));
    if (task == NULL) {
        return NGX_ERROR;
    }

    ctx = task-&gt;ctx;

    ctx-&gt;foo = 42;

    task-&gt;handler = my_thread_func;
    task-&gt;event.handler = my_thread_completion;
    task-&gt;event.data = ctx;

    if (ngx_thread_task_post(conf-&gt;thread_pool, task) != NGX_OK) {
        return NGX_ERROR;
    }

    return NGX_OK;
}
</pre>



<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><h4 id="Adding-new-modules"><a href="#Adding-new-modules" class="headerlink" title="Adding new modules"></a>Adding new modules</h4><p> Each standalone nginx module resides in a separate directory that contains at least two files: <code>config</code> and a file with the module source code. The <code>config</code> file contains all information needed for nginx to integrate the module, for example: </p>
<pre class="notranslate">ngx_module_type=CORE
ngx_module_name=ngx_foo_module
ngx_module_srcs="$ngx_addon_dir/ngx_foo_module.c"

. auto/module

ngx_addon_name=$ngx_module_name
</pre>

<p> The <code>config</code> file is a POSIX shell script that can set and access the following variables: </p>
<ul>
<li><code>ngx_module_type</code> — Type of module to build. Possible values are <code>CORE</code> , <code>HTTP</code> , <code>HTTP_FILTER</code> , <code>HTTP_INIT_FILTER</code> , <code>HTTP_AUX_FILTER</code> , <code>MAIL</code> , <code>STREAM</code> , or <code>MISC</code> . -  <code>ngx_module_name</code> — Module names. To build multiple modules from a set of source files, specify a whitespace-separated list of names. The first name indicates the name of the output binary for the dynamic module. The names in the list must match the names used in the source code. -  <code>ngx_addon_name</code> — Name of the module as it appears in output on the console from the configure script. -  <code>ngx_module_srcs</code> — Whitespace-separated list of source files used to compile the module. The <code>$ngx_addon_dir</code> variable can be used to represent the path to the module directory. -  <code>ngx_module_incs</code> — Include paths required to build the module -  <code>ngx_module_deps</code> — Whitespace-separated list of the module’s dependencies. Usually, it is the list of header files. -  <code>ngx_module_libs</code> — Whitespace-separated list of libraries to link with the module. For example, use <code>ngx_module_libs=-lpthread</code> to link <code>libpthread</code> library. The following macros can be used to link against the same libraries as nginx: <code>LIBXSLT</code> , <code>LIBGD</code> , <code>GEOIP</code> , <code>PCRE</code> , <code>OPENSSL</code> , <code>MD5</code> , <code>SHA1</code> , <code>ZLIB</code> , and <code>PERL</code> . -  <code>ngx_module_link</code> — Variable set by the build system to <code>DYNAMIC</code> for a dynamic module or <code>ADDON</code> for a static module and used to determine different actions to perform depending on linking type. -  <code>ngx_module_order</code> — Load order for the module; useful for the <code>HTTP_FILTER</code> and <code>HTTP_AUX_FILTER</code> module types. The format for this option is a whitespace-separated list of modules. All modules in the list following the current module’s name end up after it in the global list of modules, which sets up the order for modules initialization. For filter modules later initialization means earlier execution.  The following modules are typically used as references. The <code>ngx_http_copy_filter_module</code> reads the data for other filter modules and is placed near the bottom of the list so that it is one of the first to be executed. The <code>ngx_http_write_filter_module</code> writes the data to the client socket and is placed near the top of the list, and is the last to be executed.  By default, filter modules are placed before the <code>ngx_http_copy_filter</code> in the module list so that the filter handler is executed after the copy filter handler. For other module types the default is the empty string.<br>To compile a module into nginx statically, use the <code>--add-module=/path/to/module</code> argument to the configure script. To compile a module for later dynamic loading into nginx, use the <code>--add-dynamic-module=/path/to/module</code> argument. </li>
</ul>
<h4 id="Core-Modules"><a href="#Core-Modules" class="headerlink" title="Core Modules"></a>Core Modules</h4><p> Modules are the building blocks of nginx, and most of its functionality is implemented as modules. The module source file must contain a global variable of type <code>ngx_module_t</code> , which is defined as follows: </p>
<pre class="notranslate">struct ngx_module_s {

    /* private part is omitted */

    void                 *ctx;
    ngx_command_t        *commands;
    ngx_uint_t            type;

    ngx_int_t           (*init_master)(ngx_log_t *log);

    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
    void                (*exit_thread)(ngx_cycle_t *cycle);
    void                (*exit_process)(ngx_cycle_t *cycle);

    void                (*exit_master)(ngx_cycle_t *cycle);

    /* stubs for future extensions are omitted */
};
</pre>

<p> The omitted private part includes the module version and a signature and is filled using the predefined macro <code>NGX_MODULE_V1</code> . </p>
<p> Each module keeps its private data in the <code>ctx</code> field, recognizes the configuration directives, specified in the <code>commands</code> array, and can be invoked at certain stages of nginx lifecycle. The module lifecycle consists of the following events: </p>
<ul>
<li><p>Configuration directive handlers are called as they appear in configuration files in the context of the master process. -  After the configuration is parsed successfully, <code>init_module</code> handler is called in the context of the master process. The <code>init_module</code> handler is called in the master process each time a configuration is loaded. -  The master process creates one or more worker processes and the <code>init_process</code> handler is called in each of them. -  When a worker process receives the shutdown or terminate command from the master, it invokes the <code>exit_process</code> handler. -  The master process calls the <code>exit_master</code> handler before exiting.<br>Because threads are used in nginx only as a supplementary I/O facility with its own API, <code>init_thread</code> and <code>exit_thread</code> handlers are not currently called. There is also no <code>init_master</code> handler, because it would be unnecessary overhead. </p>
<p>The module <code>type</code> defines exactly what is stored in the <code>ctx</code> field. Its value is one of the following types: </p>
</li>
<li><p><code>NGX_CORE_MODULE</code>  -  <code>NGX_EVENT_MODULE</code>  -  <code>NGX_HTTP_MODULE</code>  -  <code>NGX_MAIL_MODULE</code>  -  <code>NGX_STREAM_MODULE</code><br>The <code>NGX_CORE_MODULE</code> is the most basic and thus the most generic and most low-level type of module. The other module types are implemented on top of it and provide a more convenient way to deal with corresponding domains, like handling events or HTTP requests. </p>
<p>The set of core modules includes <code>ngx_core_module</code> , <code>ngx_errlog_module</code> , <code>ngx_regex_module</code> , <code>ngx_thread_pool_module</code> and <code>ngx_openssl_module</code> modules. The HTTP module, the stream module, the mail module and event modules are core modules too. The context of a core module is defined as: </p>
</li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_str_t             name;
    void               *(*create_conf)(ngx_cycle_t *cycle);
    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;
</pre>

<p> where the <code>name</code> is a module name string, <code>create_conf</code> and <code>init_conf</code> are pointers to functions that create and initialize module configuration respectively. For core modules, nginx calls <code>create_conf</code> before parsing a new configuration and <code>init_conf</code> after all configuration is parsed successfully. The typical <code>create_conf</code> function allocates memory for the configuration and sets default values. </p>
<p> For example, a simplistic module called <code>ngx_foo_module</code> might look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author.
 */


#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;


typedef struct {
    ngx_flag_t  enable;
} ngx_foo_conf_t;


static void *ngx_foo_create_conf(ngx_cycle_t *cycle);
static char *ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf);

static char *ngx_foo_enable(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_enable_post = { ngx_foo_enable };


static ngx_command_t  ngx_foo_commands[] = {

    { ngx_string("foo_enabled"),
      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      0,
      offsetof(ngx_foo_conf_t, enable),
      &amp;ngx_foo_enable_post },

      ngx_null_command
};


static ngx_core_module_t  ngx_foo_module_ctx = {
    ngx_string("foo"),
    ngx_foo_create_conf,
    ngx_foo_init_conf
};


ngx_module_t  ngx_foo_module = {
    NGX_MODULE_V1,
    &amp;ngx_foo_module_ctx,                   /* module context */
    ngx_foo_commands,                      /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static void *
ngx_foo_create_conf(ngx_cycle_t *cycle)
{
    ngx_foo_conf_t  *fcf;

    fcf = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_foo_conf_t));
    if (fcf == NULL) {
        return NULL;
    }

    fcf-&gt;enable = NGX_CONF_UNSET;

    return fcf;
}


static char *
ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_foo_conf_t *fcf = conf;

    ngx_conf_init_value(fcf-&gt;enable, 0);

    return NGX_CONF_OK;
}


static char *
ngx_foo_enable(ngx_conf_t *cf, void *post, void *data)
{
    ngx_flag_t  *fp = data;

    if (*fp == 0) {
        return NGX_CONF_OK;
    }

    ngx_log_error(NGX_LOG_NOTICE, cf-&gt;log, 0, "Foo Module is enabled");

    return NGX_CONF_OK;
}
</pre>



<h4 id="Configuration-Directives"><a href="#Configuration-Directives" class="headerlink" title="Configuration Directives"></a>Configuration Directives</h4><p> The <code>ngx_command_t</code> type defines a single configuration directive. Each module that supports configuration provides an array of such structures that describe how to process arguments and what handlers to call: </p>
<pre class="notranslate">typedef struct ngx_command_s  ngx_command_t;

struct ngx_command_s {
    ngx_str_t             name;
    ngx_uint_t            type;
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    ngx_uint_t            conf;
    ngx_uint_t            offset;
    void                 *post;
};
</pre>

<p> Terminate the array with the special value <code>ngx_null_command</code> . The <code>name</code> is the name of a directive as it appears in the configuration file, for example “worker_processes” or “listen”. The <code>type</code> is a bit-field of flags that specify the number of arguments the directive takes, its type, and the context in which it appears. The flags are: </p>
<ul>
<li><code>NGX_CONF_NOARGS</code> — Directive takes no arguments. -  <code>NGX_CONF_1MORE</code> — Directive takes one or more arguments. -  <code>NGX_CONF_2MORE</code> — Directive takes two or more arguments. -  <code>NGX_CONF_TAKE1</code> .. <code>NGX_CONF_TAKE7</code> — Directive takes exactly the indicated number of arguments. -  <code>NGX_CONF_TAKE12</code> , <code>NGX_CONF_TAKE13</code> , <code>NGX_CONF_TAKE23</code> , <code>NGX_CONF_TAKE123</code> , <code>NGX_CONF_TAKE1234</code> — Directive may take different number of arguments. Options are limited to the given numbers. For example, <code>NGX_CONF_TAKE12</code> means it takes one or two arguments.<br>The flags for directive types are: </li>
<li><code>NGX_CONF_BLOCK</code> — Directive is a block, that is, it can contain other directives within its opening and closing braces, or even implement its own parser to handle contents inside. -  <code>NGX_CONF_FLAG</code> — Directive takes a boolean value, either <code>on</code> or <code>off</code> .<br>A directive’s context defines where it may appear in the configuration: </li>
<li><p><code>NGX_MAIN_CONF</code> — In the top level context. -  <code>NGX_HTTP_MAIN_CONF</code> — In the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF</code> — In a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF</code> — In a <code>location</code> block within the <code>http</code> block. -  <code>NGX_HTTP_UPS_CONF</code> — In an <code>upstream</code> block within the <code>http</code> block. -  <code>NGX_HTTP_SIF_CONF</code> — In an <code>if</code> block within a <code>server</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LIF_CONF</code> — In an <code>if</code> block within a <code>location</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LMT_CONF</code> — In a <code>limit_except</code> block within the <code>http</code> block. -  <code>NGX_STREAM_MAIN_CONF</code> — In the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF</code> — In a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_STREAM_UPS_CONF</code> — In an <code>upstream</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF</code> — In the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF</code> — In a <code>server</code> block within the <code>mail</code> block. -  <code>NGX_EVENT_CONF</code> — In the <code>event</code> block. -  <code>NGX_DIRECT_CONF</code> — Used by modules that don’t create a hierarchy of contexts and only have one global configuration. This configuration is passed to the handler as the <code>conf</code> argument.<br>The configuration parser uses these flags to throw an error in case of a misplaced directive and calls directive handlers supplied with a proper configuration pointer, so that the same directives in different locations can store their values in distinct places. </p>
<p>The <code>set</code> field defines a handler that processes a directive and stores parsed values into the corresponding configuration. There’s a number of functions that perform common conversions: </p>
</li>
<li><code>ngx_conf_set_flag_slot</code> — Converts the literal strings <code>on</code> and <code>off</code> into an <code>ngx_flag_t</code> value with values 1 or 0, respectively. -  <code>ngx_conf_set_str_slot</code> — Stores a string as a value of the <code>ngx_str_t</code> type. -  <code>ngx_conf_set_str_array_slot</code> — Appends a value to an array <code>ngx_array_t</code> of strings <code>ngx_str_t</code> . The array is created if does not already exist. -  <code>ngx_conf_set_keyval_slot</code> — Appends a key-value pair to an array <code>ngx_array_t</code> of key-value pairs <code>ngx_keyval_t</code> . The first string becomes the key and the second the value. The array is created if it does not already exist. -  <code>ngx_conf_set_num_slot</code> — Converts a directive’s argument to an <code>ngx_int_t</code> value. -  <code>ngx_conf_set_size_slot</code> — Converts a <a href="syntax.html">size</a> to a <code>size_t</code> value expressed in bytes. -  <code>ngx_conf_set_off_slot</code> — Converts an <a href="syntax.html">offset</a> to an <code>off_t</code> value expressed in bytes. -  <code>ngx_conf_set_msec_slot</code> — Converts a <a href="syntax.html">time</a> to an <code>ngx_msec_t</code> value expressed in milliseconds. -  <code>ngx_conf_set_sec_slot</code> — Converts a <a href="syntax.html">time</a> to a <code>time_t</code> value expressed in in seconds. -  <code>ngx_conf_set_bufs_slot</code> — Converts the two supplied arguments into an <code>ngx_bufs_t</code> object that holds the number and <a href="syntax.html">size</a> of buffers. -  <code>ngx_conf_set_enum_slot</code> — Converts the supplied argument into an <code>ngx_uint_t</code> value. The null-terminated array of <code>ngx_conf_enum_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding integer values. -  <code>ngx_conf_set_bitmask_slot</code> — Converts the supplied arguments into an <code>ngx_uint_t</code> value. The mask values for each argument are ORed producing the result. The null-terminated array of <code>ngx_conf_bitmask_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding mask values. -  <code>set_path_slot</code> — Converts the supplied arguments to an <code>ngx_path_t</code> value and performs all required initializations. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_temp_path">proxy_temp_path</a> directive. -  <code>set_access_slot</code> — Converts the supplied arguments to a file permissions mask. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_store_access">proxy_store_access</a> directive. </li>
</ul>
<p> The <code>conf</code> field defines which configuration structure is passed to the directory handler. Core modules only have the global configuration and set <code>NGX_DIRECT_CONF</code> flag to access it. Modules like HTTP, Stream or Mail create hierarchies of configurations. For example, a module’s configuration is created for <code>server</code> , <code>location</code> and <code>if</code> scopes. </p>
<ul>
<li><code>NGX_HTTP_MAIN_CONF_OFFSET</code> — Configuration for the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF_OFFSET</code> — Configuration for a <code>location</code> block within the <code>http</code> . -  <code>NGX_STREAM_MAIN_CONF_OFFSET</code> — Configuration for the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF_OFFSET</code> — Configuration for the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>mail</code> block. </li>
</ul>
<p> The <code>offset</code> defines the offset of a field in a module configuration structure that holds values for this particular directive. The typical use is to employ the <code>offsetof()</code> macro. </p>
<p> The <code>post</code> field has two purposes: it may be used to define a handler to be called after the main handler has completed, or to pass additional data to the main handler. In the first case, the <code>ngx_conf_post_t</code> structure needs to be initialized with a pointer to the handler, for example: </p>
<pre class="notranslate">static char *ngx_do_foo(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_post = { ngx_do_foo };
</pre>

<p> The <code>post</code> argument is the <code>ngx_conf_post_t</code> object itself, and the <code>data</code> is a pointer to the value, converted from arguments by the main handler with the appropriate type. </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h4 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h4><p> Each HTTP client connection runs through the following stages: </p>
<ul>
<li><p><code>ngx_event_accept()</code> accepts a client TCP connection. This handler is called in response to a read notification on a listen socket. A new <code>ngx_connecton_t</code> object is created at this stage to wrap the newly accepted client socket. Each nginx listener provides a handler to pass the new connection object to. For HTTP connections it’s <code>ngx_http_init_connection(c)</code> . -  <code>ngx_http_init_connection()</code> performs early initialization of the HTTP connection. At this stage an <code>ngx_http_connection_t</code> object is created for the connection and its reference is stored in the connection’s <code>data</code> field. Later it will be replaced by an HTTP request object. A PROXY protocol parser and the SSL handshake are started at this stage as well. -  <code>ngx_http_wait_request_handler()</code> read event handler is called when data is available on the client socket. At this stage an HTTP request object <code>ngx_http_request_t</code> is created and set to the connection’s <code>data</code> field. -  <code>ngx_http_process_request_line()</code> read event handler reads client request line. The handler is set by <code>ngx_http_wait_request_handler()</code> . The data is read into connection’s <code>buffer</code> . The size of the buffer is initially set by the directive <a href="http/ngx_http_core_module.html#client_header_buffer_size">client_header_buffer_size</a> . The entire client header is supposed to fit in the buffer. If the initial size is not sufficient, a bigger buffer is allocated, with the capacity set by the <code>large_client_header_buffers</code> directive. -  <code>ngx_http_process_request_headers()</code> read event handler, is set after <code>ngx_http_process_request_line()</code> to read the client request header. -  <code>ngx_http_core_run_phases()</code> is called when the request header is completely read and parsed. This function runs request phases from <code>NGX_HTTP_POST_READ_PHASE</code> to <code>NGX_HTTP_CONTENT_PHASE</code> . The last phase is intended to generate a response and pass it along the filter chain. The response is not necessarily sent to the client at this phase. It might remain buffered and be sent at the finalization stage. -  <code>ngx_http_finalize_request()</code> is usually called when the request has generated all the output or produced an error. In the latter case an appropriate error page is looked up and used as the response. If the response is not completely sent to the client by this point, an HTTP writer <code>ngx_http_writer()</code> is activated to finish sending outstanding data. -  <code>ngx_http_finalize_connection()</code> is called when the complete response has been sent to the client and the request can be destroyed. If the client connection keepalive feature is enabled, <code>ngx_http_set_keepalive()</code> is called, which destroys the current request and waits for the next request on the connection. Otherwise, <code>ngx_http_close_request()</code> destroys both the request and the connection. </p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>For each client HTTP request the <code>ngx_http_request_t</code> object is created. Some of the fields of this object are: </p>
</li>
<li><p><code>connection</code> — Pointer to a <code>ngx_connection_t</code> client connection object. Several requests can reference the same connection object at the same time - one main request and its subrequests. After a request is deleted, a new request can be created on the same connection.  Note that for HTTP connections <code>ngx_connection_t</code> ‘s <code>data</code> field points back to the request. Such requests are called active, as opposed to the other requests tied to the connection. An active request is used to handle client connection events and is allowed to output its response to the client. Normally, each request becomes active at some point so that it can send its output. -  <code>ctx</code> — Array of HTTP module contexts. Each module of type <code>NGX_HTTP_MODULE</code> can store any value (normally, a pointer to a structure) in the request. The value is stored in the <code>ctx</code> array at the module’s <code>ctx_index</code> position. The following macros provide a convenient way to get and set request contexts: <ul class="compact"><li> <code>ngx_http_get_module_ctx(r, module)</code> — Returns the <code>module</code> ‘s context -  <code>ngx_http_set_ctx(r, c, module)</code> — Sets <code>c</code> as the <code>module</code> ‘s context<br><code>posted_requests</code> — List of requests to be started or resumed, which is done by calling the request’s <code>write_event_handler</code> . Normally, this handler holds the request main function, which at first runs request phases and then produces the output. </li></ul></p>
<p>A request is usually posted by the <code>ngx_http_post_request(r, NULL)</code> call. It is always posted to the main request <code>posted_requests</code> list. The function <code>ngx_http_run_posted_requests(c)</code> runs all requests that are posted in the main request of the passed connection’s active request. All event handlers call <code>ngx_http_run_posted_requests</code> , which can lead to new posted requests. Normally, it is called after invoking a request’s read or write handler. </p>
<p><code>keepalive</code> — Flag indicating whether client connection keepalive is supported. The value is inferred from the HTTP version and the value of the “Connection” header. </p>
</li>
</ul>
<h4 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h4><p> Each HTTP module can have three types of configuration: </p>
<ul>
<li>Main configuration — Applies to the entire <code>http</code> block. Functions as global settings for a module. -  Server configuration — Applies to a single <code>server</code> block. Functions as server-specific settings for a module. -  Location configuration — Applies to a single <code>location</code> , <code>if</code> or <code>limit_except</code> block. Functions as location-specific settings for a module.<br>Configuration structures are created at the nginx configuration stage by calling functions, which allocate the structures, initialize them and merge them. The following example shows how to create a simple location configuration for a module. The configuration has one setting, <code>foo</code> , of type unsigned integer. </li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_uint_t  foo;
} ngx_http_foo_loc_conf_t;


static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    NULL,                                  /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    ngx_http_foo_create_loc_conf,          /* create location configuration */
    ngx_http_foo_merge_loc_conf            /* merge location configuration */
};


static void *
ngx_http_foo_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_foo_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_foo_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf-&gt;foo = NGX_CONF_UNSET_UINT;

    return conf;
}


static char *
ngx_http_foo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_foo_loc_conf_t *prev = parent;
    ngx_http_foo_loc_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf-&gt;foo, prev-&gt;foo, 1);
}
</pre>

<p> As seen in the example, the <code>ngx_http_foo_create_loc_conf()</code> function creates a new configuration structure, and <code>ngx_http_foo_merge_loc_conf()</code> merges a configuration with configuration from a higher level. In fact, server and location configuration do not exist only at the server and location levels, but are also created for all levels above them. Specifically, a server configuration is also created at the main level and location configurations are created at the main, server, and location levels. These configurations make it possible to specify server- and location-specific settings at any level of an nginx configuration file. Eventually configurations are merged down. A number of macros like <code>NGX_CONF_UNSET</code> and <code>NGX_CONF_UNSET_UINT</code> are provided for indicating a missing setting and ignoring it while merging. Standard nginx merge macros like <code>ngx_conf_merge_value()</code> and <code>ngx_conf_merge_uint_value()</code> provide a convenient way to merge a setting and set the default value if none of the configurations provided an explicit value. For complete list of macros for different types, see <code>src/core/ngx_conf_file.h</code> . </p>
<p> The following macros are available. for accessing configuration for HTTP modules at configuration time. They all take <code>ngx_conf_t</code> reference as the first argument. </p>
<ul>
<li><code>ngx_http_conf_get_module_main_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_srv_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_loc_conf(cf, module)</code><br>The following example gets a pointer to a location configuration of standard nginx core module <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> and replaces the location content handler kept in the <code>handler</code> field of the structure. </li>
</ul>
<pre class="notranslate">static ngx_int_t ngx_http_foo_handler(ngx_http_request_t *r);


static ngx_command_t  ngx_http_foo_commands[] = {

    { ngx_string("foo"),
      NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
      ngx_http_foo,
      0,
      0,
      NULL },

      ngx_null_command
};


static char *
ngx_http_foo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_bar_handler;

    return NGX_CONF_OK;
}
</pre>

<p> The following macros are available for accessing configuration for HTTP modules at runtime. </p>
<ul>
<li><code>ngx_http_get_module_main_conf(r, module)</code>  -  <code>ngx_http_get_module_srv_conf(r, module)</code>  -  <code>ngx_http_get_module_loc_conf(r, module)</code><br>These macros receive a reference to an HTTP request <code>ngx_http_request_t</code> . The main configuration of a request never changes. Server configuration can change from the default after the virtual server for the request is chosen. Location configuration selected for processing a request can change multiple times as a result of a rewrite operation or internal redirect. The following example shows how to access a module’s HTTP configuration at runtime. </li>
</ul>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_http_foo_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_foo_module);

    ...
}
</pre>

<h4 id="相"><a href="#相" class="headerlink" title="相"></a>相</h4><p> Each HTTP request passes through a sequence of phases. In each phase a distinct type of processing is performed on the request. Module-specific handlers can be registered in most phases, and many standard nginx modules register their phase handlers as a way to get called at a specific stage of request processing. Phases are processed successively and the phase handlers are called once the request reaches the phase. Following is the list of nginx HTTP phases. </p>
<ul>
<li><code>NGX_HTTP_POST_READ_PHASE</code> — First phase. The <a href="http/ngx_http_realip_module.html">ngx_http_realip_module</a> registers its handler at this phase to enable substitution of client addresses before any other module is invoked. -  <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> — Phase where rewrite directives defined in a <code>server</code> block (but outside a <code>location</code> block) are processed. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> installs its handler at this phase. -  <code>NGX_HTTP_FIND_CONFIG_PHASE</code> — Special phase where a location is chosen based on the request URI. Before this phase, the default location for the relevant virtual server is assigned to the request, and any module requesting a location configuration receives the configuration for the default server location. This phase a assigns a new location to the request. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_REWRITE_PHASE</code> — Same as <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> , but for rewrite rules defined in the location, chosen in the previous phase. -  <code>NGX_HTTP_POST_REWRITE_PHASE</code> — Special phase where the request is redirected to a new location if its URI changed during a rewrite. This is implemented by the request going through the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> again. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PREACCESS_PHASE</code> — A common phase for different types of handlers, not associated with access control. The standard nginx modules <a href="http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a> and <a href="http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a> register their handlers at this phase. -  <code>NGX_HTTP_ACCESS_PHASE</code> — Phase where it is verified that the client is authorized to make the request. Standard nginx modules such as <a href="http/ngx_http_access_module.html">ngx_http_access_module</a> and <a href="http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> register their handlers at this phase. By default the client must pass the authorization check of all handlers registered at this phase for the request to continue to the next phase. The <a href="http/ngx_http_core_module.html#satisfy">satisfy</a> directive, can be used to permit processing to continue if any of the phase handlers authorizes the client. -  <code>NGX_HTTP_POST_ACCESS_PHASE</code> — Special phase where the <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> directive is processed. If some access phase handlers denied access and none explicitly allowed it, the request is finalized. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PRECONTENT_PHASE</code> — Phase for handlers to be called prior to generating content. Standard modules such as <a href="http/ngx_http_core_module.html#try_files">ngx_http_try_files_module</a> and <a href="http/ngx_http_mirror_module.html">ngx_http_mirror_module</a> register their handlers at this phase. -  <code>NGX_HTTP_CONTENT_PHASE</code> — Phase where the response is normally generated. Multiple nginx standard modules register their handlers at this phase, including <a href="http/ngx_http_index_module.html">ngx_http_index_module</a> or <code>ngx_http_static_module</code> . They are called sequentially until one of them produces the output. It’s also possible to set content handlers on a per-location basis. If the <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> ‘s location configuration has <code>handler</code> set, it is called as the content handler and the handlers installed at this phase are ignored. -  <code>NGX_HTTP_LOG_PHASE</code> — Phase where request logging is performed. Currently, only the <a href="http/ngx_http_log_module.html">ngx_http_log_module</a> registers its handler at this stage for access logging. Log phase handlers are called at the very end of request processing, right before freeing the request.<br>Following is the example of a preaccess phase handler. </li>
</ul>
<pre class="notranslate">static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    ngx_http_foo_init,                     /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_str_t  *ua;

    ua = r-&gt;headers_in-&gt;user_agent;

    if (ua == NULL) {
        return NGX_DECLINED;
    }

    /* reject requests with "User-Agent: foo" */
    if (ua-&gt;value.len == 3 &amp;&amp; ngx_strncmp(ua-&gt;value.data, "foo", 3) == 0) {
        return NGX_HTTP_FORBIDDEN;
    }

    return NGX_DECLINED;
}


static ngx_int_t
ngx_http_foo_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_foo_handler;

    return NGX_OK;
}
</pre>

<p> Phase handlers are expected to return specific codes: </p>
<ul>
<li><code>NGX_OK</code> — Proceed to the next phase. -  <code>NGX_DECLINED</code> — Proceed to the next handler of the current phase. If the current handler is the last in the current phase, move to the next phase. -  <code>NGX_AGAIN</code> , <code>NGX_DONE</code> — Suspend phase handling until some future event which can be an asynchronous I/O operation or just a delay, for example. It is assumed, that phase handling will be resumed later by calling <code>ngx_http_core_run_phases()</code> . -  Any other value returned by the phase handler is treated as a request finalization code, in particular, an HTTP response code. The request is finalized with the code provided.<br>For some phases, return codes are treated in a slightly different way. At the content phase, any return code other that <code>NGX_DECLINED</code> is considered a finalization code. Any return code from the location content handlers is considered a finalization code. At the access phase, in <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> mode, any return code other than <code>NGX_OK</code> , <code>NGX_DECLINED</code> , <code>NGX_AGAIN</code> , <code>NGX_DONE</code> is considered a denial. If no subsequent access handlers allow or deny access with a different code, the denial code will become the finalization code. </li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h4 id="Accessing-existing-variables"><a href="#Accessing-existing-variables" class="headerlink" title="Accessing existing variables"></a>Accessing existing variables</h4><p> Variables can be referenced by index (this is the most common method) or name (see <a href="#http_creating_variables">below</a> ). The index is created at configuration stage, when a variable is added to the configuration. To obtain the variable index, use <code>ngx_http_get_variable_index()</code> : </p>
<pre class="notranslate">ngx_str_t  name;  /* ngx_string("foo") */
ngx_int_t  index;

index = ngx_http_get_variable_index(cf, &amp;name);
</pre>

<p> Here, <code>cf</code> is a pointer to nginx configuration and <code>name</code> points to a string containing the variable name. The function returns <code>NGX_ERROR</code> on error or a valid index otherwise, which is typically stored somewhere in the module’s configuration for future use. </p>
<p> All HTTP variables are evaluated in the context of a given HTTP request, and results are specific to and cached in that HTTP request. All functions that evaluate variables return the <code>ngx_http_variable_value_t</code> type, representing the variable value: </p>
<pre class="notranslate">typedef ngx_variable_value_t  ngx_http_variable_value_t;

typedef struct {
    unsigned    len:28;

    unsigned    valid:1;
    unsigned    no_cacheable:1;
    unsigned    not_found:1;
    unsigned    escape:1;

    u_char     *data;
} ngx_variable_value_t;
</pre>

<p>  哪里： </p>
<ul>
<li><code>len</code> — The length of the value -  <code>data</code> — The value itself -  <code>valid</code> — The value is valid -  <code>not_found</code> — The variable was not found and thus the <code>data</code> and <code>len</code> fields are irrelevant; this can happen, for example, with variables like <code>$arg_foo</code> when a corresponding argument was not passed in a request -  <code>no_cacheable</code> — Do not cache result -  <code>escape</code> — Used internally by the logging module to mark values that require escaping on output. </li>
</ul>
<p> The <code>ngx_http_get_flushed_variable()</code> and <code>ngx_http_get_indexed_variable()</code> functions are used to obtain the value of a variable. They have the same interface - accepting an HTTP request <code>r</code> as a context for evaluating the variable and an <code>index</code> that identifies it. An example of typical usage: </p>
<pre class="notranslate">ngx_http_variable_value_t  *v;

v = ngx_http_get_flushed_variable(r, index);

if (v == NULL || v-&gt;not_found) {
    /* we failed to get value or there is no such variable, handle it */
    return NGX_ERROR;
}

/* some meaningful value is found */
</pre>

<p> The difference between functions is that the <code>ngx_http_get_indexed_variable()</code> returns a cached value and <code>ngx_http_get_flushed_variable()</code> flushes the cache for non-cacheable variables. </p>
<p> Some modules, such as SSI and Perl, need to deal with variables for which the name is not known at configuration time. An index therefore cannot be used to access them, but the <code>ngx_http_get_variable(r, name, key)</code> function is available. It searches for a variable with a given <code>name</code> and its hash <code>key</code> derived from the name. </p>
<h4 id="Creating-variables"><a href="#Creating-variables" class="headerlink" title="Creating variables"></a>Creating variables</h4><p> To create a variable, use the <code>ngx_http_add_variable()</code> function. It takes as arguments a configuration (where the variable is registered), the variable name and flags that control the function’s behaviour: </p>
<ul>
<li><code>NGX_HTTP_VAR_CHANGEABLE</code> — Enables redefinition of the variable: there is no conflict if another module defines a variable with the same name. This allows the <a href="http/ngx_http_rewrite_module.html#set">set</a> directive to override variables. -  <code>NGX_HTTP_VAR_NOCACHEABLE</code> — Disables caching, which is useful for variables such as <code>$time_local</code> . -  <code>NGX_HTTP_VAR_NOHASH</code> — Indicates that this variable is only accessible by index, not by name. This is a small optimization for use when it is known that the variable is not needed in modules like SSI or Perl. -  <code>NGX_HTTP_VAR_PREFIX</code> — The name of the variable is a prefix. In this case, a handler must implement additional logic to obtain the value of a specific variable. For example, all “ <code>arg_</code> ” variables are processed by the same handler, which performs lookup in request arguments and returns the value of a specific argument.<br>The function returns NULL in case of error or a pointer to <code>ngx_http_variable_t</code> otherwise: </li>
</ul>
<pre class="notranslate">struct ngx_http_variable_s {
    ngx_str_t                     name;
    ngx_http_set_variable_pt      set_handler;
    ngx_http_get_variable_pt      get_handler;
    uintptr_t                     data;
    ngx_uint_t                    flags;
    ngx_uint_t                    index;
};
</pre>

<p> The <code>get</code> and <code>set</code> handlers are called to obtain or set the variable value, <code>data</code> is passed to variable handlers, and <code>index</code> holds assigned variable index used to reference the variable. </p>
<p> Usually, a null-terminated static array of <code>ngx_http_variable_t</code> structures is created by a module and processed at the preconfiguration stage to add variables into the configuration, for example: </p>
<pre class="notranslate">static ngx_http_variable_t  ngx_http_foo_vars[] = {

    { ngx_string("foo_v1"), NULL, ngx_http_foo_v1_variable, 0, 0, 0 },

      ngx_http_null_variable
};

static ngx_int_t
ngx_http_foo_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_foo_vars; v-&gt;name.len; v++) {
        var = ngx_http_add_variable(cf, &amp;v-&gt;name, v-&gt;flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var-&gt;get_handler = v-&gt;get_handler;
        var-&gt;data = v-&gt;data;
    }

    return NGX_OK;
}
</pre>

<p> This function in the example is used to initialize the <code>preconfiguration</code> field of the HTTP module context and is called before the parsing of HTTP configuration, so that the parser can refer to these variables. </p>
<p> The <code>get</code> handler is responsible for evaluating a variable in the context of a specific request, for example: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_variable_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r-&gt;pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;len = ngx_sprintf(p, "%uA", r-&gt;connection-&gt;number) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;
    v-&gt;data = p;

    return NGX_OK;
}
</pre>

<p> It returns <code>NGX_ERROR</code> in case of internal error (for example, failed memory allocation) or <code>NGX_OK</code> otherwise. To learn the status of variable evaluation, inspect the flags in <code>ngx_http_variable_value_t</code> (see the description <a href="#http_existing_variables">above</a> ). </p>
<p> The <code>set</code> handler allows setting the property referenced by the variable. For example, the set handler of the <code>$limit_rate</code> variable modifies the request’s <code>limit_rate</code> field: </p>
<pre class="notranslate">...
{ ngx_string("limit_rate"), ngx_http_variable_request_set_size,
  ngx_http_variable_request_get_size,
  offsetof(ngx_http_request_t, limit_rate),
  NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE, 0 },
...

static void
ngx_http_variable_request_set_size(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ssize_t    s, *sp;
    ngx_str_t  val;

    val.len = v-&gt;len;
    val.data = v-&gt;data;

    s = ngx_parse_size(&amp;val);

    if (s == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                      "invalid size \"%V\"", &amp;val);
        return;
    }

    sp = (ssize_t *) ((char *) r + data);

    *sp = s;

    return;
}
</pre>



<h4 id="Complex-values"><a href="#Complex-values" class="headerlink" title="Complex values"></a>Complex values</h4><p> A complex value, despite its name, provides an easy way to evaluate expressions which can contain text, variables, and their combination. </p>
<p> The complex value description in <code>ngx_http_compile_complex_value</code> is compiled at the configuration stage into <code>ngx_http_complex_value_t</code> which is used at runtime to obtain results of expression evaluation. </p>
<pre class="notranslate">ngx_str_t                         *value;
ngx_http_complex_value_t           cv;
ngx_http_compile_complex_value_t   ccv;

value = cf-&gt;args-&gt;elts; /* directive arguments */

ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

ccv.cf = cf;
ccv.value = &amp;value[1];
ccv.complex_value = &amp;cv;
ccv.zero = 1;
ccv.conf_prefix = 1;

if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
    return NGX_CONF_ERROR;
}
</pre>

<p> Here, <code>ccv</code> holds all parameters that are required to initialize the complex value <code>cv</code> : </p>
<ul>
<li><p><code>cf</code> — Configuration pointer -  <code>value</code> — String to be parsed (input) -  <code>complex_value</code> — Compiled value (output) -  <code>zero</code> — Flag that enables zero-terminating value -  <code>conf_prefix</code> — Prefixes the result with the configuration prefix (the directory where nginx is currently looking for configuration) -  <code>root_prefix</code> — Prefixes the result with the root prefix (the normal nginx installation prefix)<br>The <code>zero</code> flag is useful when results are to be passed to libraries that require zero-terminated strings, and prefixes are handy when dealing with filenames. </p>
<p>Upon successful compilation, <code>cv.lengths</code> contains information about the presence of variables in the expression. The NULL value means that the expression contained static text only, and so can be stored in a simple string rather than as a complex value. </p>
<p>The <code>ngx_http_set_complex_value_slot()</code> is a convenient function used to initialize a complex value completely in the directive declaration itself. </p>
<p>At runtime, a complex value can be calculated using the <code>ngx_http_complex_value()</code> function: </p>
</li>
</ul>
<pre class="notranslate">ngx_str_t  res;

if (ngx_http_complex_value(r, &amp;cv, &amp;res) != NGX_OK) {
    return NGX_ERROR;
}
</pre>

<p> Given the request <code>r</code> and previously compiled value <code>cv</code> , the function evaluates the expression and writes the result to <code>res</code> . </p>
<h4 id="Request-redirection"><a href="#Request-redirection" class="headerlink" title="Request redirection"></a>Request redirection</h4><p> An HTTP request is always connected to a location via the <code>loc_conf</code> field of the <code>ngx_http_request_t</code> structure. This means that at any point the location configuration of any module can be retrieved from the request by calling <code>ngx_http_get_module_loc_conf(r, module)</code> . Request location can change several times during the request’s lifetime. Initially, a default server location of the default server is assigned to a request. If the request switches to a different server (chosen by the HTTP “Host” header or SSL SNI extension), the request switches to the default location of that server as well. The next change of the location takes place at the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> request phase. At this phase a location is chosen by request URI among all non-named locations configured for the server. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> can change the request URI at the <code>NGX_HTTP_REWRITE_PHASE</code> request phase as a result of the <a href="http/ngx_http_rewrite_module.html#rewrite">rewrite</a> directive and send the request back to the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> phase for selection of a new location based on the new URI. </p>
<p> It is also possible to redirect a request to a new location at any point by calling one of <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> . </p>
<p> The <code>ngx_http_internal_redirect(r, uri, args)</code> function changes the request URI and returns the request to the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. The request proceeds with a server default location. Later at <code>NGX_HTTP_FIND_CONFIG_PHASE</code> a new location is chosen based on the new request URI. </p>
<p> The following example performs an internal redirect with the new request arguments. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_redirect(ngx_http_request_t *r)
{
    ngx_str_t  uri, args;

    ngx_str_set(&amp;uri, "/foo");
    ngx_str_set(&amp;args, "bar=1");

    return ngx_http_internal_redirect(r, &amp;uri, &amp;args);
}
</pre>

<p> The function <code>ngx_http_named_location(r, name)</code> redirects a request to a named location. The name of the location is passed as the argument. The location is looked up among all named locations of the current server, after which the requests switches to the <code>NGX_HTTP_REWRITE_PHASE</code> phase. </p>
<p> The following example performs a redirect to a named location @foo. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_named_redirect(ngx_http_request_t *r)
{
    ngx_str_t  name;

    ngx_str_set(&amp;name, "foo");

    return ngx_http_named_location(r, &amp;name);
}
</pre>

<p> Both functions - <code>ngx_http_internal_redirect(r, uri, args)</code> and <code>ngx_http_named_location(r, name)</code> can be called when nginx modules have already stored some contexts in a request’s <code>ctx</code> field. It’s possible for these contexts to become inconsistent with the new location configuration. To prevent inconsistency, all request contexts are erased by both redirect functions. </p>
<p> Calling <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> increases the request <code>count</code> . For consistent request reference counting, call <code>ngx_http_finalize_request(r, NGX_DONE)</code> after redirecting the request. This will finalize current request code path and decrease the counter. </p>
<p> Redirected and rewritten requests become internal and can access the <a href="http/ngx_http_core_module.html#internal">internal</a> locations. Internal requests have the <code>internal</code> flag set. </p>
<h4 id="Subrequests"><a href="#Subrequests" class="headerlink" title="Subrequests"></a>Subrequests</h4><p> Subrequests are primarily used to insert output of one request into another, possibly mixed with other data. A subrequest looks like a normal request, but shares some data with its parent. In particular, all fields related to client input are shared because a subrequest does not receive any other input from the client. The request field <code>parent</code> for a subrequest contains a link to its parent request and is NULL for the main request. The field <code>main</code> contains a link to the main request in a group of requests. </p>
<p> A subrequest starts in the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. It passes through the same subsequent phases as a normal request and is assigned a location based on its own URI. </p>
<p> The output header in a subrequest is always ignored. The <code>ngx_http_postpone_filter</code> places the subrequest’s output body in the right position relative to other data produced by the parent request. </p>
<p> Subrequests are related to the concept of active requests. A request <code>r</code> is considered active if <code>c-&amp;gt;data == r</code> , where <code>c</code> is the client connection object. At any given point, only the active request in a request group is allowed to output its buffers to the client. An inactive request can still send its output to the filter chain, but it does not pass beyond the <code>ngx_http_postpone_filter</code> and remains buffered by that filter until the request becomes active. Here are some rules of request activation: </p>
<ul>
<li>Initially, the main request is active. -  The first subrequest of an active request becomes active right after creation. -  The <code>ngx_http_postpone_filter</code> activates the next request in the active request’s subrequest list, once all data prior to that request are sent. -  When a request is finalized, its parent is activated.<br>Create a subrequest by calling the function <code>ngx_http_subrequest(r, uri, args, psr, ps, flags)</code> , where <code>r</code> is the parent request, <code>uri</code> and <code>args</code> are the URI and arguments of the subrequest, <code>psr</code> is the output parameter, which receives the newly created subrequest reference, <code>ps</code> is a callback object for notifying the parent request that the subrequest is being finalized, and <code>flags</code> is bitmask of flags. The following flags are available: </li>
<li><code>NGX_HTTP_SUBREQUEST_IN_MEMORY</code> - Output is not sent to the client, but rather stored in memory. The flag only affects subrequests which are processed by one of the proxying modules. After a subrequest is finalized its output is available in a <code>r-&amp;gt;upstream-&amp;gt;buffer</code> of type <code>ngx_buf_t</code> . -  <code>NGX_HTTP_SUBREQUEST_WAITED</code> - The subrequest’s <code>done</code> flag is set even if the subrequest is not active when it is finalized. This subrequest flag is used by the SSI filter. -  <code>NGX_HTTP_SUBREQUEST_CLONE</code> - The subrequest is created as a clone of its parent. It is started at the same location and proceeds from the same phase as the parent request.<br>The following example creates a subrequest with the URI of <code>/foo</code> . </li>
</ul>
<pre class="notranslate">ngx_int_t            rc;
ngx_str_t            uri;
ngx_http_request_t  *sr;

...

ngx_str_set(&amp;uri, "/foo");

rc = ngx_http_subrequest(r, &amp;uri, NULL, &amp;sr, NULL, 0);
if (rc == NGX_ERROR) {
    /* error */
}
</pre>

<p> This example clones the current request and sets a finalization callback for the subrequest. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_clone(ngx_http_request_t *r)
{
    ngx_http_request_t          *sr;
    ngx_http_post_subrequest_t  *ps;

    ps = ngx_palloc(r-&gt;pool, sizeof(ngx_http_post_subrequest_t));
    if (ps == NULL) {
        return NGX_ERROR;
    }

    ps-&gt;handler = ngx_http_foo_subrequest_done;
    ps-&gt;data = "foo";

    return ngx_http_subrequest(r, &amp;r-&gt;uri, &amp;r-&gt;args, &amp;sr, ps,
                               NGX_HTTP_SUBREQUEST_CLONE);
}


ngx_int_t
ngx_http_foo_subrequest_done(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    char  *msg = (char *) data;

    ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  "done subrequest r:%p msg:%s rc:%i", r, msg, rc);

    return rc;
}
</pre>

<p> Subrequests are normally created in a body filter, in which case their output can be treated like the output from any explicit request. This means that eventually the output of a subrequest is sent to the client, after all explicit buffers that are passed before subrequest creation and before any buffers that are passed after creation. This ordering is preserved even for large hierarchies of subrequests. The following example inserts output from a subrequest after all request data buffers, but before the final buffer with the <code>last_buf</code> flag. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_uint_t                  last;
    ngx_chain_t                *cl, out;
    ngx_http_request_t         *sr;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    last = 0;

    for (cl = in; cl; cl = cl-&gt;next) {
        if (cl-&gt;buf-&gt;last_buf) {
            cl-&gt;buf-&gt;last_buf = 0;
            cl-&gt;buf-&gt;last_in_chain = 1;
            cl-&gt;buf-&gt;sync = 1;
            last = 1;
        }
    }

    /* Output explicit output buffers */

    rc = ngx_http_next_body_filter(r, in);

    if (rc == NGX_ERROR || !last) {
        return rc;
    }

    /*
     * Create the subrequest.  The output of the subrequest
     * will automatically be sent after all preceding buffers,
     * but before the last_buf buffer passed later in this function.
     */

    if (ngx_http_subrequest(r, ctx-&gt;uri, NULL, &amp;sr, NULL, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, NULL, ngx_http_foo_filter_module);

    /* Output the final buffer with the last_buf flag */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = 1;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<p> A subrequest can also be created for other purposes than data output. For example, the <a href="http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> module creates a subrequest at the <code>NGX_HTTP_ACCESS_PHASE</code> phase. To disable output at this point, the <code>header_only</code> flag is set on the subrequest. This prevents the subrequest body from being sent to the client. Note that the subrequest’s header is never sent to the client. The result of the subrequest can be analyzed in the callback handler. </p>
<h4 id="Request-finalization"><a href="#Request-finalization" class="headerlink" title="Request finalization"></a>Request finalization</h4><p> An HTTP request is finalized by calling the function <code>ngx_http_finalize_request(r, rc)</code> . It is usually finalized by the content handler after all output buffers are sent to the filter chain. At this point all of the output might not be sent to the client, with some of it remaining buffered somewhere along the filter chain. If it is, the <code>ngx_http_finalize_request(r, rc)</code> function automatically installs a special handler <code>ngx_http_writer(r)</code> to finish sending the output. A request is also finalized in case of an error or if a standard HTTP response code needs to be returned to the client. </p>
<p> The function <code>ngx_http_finalize_request(r, rc)</code> expects the following <code>rc</code> values: </p>
<ul>
<li><p><code>NGX_DONE</code> - Fast finalization. Decrement the request <code>count</code> and destroy the request if it reaches zero. The client connection can be used for more requests after the current request is destroyed. -  <code>NGX_ERROR</code> , <code>NGX_HTTP_REQUEST_TIME_OUT</code> ( <code>408</code> ), <code>NGX_HTTP_CLIENT_CLOSED_REQUEST</code> ( <code>499</code> ) - Error finalization. Terminate the request as soon as possible and close the client connection. -  <code>NGX_HTTP_CREATED</code> ( <code>201</code> ), <code>NGX_HTTP_NO_CONTENT</code> ( <code>204</code> ), codes greater than or equal to <code>NGX_HTTP_SPECIAL_RESPONSE</code> ( <code>300</code> ) - Special response finalization. For these values nginx either sends to the client a default response page for the code or performs the internal redirect to an <a href="http/ngx_http_core_module.html#error_page">error_page</a> location if that is configured for the code. -  Other codes are considered successful finalization codes and might activate the request writer to finish sending the response body. Once the body is completely sent, the request <code>count</code> is decremented. If it reaches zero, the request is destroyed, but the client connection can still be used for other requests. If <code>count</code> is positive, there are unfinished activities within the request, which will be finalized at a later point. </p>
<h4 id="Request-body"><a href="#Request-body" class="headerlink" title="Request body"></a>Request body</h4><p>For dealing with the body of a client request, nginx provides the <code>ngx_http_read_client_request_body(r, post_handler)</code> and <code>ngx_http_discard_request_body(r)</code> functions. The first function reads the request body and makes it available via the <code>request_body</code> request field. The second function instructs nginx to discard (read and ignore) the request body. One of these functions must be called for every request. Normally, the content handler makes the call. </p>
<p>Reading or discarding the client request body from a subrequest is not allowed. It must always be done in the main request. When a subrequest is created, it inherits the parent’s <code>request_body</code> object which can be used by the subrequest if the main request has previously read the request body. </p>
<p>The function <code>ngx_http_read_client_request_body(r, post_handler)</code> starts the process of reading the request body. When the body is completely read, the <code>post_handler</code> callback is called to continue processing the request. If the request body is missing or has already been read, the callback is called immediately. The function <code>ngx_http_read_client_request_body(r, post_handler)</code> allocates the <code>request_body</code> request field of type <code>ngx_http_request_body_t</code> . The field <code>bufs</code> of this object keeps the result as a buffer chain. The body can be saved in memory buffers or file buffers, if the capacity specified by the <a href="http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a> directive is not enough to fit the entire body in memory. </p>
<p>The following example reads a client request body and returns its size. </p>
</li>
</ul>
<pre class="notranslate">ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t  rc;

    rc = ngx_http_read_client_request_body(r, ngx_http_foo_init);

    if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) {
        /* error */
        return rc;
    }

    return NGX_DONE;
}


void
ngx_http_foo_init(ngx_http_request_t *r)
{
    off_t         len;
    ngx_buf_t    *b;
    ngx_int_t     rc;
    ngx_chain_t  *in, out;

    if (r-&gt;request_body == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    len = 0;

    for (in = r-&gt;request_body-&gt;bufs; in; in = in-&gt;next) {
        len += ngx_buf_size(in-&gt;buf);
    }

    b = ngx_create_temp_buf(r-&gt;pool, NGX_OFF_T_LEN);
    if (b == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    b-&gt;last = ngx_sprintf(b-&gt;pos, "%O", len);
    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = b-&gt;last - b-&gt;pos;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        ngx_http_finalize_request(r, rc);
        return;
    }

    out.buf = b;
    out.next = NULL;

    rc = ngx_http_output_filter(r, &amp;out);

    ngx_http_finalize_request(r, rc);
}
</pre>

<p> The following fields of the request determine how the request body is read: </p>
<ul>
<li><code>request_body_in_single_buf</code> - Read the body to a single memory buffer. -  <code>request_body_in_file_only</code> - Always read the body to a file, even if fits in the memory buffer. -  <code>request_body_in_persistent_file</code> - Do not unlink the file immediately after creation. A file with this flag can be moved to another directory. -  <code>request_body_in_clean_file</code> - Unlink the file when the request is finalized. This can be useful when a file was supposed to be moved to another directory but was not moved for some reason. -  <code>request_body_file_group_access</code> - Enable group access to the file by replacing the default 0600 access mask with 0660. -  <code>request_body_file_log_level</code> - Severity level at which to log file errors. -  <code>request_body_no_buffering</code> - Read the request body without buffering.<br>The <code>request_body_no_buffering</code> flag enables the unbuffered mode of reading a request body. In this mode, after calling <code>ngx_http_read_client_request_body()</code> , the <code>bufs</code> chain might keep only a part of the body. To read the next part, call the <code>ngx_http_read_unbuffered_request_body(r)</code> function. The return value <code>NGX_AGAIN</code> and the request flag <code>reading_body</code> indicate that more data is available. If <code>bufs</code> is NULL after calling this function, there is nothing to read at the moment. The request callback <code>read_event_handler</code> will be called when the next part of request body is available. </li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p> In nginx an HTTP response is produced by sending the response header followed by the optional response body. Both header and body are passed through a chain of filters and eventually get written to the client socket. An nginx module can install its handler into the header or body filter chain and process the output coming from the previous handler. </p>
<h4 id="Response-header"><a href="#Response-header" class="headerlink" title="Response header"></a>Response header</h4><p> The <code>ngx_http_send_header(r)</code> function sends the output header. Do not call this function until <code>r-&amp;gt;headers_out</code> contains all of the data required to produce the HTTP response header. The <code>status</code> field in <code>r-&amp;gt;headers_out</code> must always be set. If the response status indicates that a response body follows the header, <code>content_length_n</code> can be set as well. The default value for this field is <code>-1</code> , which means that the body size is unknown. In this case, chunked transfer encoding is used. To output an arbitrary header, append the <code>headers</code> list. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t         rc;
    ngx_table_elt_t  *h;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    /* X-Foo: foo */

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    ...
}
</pre>

<h4 id="Header-filters"><a href="#Header-filters" class="headerlink" title="Header filters"></a>Header filters</h4><p> The <code>ngx_http_send_header(r)</code> function invokes the header filter chain by calling the first header filter handler stored in the <code>ngx_http_top_header_filter</code> variable. It’s assumed that every header handler calls the next handler in the chain until the final handler <code>ngx_http_header_filter(r)</code> is called. The final header handler constructs the HTTP response based on <code>r-&amp;gt;headers_out</code> and passes it to the <code>ngx_http_writer_filter</code> for output. </p>
<p> To add a handler to the header filter chain, store its address in the global variable <code>ngx_http_top_header_filter</code> at configuration time. The previous handler address is normally stored in a static variable in a module and is called by the newly added handler before exiting. </p>
<p> The following example of a header filter module adds the HTTP header “ <code>X-Foo: foo</code> “ to every response with status <code>200</code> . </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


static ngx_int_t ngx_http_foo_header_filter(ngx_http_request_t *r);
static ngx_int_t ngx_http_foo_header_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_foo_header_filter_module_ctx = {
    NULL,                                   /* preconfiguration */
    ngx_http_foo_header_filter_init,        /* postconfiguration */

    NULL,                                   /* create main configuration */
    NULL,                                   /* init main configuration */

    NULL,                                   /* create server configuration */
    NULL,                                   /* merge server configuration */

    NULL,                                   /* create location configuration */
    NULL                                    /* merge location configuration */
};


ngx_module_t  ngx_http_foo_header_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_foo_header_filter_module_ctx, /* module context */
    NULL,                                   /* module directives */
    NGX_HTTP_MODULE,                        /* module type */
    NULL,                                   /* init master */
    NULL,                                   /* init module */
    NULL,                                   /* init process */
    NULL,                                   /* init thread */
    NULL,                                   /* exit thread */
    NULL,                                   /* exit process */
    NULL,                                   /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;


static ngx_int_t
ngx_http_foo_header_filter(ngx_http_request_t *r)
{
    ngx_table_elt_t  *h;

    /*
     * The filter handler adds "X-Foo: foo" header
     * to every HTTP 200 response
     */

    if (r-&gt;headers_out.status != NGX_HTTP_OK) {
        return ngx_http_next_header_filter(r);
    }

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    return ngx_http_next_header_filter(r);
}


static ngx_int_t
ngx_http_foo_header_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_foo_header_filter;

    return NGX_OK;
}
</pre>

<h4 id="Response-body"><a href="#Response-body" class="headerlink" title="Response body"></a>Response body</h4><p> To send the response body, call the <code>ngx_http_output_filter(r, cl)</code> function. The function can be called multiple times. Each time, it sends a part of the response body in the form of a buffer chain. Set the <code>last_buf</code> flag in the last body buffer. </p>
<p> The following example produces a complete HTTP response with “foo” as its body. For the example to work as subrequest as well as a main request, the <code>last_in_chain</code> flag is set in the last buffer of the output. The <code>last_buf</code> flag is set only for the main request because the last buffer for a subrequest does not end the entire output. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_bar_content_handler(ngx_http_request_t *r)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    b-&gt;memory = 1;

    b-&gt;pos = (u_char *) "foo";
    b-&gt;last = b-&gt;pos + 3;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<h4 id="Body-filters"><a href="#Body-filters" class="headerlink" title="Body filters"></a>Body filters</h4><p> The function <code>ngx_http_output_filter(r, cl)</code> invokes the body filter chain by calling the first body filter handler stored in the <code>ngx_http_top_body_filter</code> variable. It’s assumed that every body handler calls the next handler in the chain until the final handler <code>ngx_http_write_filter(r, cl)</code> is called. </p>
<p> A body filter handler receives a chain of buffers. The handler is supposed to process the buffers and pass a possibly new chain to the next handler. It’s worth noting that the chain links <code>ngx_chain_t</code> of the incoming chain belong to the caller, and must not be reused or changed. Right after the handler completes, the caller can use its output chain links to keep track of the buffers it has sent. To save the buffer chain or to substitute some buffers before passing to the next filter, a handler needs to allocate its own chain links. </p>
<p> Following is an example of a simple body filter that counts the number of bytes in the body. The result is available as the <code>$counter</code> variable which can be used in the access log. </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


typedef struct {
    off_t  count;
} ngx_http_counter_filter_ctx_t;


static ngx_int_t ngx_http_counter_body_filter(ngx_http_request_t *r,
    ngx_chain_t *in);
static ngx_int_t ngx_http_counter_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);
static ngx_int_t ngx_http_counter_add_variables(ngx_conf_t *cf);
static ngx_int_t ngx_http_counter_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_counter_filter_module_ctx = {
    ngx_http_counter_add_variables,        /* preconfiguration */
    ngx_http_counter_filter_init,          /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


ngx_module_t  ngx_http_counter_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_counter_filter_module_ctx,   /* module context */
    NULL,                                  /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_body_filter_pt  ngx_http_next_body_filter;

static ngx_str_t  ngx_http_counter_name = ngx_string("counter");


static ngx_int_t
ngx_http_counter_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_chain_t                    *cl;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_counter_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_counter_filter_module);
    }

    for (cl = in; cl; cl = cl-&gt;next) {
        ctx-&gt;count += ngx_buf_size(cl-&gt;buf);
    }

    return ngx_http_next_body_filter(r, in);
}


static ngx_int_t
ngx_http_counter_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char                         *p;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        v-&gt;not_found = 1;
        return NGX_OK;
    }

    p = ngx_pnalloc(r-&gt;pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;data = p;
    v-&gt;len = ngx_sprintf(p, "%O", ctx-&gt;count) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &amp;ngx_http_counter_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var-&gt;get_handler = ngx_http_counter_variable;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_counter_body_filter;

    return NGX_OK;
}
</pre>

<h4 id="Building-filter-modules"><a href="#Building-filter-modules" class="headerlink" title="Building filter modules"></a>Building filter modules</h4><p> When writing a body or header filter, pay special attention to the filter’s position in the filter order. There’s a number of header and body filters registered by nginx standard modules. The nginx standard modules register a number of head and body filters and it’s important to register a new filter module in the right place with respect to them. Normally, modules register filters in their postconfiguration handlers. The order in which filters are called during processing is obviously the reverse of the order in which they are registered. </p>
<p> For third-party filter modules nginx provides a special slot <code>HTTP_AUX_FILTER_MODULES</code> . To register a filter module in this slot, set the <code>ngx_module_type</code> variable to <code>HTTP_AUX_FILTER</code> in the module’s configuration. </p>
<p> The following example shows a filter module config file assuming for a module with just one source file, <code>ngx_http_foo_filter_module.c</code> . </p>
<pre class="notranslate">ngx_module_type=HTTP_AUX_FILTER
ngx_module_name=ngx_http_foo_filter_module
ngx_module_srcs="$ngx_addon_dir/ngx_http_foo_filter_module.c"

. auto/module
</pre>

<h4 id="Buffer-reuse"><a href="#Buffer-reuse" class="headerlink" title="Buffer reuse"></a>Buffer reuse</h4><p> When issuing or altering a stream of buffers, it’s often desirable to reuse the allocated buffers. A standard and widely adopted approach in nginx code is to keep two buffer chains for this purpose: <code>free</code> and <code>busy</code> . The <code>free</code> chain keeps all free buffers, which can be reused. The <code>busy</code> chain keeps all buffers sent by the current module that are still in use by some other filter handler. A buffer is considered in use if its size is greater than zero. Normally, when a buffer is consumed by a filter, its <code>pos</code> (or <code>file_pos</code> for a file buffer) is moved towards <code>last</code> ( <code>file_last</code> for a file buffer). Once a buffer is completely consumed, it’s ready to be reused. To add newly freed buffers to the <code>free</code> chain it’s enough to iterate over the <code>busy</code> chain and move the zero size buffers at the head of it to <code>free</code> . This operation is so common that there is a special function for it, <code>ngx_chain_update_chains(free, busy, out, tag)</code> . The function appends the output chain <code>out</code> to <code>busy</code> and moves free buffers from the top of <code>busy</code> to <code>free</code> . Only the buffers with the specified <code>tag</code> are reused. This lets a module reuse only the buffers that it allocated itself. </p>
<p> The following example is a body filter that inserts the string “foo” before each incoming buffer. The new buffers allocated by the module are reused if possible. Note that for this example to work properly, setting up a <a href="#http_header_filters">header filter</a> and resetting <code>content_length_n</code> to <code>-1</code> is also required, but the relevant code is not provided here. </p>
<pre class="notranslate">typedef struct {
    ngx_chain_t  *free;
    ngx_chain_t  *busy;
}  ngx_http_foo_filter_ctx_t;


ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_chain_t                *cl, *tl, *out, **ll;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_foo_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_foo_filter_module);
    }

    /* create a new chain "out" from "in" with all the changes */

    ll = &amp;out;

    for (cl = in; cl; cl = cl-&gt;next) {

        /* append "foo" in a reused buffer if possible */

        tl = ngx_chain_get_free_buf(r-&gt;pool, &amp;ctx-&gt;free);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        b = tl-&gt;buf;
        b-&gt;tag = (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module;
        b-&gt;memory = 1;
        b-&gt;pos = (u_char *) "foo";
        b-&gt;last = b-&gt;pos + 3;

        *ll = tl;
        ll = &amp;tl-&gt;next;

        /* append the next incoming buffer */

        tl = ngx_alloc_chain_link(r-&gt;pool);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        tl-&gt;buf = cl-&gt;buf;
        *ll = tl;
        ll = &amp;tl-&gt;next;
    }

    *ll = NULL;

    /* send the new chain */

    rc = ngx_http_next_body_filter(r, out);

    /* update "busy" and "free" chains for reuse */

    ngx_chain_update_chains(r-&gt;pool, &amp;ctx-&gt;free, &amp;ctx-&gt;busy, &amp;out,
                            (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module);

    return rc;
}
</pre>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> provides the basic functionality needed to pass requests to remote servers. Modules that implement specific protocols, such as HTTP or FastCGI, use this functionality. The module also provides an interface for creating custom load-balancing modules and implements a default round-robin method. </p>
<p> The <a href="http/ngx_http_upstream_module.html#least_conn">least_conn</a> and <a href="http/ngx_http_upstream_module.html#hash">hash</a> modules implement alternative load-balancing methods, but are actually implemented as extensions of the upstream round-robin module and share a lot of code with it, such as the representation of a server group. The <a href="http/ngx_http_upstream_module.html#keepalive">keepalive</a> module is an independent module that extends upstream functionality. </p>
<p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> can be configured explicitly by placing the corresponding <a href="http/ngx_http_upstream_module.html#upstream">upstream</a> block into the configuration file, or implicitly by using directives such as <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> that accept a URL that gets evaluated at some point into a list of servers. The alternative load-balancing methods are available only with an explicit upstream configuration. The upstream module configuration has its own directive context <code>NGX_HTTP_UPS_CONF</code> . The structure is defined as follows: </p>
<pre class="notranslate">struct ngx_http_upstream_srv_conf_s {
    ngx_http_upstream_peer_t         peer;
    void                           **srv_conf;

    ngx_array_t                     *servers;  /* ngx_http_upstream_server_t */

    ngx_uint_t                       flags;
    ngx_str_t                        host;
    u_char                          *file_name;
    ngx_uint_t                       line;
    in_port_t                        port;
    ngx_uint_t                       no_port;  /* unsigned no_port:1 */

#if (NGX_HTTP_UPSTREAM_ZONE)
    ngx_shm_zone_t                  *shm_zone;
#endif
};
</pre>


<ul>
<li><code>srv_conf</code> — Configuration context of upstream modules. -  <code>servers</code> — Array of <code>ngx_http_upstream_server_t</code> , the result of parsing a set of <a href="http/ngx_http_upstream_module.html#server">server</a> directives in the <code>upstream</code> block. -  <code>flags</code> — Flags that mostly mark which features are supported by the load-balancing method. The features are configured as parameters of the <a href="http/ngx_http_upstream_module.html#server">server</a> directive: <ul class="compact"><li> <code>NGX_HTTP_UPSTREAM_CREATE</code> — Distinguishes explicitly defined upstreams from those that are automatically created by the <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> directive and “friends” (FastCGI, SCGI, etc.) -  <code>NGX_HTTP_UPSTREAM_WEIGHT</code> — The “ <code>weight</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_FAILS</code> — The “ <code>max_fails</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_FAIL_TIMEOUT</code> — The “ <code>fail_timeout</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_DOWN</code> — The “ <code>down</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_BACKUP</code> — The “ <code>backup</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_CONNS</code> — The “ <code>max_conns</code> ” parameter is supported <pre class="notranslate">typedef struct {
 ngx_http_upstream_init_pt        init_upstream;
 ngx_http_upstream_init_peer_pt   init;
 void                            *data;
} ngx_http_upstream_peer_t;
</pre></li>
<li><code>init_upstream(cf, us)</code> — Configuration-time method responsible for initializing a group of servers and initializing the <code>init()</code> method in case of success. A typical load-balancing module uses a list of servers in the <code>upstream</code> block to create an efficient data structure that it uses and saves its own configuration to the <code>data</code> field. -  <code>init(r, us)</code> — Initializes a per-request <code>ngx_http_upstream_peer_t.peer</code> structure that is used for load balancing (not to be confused with the <code>ngx_http_upstream_srv_conf_t.peer</code> described above which is per-upstream). It is passed as the <code>data</code> argument to all callbacks that deal with server selection. </li>
</ul>
<p> When nginx has to pass a request to another host for processing, it uses the configured load-balancing method to obtain an address to connect to. The method is obtained from the <code>ngx_http_upstream_t.peer</code> object of type <code>ngx_peer_connection_t</code> : </p>
<pre class="notranslate">struct ngx_peer_connection_s {
    ...

    struct sockaddr                 *sockaddr;
    socklen_t                        socklen;
    ngx_str_t                       *name;

    ngx_uint_t                       tries;

    ngx_event_get_peer_pt            get;
    ngx_event_free_peer_pt           free;
    ngx_event_notify_peer_pt         notify;
    void                            *data;

#if (NGX_SSL || NGX_COMPAT)
    ngx_event_set_peer_session_pt    set_session;
    ngx_event_save_peer_session_pt   save_session;
#endif

    ...
};
</pre>

<p> The structure has the following fields: </p>
<ul>
<li><code>sockaddr</code> , <code>socklen</code> , <code>name</code> — Address of the upstream server to connect to; this is the output parameter of a load-balancing method. -  <code>data</code> — The per-request data of a load-balancing method; keeps the state of the selection algorithm and usually includes the link to the upstream configuration. It is passed as an argument to all methods that deal with server selection (see <a href="#lb_method_get">below</a> ). -  <code>tries</code> — Allowed <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_tries">number</a> of attempts to connect to an upstream server. -  <code>get</code> , <code>free</code> , <code>notify</code> , <code>set_session</code> , and <code>save_session</code> - Methods of the load-balancing module, described below. </li>
</ul>
<p> All methods accept at least two arguments: a peer connection object <code>pc</code> and the <code>data</code> created by <code>ngx_http_upstream_srv_conf_t.peer.init()</code> . Note that it might differ from <code>pc.data</code> due to “chaining” of load-balancing modules. </p>
<ul>
<li><code>get(pc, data)</code> — The method called when the upstream module is ready to pass a request to an upstream server and needs to know its address. The method has to fill the <code>sockaddr</code> , <code>socklen</code> , and <code>name</code> fields of <code>ngx_peer_connection_t</code> structure. The return is one of: <ul class="compact"><li> <code>NGX_OK</code> — Server was selected. -  <code>NGX_ERROR</code> — Internal error occurred. -  <code>NGX_BUSY</code> — no servers are currently available. This can happen due to many reasons, including: the dynamic server group is empty, all servers in the group are in the failed state, or all servers in the group are already handling the maximum number of connections. -  <code>NGX_DONE</code> — the underlying connection was reused and there is no need to create a new connection to the upstream server. This value is set by the <code>keepalive</code> module. -  <code>NGX_PEER_FAILED</code> — Attempt was <a href="http/ngx_http_upstream_module.html#max_fails">unsuccessful</a> -  <code>NGX_PEER_NEXT</code> — A special case when upstream server returns codes <code>403</code> or <code>404</code> , which are not considered a <a href="http/ngx_http_upstream_module.html#max_fails">failure</a> . -  <code>NGX_PEER_KEEPALIVE</code> — Currently unused </li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p> The <a href="http://hg.nginx.org/nginx-dev-examples" target="_blank" rel="noopener">nginx-dev-examples</a> repository provides nginx module examples. </p>
<h4 id="Code-style"><a href="#Code-style" class="headerlink" title="Code style"></a>Code style</h4><h4 id="General-rules"><a href="#General-rules" class="headerlink" title="General rules"></a>General rules</h4><ul>
<li>maximum text width is 80 characters -  indentation is 4 spaces -  no tabs, no trailing spaces -  list elements on the same line are separated with spaces -  hexadecimal literals are lowercase -  file names, function and type names, and global variables have the <code>ngx_</code> or more specific prefix such as <code>ngx_http_</code> and <code>ngx_mail_</code> </li>
</ul>
<pre class="notranslate">size_t
ngx_utf8_length(u_char *p, size_t n)
{
    u_char  c, *last;
    size_t  len;

    last = p + n;

    for (len = 0; p &lt; last; len++) {

        c = *p;

        if (c &lt; 0x80) {
            p++;
            continue;
        }

        if (ngx_utf8_decode(&amp;p, n) &gt; 0x10ffff) {
            /* invalid UTF-8 */
            return n;
        }
    }

    return len;
}
</pre>



<h4 id="档"><a href="#档" class="headerlink" title="档"></a>档</h4><p> A typical source file may contain the following sections separated by two empty lines: </p>
<ul>
<li>copyright statements -   包括 -  preprocessor definitions -  type definitions -  function prototypes -  variable definitions -  function definitions </li>
</ul>
<p> Copyright statements look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author Name
 * Copyright (C) Organization, Inc.
 */
</pre>

<p> If the file is modified significantly, the list of authors should be updated, the new author is added to the top. </p>
<p> The <code>ngx_config.h</code> and <code>ngx_core.h</code> files are always included first, followed by one of <code>ngx_http.h</code> , <code>ngx_stream.h</code> , or <code>ngx_mail.h</code> . Then follow optional external header files: </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;

#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;
#include &lt;libxslt/xslt.h&gt;

#if (NGX_HAVE_EXSLT)
#include &lt;libexslt/exslt.h&gt;
#endif
</pre>



<p> Header files should include the so called “header protection”: </p>
<pre class="notranslate">#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_
#define _NGX_PROCESS_CYCLE_H_INCLUDED_
...
#endif /* _NGX_PROCESS_CYCLE_H_INCLUDED_ */
</pre>



<h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><ul>
<li>“ <code>//</code> ” comments are not used -  text is written in English, American spelling is preferred </li><li> multi-line comments are formatted like this: <blockquote class="example"><pre class="notranslate">/*<ul>
<li>The red-black tree code is based on the algorithm described in</li>
<li>the “Introduction to Algorithms” by Cormen, Leiserson and Rivest.<br><em>/<br></em></li></ul></pre></blockquote><blockquote class="example"><pre class="notranslate">/ find the server configuration for the address:port */<br></pre></blockquote></li><pre class="notranslate">/* find the server configuration for the address:port */
</pre>



</ul></li>
</ul>
</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p> Macro names start from <code>ngx_</code> or <code>NGX_</code> (or more specific) prefix. Macro names for constants are uppercase. Parameterized macros and macros for initializers are lowercase. The macro name and value are separated by at least two spaces: </p>
<pre class="notranslate">#define NGX_CONF_BUFFER  4096

#define ngx_buf_in_memory(b)  (b-&gt;temporary || b-&gt;memory || b-&gt;mmap)

#define ngx_buf_size(b)                                                      \
    (ngx_buf_in_memory(b) ? (off_t) (b-&gt;last - b-&gt;pos):                      \
                            (b-&gt;file_last - b-&gt;file_pos))

#define ngx_null_string  { 0, NULL }
</pre>

<p> Conditions are inside parentheses, negation is outside: </p>
<pre class="notranslate">#if (NGX_HAVE_KQUEUE)
...
#elif ((NGX_HAVE_DEVPOLL &amp;&amp; !(NGX_TEST_BUILD_DEVPOLL)) \
       || (NGX_HAVE_EVENTPORT &amp;&amp; !(NGX_TEST_BUILD_EVENTPORT)))
...
#elif (NGX_HAVE_EPOLL &amp;&amp; !(NGX_TEST_BUILD_EPOLL))
...
#elif (NGX_HAVE_POLL)
...
#else /* select */
...
#endif /* NGX_HAVE_KQUEUE */
</pre>



<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p> Type names end with the “ <code>_t</code> ” suffix. A defined type name is separated by at least two spaces: </p>
<pre class="notranslate">typedef ngx_uint_t  ngx_rbtree_key_t;
</pre>



<p> Structure types are defined using <code>typedef</code> . Inside structures, member types and names are aligned: </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p> Keep alignment identical among different structures in the file. A structure that points to itself has the name, ending with “ <code>_s</code> ”. Adjacent structure definitions are separated with two empty lines: </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};


typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p> Each structure member is declared on its own line: </p>
<pre class="notranslate">typedef struct {
    ngx_uint_t        hash;
    ngx_str_t         key;
    ngx_str_t         value;
    u_char           *lowcase_key;
} ngx_table_elt_t;
</pre>



<p> Function pointers inside structures have defined types ending with “ <code>_pt</code> ”: </p>
<pre class="notranslate">typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);
typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);

typedef struct {
    ngx_recv_pt        recv;
    ngx_recv_chain_pt  recv_chain;
    ngx_recv_pt        udp_recv;
    ngx_send_pt        send;
    ngx_send_pt        udp_send;
    ngx_send_chain_pt  udp_send_chain;
    ngx_send_chain_pt  send_chain;
    ngx_uint_t         flags;
} ngx_os_io_t;
</pre>



<p> Enumerations have types ending with “ <code>_e</code> ”: </p>
<pre class="notranslate">typedef enum {
    ngx_http_fastcgi_st_version = 0,
    ngx_http_fastcgi_st_type,
    ...
    ngx_http_fastcgi_st_padding
} ngx_http_fastcgi_state_e;
</pre>



<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p> Variables are declared sorted by length of a base type, then alphabetically. Type names and variable names are aligned. The type and name “columns” are separated with two spaces. Large arrays are put at the end of a declaration block: </p>
<pre class="notranslate">u_char                      |  | *rv, *p;
ngx_conf_t                  |  | *cf;
ngx_uint_t                  |  |  i, j, k;
unsigned int                |  |  len;
struct sockaddr             |  | *sa;
const unsigned char         |  | *data;
ngx_peer_connection_t       |  | *pc;
ngx_http_core_srv_conf_t    |  |**cscfp;
ngx_http_upstream_srv_conf_t|  | *us, *uscf;
u_char                      |  |  text[NGX_SOCKADDR_STRLEN];
</pre>



<p> Static and global variables may be initialized on declaration: </p>
<pre class="notranslate">static ngx_str_t  ngx_http_memcached_key = ngx_string("memcached_key");
</pre>



<pre class="notranslate">static ngx_uint_t  mday[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</pre>



<pre class="notranslate">static uint32_t  ngx_crc32_table16[] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    ...
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};
</pre>



<p> There is a bunch of commonly used type/name combinations: </p>
<pre class="notranslate">u_char                        *rv;
ngx_int_t                      rc;
ngx_conf_t                    *cf;
ngx_connection_t              *c;
ngx_http_request_t            *r;
ngx_peer_connection_t         *pc;
ngx_http_upstream_srv_conf_t  *us, *uscf;
</pre>



<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p> All functions (even static ones) should have prototypes. Prototypes include argument names. Long prototypes are wrapped with a single indentation on continuation lines: </p>
<pre class="notranslate">static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);

static char *ngx_http_merge_servers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_http_module_t *module,
    ngx_uint_t ctx_index);
</pre>

<p> The function name in a definition starts with a new line. The function body opening and closing braces are on separate lines. The body of a function is indented. There are two empty lines between functions: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_find_virtual_server(ngx_http_request_t *r, u_char *host, size_t len)
{
    ...
}


static ngx_int_t
ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ...
}
</pre>

<p> There is no space after the function name and opening parenthesis. Long function calls are wrapped such that continuation lines start from the position of the first function argument. If this is impossible, format the first continuation line such that it ends at position 79: </p>
<pre class="notranslate">ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
               "http header: \"%V: %V\"",
               &amp;h-&gt;key, &amp;h-&gt;value);

hc-&gt;busy = ngx_palloc(r-&gt;connection-&gt;pool,
                  cscf-&gt;large_client_header_buffers.num * sizeof(ngx_buf_t *));
</pre>

<p> The <code>ngx_inline</code> macro should be used instead of <code>inline</code> : </p>
<pre class="notranslate">static ngx_inline void ngx_cpuid(uint32_t i, uint32_t *buf);
</pre>



<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p> Binary operators except “ <code>.</code> ” and “ <code>−&amp;gt;</code> ” should be separated from their operands by one space. Unary operators and subscripts are not separated from their operands by spaces: </p>
<pre class="notranslate">width = width * 10 + (*fmt++ - '0');
</pre>



<pre class="notranslate">ch = (u_char) ((decoded &lt;&lt; 4) + (ch - '0'));
</pre>



<pre class="notranslate">r-&gt;exten.data = &amp;r-&gt;uri.data[i + 1];
</pre>



<p> Type casts are separated by one space from casted expressions. An asterisk inside type cast is separated with space from type name: </p>
<pre class="notranslate">len = ngx_sock_ntop((struct sockaddr *) sin6, p, len, 1);
</pre>



<p> If an expression does not fit into single line, it is wrapped. The preferred point to break a line is a binary operator. The continuation line is lined up with the start of expression: </p>
<pre class="notranslate">if (status == NGX_HTTP_MOVED_PERMANENTLY
    || status == NGX_HTTP_MOVED_TEMPORARILY
    || status == NGX_HTTP_SEE_OTHER
    || status == NGX_HTTP_TEMPORARY_REDIRECT
    || status == NGX_HTTP_PERMANENT_REDIRECT)
{
    ...
}
</pre>



<pre class="notranslate">p-&gt;temp_file-&gt;warn = "an upstream response is buffered "
                     "to a temporary file";
</pre>

<p> As a last resort, it is possible to wrap an expression so that the continuation line ends at position 79: </p>
<pre class="notranslate">hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, sizeof(ngx_hash_wildcard_t)
                                     + size * sizeof(ngx_hash_elt_t *));
</pre>

<p> The above rules also apply to sub-expressions, where each sub-expression has its own indentation level: </p>
<pre class="notranslate">if (((u-&gt;conf-&gt;cache_use_stale &amp; NGX_HTTP_UPSTREAM_FT_UPDATING)
     || c-&gt;stale_updating) &amp;&amp; !r-&gt;background
    &amp;&amp; u-&gt;conf-&gt;cache_background_update)
{
    ...
}
</pre>

<p> Sometimes, it is convenient to wrap an expression after a cast. In this case, the continuation line is indented: </p>
<pre class="notranslate">node = (ngx_rbtree_node_t *)
           ((u_char *) lr - offsetof(ngx_rbtree_node_t, color));
</pre>



<p> Pointers are explicitly compared to <code>NULL</code> (not <code>0</code> ): </p>
<pre class="notranslate">if (ptr != NULL) {
    ...
}
</pre>



<h4 id="Conditionals-and-Loops"><a href="#Conditionals-and-Loops" class="headerlink" title="Conditionals and Loops"></a>Conditionals and Loops</h4><p> The “ <code>if</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line, or on a dedicated line if the condition takes several lines. Closing brace is located on a dedicated line, optionally followed by “ <code>else if</code> / <code>else</code> ”. Usually, there is an empty line before the “ <code>else if</code> / <code>else</code> ” part: </p>
<pre class="notranslate">if (node-&gt;left == sentinel) {
    temp = node-&gt;right;
    subst = node;

} else if (node-&gt;right == sentinel) {
    temp = node-&gt;left;
    subst = node;

} else {
    subst = ngx_rbtree_min(node-&gt;right, sentinel);

    if (subst-&gt;left != sentinel) {
        temp = subst-&gt;left;

    } else {
        temp = subst-&gt;right;
    }
}
</pre>



<p> Similar formatting rules are applied to “ <code>do</code> ” and “ <code>while</code> ” loops: </p>
<pre class="notranslate">while (p &lt; last &amp;&amp; *p == ' ') {
    p++;
}
</pre>



<pre class="notranslate">do {
    ctx-&gt;node = rn;
    ctx = ctx-&gt;next;
} while (ctx);
</pre>



<p> The “ <code>switch</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line. Closing brace is located on a dedicated line. The “ <code>case</code> ” keywords are lined up with “ <code>switch</code> ”: </p>
<pre class="notranslate">switch (ch) {
case '!':
    looked = 2;
    state = ssi_comment0_state;
    break;

case '&lt;':
    copy_end = p;
    break;

default:
    copy_end = p;
    looked = 0;
    state = ssi_start_state;
    break;
}
</pre>



<p> Most “ <code>for</code> ” loops are formatted like this: </p>
<pre class="notranslate">for (i = 0; i &lt; ccf-&gt;env.nelts; i++) {
    ...
}
</pre>



<pre class="notranslate">for (q = ngx_queue_head(locations);
     q != ngx_queue_sentinel(locations);
     q = ngx_queue_next(q))
{
    ...
}
</pre>

<p> If some part of the “ <code>for</code> ” statement is omitted, this is indicated by the “ <code>/* void */</code> ” comment: </p>
<pre class="notranslate">for (i = 0; /* void */ ; i++) {
    ...
}
</pre>

<p> A loop with an empty body is also indicated by the “ <code>/* void */</code> ” comment which may be put on the same line: </p>
<pre class="notranslate">for (cl = *busy; cl-&gt;next; cl = cl-&gt;next) { /* void */ }
</pre>

<p> An endless loop looks like this: </p>
<pre class="notranslate">for ( ;; ) {
    ...
}
</pre>



<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p> Labels are surrounded with empty lines and are indented at the previous level: </p>
<pre class="notranslate">    if (i == 0) {
        u-&gt;err = "host not found";
        goto failed;
    }

    u-&gt;addrs = ngx_pcalloc(pool, i * sizeof(ngx_addr_t));
    if (u-&gt;addrs == NULL) {
        goto failed;
    }

    u-&gt;naddrs = i;

    ...

    return NGX_OK;

failed:

    freeaddrinfo(res);
    return NGX_ERROR;
</pre>





</li></ul></li></ul></li></ul>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作(*锐)！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/weixin.png" alt="IM.NGINX 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="IM.NGINX 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    IM.NGINX
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://nginx.im/ngx/dev/development_guide.html" title="dev/development_guide-nginx中文手册">http://nginx.im/ngx/dev/development_guide.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/nginx/" rel="tag"># nginx</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ngx/windows.html" rel="next" title="windows-nginx中文手册">
                <i class="fa fa-chevron-left"></i> windows-nginx中文手册
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/ngx/http/configuring_https_servers.html" rel="prev" title="http/configuring_https_servers-nginx中文手册">
                http/configuring_https_servers-nginx中文手册 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTg1NS84NDE5"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="IM.NGINX" />
            
              <p class="site-author-name" itemprop="name">IM.NGINX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">153</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#开发指南"><span class="nav-number">1.</span> <span class="nav-text">开发指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">1.0.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码布局"><span class="nav-number">1.0.2.</span> <span class="nav-text">代码布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含文件"><span class="nav-number">1.0.3.</span> <span class="nav-text">包含文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整型"><span class="nav-number">1.0.4.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的返回码"><span class="nav-number">1.0.5.</span> <span class="nav-text">常见的返回码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">1.0.6.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.0.7.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#概观"><span class="nav-number">1.0.8.</span> <span class="nav-text">概观</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化"><span class="nav-number">1.0.9.</span> <span class="nav-text">格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字转换"><span class="nav-number">1.0.10.</span> <span class="nav-text">数字转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用表达"><span class="nav-number">1.0.11.</span> <span class="nav-text">常用表达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间"><span class="nav-number">1.0.12.</span> <span class="nav-text">时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集装箱"><span class="nav-number">1.0.13.</span> <span class="nav-text">集装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排列"><span class="nav-number">1.0.14.</span> <span class="nav-text">排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#名单"><span class="nav-number">1.0.15.</span> <span class="nav-text">名单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">1.0.16.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">1.0.17.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希"><span class="nav-number">1.0.18.</span> <span class="nav-text">哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符匹配"><span class="nav-number">1.0.19.</span> <span class="nav-text">通配符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理"><span class="nav-number">1.0.20.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆"><span class="nav-number">1.0.21.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#池"><span class="nav-number">1.0.22.</span> <span class="nav-text">池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存"><span class="nav-number">1.0.23.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#记录"><span class="nav-number">1.0.24.</span> <span class="nav-text">记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#周期"><span class="nav-number">1.0.25.</span> <span class="nav-text">周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲"><span class="nav-number">1.0.26.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联网"><span class="nav-number">1.0.27.</span> <span class="nav-text">联网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接"><span class="nav-number">1.0.28.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#活动"><span class="nav-number">1.0.29.</span> <span class="nav-text">活动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件"><span class="nav-number">1.0.30.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-events"><span class="nav-number">1.0.31.</span> <span class="nav-text">I/O events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer-events"><span class="nav-number">1.0.32.</span> <span class="nav-text">Timer events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Posted-events"><span class="nav-number">1.0.33.</span> <span class="nav-text">Posted events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Event-loop"><span class="nav-number">1.0.34.</span> <span class="nav-text">Event loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流程"><span class="nav-number">1.0.35.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主题"><span class="nav-number">1.0.36.</span> <span class="nav-text">主题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modules"><span class="nav-number">1.0.37.</span> <span class="nav-text">Modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding-new-modules"><span class="nav-number">1.0.38.</span> <span class="nav-text">Adding new modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Core-Modules"><span class="nav-number">1.0.39.</span> <span class="nav-text">Core Modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Configuration-Directives"><span class="nav-number">1.0.40.</span> <span class="nav-text">Configuration Directives</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP"><span class="nav-number">1.0.41.</span> <span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接-1"><span class="nav-number">1.0.42.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求"><span class="nav-number">1.0.43.</span> <span class="nav-text">请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组态"><span class="nav-number">1.0.44.</span> <span class="nav-text">组态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相"><span class="nav-number">1.0.45.</span> <span class="nav-text">相</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">1.0.46.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Accessing-existing-variables"><span class="nav-number">1.0.47.</span> <span class="nav-text">Accessing existing variables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-variables"><span class="nav-number">1.0.48.</span> <span class="nav-text">Creating variables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Complex-values"><span class="nav-number">1.0.49.</span> <span class="nav-text">Complex values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Request-redirection"><span class="nav-number">1.0.50.</span> <span class="nav-text">Request redirection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subrequests"><span class="nav-number">1.0.51.</span> <span class="nav-text">Subrequests</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Request-finalization"><span class="nav-number">1.0.52.</span> <span class="nav-text">Request finalization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Request-body"><span class="nav-number">1.0.53.</span> <span class="nav-text">Request body</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应"><span class="nav-number">1.0.54.</span> <span class="nav-text">响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-header"><span class="nav-number">1.0.55.</span> <span class="nav-text">Response header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Header-filters"><span class="nav-number">1.0.56.</span> <span class="nav-text">Header filters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-body"><span class="nav-number">1.0.57.</span> <span class="nav-text">Response body</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Body-filters"><span class="nav-number">1.0.58.</span> <span class="nav-text">Body filters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Building-filter-modules"><span class="nav-number">1.0.59.</span> <span class="nav-text">Building filter modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer-reuse"><span class="nav-number">1.0.60.</span> <span class="nav-text">Buffer reuse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#负载均衡"><span class="nav-number">1.0.61.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">1.0.62.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Code-style"><span class="nav-number">1.0.63.</span> <span class="nav-text">Code style</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#General-rules"><span class="nav-number">1.0.64.</span> <span class="nav-text">General rules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#档"><span class="nav-number">1.0.65.</span> <span class="nav-text">档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#评论"><span class="nav-number">1.0.66.</span> <span class="nav-text">评论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预处理器"><span class="nav-number">1.0.67.</span> <span class="nav-text">预处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型"><span class="nav-number">1.0.68.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量-1"><span class="nav-number">1.0.69.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能"><span class="nav-number">1.0.70.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表达式"><span class="nav-number">1.0.71.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Conditionals-and-Loops"><span class="nav-number">1.0.72.</span> <span class="nav-text">Conditionals and Loops</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标签"><span class="nav-number">1.0.73.</span> <span class="nav-text">标签</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IM.NGINX</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
		
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
