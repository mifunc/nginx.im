<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[stream/stream_processing-nginx中文手册]]></title>
      <url>/ngx/stream/stream_processing.html</url>
      <content type="html"><![CDATA[<p>stream,stream_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理TCP-UDP会话"><a href="#nginx如何处理TCP-UDP会话" class="headerlink" title=" nginx如何处理TCP / UDP会话"></a> nginx如何处理TCP / UDP会话</h2><p> 来自客户端的TCP / UDP会话在称为<strong>阶段的</strong>连续步骤中处理： </p>
<p> Post-accept   接受客户端连接后的第一阶段。 在此阶段调用ngx_stream_realip_module模块。  Pre-access   初步检查访问。 在此阶段调用ngx_stream_limit_conn_module模块。  Access   实际数据处理前的客户端访问限制。 在此阶段调用ngx_stream_access_module模块。  SSL   TLS / SSL终止。 在此阶段调用ngx_stream_ssl_module模块。  Preread   将初始数据字节读入预读缓冲区，以允许诸如ngx_stream_ssl_preread_module之类的模块在处理之前分析数据。  Content   实际处理数据的强制阶段（通常代理到上游服务器）或指定值返回给客户端。  Log   记录客户端会话处理结果的最后阶段。 在此阶段调用ngx_stream_log_module模块。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_zone_sync_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_zone_sync_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_zone_sync_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-zone-sync-module"><a href="#Module-ngx-stream-zone-sync-module" class="headerlink" title="Module ngx_stream_zone_sync_module"></a>Module ngx_stream_zone_sync_module</h2><p> Example Configuration<br> Directives<br> zone_sync<br> zone_sync_buffers<br> zone_sync_connect_retry_interval<br> zone_sync_connect_timeout<br> zone_sync_interval<br> zone_sync_recv_buffer_size<br> zone_sync_server<br> zone_sync_ssl<br> zone_sync_ssl_certificate<br> zone_sync_ssl_certificate_key<br> zone_sync_ssl_ciphers<br> zone_sync_ssl_crl<br> zone_sync_ssl_name<br> zone_sync_ssl_password_file<br> zone_sync_ssl_protocols<br> zone_sync_ssl_server_name<br> zone_sync_ssl_trusted_certificate<br> zone_sync_ssl_verify<br> zone_sync_ssl_verify_depth<br> zone_sync_timeout<br> API endpoints<br> Starting, stopping, removing a cluster node<br> ngx_stream_zone_sync_module模块（1.13.8）为在集群节点之间同步共享内存区域的内容提供必要的支持。 要为特定区域启用同步，相应的模块必须支持此功能。 目前，可以在http和流中同步HTTP 粘性会话，有关过多HTTP请求的信息和键值对。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
</blockquote>
<p> 最小配置： </p>
<blockquote>
<p>http { … upstream backend { server backend1.example.com:8080; server backend2.example.com:8081; sticky learn create=$upstream_cookie_examplecookie lookup=$cookie_examplecookie zone=client_sessions:1m <strong>sync</strong> ; } … } stream { … server { zone_sync; listen 127.0.0.1:8090; # cluster of 2 nodes zone_sync_server a.example.com; zone_sync_server b.example.com; }  启用了SSL并且由DNS定义的集群成员的更复杂配置： </p>
<p>… stream { … resolver 127.0.0.1 valid=10s; server { zone_sync; # the name resolves to multiple addresses that correspond to cluster nodes zone_sync_server cluster.example.com resolve; listen 127.0.0.1:4433 ssl; ssl_certificate localhost.crt; ssl_certificate_key localhost.key; zone_sync_ssl on; zone_sync_ssl_certificate localhost.crt; zone_sync_ssl_certificate_key localhost.key; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>zone_sync</strong> ;<br>  Default:  —  Context:  server<br>  启用集群节点之间的共享内存区域同步。 使用zone_sync_server指令定义集群节点。 </p>
<p> Syntax:  <strong>zone_sync_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  zone_sync_buffers 256 4k|8k;  Context:  stream , server<br>  设置用于推送区域内容的每个区域缓冲区的<em>number</em>和<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>zone_sync_connect_retry_interval</strong> <em>time</em> ;<br>  Default:  zone_sync_connect_retry_interval 1s;  Context:  stream , server<br>  定义到另一个群集节点的连接尝试之间的间隔。 </p>
<p> Syntax:  <strong>zone_sync_connect_timeout</strong> <em>time</em> ;<br>  Default:  zone_sync_connect_timeout 5s;  Context:  stream , server<br>  定义与另一个群集节点建立连接的超时。 </p>
<p> Syntax:  <strong>zone_sync_interval</strong> <em>time</em> ;<br>  Default:  zone_sync_interval 1s;  Context:  stream , server<br>  定义在共享内存区域中轮询更新的时间间隔。 </p>
<p> Syntax:  <strong>zone_sync_recv_buffer_size</strong> <em>size</em> ;<br>  Default:  zone_sync_recv_buffer_size 4k|8k;  Context:  stream , server<br>  设置用于解析传入的同步消息流的每连接接收缓冲区的<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>zone_sync_server</strong> <em>address</em> [ resolve ];<br>  Default:  —  Context:  server<br>  定义群集节点的<em>address</em> 。 可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ unix: ”前缀后指定的UNIX域套接字路径。 解析为多个IP地址的域名一次定义多个节点。 </p>
<p> resolve参数指示nginx监视与节点域名对应的IP地址的更改，并自动修改配置，而无需重新启动nginx。 </p>
<p> 群集节点可以动态指定为带有resolve参数的单个zone_sync_server指令，也可以静态指定为一系列不带参数的指令。 </p>
<blockquote>
<p> 每个群集节点只应指定一次。<br> 所有群集节点都应使用相同的配置。  为了使resolve参数起作用，必须在流块中指定解析器指令。 例： </p>
<p>stream { resolver 10.0.0.1; server { zone_sync; zone_sync_server cluster.example.com resolve; … } }  Syntax:  <strong>zone_sync_ssl</strong> on | off ;<br>  Default:  zone_sync_ssl off;  Context:  stream , server<br>  启用S​​SL / TLS协议以连接到另一个群集服务器。 </p>
</blockquote>
<p> Syntax:  <strong>zone_sync_ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的证书的<em>file</em> ，该证书用于对另一个群集服务器进行身份验证。 </p>
<p> Syntax:  <strong>zone_sync_ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的密钥的<em>file</em> ，用于对另一个群集服务器进行身份验证。 </p>
<p> Syntax:  <strong>zone_sync_ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  zone_sync_ssl_ciphers DEFAULT;  Context:  stream , server<br>  指定用于连接到另一个群集服务器的已启用密码。 密码以OpenSSL库理解的格式指定。 </p>
<p> 可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> Syntax:  <strong>zone_sync_ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证另一个群集服务器的证书。 </p>
<p> Syntax:  <strong>zone_sync_ssl_name</strong> <em>name</em> ;<br>  Default:  zone_sync_ssl_name host from zone_sync_server;  Context:  stream , server<br>  该指令出现在1.15.7版中。 </p>
<p> 允许覆盖用于验证群集服务器证书的服务器名称，并在与群集服务器建立连接时通过SNI传递 。 </p>
<p> 默认情况下，使用zone_sync_server地址的主机部分，如果指定了resolve参数，则使用已解析的IP地址。 </p>
<p> Syntax:  <strong>zone_sync_ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> Syntax:  <strong>zone_sync_ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  zone_sync_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  stream , server<br>  启用指定的协议以连接到另一个群集服务器。 </p>
<p> Syntax:  <strong>zone_sync_ssl_server_name</strong> on | off ;<br>  Default:  zone_sync_ssl_server_name off;  Context:  stream , server<br>  该指令出现在1.15.7版中。 </p>
<p> 在与另一个群集服务器建立连接时，启用或禁用通过TLS服务器名称指示扩展 （SNI，RFC 6066）传递服务器名称。 </p>
<p> Syntax:  <strong>zone_sync_ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的可信CA证书的<em>file</em> ，该证书用于验证另一个群集服务器的证书。 </p>
<p> Syntax:  <strong>zone_sync_ssl_verify</strong> on | off ;<br>  Default:  zone_sync_ssl_verify off;  Context:  stream , server<br>  启用或禁用其他群集服务器证书的验证。 </p>
<p> Syntax:  <strong>zone_sync_ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  zone_sync_ssl_verify_depth 1;  Context:  stream , server<br>  在另一个群集服务器证书链中设置验证深度。 </p>
<p> Syntax:  <strong>zone_sync_timeout</strong> <em>timeout</em> ;<br>  Default:  zone_sync_timeout 5s;  Context:  stream , server<br>  设置与另一个群集节点连接时两次连续读取或写入操作之间的<em>timeout</em> 。 如果在此时间内没有传输数据，则关闭连接。 </p>
<h4 id="API端点"><a href="#API端点" class="headerlink" title="API端点"></a>API端点</h4><p> 节点的同步状态可通过API的/ stream / zone_sync / endpoint获得，它返回以下度量标准。 </p>
<h4 id="启动，停止，删除群集节点"><a href="#启动，停止，删除群集节点" class="headerlink" title="启动，停止，删除群集节点"></a>启动，停止，删除群集节点</h4><p> 要启动新节点，请使用新节点的IP地址更新群集主机名的DNS记录并启动实例。 新节点将从DNS或静态配置中发现其他节点，并将开始向它们发送更新。 其他节点最终将使用DNS发现新节点并开始向其推送更新。 在静态配置的情况下，需要重新加载其他节点以便将更新发送到新节点。 </p>
<p> 要停止节点，请将QUIT信号发送到实例。 该节点将完成区域同步并正常关闭打开的连接。 </p>
<p> 要删除节点，请更新群集主机名的DNS记录，并删除该节点的IP地址。 所有其他节点最终将发现节点已被删除，关闭与节点的连接，并且将不再尝试连接到节点。 移除节点后，可以如上所述停止节点。 在静态配置的情况下，需要重新加载其他节点以便停止向已删除节点发送更新。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-module"><a href="#Module-ngx-stream-upstream-module" class="headerlink" title="Module ngx_stream_upstream_module"></a>Module ngx_stream_upstream_module</h2><p> Example Configuration<br> Directives<br> upstream<br> server<br> zone<br> state<br> hash<br> least_conn<br> least_time<br> random<br> Embedded Variables<br> ngx_stream_upstream_module模块（1.9.0）用于定义可由proxy_pass指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>upstream <strong>backend</strong> { hash $remote_addr consistent; server backend1.example.com:12345 weight=5; server backend2.example.com:12345; server unix:/tmp/backend3; server backup1.example.com:12345 backup; server backup2.example.com:12345 backup; } server { listen 12346; proxy_pass <strong>backend</strong> ; }  具有定期运行状况检查的动态可配置组可作为我们商业订阅的一部分： </p>
<p>resolver 10.0.0.1; upstream <strong>dynamic</strong> { zone upstream_dynamic 64k; server backend1.example.com:12345 weight=5; server backend2.example.com:12345 fail_timeout=5s slow_start=30s; server 192.0.2.1:12345 max_fails=3; server backend3.example.com:12345 resolve; server backend4.example.com service=http resolve; server backup1.example.com:12345 backup; server backup2.example.com:12345 backup; } server { listen 12346; proxy_pass <strong>dynamic</strong> ; health_check; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>upstream</strong> <em>name</em> { … }<br>  Default:  —  Context:  stream<br>  定义一组服务器。 服务器可以侦听不同的端口。 此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p> 例： </p>
<blockquote>
<p>upstream backend { server backend1.example.com:12345 weight=5; server 127.0.0.1:12345 max_fails=3 fail_timeout=30s; server unix:/tmp/backend2; server backend3.example.com:12345 resolve; server backup1.example.com:12345 backup; }  默认情况下，使用加权循环平衡方法在服务器之间分配连接。 在上面的示例中，每个7个连接将按如下方式分发：5个连接到backend1.example.com:12345并且每个连接到第二个和第三个服务器。 如果在与服务器通信期间发生错误，则连接将传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。 如果与所有服务器的通信失败，则将关闭连接。 </p>
</blockquote>
<p> Syntax:  <strong>server</strong> <em>address</em> [ <em>parameters</em> ];<br>  Default:  —  Context:  upstream<br>  定义服务器的<em>address</em>和其他<em>parameters</em> 。 可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ unix: ”前缀后指定的UNIX域套接字路径。 解析为多个IP地址的域名一次定义多个服务器。 </p>
<p> 可以定义以下参数： </p>
<p> weight = <em>number</em>  设置服务器的权重，默认为1。  max_conns = <em>number</em>  限制与代理服务器的最大并发连接<em>number</em> （1.11.5）。 默认值为零，表示没有限制。 如果服务器组不驻留在共享内存中 ，则每个工作进程的限制都有效。 </p>
<blockquote>
<p> 在1.11.5版之前，此参数作为我们商业订阅的一部分提供。  max_fails = <em>number</em>  设置在fail_timeout参数设置的持续时间内发生的与服务器通信的不成功尝试次数，以考虑服务器在fail_timeout参数设置的持续时间内不可用。 默认情况下，不成功尝试次数设置为1.零值禁用尝试的计费。 这里，在与服务器建立连接时，尝试失败是错误或超时。  fail_timeout = <em>time</em>  套 *  指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; </p>
<ul>
<li>以及服务器被视为不可用的时间段。<br>默认情况下，参数设置为10秒。  backup   将服务器标记为备份服务器。 当主服务器不可用时，将传递与备份服务器的连接。  down   将服务器标记为永久不可用。  此外，以下参数作为我们商业订阅的一部分提供： </li>
</ul>
</blockquote>
<p> resolve   监视与服务器域名对应的IP地址的更改，并自动修改上游配置，而无需重新启动nginx。 服务器组必须驻留在共享内存中 。  要使此参数起作用，必须在流块中指定解析程序指令。 例： </p>
<blockquote>
<p>stream { resolver 10.0.0.1; upstream u { zone …; … server example.com:12345 resolve; } }  service = <em>name</em>  能够解析DNS SRV记录并设置服务<em>name</em> （1.9.13）。 要使此参数起作用，必须为服务器指定resolve参数并指定不带端口号的主机名。  如果服务名称不包含点（“ . ”），则构造符合RFC的名称，并将TCP协议添加到服务前缀。 例如，要查找_http._tcp.backend.example.com SRV记录，必须指定该指令： </p>
<p>server backend.example.com service=http resolve;  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。 例如，要查找_http._tcp.backend.example.com和server1.backend.example.com SRV记录，必须指定指令： </p>
<p>server backend.example.com service=_http._tcp resolve; server example.com service=server1.backend resolve;  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。 如果为服务器指定了backup参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
</blockquote>
<p> slow_start = <em>time</em>  设置服务器将其权重从零恢复到标称值的时间，当不健康的服务器变得健康时 ，或者服务器在一段时间被认为不可用后变得可用时。 默认值为零，即禁用慢启动。 </p>
<blockquote>
<p> 该参数不能与散列负载平衡方法一起使用。<br> 如果组中只有一个服务器，则忽略max_fails ， fail_timeout和slow_start参数，并且永远不会将此类服务器视为不可用。  Syntax:  <strong>zone</strong> <em>name</em> [ <em>size</em> ];<br>  Default:  —  Context:  upstream<br>  定义共享内存区域的<em>name</em>和<em>size</em> ，该区域保持组工作进程之间共享的组配置和运行时状态。 几个组可能共享同一个区域。 在这种情况下，仅指定一次<em>size</em>就足够了。 </p>
</blockquote>
<p> 此外，作为我们商业订阅的一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。 可通过API模块（1.13.3）访问该配置。 </p>
<blockquote>
<p> 在1.13.3版之前，只能通过upstream_conf处理的特殊位置访问配置。  Syntax:  <strong>state</strong> <em>file</em> ;<br>  Default:  —  Context:  upstream<br>  该指令出现在1.9.7版中。 </p>
</blockquote>
<p> 指定保持动态可配置组状态的<em>file</em> 。 </p>
<p> 例子： </p>
<blockquote>
<p>state /var/lib/nginx/state/servers.conf; # path for Linux state /var/db/nginx/state/servers.conf; # path for FreeBSD  该状态目前仅限于具有其参数的服务器列表。 解析配置时会读取文件，每次更改上游配置时都会更新该文件。 应避免直接更改文件内容。 该指令不能与server指令一起使用。 </p>
<p> 配置重新加载或二进制升级期间所做的更改可能会丢失。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>hash</strong> <em>key</em> [ consistent ];<br>  Default:  —  Context:  upstream<br>  指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<em>key</em> 。 <em>key</em>可以包含文本，变量及其组合（1.11.2）。 用法示例： </p>
<p>hash $remote_addr;  请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。 该方法与Cache :: Memcached Perl库兼容。 </p>
</blockquote>
<p> 如果指定了consistent参数，则将使用ketama一致性哈希方法。 该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。 这有助于为缓存服务器实现更高的缓存命中率。 该方法与Cache :: Memcached :: Fast Perl库兼容，并将<em>ketama_points</em>参数设置为160。 </p>
<p> Syntax:  <strong>least_conn</strong> ;<br>  Default:  —  Context:  upstream<br>  指定组应使用负载平衡方法，其中将连接传递到具有最少活动连接的服务器，同时考虑服务器的权重。 如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p> Syntax:  <strong>least_time</strong> connect | first_byte | last_byte [ inflight ];<br>  Default:  —  Context:  upstream<br>  指定组应使用负载平衡方法，其中连接以最少的平均时间和最少的活动连接传递到服务器，同时考虑服务器的权重。 如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p> 如果指定了connect参数，则使用连接到上游服务器的时间。 如果指定了first_byte参数，则使用接收数据的第一个字节的时间。 如果指定了last_byte则使用接收最后一个数据字节的时间。 如果指定了inflight参数（1.11.6），则还会考虑不完整的连接。 </p>
<blockquote>
<p> 在1.11.6版之前，默认情况下会考虑不完整的连接。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>random</strong> [ two [ <em>method</em> ]];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.15.1版本中。 </p>
</blockquote>
<p> 指定组应使用负载平衡方法，其中将连接传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p> 可选的two参数指示nginx随机选择两个服务器，然后使用指定的method选择服务器。 默认方法是least_conn ，它将连接传递给具有最少活动连接数的服务器。 </p>
<p> least_time方法将连接传递给平均时间最短且活动连接数最少的服务器。 如果指定了least_time=connect参数，则使用连接到上游服务器的时间。 如果指定了least_time=first_byte参数，则使用接收数据的第一个字节的时间。 如果指定了least_time=last_byte则使用接收最后一个数据字节的时间。 </p>
<blockquote>
<p> least_time方法可作为我们商业订阅的一部分。 ####  嵌入式变量</p>
</blockquote>
<p> ngx_stream_upstream_module模块支持以下嵌入变量： </p>
<p> $upstream_addr   保留IP地址和端口，或上游服务器的UNIX域套接字的路径（1.11.4）。 如果在代理期间联系了多个服务器，则它们的地址用逗号分隔，例如“ 192.168.1.1:12345, 192.168.1.2:12345, unix:/tmp/sock ”。 如果无法选择服务器，则变量将保留服务器组的名称。  $upstream_bytes_received   从上游服务器（1.11.4）接收的字节数。 来自多个连接的值由逗号分隔，例如$ upstream_addr变量中的地址。  $upstream_bytes_sent   发送到上游服务器的字节数（1.11.4）。 来自多个连接的值由逗号分隔，例如$ upstream_addr变量中的地址。  $upstream_connect_time   时间连接到上游服务器（1.11.4）; 时间以秒为单位，分辨率为毫秒。 多个连接的时间由逗号分隔，如$ upstream_addr变量中的地址。  $upstream_first_byte_time   接收数据的第一个字节的时间（1.11.4）; 时间以秒为单位，分辨率为毫秒。 多个连接的时间由逗号分隔，如$ upstream_addr变量中的地址。  $upstream_session_time   会话持续时间（以秒为单位），分辨率为毫秒（1.11.4）。 多个连接的时间由逗号分隔，如$ upstream_addr变量中的地址。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-hc-module"><a href="#Module-ngx-stream-upstream-hc-module" class="headerlink" title="Module ngx_stream_upstream_hc_module"></a>Module ngx_stream_upstream_hc_module</h2><p> Example Configuration<br> Directives<br> health_check<br> health_check_timeout<br> match<br> ngx_stream_upstream_hc_module模块（1.9.0）允许对组中的服务器启用定期运行状况检查。 服务器组必须驻留在共享内存中 。 </p>
<p> 如果运行状况检查失败，则服务器将被视为运行状况不佳。 如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。 客户端连接不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>upstream tcp { zone upstream_tcp 64k; server backend1.example.com:12345 weight=5; server backend2.example.com:12345 fail_timeout=5s slow_start=30s; server 192.0.2.1:12345 max_fails=3; server backup1.example.com:12345 backup; server backup2.example.com:12345 backup; } server { listen 12346; proxy_pass tcp; health_check; }  使用此配置，nginx将检查每五秒钟与tcp组中每个服务器建立TCP连接的能力。 当无法建立与服务器的连接时，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
</blockquote>
<p> 可以为UDP协议配置运行状况检查： </p>
<blockquote>
<p>upstream dns_upstream { zone dns_zone 64k; server dns1.example.com:53; server dns2.example.com:53; server dns3.example.com:53; } server { listen 53 udp; proxy_pass dns_upstream; health_check udp; }  在这种情况下，预期缺少ICMP“ Destination Unreachable ”消息以回复发送的字符串“ nginx health check ”。 </p>
</blockquote>
<p> 还可以配置运行状况检查以测试从服务器获取的数据。 测试使用match伪指令单独配置，并在health_check指令的match参数中引用。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>health_check</strong> [ <em>parameters</em> ];<br>  Default:  —  Context:  server<br>  启用对组中服务器的定期运行状况检查。 </p>
<p> 支持以下可选参数： </p>
<p> interval = <em>time</em>  设置两次连续运行状况检查之间的间隔，默认为5秒。  jitter = <em>time</em>  设置每个健康检查随机延迟的时间，默认情况下，没有延迟。  fails = <em>number</em>  设置特定服务器的连续失败运行状况检查的数量，在此之后，此服务器将被视为运行状况不佳，默认情况下为1。  passes = <em>number</em>  设置特定服务器的连续传递运行状况检查的数量，在此之后服务器将被视为运行状况，默认情况下为1。  mandatory   设置服务器的初始“检查”状态，直到第一次健康检查完成（1.11.7）。 客户端连接不会传递到处于“检查”状态的服务器。 如果未指定参数，则服务器最初将被视为健康。  match = <em>name</em>  指定配置成功连接应传递的测试的match块，以便进行运行状况检查。 默认情况下，对于TCP，仅检查与服务器建立TCP连接的能力。 对于UDP ，预期缺少ICMP“ Destination Unreachable ”消息以回复发送的字符串“ nginx health check ”。 </p>
<blockquote>
<p> 在1.11.7版之前，默认情况下，UDP运行状况检查需要带有send和expect参数的匹配块。  port = <em>number</em>  定义连接到服务器以执行运行状况检查时使用的端口（1.9.7）。 默认情况下，等于服务器端口。  udp   指定UDP协议应该用于运行状况检查而不是默认的TCP协议（1.9.13）。  Syntax:  <strong>health_check_timeout</strong> <em>timeout</em> ;<br>  Default:  health_check_timeout 5s;  Context:  stream , server<br>  覆盖运行状况检查的proxy_timeout值。 </p>
</blockquote>
<p> Syntax:  <strong>match</strong> <em>name</em> { … }<br>  Default:  —  Context:  stream<br>  定义用于验证服务器对运行状况检查的响应的命名测试集。 </p>
<p> 可以配置以下参数： </p>
<p> send <em>string</em> ;  将<em>string</em>发送到服务器;  expect <em>string</em> | ~ <em>regex</em> ;  文字字符串（1.9.12）或从服务器获取的数据应匹配的正则表达式。 使用前面的“ ~* ”修饰符（对于不区分大小写的匹配）或“ ~ ”修饰符（对于区分大小写的匹配）指定正则表达式。  send和expect参数都可以包含十六进制文字，前缀为“ \x ”，后跟两个十六进制数字，例如“ \x80 ”（1.9.12）。 </p>
<p> 在下列情况下通过健康检查 </p>
<ul>
<li>TCP连接成功建立; </li>
<li>send参数中的<em>string</em> （如果已指定）已发送; </li>
<li>如果指定，从服务器获取的数据与expect参数中的字符串或正则表达式匹配; </li>
<li>经过的时间不超过health_check_timeout指令中指定的值。<br>例： </li>
</ul>
<blockquote>
<p>upstream backend { zone upstream_backend 10m; server 127.0.0.1:12345; } match http { send “GET / HTTP/1.0\r\nHost: localhost\r\n\r\n”; expect ~ “200 OK”; } server { listen 12346; proxy_pass backend; health_check match=http; }<br> 仅检查从服务器获得的第一个proxy_buffer_size字节数据。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_preread_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_preread_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_preread_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-preread-module"><a href="#Module-ngx-stream-ssl-preread-module" class="headerlink" title="Module ngx_stream_ssl_preread_module"></a>Module ngx_stream_ssl_preread_module</h2><p> Example Configuration<br> Directives<br> ssl_preread<br> Embedded Variables<br> ngx_stream_ssl_preread_module模块（1.11.5）允许从ClientHello消息中提取信息而不终止SSL / TLS，例如，通过SNI请求的服务器名称或在ALPN中通告的协议。 默认情况下不构建此模块，应使用–with-stream_ssl_preread_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p> 根据服务器名称选择上游： </p>
<blockquote>
<p>map $ssl_preread_server_name $name { backend.example.com backend; default backend2; } upstream backend { server 192.168.0.1:12345; server 192.168.0.2:12345; } upstream backend2 { server 192.168.0.3:12345; server 192.168.0.4:12345; } server { listen 12346; proxy_pass $name; ssl_preread on; }  根据协议选择上游： </p>
<p>map $ssl_preread_alpn_protocols $proxy { ~\bh2\b 127.0.0.1:8001; ~\bhttp/1.1\b 127.0.0.1:8002; ~\bxmpp-client\b 127.0.0.1:8003; } server { listen 9000; proxy_pass $proxy; ssl_preread on; }  根据SSL协议版本选择上游： </p>
<p>map $ssl_preread_protocol $upstream { “” ssh.example.com:22; “TLSv1.2” new.example.com:443; default tls.example.com:443; } # ssh and https on the same port server { listen 192.168.0.1:443; proxy_pass $upstream; ssl_preread on; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ssl_preread</strong> on | off ;<br>  Default:  ssl_preread off;  Context:  stream , server<br>  允许在预读阶段从ClientHello消息中提取信息。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> $ssl_preread_protocol   客户端支持的最高SSL协议版本（1.15.2）  $ssl_preread_server_name   通过SNI请求的服务器名称  $ssl_preread_alpn_protocols   客户端通过ALPN（1.13.10）公布的协议列表。 值以逗号分隔。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-module"><a href="#Module-ngx-stream-ssl-module" class="headerlink" title="Module ngx_stream_ssl_module"></a>Module ngx_stream_ssl_module</h2><p> Example Configuration<br> Directives<br> ssl_certificate<br> ssl_certificate_key<br> ssl_ciphers<br> ssl_client_certificate<br> ssl_crl<br> ssl_dhparam<br> ssl_ecdh_curve<br> ssl_handshake_timeout<br> ssl_password_file<br> ssl_prefer_server_ciphers<br> ssl_protocols<br> ssl_session_cache<br> ssl_session_ticket_key<br> ssl_session_tickets<br> ssl_session_timeout<br> ssl_trusted_certificate<br> ssl_verify_client<br> ssl_verify_depth<br> Embedded Variables<br> ngx_stream_ssl_module模块（1.9.0）为流代理服务器提供必要的支持，以使用SSL / TLS协议。 默认情况下不构建此模块，应使用–with-stream_ssl_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p> 为减少处理器负载，建议使用 </p>
<ul>
<li>设置工作进程数等于处理器数， </li>
<li>启用共享会话缓存， </li>
<li>禁用内置会话缓存， </li>
<li>并可能增加会话生命周期 （默认为5分钟）： </li>
</ul>
<blockquote>
<p> <strong>worker_processes auto;</strong> stream { … server { listen 12345 ssl; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5; ssl_certificate /usr/local/nginx/conf/cert.pem; ssl_certificate_key /usr/local/nginx/conf/cert.key; <strong>ssl_session_cache shared:SSL:10m;</strong> <strong>ssl_session_timeout 10m;</strong> … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有给定服务器的PEM格式的证书的<em>file</em> 。 如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。 PEM格式的密钥可以放在同一文件中。 </p>
<p> 从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<blockquote>
<p>server { listen 12345 ssl; ssl_certificate example.com.rsa.crt; ssl_certificate_key example.com.rsa.key; ssl_certificate example.com.ecdsa.crt; ssl_certificate_key example.com.ecdsa.key; … }<br> 只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。 对于旧版本，只能使用一个证书链。  Syntax:  <strong>ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有给定服务器的PEM格式的密钥的<em>file</em> 。 </p>
</blockquote>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> ，该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  ssl_ciphers HIGH:!aNULL:!MD5;  Context:  stream , server<br>  指定启用的密码。 密码以OpenSSL库理解的格式指定，例如： </p>
<blockquote>
<p>ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;  可以使用“ openssl ciphers ”命令查看完整列表。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_client_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.11.8版中。 </p>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证客户端证书。 </p>
<p> 证书列表将发送给客户。 如果不需要，可以使用ssl_trusted_certificate指令。 </p>
<p> Syntax:  <strong>ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.11.8版中。 </p>
<p> 指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证客户端证书。 </p>
<p> Syntax:  <strong>ssl_dhparam</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  为DHE密码指定具有DH参数的<em>file</em> 。 </p>
<p> 默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p> 在1.11.0版之前，默认使用内置参数。  Syntax:  <strong>ssl_ecdh_curve</strong> <em>curve</em> ;<br>  Default:  ssl_ecdh_curve auto;  Context:  stream , server<br>  指定ECDHE密码的<em>curve</em> 。 </p>
</blockquote>
<p> 使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<blockquote>
<p>ssl_ecdh_curve prime256v1:secp384r1;  特殊值auto （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的prime256v1 。 </p>
<p> 在版本1.11.0之前，默认使用prime256v1曲线。  Syntax:  <strong>ssl_handshake_timeout</strong> <em>time</em> ;<br>  Default:  ssl_handshake_timeout 60s;  Context:  stream , server<br>  指定SSL握手完成的超时。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> 例： </p>
<blockquote>
<p>stream { ssl_password_file /etc/keys/global.pass; … server { listen 127.0.0.1:12345; ssl_certificate_key /etc/keys/first.key; } server { listen 127.0.0.1:12346; # named pipe can also be used instead of a file ssl_password_file /etc/keys/fifo; ssl_certificate_key /etc/keys/second.key; } }  Syntax:  <strong>ssl_prefer_server_ciphers</strong> on | off ;<br>  Default:  ssl_prefer_server_ciphers off;  Context:  stream , server<br>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  stream , server<br>  启用指定的协议。 </p>
<blockquote>
<p> TLSv1.1和TLSv1.2参数仅在使用OpenSSL 1.0.1或更高版本时有效。<br> 仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， TLSv1.3参数（1.13.0）才有效。  Syntax:  <strong>ssl_session_cache</strong> off | none | [ builtin [: <em>size</em> ]] [ shared : <em>name</em> : <em>size</em> ];<br>  Default:  ssl_session_cache none;  Context:  stream , server<br>  设置存储会话参数的缓存的类型和大小。 缓存可以是以下任何类型： </p>
</blockquote>
<p> off   严格禁止使用会话缓存：nginx明确告诉客户端会话可能不会被重用。  none   轻轻地禁止使用会话缓存：nginx告诉客户端会话可以重用，但实际上并不会将会话参数存储在缓存中。  builtin   一个用OpenSSL构建的缓存; 仅由一个工作进程使用。 缓存大小在会话中指定。 如果未给出大小，则等于20480个会话。 使用内置缓存可能会导致内存碎片。  shared   所有工作进程之间共享的缓存。 高速缓存大小以字节为单位指定; 一兆字节可以存储大约4000个会话。 每个共享缓存都应具有任意名称。 可以在多个服务器中使用具有相同名称的缓存。  两种缓存类型可以同时使用，例如： </p>
<blockquote>
<p>ssl_session_cache builtin:1000 shared:SSL:10m;  但只使用没有内置缓存的共享缓存应该更有效。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_ticket_key</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  设置具有用于加密和解密TLS会话票证的密钥的<em>file</em> 。 如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。 默认情况下，使用随机生成的密钥。 </p>
<p> 如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。 这允许配置键旋转，例如： </p>
<blockquote>
<p>ssl_session_ticket_key current.key; ssl_session_ticket_key previous.key;  该<em>file</em>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<p>openssl rand 80 &gt; ticket.key  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_tickets</strong> on | off ;<br>  Default:  ssl_session_tickets on;  Context:  stream , server<br>  通过TLS会话票证启用或禁用会话恢复。 </p>
<p> Syntax:  <strong>ssl_session_timeout</strong> <em>time</em> ;<br>  Default:  ssl_session_timeout 5m;  Context:  stream , server<br>  指定客户端可以重用会话参数的时间。 </p>
<p> Syntax:  <strong>ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.11.8版中。 </p>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证客户端证书。 </p>
<p> 与ssl_client_certificate设置的证书不同 ，这些证书的列表不会发送给客户端。 </p>
<p> Syntax:  <strong>ssl_verify_client</strong> on | off | optional | optional_no_ca ;<br>  Default:  ssl_verify_client off;  Context:  stream , server<br>  该指令出现在1.11.8版中。 </p>
<p> 启用客户端证书验证。 验证结果存储在$ ssl_client_verify变量中。 如果在客户端证书验证期间发生错误或客户端未提供所需证书，则会关闭连接。 </p>
<p> optional参数请求客户端证书，并在证书存在时验证它。 </p>
<p> optional_no_ca参数请求客户端证书，但不要求它由可信CA证书签名。 这适用于nginx外部的服务执行实际证书验证的情况。 可以通过$ ssl_client_cert变量访问证书的内容。 </p>
<p> Syntax:  <strong>ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  ssl_verify_depth 1;  Context:  stream , server<br>  该指令出现在1.11.8版中。 </p>
<p> 设置客户端证书链中的验证深度。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_stream_ssl_module模块支持自1.11.2以来的变量。 </p>
<p> $ssl_cipher   返回用于建立的SSL连接的密码字符串;  $ssl_ciphers   返回客户端支持的密码列表（1.11.7）。 已知密码按名称列出，未知以十六进制显示，例如： </p>
<blockquote>
<p>AES128-SHA:AES256-SHA:0x00ff<br> 仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。 对于旧版本，该变量仅适用于新会话，仅列出已知密码。  $ssl_client_cert   为已建立的SSL连接返回PEM格式的客户端证书，除了第一行前面的每一行都带有制表符（1.11.8）;  $ssl_client_fingerprint   返回已建立的SSL连接的客户端证书的SHA1指纹（1.11.8）;  $ssl_client_i_dn   根据RFC 2253 （1.11.8），为已建立的SSL连接返回客户端证书的“issuer DN”字符串;  $ssl_client_raw_cert   为已建立的SSL连接返回PEM格式的客户端证书（1.11.8）;  $ssl_client_s_dn   根据RFC 2253 （1.11.8），为已建立的SSL连接返回客户端证书的“subject DN”字符串;  $ssl_client_serial   返回已建立的SSL连接的客户端证书的序列号（1.11.8）;  $ssl_client_v_end   返回客户端证书的结束日期（1.11.8）;  $ssl_client_v_remain   返回客户端证书到期前的天数（1.11.8）;  $ssl_client_v_start   返回客户端证书的开始日期（1.11.8）;  $ssl_client_verify   返回客户端证书验证（1.11.8）的结果：“ SUCCESS ”，“ FAILED: <em>reason</em> ”，如果证书不存在则返回“ NONE ”;  $ssl_curves   返回客户端支持的曲线列表（1.11.7）。 已知曲线按名称列出，未知以十六进制显示，例如：<br>0x001d:prime256v1:secp521r1:secp384r1<br> 仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。 对于旧版本，变量值将为空字符串。<br> 该变量仅适用于新会话。  $ssl_protocol   返回已建立的SSL连接的协议;  $ssl_server_name   返回通过SNI请求的服务器名称;  $ssl_session_id   返回已建立的SSL连接的会话标识;  $ssl_session_reused   如果重用SSL会话，则返回“ r ”，或“ . “ 除此以外。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-split-clients-module"><a href="#Module-ngx-stream-split-clients-module" class="headerlink" title="Module ngx_stream_split_clients_module"></a>Module ngx_stream_split_clients_module</h2><p> Example Configuration<br> Directives<br> split_clients<br> ngx_stream_split_clients_module模块（1.11.3）创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>stream { … split_clients “${remote_addr}AAA” $upstream { 0.5% feature_test1; 2.0% feature_test2; * production; } server { … proxy_pass $upstream; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>split_clients</strong> <em>string</em> <em>$variable</em> { … }<br>  Default:  —  Context:  stream<br>  为A / B测试创建变量，例如： </p>
<blockquote>
<p>split_clients “${remote_addr}AAA” $variant { 0.5% .one; 2.0% .two; * “”; }  使用MurmurHash2对原始字符串的值进行哈希处理。 在给出的示例中，从0到21474835（0.5％）的哈希值对应于$variant变量的值”.one” ，从21474836到107374180（2％）的哈希值对应于值”.two”和哈希值从107374181到4294967295的值对应于值”” （空字符串）。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_return_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_return_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_return_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-return-module"><a href="#Module-ngx-stream-return-module" class="headerlink" title="Module ngx_stream_return_module"></a>Module ngx_stream_return_module</h2><p> Example Configuration<br> Directives<br> return<br> ngx_stream_return_module模块（1.11.2）允许向客户端发送指定值，然后关闭连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { listen 12345; return $time_iso8601; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>return</strong> <em>value</em> ;<br>  Default:  —  Context:  server<br>  指定要发送到客户端的<em>value</em> 。 该值可以包含文本，变量及其组合。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_realip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_realip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-realip-module"><a href="#Module-ngx-stream-realip-module" class="headerlink" title="Module ngx_stream_realip_module"></a>Module ngx_stream_realip_module</h2><p> Example Configuration<br> Directives<br> set_real_ip_from<br> Embedded Variables<br> ngx_stream_realip_module模块用于将客户端地址和端口更改为PROXY协议头（1.11.4）中发送的端口和端口。 必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> 默认情况下不构建此模块，应使用–with-stream_realip_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>listen 12345 proxy_protocol; set_real_ip_from 192.168.1.0/24; set_real_ip_from 192.168.2.1; set_real_ip_from 2001:0db8::/32; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>set_real_ip_from</strong> <em>address</em> | <em>CIDR</em> | unix: ;<br>  Default:  —  Context:  stream , server<br>  定义已知可发送正确替换地址的可信地址。 如果指定了特殊值unix:则所有UNIX域套接字都将受信任。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> $realip_remote_addr   保留原始客户端地址  $realip_remote_port   保留原始客户端端口  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_proxy_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_proxy_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-proxy-module"><a href="#Module-ngx-stream-proxy-module" class="headerlink" title="Module ngx_stream_proxy_module"></a>Module ngx_stream_proxy_module</h2><p> Example Configuration<br> Directives<br> proxy_bind<br> proxy_buffer_size<br> proxy_connect_timeout<br> proxy_download_rate<br> proxy_next_upstream<br> proxy_next_upstream_timeout<br> proxy_next_upstream_tries<br> proxy_pass<br> proxy_protocol<br> proxy_requests<br> proxy_responses<br> proxy_socket_keepalive<br> proxy_ssl<br> proxy_ssl_certificate<br> proxy_ssl_certificate_key<br> proxy_ssl_ciphers<br> proxy_ssl_crl<br> proxy_ssl_name<br> proxy_ssl_password_file<br> proxy_ssl_protocols<br> proxy_ssl_server_name<br> proxy_ssl_session_reuse<br> proxy_ssl_trusted_certificate<br> proxy_ssl_verify<br> proxy_ssl_verify_depth<br> proxy_timeout<br> proxy_upload_rate<br> ngx_stream_proxy_module模块（1.9.0）允许通过TCP，UDP（1.9.13）和UNIX域套接字代理数据流。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { listen 127.0.0.1:12345; proxy_pass 127.0.0.1:8080; } server { listen 12345; proxy_connect_timeout 1s; proxy_timeout 1m; proxy_pass example.com:12345; } server { listen 53 udp reuseport; proxy_timeout 20s; proxy_pass dns.example.com:53; } server { listen [::1]:12345; proxy_pass unix:/tmp/stream.socket; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>proxy_bind</strong> <em>address</em> [ transparent ] | off ;<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.9.2版本中。 </p>
<p> 使与代理服务器的传出连接源自指定的本地IP <em>address</em> 。 参数值可以包含变量（1.11.2）。 特殊值off取消了从先前配置级别继承的proxy_bind指令的效果，允许系统自动分配本地IP地址。 </p>
<p> transparent参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>proxy_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_buffer_size</strong> <em>size</em> ;<br>  Default:  proxy_buffer_size 16k;  Context:  stream , server<br>  该指令出现在1.9.4版本中。 </p>
<p> 设置用于从代理服务器读取数据的缓冲区的<em>size</em> 。 还设置用于从客户端读取数据的缓冲区的<em>size</em> 。 </p>
<p> Syntax:  <strong>proxy_connect_timeout</strong> <em>time</em> ;<br>  Default:  proxy_connect_timeout 60s;  Context:  stream , server<br>  定义与代理服务器建立连接的超时。 </p>
<p> Syntax:  <strong>proxy_download_rate</strong> <em>rate</em> ;<br>  Default:  proxy_download_rate 0;  Context:  stream , server<br>  该指令出现在1.9.3版本中。 </p>
<p> 限制从代理服务器读取数据的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 每个连接设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。 </p>
<p> Syntax:  <strong>proxy_next_upstream</strong> on | off ;<br>  Default:  proxy_next_upstream on;  Context:  stream , server<br>  当无法建立与代理服务器的连接时，确定是否将客户端连接传递给下一个服务器。 </p>
<p> 将连接传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>proxy_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  proxy_next_upstream_timeout 0;  Context:  stream , server<br>  限制将连接传递给下一个服务器所允许的时间。 0值关闭此限制。 </p>
<p> Syntax:  <strong>proxy_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  proxy_next_upstream_tries 0;  Context:  stream , server<br>  限制将连接传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>proxy_pass</strong> <em>address</em> ;<br>  Default:  —  Context:  server<br>  设置代理服务器的地址。 地址可以指定为域名或IP地址，以及端口： </p>
<blockquote>
<p>proxy_pass localhost:12345;  或者作为UNIX域套接字路径： </p>
<p>proxy_pass unix:/tmp/stream.socket;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> 也可以使用变量（1.11.3）指定地址： </p>
<blockquote>
<p>proxy_pass $upstream;  在这种情况下，在所描述的服务器组中搜索服务器名称，并且如果未找到，则使用解析器来确定服务器名称。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_protocol</strong> on | off ;<br>  Default:  proxy_protocol off;  Context:  stream , server<br>  该指令出现在1.9.2版本中。 </p>
<p> 启用PROXY协议以连接到代理服务器。 </p>
<p> Syntax:  <strong>proxy_requests</strong> <em>number</em> ;<br>  Default:  proxy_requests 0;  Context:  stream , server<br>  该指令出现在1.15.7版中。 </p>
<p> 设置客户端与现有UDP流会话之间的绑定被删除的客户端数据报的数量。 在收到指定数量的数据报后，来自同一客户端的下一个数据报将启动一个新会话。 当所有客户端数据报都传输到代理服务器并且收到预期的响应数时，或者当它达到超时时，会话终止。 </p>
<p> Syntax:  <strong>proxy_responses</strong> <em>number</em> ;<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.9.13版本中。 </p>
<p> 如果使用UDP协议，则设置代理服务器响应客户端数据报所需的数据报数。 该号码用作会话终止的提示。 默认情况下，数据报的数量不受限制。 </p>
<p> 如果指定零值，则不期望响应。 但是，如果收到响应且会话仍未完成，则将处理响应。 </p>
<p> Syntax:  <strong>proxy_socket_keepalive</strong> on | off ;<br>  Default:  proxy_socket_keepalive off;  Context:  stream , server<br>  该指令出现在1.15.6版中。 </p>
<p> 配置到代理服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>proxy_ssl</strong> on | off ;<br>  Default:  proxy_ssl off;  Context:  stream , server<br>  启用S​​SL / TLS协议以连接到代理服务器。 </p>
<p> Syntax:  <strong>proxy_ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的证书的<em>file</em> ，该证书用于对代理服务器进行身份验证。 </p>
<p> Syntax:  <strong>proxy_ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的密钥的<em>file</em> ，用于对代理服务器进行身份验证。 </p>
<p> Syntax:  <strong>proxy_ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  proxy_ssl_ciphers DEFAULT;  Context:  stream , server<br>  指定与代理服务器的连接的已启用密码。 密码以OpenSSL库理解的格式指定。 </p>
<p> 可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> Syntax:  <strong>proxy_ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证代理服务器的证书。 </p>
<p> Syntax:  <strong>proxy_ssl_name</strong> <em>name</em> ;<br>  Default:  proxy_ssl_name host from proxy_pass;  Context:  stream , server<br>  允许覆盖用于验证代理服务器证书的服务器名称，并在与代理服务器建立连接时通过SNI传递 。 也可以使用变量（1.11.3）指定服务器名称。 </p>
<p> 默认情况下，使用proxy_pass地址的主机部分。 </p>
<p> Syntax:  <strong>proxy_ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> Syntax:  <strong>proxy_ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  stream , server<br>  启用指定的协议以连接到代理服务器。 </p>
<p> Syntax:  <strong>proxy_ssl_server_name</strong> on | off ;<br>  Default:  proxy_ssl_server_name off;  Context:  stream , server<br>  在与代理服务器建立连接时，启用或禁用通过TLS服务器名称指示扩展 （SNI，RFC 6066）传递服务器名称。 </p>
<p> Syntax:  <strong>proxy_ssl_session_reuse</strong> on | off ;<br>  Default:  proxy_ssl_session_reuse on;  Context:  stream , server<br>  确定在使用代理服务器时是否可以重用SSL会话。 如果日志中出现“ SSL3_GET_FINISHED:digest check failed ”错误，请尝试禁用会话重用。 </p>
<p> Syntax:  <strong>proxy_ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  stream , server<br>  指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证代理服务器的证书。 </p>
<p> Syntax:  <strong>proxy_ssl_verify</strong> on | off ;<br>  Default:  proxy_ssl_verify off;  Context:  stream , server<br>  启用或禁用代理服务器证书的验证。 </p>
<p> Syntax:  <strong>proxy_ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  proxy_ssl_verify_depth 1;  Context:  stream , server<br>  在代理服务器证书链中设置验证深度。 </p>
<p> Syntax:  <strong>proxy_timeout</strong> <em>timeout</em> ;<br>  Default:  proxy_timeout 10m;  Context:  stream , server<br>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<em>timeout</em> 。 如果在此时间内没有传输数据，则关闭连接。 </p>
<p> Syntax:  <strong>proxy_upload_rate</strong> <em>rate</em> ;<br>  Default:  proxy_upload_rate 0;  Context:  stream , server<br>  该指令出现在1.9.3版本中。 </p>
<p> 限制从客户端读取数据的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据连接设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_map_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_map_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-map-module"><a href="#Module-ngx-stream-map-module" class="headerlink" title="Module ngx_stream_map_module"></a>Module ngx_stream_map_module</h2><p> Example Configuration<br> Directives<br> map<br> map_hash_bucket_size<br> map_hash_max_size<br> ngx_stream_map_module模块（1.11.2）创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>map $remote_addr $limit { 127.0.0.1 “”; default $binary_remote_addr; } limit_conn_zone $limit zone=addr:10m; limit_conn addr 1; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>map</strong> <em>string</em> <em>$variable</em> { … }<br>  Default:  —  Context:  stream<br>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p> 由于变量仅在使用时进行评估，因此即使是大量“ map ”变量的声明也不会给连接处理增加任何额外成本。  地图块内的参数指定源和结果值之间的映射。 </p>
</blockquote>
<p> 源值指定为字符串或正则表达式。 </p>
<p> 字符串匹配忽略大小写。 </p>
<p> 正则表达式应该从“ ~ ”符号开始，用于区分大小写的匹配，或者从“ ~* ”符号开始，用于不区分大小写的匹配。 正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p> 如果源值与下面描述的特殊参数名称之一匹配，则应使用“ \ ”符号作为前缀。 </p>
<p> 结果值可以包含文本，变量及其组合。 </p>
<p> 还支持以下特殊参数： </p>
<p> default <em>value</em>  如果源值与任何指定的变量都不匹配，则设置结果值。 如果未指定default，则默认结果值将为空字符串。  hostnames   表示源值可以是带有前缀或后缀掩码的主机名： </p>
<blockquote>
<p><em>.example.com 1; example.</em> 1;  以下两条记录<br>example.com 1; <em>.example.com 1;  可以合并：<br>.example.com 1;  应在值列表之前指定此参数。  include </em>file*  包含一个包含值的文件。 可能有几个夹杂物。  volatile   表示该变量不可缓存（1.11.7）。  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
</blockquote>
<ol>
<li>没有掩码的字符串值 </li>
<li>带有前缀掩码的最长字符串值，例如“ *.example.com ” </li>
<li>带有后缀掩码的最长字符串值，例如“ mail.* ” </li>
<li>第一个匹配正则表达式（按配置文件中的出现顺序） </li>
<li><p>默认值<br>Syntax:  <strong>map_hash_bucket_size</strong> <em>size</em> ;<br>Default:  map_hash_bucket_size 32|64|128;  Context:  stream<br>设置映射变量哈希表的存储区大小。 默认值取决于处理器的缓存行大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p>Syntax:  <strong>map_hash_max_size</strong> <em>size</em> ;<br>Default:  map_hash_max_size 2048;  Context:  stream<br>设置映射变量哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_log_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_log_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-log-module"><a href="#Module-ngx-stream-log-module" class="headerlink" title="Module ngx_stream_log_module"></a>Module ngx_stream_log_module</h2><p> Example Configuration<br> Directives<br> access_log<br> log_format<br> open_log_file_cache<br> ngx_stream_log_module模块（1.11.4）以指定的格式写入会话日志。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>log_format basic ‘$remote_addr [$time_local] ‘ ‘$protocol $status $bytes_sent $bytes_received ‘ ‘$session_time’; access_log /spool/logs/nginx-access.log basic buffer=32k; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>access_log</strong> <em>path</em> <em>format</em> [ buffer = <em>size</em> ] [ gzip[= <em>level</em> ] ] [ flush = <em>time</em> ] [ if = <em>condition</em> ];<br> <strong>access_log</strong> off ;<br>  Default:  access_log off;  Context:  stream , server<br>  设置缓冲日志写入的路径， 格式和配置。 可以在同一级别指定多个日志。 可以通过在第一个参数中指定“ syslog: ”前缀来配置记录到syslog 。 特殊值off取消当前级别的所有access_log指令。 </p>
<p> 如果使用buffer或gzip参数，则将缓冲对log的写入。 </p>
<blockquote>
<p> 缓冲区大小不得超过磁盘文件的原子写入大小。 对于FreeBSD，这个大小是无限的。  启用缓冲后，数据将写入文件： </p>
</blockquote>
<ul>
<li>如果下一个日志行不适合缓冲区; </li>
<li>如果缓冲的数据早于flush参数指定的数据; </li>
<li><p>当工作进程重新打开日志文件或正在关闭时。<br>如果使用gzip参数，则在写入文件之前将压缩缓冲的数据。 压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。 默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ zcat ”解压缩或读取。 </p>
<p>例： </p>
</li>
</ul>
<blockquote>
<p>access_log /path/to/log.gz basic gzip flush=5m;<br> 要使gzip压缩起作用，必须使用zlib库构建nginx。  文件路径可以包含变量，但是这样的日志有一些约束： </p>
</blockquote>
<ul>
<li>工作进程使用其凭据的用户应具有在具有此类日志的目录中创建文件的权限; </li>
<li>缓冲写入不起作用; </li>
<li><p>每个日志写入都会打开和关闭该文件。 但是，由于常用文件的描述符可以存储在缓存中 ，因此写入旧文件可以在open_log_file_cache指令的valid参数指定的时间内继续写入<br>if参数启用条件记录。 如果<em>condition</em>计算为“0”或空字符串，则不会记录会话。 </p>
<p>Syntax:  <strong>log_format</strong> <em>name</em> [ escape = default | json | none ] <em>string</em> …;<br>Default:  —  Context:  stream<br>指定日志格式，例如： </p>
</li>
</ul>
<blockquote>
<p>log_format proxy ‘$remote_addr [$time_local] ‘ ‘$protocol $status $bytes_sent $bytes_received ‘ ‘$session_time “$upstream_addr” ‘ ‘“$upstream_bytes_sent” “$upstream_bytes_received” “$upstream_connect_time”‘;  escape参数（1.11.8）允许设置在变量中转义的json或default字符，默认情况下，使用default转义。 none参数（1.13.10）禁用转义。 </p>
</blockquote>
<p> Syntax:  <strong>open_log_file_cache</strong> max = <em>N</em> [ inactive = <em>time</em> ] [ min_uses = <em>N</em> ] [ valid = <em>time</em> ];<br> <strong>open_log_file_cache</strong> off ;<br>  Default:  open_log_file_cache off;  Context:  stream , server<br>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。 该指令具有以下参数： </p>
<p> max   设置缓存中的最大描述符数; 如果缓存变满，则最近最少使用（LRU）描述符将被关闭  inactive   如果在此期间没有访问权限，则设置关闭缓存描述符的时间; 默认情况下，10秒  min_uses   设置在inactive参数定义的时间内使文件使用的最小数量，以使描述符在缓存中保持打开状态; 默认情况下，1  valid   设置应该检查文件是否仍然存在同名的时间; 默认情况下，60秒  off   禁用缓存  用法示例： </p>
<blockquote>
<p>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-limit-conn-module"><a href="#Module-ngx-stream-limit-conn-module" class="headerlink" title="Module ngx_stream_limit_conn_module"></a>Module ngx_stream_limit_conn_module</h2><p> Example Configuration<br> Directives<br> limit_conn<br> limit_conn_log_level<br> limit_conn_zone<br> ngx_stream_limit_conn_module模块（1.9.3）用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>stream { limit_conn_zone $binary_remote_addr zone=addr:10m; … server { … limit_conn addr 1; limit_conn_log_level error; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>limit_conn</strong> <em>zone</em> <em>number</em> ;<br>  Default:  —  Context:  stream , server<br>  设置共享内存区域和给定键值的最大允许连接数。 超过此限制时，服务器将关闭连接。 例如，指令 </p>
<blockquote>
<p>limit_conn_zone $binary_remote_addr zone=addr:10m; server { … limit_conn addr 1; }  每次只允许一个IP地址连接一个。 </p>
</blockquote>
<p> 如果指定了几个limit_conn指令，则将应用任何已配置的限制。 </p>
<p> 当且仅当当前级别没有limit_conn指令时，指令才从前一级继承。 </p>
<p> Syntax:  <strong>limit_conn_log_level</strong> info | notice | warn | error ;<br>  Default:  limit_conn_log_level error;  Context:  stream , server<br>  为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p> Syntax:  <strong>limit_conn_zone</strong> <em>key</em> zone = <em>name</em> : <em>size</em> ;<br>  Default:  —  Context:  stream<br>  设置共享内存区域的参数，该区域将保留各种键的状态。 特别是，状态包括当前的连接数。 <em>key</em>可以包含文本，变量及其组合（1.11.2）。 不计算具有空键值的连接。 用法示例： </p>
<blockquote>
<p>limit_conn_zone $binary_remote_addr zone=addr:10m;  这里，密钥是$binary_remote_addr变量设置的客户端IP地址。 $binary_remote_addr的大小为IPv4地址的4个字节或IPv6地址的16个字节。 存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。 一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。 如果区域存储耗尽，服务器将关闭连接。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_keyval_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_keyval_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-keyval-module"><a href="#Module-ngx-stream-keyval-module" class="headerlink" title="Module ngx_stream_keyval_module"></a>Module ngx_stream_keyval_module</h2><p> Example Configuration<br> Directives<br> keyval<br> keyval_zone<br> ngx_stream_keyval_module模块（1.13.7）创建的变量的值取自API管理的键值对。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>http { server { … location /api { api write=on; } } } stream { keyval_zone zone=one:32k state=one.keyval; keyval $ssl_server_name $name zone=one; server { listen 12345 ssl; proxy_pass $name; ssl_certificate /usr/local/nginx/conf/cert.pem; ssl_certificate_key /usr/local/nginx/conf/cert.key; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>keyval</strong> <em>key</em> <em>$variable</em> zone = <em>name</em> ;<br>  Default:  —  Context:  stream<br>  创建一个新的<em>$variable</em>其值由<em>key</em>数据库中的键查找。 字符串匹配忽略大小写。 数据库存储在zone参数指定的共享内存区域中。 </p>
<p> Syntax:  <strong>keyval_zone</strong> zone = <em>name</em> : <em>size</em> [ state = <em>file</em> ] [ timeout = <em>time</em> ] [ sync ];<br>  Default:  —  Context:  stream<br>  设置保留键值数据库的共享内存区域的<em>name</em>和<em>size</em> 。 键值对由API管理。 </p>
<p> 可选的state参数指定一个<em>file</em> ，该<em>file</em>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p> 可选的timeout参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p> 可选的sync参数（1.15.0）可以同步共享内存区域。 同步需要设置超时参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_js_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_js_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-js-module"><a href="#Module-ngx-stream-js-module" class="headerlink" title="Module ngx_stream_js_module"></a>Module ngx_stream_js_module</h2><p> Example Configuration<br> Directives<br> js_access<br> js_filter<br> js_include<br> js_preread<br> js_set<br> Session Object Properties<br> ngx_stream_js_module模块用于在njs中实现处理程序 - 这是JavaScript语言的一个子集。 </p>
<p> 默认情况下不构建此模块。 可在此处下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p> 此示例适用于njs 0.2.4及更高版本。 对于njs 0.2.3及更早版本，请使用此示例。<br>load_module modules/ngx_stream_js_module.so; … stream { js_include stream.js; js_set $bar bar; js_set $req_line req_line; server { listen 12345; js_preread preread; return $req_line; } server { listen 12346; js_access access; proxy_pass 127.0.0.1:8000; js_filter header_inject; } } http { server { listen 8000; location / { return 200 $http_foo\n; } } }  stream.js文件： </p>
<p>var line = ‘’; function bar(s) { var v = s.variables; s.log(“hello from bar() handler!”); return “bar-var” + v.remote_port + “; pid=” + v.pid; } function preread(s) { s.on(‘upload’, function (data, flags) { var n = data.indexOf(‘\n’); if (n != -1) { line = data.substr(0, n); s.done(); } }); } function req_line(s) { return line; } // Read HTTP request line. // Collect bytes in ‘req’ until // request line is read. // Injects HTTP header into a client’s request var my_header = ‘Foo: foo’; function header_inject(s) { var req = ‘’; s.on(‘upload’, function(data, flags) { req += data; var n = req.search(‘\n’); if (n != -1) { var rest = req.substr(n + 1); req = req.substr(0, n + 1); s.send(req + my_header + ‘\r\n’ + rest, flags); s.off(‘upload’); } }); } function access(s) { if (s.remoteAddress.match(‘^192.*’)) { s.abort(); return; } s.allow(); } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>js_access</strong> <em>function</em> ;<br>  Default:  —  Context:  stream , server<br>  设置将在访问阶段调用的njs函数。 </p>
<p> Syntax:  <strong>js_filter</strong> <em>function</em> ;<br>  Default:  —  Context:  stream , server<br>  设置数据过滤器。 </p>
<p> Syntax:  <strong>js_include</strong> <em>file</em> ;<br>  Default:  —  Context:  stream<br>  指定在njs中实现服务器和变量处理程序的文件。 </p>
<p> Syntax:  <strong>js_preread</strong> <em>function</em> ;<br>  Default:  —  Context:  stream , server<br>  设置将在预读阶段调用的njs函数。 </p>
<p> Syntax:  <strong>js_set</strong> <em>$variable</em> <em>function</em> ;<br>  Default:  —  Context:  stream<br>  为指定的变量设置njs函数。 </p>
<h4 id="会话对象属性"><a href="#会话对象属性" class="headerlink" title="会话对象属性"></a>会话对象属性</h4><p> 每个流njs处理程序接收一个参数，即流会话对象 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geo_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geo_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geo-module"><a href="#Module-ngx-stream-geo-module" class="headerlink" title="Module ngx_stream_geo_module"></a>Module ngx_stream_geo_module</h2><p> Example Configuration<br> Directives<br> geo<br> ngx_stream_geo_module模块（1.11.3）使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>geo $geo { default 0; 127.0.0.1 2; 192.168.1.0/24 1; 10.1.0.0/16 1; ::1 2; 2001:0db8::/32 1; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>geo</strong> [ <em>$address</em> ] <em>$variable</em> { … }<br>  Default:  —  Context:  stream<br>  描述指定变量的值对客户端IP地址的依赖性。 默认情况下，地址取自$remote_addr变量，但也可以从另一个变量中获取，例如： </p>
<blockquote>
<p>geo $arg_remote_addr $geo { …; }<br> 由于变量仅在使用时进行评估，因此即使存在大量已声明的“ geo ”变量也不会导致连接处理的任何额外成本。  如果变量的值不表示有效的IP地址，则使用“ 255.255.255.255 ”地址。 </p>
</blockquote>
<p> 地址被指定为CIDR表示法中的前缀（包括单个地址）或作为范围。 </p>
<p> 还支持以下特殊参数： </p>
<p> delete   删除指定的网络。  default   如果客户端地址与任何指定的地址不匹配，则设置为该变量的值。 当以CIDR表示法指定地址时，可以使用“ 0.0.0.0/0 ”和“ ::/0 ”而不是default 。 如果未指定default，则默认值为空字符串。  include   包括一个包含地址和值的文件。 可能有几个夹杂物。  ranges   表示地址被指定为范围。 这个参数应该是第一个。 要加快地理基地的加载速度，地址应按升序排列。  例： </p>
<blockquote>
<p>geo $country { default ZZ; include conf/geo.conf; delete 127.0.0.0/16; 127.0.0.0/24 US; 127.0.0.1/32 RU; 10.1.0.0/16 RU; 192.168.1.0/24 UK; }  conf/geo.conf文件可以包含以下行： </p>
<p>10.2.0.0/16 RU; 192.168.2.0/24 RU;  使用最具体匹配的值。 例如，对于127.0.0.1地址，将选择值“ RU ”，而不是“ US ”。 </p>
</blockquote>
<p> 范围示例： </p>
<blockquote>
<p>geo $country { ranges; default ZZ; 127.0.0.0-127.0.0.0 US; 127.0.0.1-127.0.0.1 RU; 127.0.0.1-127.0.0.255 US; 10.1.0.0-10.1.255.255 RU; 192.168.1.0-192.168.1.255 UK; }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geoip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geoip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geoip-module"><a href="#Module-ngx-stream-geoip-module" class="headerlink" title="Module ngx_stream_geoip_module"></a>Module ngx_stream_geoip_module</h2><p> Example Configuration<br> Directives<br> geoip_country<br> geoip_city<br> geoip_org<br> ngx_stream_geoip_module模块（1.11.3）使用预编译的MaxMind数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p> 使用支持IPv6的数据库时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p> 默认情况下不构建此模块，应使用–with-stream_geoip_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要MaxMind GeoIP库。 ####  示例配置</p>
<p>stream { geoip_country GeoIP.dat; geoip_city GeoLiteCity.dat; map $geoip_city_continent_code $nearest_server { default example.com; EU eu.example.com; NA na.example.com; AS as.example.com; } … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>geoip_country</strong> <em>file</em> ;<br>  Default:  —  Context:  stream<br>  指定用于根据客户端IP地址确定国家/地区的数据库。 使用此数据库时，以下变量可用： </p>
<p> $geoip_country_code   两个字母的国家/地区代码，例如“ RU ”，“ US ”。  $geoip_country_code3   三个字母的国家/地区代码，例如“ RUS ”，“ USA ”。  $geoip_country_name   国名，例如“ Russian Federation ”，“ United States ”。  Syntax:  <strong>geoip_city</strong> <em>file</em> ;<br>  Default:  —  Context:  stream<br>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。 使用此数据库时，以下变量可用： </p>
<p> $geoip_area_code   电话区号（仅限美国）。 </p>
<blockquote>
<p> 此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。  $geoip_city_continent_code   两个字母的大陆代码，例如“ EU ”，“ NA ”。  $geoip_city_country_code   两个字母的国家/地区代码，例如“ RU ”，“ US ”。  $geoip_city_country_code3   三个字母的国家/地区代码，例如“ RUS ”，“ USA ”。  $geoip_city_country_name   国名，例如“ Russian Federation ”，“ United States ”。  $geoip_dma_code   根据Google AdWords API中的地理位置定位 ，美国的DMA区域代码（也称为“都市代码”）。  $geoip_latitude   纬度。  $geoip_longitude   经度。  $geoip_region   双符号国家区域代码（地区，领土，州，省，联邦土地等），例如“ 48 ”，“ DC ”。  $geoip_region_name   国家地区名称（地区，领土，州，省，联邦土地等），例如“ Moscow City ”，“ District of Columbia ”。  $geoip_city   城市名称，例如“ Moscow ”，“ Washington ”。  $geoip_postal_code   邮政编码。  Syntax:  <strong>geoip_org</strong> <em>file</em> ;<br>  Default:  —  Context:  stream<br>  指定用于根据客户端IP地址确定组织的数据库。 使用此数据库时，以下变量可用： </p>
</blockquote>
<p> $geoip_org   组织名称，例如“墨尔本大学”。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_core_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_core_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-core-module"><a href="#Module-ngx-stream-core-module" class="headerlink" title="Module ngx_stream_core_module"></a>Module ngx_stream_core_module</h2><p> Example Configuration<br> Directives<br> listen<br> preread_buffer_size<br> preread_timeout<br> proxy_protocol_timeout<br> resolver<br> resolver_timeout<br> server<br> stream<br> tcp_nodelay<br> variables_hash_bucket_size<br> variables_hash_max_size<br> Embedded Variables<br> ngx_stream_core_module模块自版本1.9.0起可用。 默认情况下不构建此模块，应使用–with-stream配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>worker_processes auto; error_log /var/log/nginx/error.log info; events { worker_connections 1024; } stream { upstream backend { hash $remote_addr consistent; server backend1.example.com:12345 weight=5; server 127.0.0.1:12345 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; } upstream dns { server 192.168.0.1:53535; server dns.example.com:53; } server { listen 12345; proxy_connect_timeout 1s; proxy_timeout 3s; proxy_pass backend; } server { listen 127.0.0.1:53 udp reuseport; proxy_timeout 20s; proxy_pass dns; } server { listen [::1]:12345; proxy_pass unix:/tmp/stream.socket; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>listen</strong> <em>address</em> : <em>port</em> [ ssl ] [ udp ] [ proxy_protocol ] [ backlog = <em>number</em> ] [ rcvbuf = <em>size</em> ] [ sndbuf = <em>size</em> ] [ bind ] [ ipv6only = on | off ] [ reuseport ] [ so_keepalive = on | off |[ <em>keepidle</em> ]:[ <em>keepintvl</em> ]:[ <em>keepcnt</em> ]];<br>  Default:  —  Context:  server<br>  设置服务器将接受连接的套接字的<em>address</em>和<em>port</em> 。 可以仅指定端口。 地址也可以是主机名，例如： </p>
<blockquote>
<p>listen 127.0.0.1:12345; listen <em>:12345; listen 12345; # same as </em>:12345 listen localhost:12345;  IPv6地址在方括号中指定： </p>
<p>listen [::1]:12345; listen [::]:12345;  UNIX域套接字使用“ unix: ”前缀指定： </p>
<p>listen unix:/var/run/nginx.sock;  ssl参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
</blockquote>
<p> udp参数配置一个侦听套接字以处理数据报（1.9.13）。 </p>
<p> proxy_protocol参数（1.11.4）允许指定此端口上接受的所有连接都应使用PROXY协议 。 </p>
<blockquote>
<p> 自版本1.13.11起支持PROXY协议版本2。  listen指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
</blockquote>
<p> backlog = <em>number</em>  在listen()调用中设置backlog参数，该参数限制挂起连接队列的最大长度（1.9.2）。 默认情况下， backlog在FreeBSD，DragonFly BSD和macOS上设置为-1，在其他平台上设置为511。  rcvbuf = <em>size</em>  设置侦听套接字的接收缓冲区大小（ SO_RCVBUF选项）（1.11.13）。  sndbuf = <em>size</em>  设置侦听套接字的发送缓冲区大小（ SO_SNDBUF选项）（1.11.13）。  bind   此参数指示对给定地址：端口对进行单独的bind()调用。 事实是，如果有几个具有相同端口但不同地址的listen指令，并且其中一个listen指令侦听给定端口（ <em>: </em>port<em> ）的所有地址，则nginx将bind()仅限于</em>: <em>port</em> 。 应该注意的是，在这种情况下将进行getsockname()系统调用以确定接受连接的地址。 如果使用ipv6only或so_keepalive参数，那么对于给定的<em>address</em> ： <em>port</em>对将始终进行单独的bind()调用。  ipv6only = on | off  此参数确定（通过IPV6_V6ONLY套接字选项）侦听通配符地址[::]的IPv6套接字是仅接受IPv6连接还是仅接受IPv6和IPv4连接。 默认情况下，此参数处于启用状态。 它只能在开始时设置一次。  reuseport   此参数（1.9.1）指示为每个工作进程创建一个单独的侦听套接字（使用Linux 3.9+和DragonFly BSD上的SO_REUSEPORT套接字选项，或FreeBSD 12+上的SO_REUSEPORT_LB ），允许内核在工作进程之间分配传入连接。 目前仅适用于Linux 3.9 +，DragonFly BSD和FreeBSD 12+（1.15.1）。 </p>
<blockquote>
<p> 不恰当地使用此选项可能会产生安全隐患 。  so_keepalive = on | off | [ <em>keepidle</em> ]：[ <em>keepintvl</em> ]：[ <em>keepcnt</em> ]  此参数配置侦听套接字的“TCP keepalive”行为。 如果省略此参数，则操作系统的设置将对套接字有效。 如果将其设置为值“ on ”，则为套接字打开SO_KEEPALIVE选项。 如果将其设置为值“ off ”，则为套接字关闭SO_KEEPALIVE选项。 某些操作系统支持使用TCP_KEEPIDLE ， TCP_KEEPINTVL和TCP_KEEPCNT套接字选项在每个套接字的基础上设置TCP keepalive参数。 在这样的系统上（目前，Linux 2.4 +，NetBSD 5+和FreeBSD 9.0-STABLE），可以使用<em>keepidle</em> ， <em>keepintvl</em>和<em>keepcnt</em>参数配置它们。 可以省略一个或两个参数，在这种情况下，相应套接字选项的系统默认设置将生效。 例如，<br>so_keepalive=30m::10 将空闲超时（ TCP_KEEPIDLE ）设置为30分钟，将探测间隔（ TCP_KEEPINTVL ）保留为系统默认值，并将探测计数（ TCP_KEEPCNT ）设置为10个探测。  不同的服务器必须侦听不同的<em>address</em> ： <em>port</em>对。 </p>
</blockquote>
<p> Syntax:  <strong>preread_buffer_size</strong> <em>size</em> ;<br>  Default:  preread_buffer_size 16k;  Context:  stream , server<br>  该指令出现在1.11.5版中。 </p>
<p> 指定预读缓冲区的<em>size</em> 。 </p>
<p> Syntax:  <strong>preread_timeout</strong> <em>timeout</em> ;<br>  Default:  preread_timeout 30s;  Context:  stream , server<br>  该指令出现在1.11.5版中。 </p>
<p> 指定预读阶段的<em>timeout</em> 。 </p>
<p> Syntax:  <strong>proxy_protocol_timeout</strong> <em>timeout</em> ;<br>  Default:  proxy_protocol_timeout 30s;  Context:  stream , server<br>  该指令出现在1.11.4版中。 </p>
<p> 指定读取PROXY协议标头以完成的<em>timeout</em> 。 如果在此时间内未传输整个标头，则关闭连接。 </p>
<p> Syntax:  <strong>resolver</strong> <em>address</em> … [ valid = <em>time</em> ] [ ipv6 = on | off ];<br>  Default:  —  Context:  stream , server<br>  该指令出现在1.11.3版中。 </p>
<p> 将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353;  可以将地址指定为域名或IP地址，以及可选端口。 如果未指定端口，则使用端口53。 以循环方式查询名称服务器。 </p>
</blockquote>
<p> 默认情况下，nginx将在解析时查找IPv4和IPv6地址。 如果不需要查找IPv6地址，可以指定ipv6=off参数。 </p>
<p> 默认情况下，nginx使用响应的TTL值缓存答案。 可选的valid参数允许覆盖它： </p>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353 valid=30s;<br> 在1.11.3版之前，该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>resolver_timeout</strong> <em>time</em> ;<br>  Default:  resolver_timeout 30s;  Context:  stream , server<br>  该指令出现在1.11.3版中。 </p>
</blockquote>
<p> 设置名称解析的超时，例如： </p>
<blockquote>
<p>resolver_timeout 5s;<br> 在1.11.3版之前，该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>server</strong> { … }<br>  Default:  —  Context:  stream<br>  设置服务器的配置。 </p>
</blockquote>
<p> Syntax:  <strong>stream</strong> { … }<br>  Default:  —  Context:  main<br>  提供指定流服务器指令的配置文件上下文。 </p>
<p> Syntax:  <strong>tcp_nodelay</strong> on | off ;<br>  Default:  tcp_nodelay on;  Context:  stream , server<br>  该指令出现在1.9.4版本中。 </p>
<p> 启用或禁用TCP_NODELAY选项的使用。 为客户端和代理服务器连接启用该选项。 </p>
<p> Syntax:  <strong>variables_hash_bucket_size</strong> <em>size</em> ;<br>  Default:  variables_hash_bucket_size 64;  Context:  stream<br>  该指令出现在1.11.2版中。 </p>
<p> 设置变量哈希表的桶大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>variables_hash_max_size</strong> <em>size</em> ;<br>  Default:  variables_hash_max_size 1024;  Context:  stream<br>  该指令出现在1.11.2版中。 </p>
<p> 设置变量哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_stream_core_module模块支持自1.11.2以来的变量。 </p>
<p> $binary_remote_addr   客户端地址采用二进制形式，值的长度始终为IPv4地址的4个字节或IPv6地址的16个字节  $bytes_received   从客户端收到的字节数（1.11.4）  $bytes_sent   发送到客户端的字节数  $connection   连接序列号  $hostname   主机名  $msec   以毫秒为单位的当前时间（以毫秒为单位）  $nginx_version   nginx版本  $pid   工作进程的PID  $protocol   用于与客户端通信的协议： TCP或UDP （1.11.4）  $proxy_protocol_addr   来自PROXY协议头的客户端地址，否则为空字符串（1.11.4）  必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> $proxy_protocol_port   来自PROXY协议头的客户端端口，否则为空字符串（1.11.4）  必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> $remote_addr   客户地址  $remote_port   客户端端口  $server_addr   接受连接的服务器的地址  计算此变量的值通常需要一次系统调用。 为避免系统调用， listen指令必须指定地址并使用bind参数。 </p>
<p> $server_port   接受连接的服务器的端口  $session_time   会话持续时间（以秒为单位），分辨率为毫秒（1.11.4）;  $status   会话状态（1.11.4），可以是以下之一：  200   会话成功完成  400   无法解析客户端数据，例如PROXY协议头  403   例如，当某些客户端地址的访问受限时，禁止访问  500   内部服务器错误  502   坏网关，例如，如果无法选择或到达上游服务器。  503   服务不可用，例如，当访问受连接数限制时  $time_iso8601   当地时间采用ISO 8601标准格式  $time_local   通用日志格式的本地时间  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_access_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_access_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-access-module"><a href="#Module-ngx-stream-access-module" class="headerlink" title="Module ngx_stream_access_module"></a>Module ngx_stream_access_module</h2><p> Example Configuration<br> Directives<br> allow<br> deny<br> ngx_stream_access_module模块（1.9.2）允许限制对某些客户端地址的访问。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { … deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; }  按顺序检查规则，直到找到第一个匹配项。 在此示例中，仅允许IPv4网络10.1.1.0/16和192.168.1.0/24不包括地址192.168.1.1 ）和IPv6网络2001:0db8::/32 。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>allow</strong> <em>address</em> | <em>CIDR</em> | unix: | all ;<br>  Default:  —  Context:  stream , server<br>  允许访问指定的网络或地址。 如果指定了特殊值unix:则允许访问所有UNIX域套接字。 </p>
<p> Syntax:  <strong>deny</strong> <em>address</em> | <em>CIDR</em> | unix: | all ;<br>  Default:  —  Context:  stream , server<br>  拒绝访问指定的网络或地址。 如果指定了特殊值unix:则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/install-nginx中文手册]]></title>
      <url>/ngx/njs/install.html</url>
      <content type="html"><![CDATA[<p>njs,install<br><a id="more"></a></p>
<h2 id="下载并安装"><a href="#下载并安装" class="headerlink" title=" 下载并安装"></a> 下载并安装</h2><p> Installing as a Linux package<br> Building from the sources   </p>
<h4 id="作为Linux软件包安装"><a href="#作为Linux软件包安装" class="headerlink" title="作为Linux软件包安装"></a>作为Linux软件包安装</h4><p> 对于Linux，可以使用njs模块包 ： </p>
<ul>
<li>nginx-module-njs - njs 动态模块 </li>
<li><p>nginx-module-njs-dbg - nginx-module-njs包的调试符号 </p>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p>可以使用以下命令克隆具有njs源的存储库 :(需要Mercurial客户端）： </p>
</li>
</ul>
<blockquote>
<p>hg clone <a href="http://hg.nginx.org/njs" target="_blank" rel="noopener">http://hg.nginx.org/njs</a>  然后应使用–add-module配置参数编译–add-module ： </p>
<p>./configure –add-module= <em>path-to-njs</em> /nginx  模块也可以构建为动态 ： </p>
<p>./configure –add-dynamic-module= <em>path-to-njs</em> /nginx  要仅构建njs命令行实用程序 ，请运行./configure并从njs根目录make njs命令。 该实用程序以./build/njs 。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/index-nginx中文手册]]></title>
      <url>/ngx/njs/index.html</url>
      <content type="html"><![CDATA[<p>njs,index<br><a id="more"></a></p>
<h2 id="njs脚本语言"><a href="#njs脚本语言" class="headerlink" title=" njs脚本语言"></a> njs脚本语言</h2><p> njs是JavaScript语言的一个子集，允许扩展nginx功能。 njs是根据ECMAScript 5.1 （严格模式）创建的，带有一些ECMAScript 6及更高版本的扩展。 合规性仍在不断发展 。 </p>
<ul>
<li>下载并安装 </li>
<li>变化 </li>
<li>参考 </li>
<li>例子 </li>
<li>兼容性 </li>
<li>命令行界面 </li>
<li>ngx_http_js_module </li>
<li><p>ngx_stream_js_module </p>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4></li>
<li><p>在请求到达上游服务器之前，njs中的复杂访问控制和安全性检查 </p>
</li>
<li>操纵响应标头 </li>
<li>编写灵活的异步内容处理程序和过滤器<br>有关更多njs用例，请参阅示例和博客文章 。 </li>
</ul>
<h4 id="基本HTTP示例"><a href="#基本HTTP示例" class="headerlink" title="基本HTTP示例"></a>基本HTTP示例</h4><p> 要在nginx中使用njs： </p>
<ul>
<li>安装 njs脚本语言 </li>
</ul>
<ul>
<li>创建一个njs脚本文件，例如hello_world.js 。 有关njs属性和方法的列表，请参见参考 。 </li>
</ul>
<blockquote>
<p>function hello(r) { r.return(200, “Hello world!”); } </p>
<ul>
<li>在nginx.conf文件中，启用ngx_http_js_module模块并使用hello_world.js脚本文件指定js_include指令： </li>
</ul>
<p>load_module modules/ngx_http_js_module.so; events {} http { js_include hello_world.js; server { listen 8000; location / { js_content hello; } } }<br> 还有一个独立的命令行实用程序，可以独立于nginx用于njs开发和调试。 </p>
</blockquote>
<h4 id="在2018年的nginx-conf上发表演讲"><a href="#在2018年的nginx-conf上发表演讲" class="headerlink" title="在2018年的nginx.conf上发表演讲"></a>在2018年的nginx.conf上发表演讲</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/examples-nginx中文手册]]></title>
      <url>/ngx/njs/examples.html</url>
      <content type="html"><![CDATA[<p>njs,examples<br><a id="more"></a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title=" 例子"></a> 例子</h2><p> Hello World<br> URL Decoding<br> URL Encoding<br> Internal Redirect<br> Returning Fastest Response from Proxy<br> Creating HS JWT<br> Accessing API from a Subrequest<br> Creating secure_link Hash<br> Legacy Examples<br> Injecting HTTP header using stream proxy   </p>
<h4 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h4><p> nginx.conf ： </p>
<blockquote>
<p>load_module modules/ngx_http_js_module.so; events {} http { js_include hello_world.js; server { listen 8000; location / { js_content hello; } } }  hello_world.js ： </p>
<p>function hello(r) { r.return(200, “Hello world!”); } ####  网址解码</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include urldecode.js; js_set $decoded_foo decoded_foo;  urldecode.js ： </p>
<p>function decoded_foo(r) { return decodeURIComponent(r.args.foo); } ####  网址编码</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include urlencode.js; js_set $encoded_foo encoded_foo; … location / { proxy_pass <a href="http://example.com?foo=$encoded\_foo" target="_blank" rel="noopener">http://example.com?foo=$encoded\_foo</a>; }  urlencode.js ： </p>
<p>function encoded_foo(r) { return encodeURIComponent(‘foo &amp; bar?’); } ####  内部重定向</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include redirect.js; location /redirect { js_content redirect; } location @named { return 200 named; }  redirect.js ： </p>
<p>function redirect(r) { r.internalRedirect(‘@named’); } ####  从代理返回最快的响应</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include fastresponse.js; location /start { js_content content; } location /foo { proxy_pass <a href="http://backend1" target="_blank" rel="noopener">http://backend1</a>; } location /bar { proxy_pass <a href="http://backend2" target="_blank" rel="noopener">http://backend2</a>; }  fastresponse.js ： </p>
<p>function content(r) { var n = 0; function done(res) { if (n++ == 0) { r.return(res.status, res.responseBody); } } r.subrequest(‘/foo’, r.variables.args, done); r.subrequest(‘/bar’, r.variables.args, done); } ####  创建HS JWT</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include hs_jwt.js; js_set $jwt jwt;  hs_jwt.js ： </p>
<p>function create_hs256_jwt(claims, key, valid) { var header = { “typ” : “JWT”, “alg” : “HS256”, “exp” : Date.now() + valid }; var s = JSON.stringify(header).toBytes().toString(‘base64url’) + ‘.’ + JSON.stringify(claims).toBytes().toString(‘base64url’); var h = require(‘crypto’).createHmac(‘sha256’, key); return s + ‘.’ + h.update(s).digest().toString(‘base64url’); } function jwt(r) { var claims = { “iss” : “nginx”, “sub” : “alice”, “foo” : 123, “bar” : “qq”, “zyx” : false }; return create_hs256_jwt(claims, ‘foo’, 600); } ####  从子请求访问API</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include subrequest.js; keyval_zone zone=foo:10m; … location /keyval { js_content set_keyval; } location /version { js_content version; } location /api { api write=on; }  subrequest.js ： </p>
<p>function set_keyval(r) { r.subrequest(‘/api/3/http/keyvals/foo’, { method: ‘POST’, body: JSON.stringify({ foo: 789, bar: “ss dd 00” })}, function(res) { if (res.status &gt;= 300) { r.return(res.status, res.responseBody); return; } r.return(500); }); } function version(r) { r.subrequest(‘/api/3/nginx’, { method: ‘GET’ }, function(res) { if (res.status != 200) { r.return(res.status); return; } var json = JSON.parse(res.responseBody); r.return(200, json.version); }); } ####  创建secure_link哈希</p>
</blockquote>
<p> nginx.conf ： </p>
<blockquote>
<p>js_include hash.js; js_set $new_foo create_secure_link; … location / { secure_link $cookie_foo; secure_link_md5 “$uri mykey”; … } location @login { add_header Set-Cookie “foo=$new_foo; Max-Age=60”; return 302 /; }  hash.js ： </p>
<p>function create_secure_link(r) { return require(‘crypto’).createHash(‘md5’) .update(r.uri).update(“ mykey”) .digest(‘base64url’); } ####  遗留的例子</p>
</blockquote>
<h4 id="使用流代理注入HTTP标头"><a href="#使用流代理注入HTTP标头" class="headerlink" title="使用流代理注入HTTP标头"></a>使用流代理注入HTTP标头</h4><p> 从njs 0.2.4开始，流配置示例已更改。 对于njs 0.2.3及更早版本，请使用此配置示例： </p>
<blockquote>
<p>load_module modules/ngx_stream_js_module.so; … stream { js_include stream.js; js_set $foo foo; js_set $bar bar; server { listen 12345; js_preread qux; return $foo; } server { listen 12346; js_access xyz; proxy_pass 127.0.0.1:8000; js_filter baz; } } http { server { listen 8000; location / { return 200 $http_foo\n; } } }  stream.js文件： </p>
<p>var req = ‘’; var matched = 0; var line = ‘’; function qux(s) { var n = s.buffer.indexOf(‘\n’); if (n == -1) { return s.AGAIN; } line = s.buffer.substr(0, n); } function foo(s) { return line; } function bar(s) { var v = s.variables; s.log(“hello from bar() handler!”); return “foo-var” + v.remote_port + “; pid=” + v.pid; } // The filter processes one buffer per call. // The buffer is available in s.buffer both for // reading and writing. Called for both directions. function baz(s) { if (s.fromUpstream || matched) { return; } // Disable certain addresses. if (s.remoteAddress.match(‘^192.<em>‘)) { return s.ERROR; } // Read HTTP request line. // Collect bytes in ‘req’ until request // line is read. Clear current buffer to // disable output. req = req + s.buffer; s.buffer = ‘’; var n = req.search(‘\n’); if (n != -1) { // Inject a new HTTP header. var rest = req.substr(n + 1); req = req.substr(0, n + 1); var addr = s.remoteAddress; s.log(‘req:’ + req); s.log(‘rest:’ + rest); // Output the result and skip further // processing. s.buffer = req + ‘Foo: addr_‘ + addr + ‘\r\n’ + rest; matched = 1; } } function xyz(s) { if (s.remoteAddress.match(‘^192.</em>‘)) { return s.ABORT; } }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_ssl_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_ssl_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-ssl-module"><a href="#Module-ngx-mail-ssl-module" class="headerlink" title="Module ngx_mail_ssl_module"></a>Module ngx_mail_ssl_module</h2><p> Example Configuration<br> Directives<br> ssl<br> ssl_certificate<br> ssl_certificate_key<br> ssl_ciphers<br> ssl_client_certificate<br> ssl_crl<br> ssl_dhparam<br> ssl_ecdh_curve<br> ssl_password_file<br> ssl_prefer_server_ciphers<br> ssl_protocols<br> ssl_session_cache<br> ssl_session_ticket_key<br> ssl_session_tickets<br> ssl_session_timeout<br> ssl_trusted_certificate<br> ssl_verify_client<br> ssl_verify_depth<br> starttls<br> ngx_mail_ssl_module模块为邮件代理服务器提供必要的支持，以使用SSL / TLS协议。 </p>
<p> 默认情况下不构建此模块，应使用–with-mail_ssl_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要OpenSSL库。 ####  示例配置</p>
</blockquote>
<p> 为减少处理器负载，建议使用 </p>
<ul>
<li>设置工作进程数等于处理器数， </li>
<li>启用共享会话缓存， </li>
<li>禁用内置会话缓存， </li>
<li>并可能增加会话生命周期 （默认为5分钟）： </li>
</ul>
<blockquote>
<p> <strong>worker_processes auto;</strong> mail { … server { listen 993 ssl; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5; ssl_certificate /usr/local/nginx/conf/cert.pem; ssl_certificate_key /usr/local/nginx/conf/cert.key; <strong>ssl_session_cache shared:SSL:10m;</strong> <strong>ssl_session_timeout 10m;</strong> … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ssl</strong> on | off ;<br>  Default:  ssl off;  Context:  mail , server<br>  该指令在1.15.0版本中已过时。 应该使用listen指令的ssl参数。 </p>
<p> Syntax:  <strong>ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  指定具有给定服务器的PEM格式的证书的<em>file</em> 。 如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。 PEM格式的密钥可以放在同一文件中。 </p>
<p> 从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<blockquote>
<p>server { listen 993 ssl; ssl_certificate example.com.rsa.crt; ssl_certificate_key example.com.rsa.key; ssl_certificate example.com.ecdsa.crt; ssl_certificate_key example.com.ecdsa.key; … }<br> 只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。 对于旧版本，只能使用一个证书链。  Syntax:  <strong>ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  指定具有给定服务器的PEM格式的密钥的<em>file</em> 。 </p>
</blockquote>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> （1.7.9），该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  ssl_ciphers HIGH:!aNULL:!MD5;  Context:  mail , server<br>  指定启用的密码。 密码以OpenSSL库理解的格式指定，例如： </p>
<blockquote>
<p>ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;  可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> 以前版本的nginx默认使用不同的密码。  Syntax:  <strong>ssl_client_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
</blockquote>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证客户端证书。 </p>
<p> 证书列表将发送给客户。 如果不需要，可以使用ssl_trusted_certificate指令。 </p>
<p> Syntax:  <strong>ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
<p> 指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证客户端证书。 </p>
<p> Syntax:  <strong>ssl_dhparam</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在0.7.2版本中。 </p>
<p> 为DHE密码指定具有DH参数的<em>file</em> 。 </p>
<p> 默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p> 在1.11.0版之前，默认使用内置参数。  Syntax:  <strong>ssl_ecdh_curve</strong> <em>curve</em> ;<br>  Default:  ssl_ecdh_curve auto;  Context:  mail , server<br>  该指令出现在1.1.0和1.0.6版本中。 </p>
</blockquote>
<p> 指定ECDHE密码的<em>curve</em> 。 </p>
<p> 使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<blockquote>
<p>ssl_ecdh_curve prime256v1:secp384r1;  特殊值auto （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的prime256v1 。 </p>
<p> 在版本1.11.0之前，默认使用prime256v1曲线。  Syntax:  <strong>ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在1.7.3版本中。 </p>
</blockquote>
<p> 指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> 例： </p>
<blockquote>
<p>mail { ssl_password_file /etc/keys/global.pass; … server { server_name mail1.example.com; ssl_certificate_key /etc/keys/first.key; } server { server_name mail2.example.com; # named pipe can also be used instead of a file ssl_password_file /etc/keys/fifo; ssl_certificate_key /etc/keys/second.key; } }  Syntax:  <strong>ssl_prefer_server_ciphers</strong> on | off ;<br>  Default:  ssl_prefer_server_ciphers off;  Context:  mail , server<br>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  mail , server<br>  启用指定的协议。 </p>
<blockquote>
<p> TLSv1.1和TLSv1.2参数（ TLSv1.2 ）仅在使用OpenSSL 1.0.1或更高版本时有效。<br> 仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， TLSv1.3参数（1.13.0）才有效。  Syntax:  <strong>ssl_session_cache</strong> off | none | [ builtin [: <em>size</em> ]] [ shared : <em>name</em> : <em>size</em> ];<br>  Default:  ssl_session_cache none;  Context:  mail , server<br>  设置存储会话参数的缓存的类型和大小。 缓存可以是以下任何类型： </p>
</blockquote>
<p> off   严格禁止使用会话缓存：nginx明确告诉客户端会话可能不会被重用。  none   轻轻地禁止使用会话缓存：nginx告诉客户端会话可以重用，但实际上并不会将会话参数存储在缓存中。  builtin   一个用OpenSSL构建的缓存; 仅由一个工作进程使用。 缓存大小在会话中指定。 如果未给出大小，则等于20480个会话。 使用内置缓存可能会导致内存碎片。  shared   所有工作进程之间共享的缓存。 高速缓存大小以字节为单位指定; 一兆字节可以存储大约4000个会话。 每个共享缓存都应具有任意名称。 可以在多个服务器中使用具有相同名称的缓存。  两种缓存类型可以同时使用，例如： </p>
<blockquote>
<p>ssl_session_cache builtin:1000 shared:SSL:10m;  但只使用没有内置缓存的共享缓存应该更有效。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_ticket_key</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在1.5.7版本中。 </p>
<p> 设置具有用于加密和解密TLS会话票证的密钥的<em>file</em> 。 如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。 默认情况下，使用随机生成的密钥。 </p>
<p> 如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。 这允许配置键旋转，例如： </p>
<blockquote>
<p>ssl_session_ticket_key current.key; ssl_session_ticket_key previous.key;  该<em>file</em>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<p>openssl rand 80 &gt; ticket.key  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_tickets</strong> on | off ;<br>  Default:  ssl_session_tickets on;  Context:  mail , server<br>  该指令出现在1.5.9版本中。 </p>
<p> 通过TLS会话票证启用或禁用会话恢复。 </p>
<p> Syntax:  <strong>ssl_session_timeout</strong> <em>time</em> ;<br>  Default:  ssl_session_timeout 5m;  Context:  mail , server<br>  指定客户端可以重用会话参数的时间。 </p>
<p> Syntax:  <strong>ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证客户端证书。 </p>
<p> 与ssl_client_certificate设置的证书不同 ，这些证书的列表不会发送给客户端。 </p>
<p> Syntax:  <strong>ssl_verify_client</strong> on | off | optional | optional_no_ca ;<br>  Default:  ssl_verify_client off;  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
<p> 启用客户端证书验证。 验证结果在验证请求的“Auth-SSL-Verify”标头中传递。 </p>
<p> optional参数请求客户端证书，并在证书存在时验证它。 </p>
<p> optional_no_ca参数请求客户端证书，但不要求它由可信CA证书签名。 这适用于nginx外部的服务执行实际证书验证的情况。 可以通过发送到身份验证服务器的请求访问证书的内容。 </p>
<p> Syntax:  <strong>ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  ssl_verify_depth 1;  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
<p> 设置客户端证书链中的验证深度。 </p>
<p> Syntax:  <strong>starttls</strong> on | off | only ;<br>  Default:  starttls off;  Context:  mail , server<br>  on   允许使用POP3的STLS命令和IMAP和SMTP的STARTTLS命令;  off   拒绝使用STLS和STARTTLS命令;  only   需要初步的TLS过渡。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_smtp_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_smtp_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_smtp_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-smtp-module"><a href="#Module-ngx-mail-smtp-module" class="headerlink" title="Module ngx_mail_smtp_module"></a>Module ngx_mail_smtp_module</h2><p> Directives<br> smtp_auth<br> smtp_capabilities<br> smtp_client_buffer<br> smtp_greeting_delay   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>smtp_auth</strong> <em>method</em> …;<br>  Default:  smtp_auth login plain;  Context:  mail , server<br>  为SMTP客户端设置允许的SASL身份验证方法。 支持的方法是： </p>
<p> login   AUTH LOGIN  plain   AUTH PLAIN  cram-md5   AUTH CRAM-MD5 。 为了使此方法有效，密码必须以未加密的方式存储。  external   AUTH EXTERNAL （1.11.6）。  none   不需要身份验证。  Syntax:  <strong>smtp_capabilities</strong> <em>extension</em> …;<br>  Default:  —  Context:  mail , server<br>  设置传递给客户端以响应EHLO命令的SMTP协议扩展列表。 smtp_auth指令和STARTTLS中指定的身份验证方法将根据starttls指令值自动添加到此列表中。 </p>
<p> 指定客户端所代理的MTA支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p> 目前的标准化扩展列表发布在www.iana.org 。 </p>
<p> Syntax:  <strong>smtp_client_buffer</strong> <em>size</em> ;<br>  Default:  smtp_client_buffer 4k|8k;  Context:  mail , server<br>  设置用于读取SMTP命令的缓冲区的<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>smtp_greeting_delay</strong> <em>time</em> ;<br>  Default:  smtp_greeting_delay 0;  Context:  mail , server<br>  允许在发送SMTP问候语之前设置延迟，以便在发送SMTP命令之前拒绝未能等待问候语的客户端。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_proxy_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_proxy_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-proxy-module"><a href="#Module-ngx-mail-proxy-module" class="headerlink" title="Module ngx_mail_proxy_module"></a>Module ngx_mail_proxy_module</h2><p> Directives<br> proxy_buffer<br> proxy_pass_error_message<br> proxy_timeout<br> xclient   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>proxy_buffer</strong> <em>size</em> ;<br>  Default:  proxy_buffer 4k|8k;  Context:  mail , server<br>  设置用于代理的缓冲区的大小。 默认情况下，缓冲区大小等于一个内存页面。 根据平台，它是4K或8K。 </p>
<p> Syntax:  <strong>proxy_pass_error_message</strong> on | off ;<br>  Default:  proxy_pass_error_message off;  Context:  mail , server<br>  指示是否将后端身份验证期间获取的错误消息传递给客户端。 </p>
<p> 通常，如果nginx中的身份验证成功，则后端无法返回错误。 如果它仍然返回错误，则表示发生了一些内部错误。 在这种情况下，后端消息可以包含不应向客户端显示的信息。 但是，对于某些POP3服务器，使用正确密码的错误进行响应是正常行为。 例如，CommuniGatePro通过定期输出身份验证错误通知用户邮箱溢出或其他事件。 在这种情况下应该启用该指令。 </p>
<p> Syntax:  <strong>proxy_timeout</strong> <em>timeout</em> ;<br>  Default:  proxy_timeout 24h;  Context:  mail , server<br>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<em>timeout</em> 。 如果在此时间内没有传输数据，则关闭连接。 </p>
<p> Syntax:  <strong>xclient</strong> on | off ;<br>  Default:  xclient on;  Context:  mail , server<br>  连接到SMTP后端时，启用或禁用带有客户端参数的XCLIENT命令的传递。 </p>
<p> 使用XCLIENT ，MTA能够将客户端信息写入日志，并根据此数据应用各种限制。 </p>
<p> 如果启用了XCLIENT ，则nginx在连接到后端时会传递以下命令： </p>
<ul>
<li>EHLO与服务器名称 </li>
<li><p>XCLIENT </p>
<ul>
<li>EHLO或HELO ，由客户通过<br>如果客户端IP地址找到的名称指向同一地址，则会在XCLIENT命令的NAME参数中传递该NAME 。 如果找不到名称，指向不同的地址，或未指定解析器 ，则在NAME参数中传递[UNAVAILABLE] 。 如果在解析过程中发生错误，则使用[TEMPUNAVAIL]值。 </li>
</ul>
<p>如果禁用了XCLIENT ，那么如果客户端已通过EHLO ，则nginx在连接到后端时传递带有服务器名称的EHLO命令，否则传递带有服务器名称的HELO 。 </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_pop3_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_pop3_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_pop3_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-pop3-module"><a href="#Module-ngx-mail-pop3-module" class="headerlink" title="Module ngx_mail_pop3_module"></a>Module ngx_mail_pop3_module</h2><p> Directives<br> pop3_auth<br> pop3_capabilities   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>pop3_auth</strong> <em>method</em> …;<br>  Default:  pop3_auth plain;  Context:  mail , server<br>  为POP3客户端设置允许的身份验证方法。 支持的方法是： </p>
<p> plain   USER / PASS ， AUTH PLAIN ， AUTH LOGIN 。 无法禁用这些方法。  apop   APOP 。 为了使此方法有效，密码必须以未加密的方式存储。  cram-md5   AUTH CRAM-MD5 。 为了使此方法有效，密码必须以未加密的方式存储。  external   AUTH EXTERNAL （1.11.6）。  Syntax:  <strong>pop3_capabilities</strong> <em>extension</em> …;<br>  Default:  pop3_capabilities TOP USER UIDL;  Context:  mail , server<br>  设置为响应CAPA命令而传递给客户端的POP3协议扩展列表。 pop3_auth指令（ SASL扩展名）和STLS中指定的身份验证方法将根据starttls指令值自动添加到此列表中。 </p>
<p> 指定客户端所代理的POP3后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p> 目前的标准化扩展列表发布在www.iana.org 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_imap_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_imap_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_imap_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-imap-module"><a href="#Module-ngx-mail-imap-module" class="headerlink" title="Module ngx_mail_imap_module"></a>Module ngx_mail_imap_module</h2><p> Directives<br> imap_auth<br> imap_capabilities<br> imap_client_buffer   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>imap_auth</strong> <em>method</em> …;<br>  Default:  imap_auth plain;  Context:  mail , server<br>  为IMAP客户端设置允许的身份验证方法。 支持的方法是： </p>
<p> login   AUTH = LOGIN  plain   AUTH =普通  cram-md5   AUTH = CRAM-MD5 。 为了使此方法有效，密码必须以未加密的方式存储。  external   AUTH = EXTERNAL （1.11.6）。  Syntax:  <strong>imap_capabilities</strong> <em>extension</em> …;<br>  Default:  imap_capabilities IMAP4 IMAP4rev1 UIDPLUS;  Context:  mail , server<br>  设置传递给客户端以响应CAPABILITY命令的IMAP协议扩展列表。 imap_auth指令和STARTTLS中指定的身份验证方法会根据starttls指令值自动添加到此列表中。 </p>
<p> 指定客户端所代理的IMAP后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p> 目前的标准化扩展列表发布在www.iana.org 。 </p>
<p> Syntax:  <strong>imap_client_buffer</strong> <em>size</em> ;<br>  Default:  imap_client_buffer 4k|8k;  Context:  mail , server<br>  设置用于读取IMAP命令的缓冲区的<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_core_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_core_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-core-module"><a href="#Module-ngx-mail-core-module" class="headerlink" title="Module ngx_mail_core_module"></a>Module ngx_mail_core_module</h2><p> Example Configuration<br> Directives<br> listen<br> mail<br> protocol<br> resolver<br> resolver_timeout<br> server<br> server_name<br> timeout<br> 默认情况下不构建此模块，应使用–with-mail配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>worker_processes 1; error_log /var/log/nginx/error.log info; events { worker_connections 1024; } mail { server_name mail.example.com; auth_http localhost:9000/cgi-bin/nginxauth.cgi; imap_capabilities IMAP4rev1 UIDPLUS IDLE LITERAL+ QUOTA; pop3_auth plain apop cram-md5; pop3_capabilities LAST TOP USER PIPELINING UIDL; smtp_auth login plain cram-md5; smtp_capabilities “SIZE 10485760” ENHANCEDSTATUSCODES 8BITMIME DSN; xclient off; server { listen 25; protocol smtp; } server { listen 110; protocol pop3; proxy_pass_error_message on; } server { listen 143; protocol imap; } server { listen 587; protocol smtp; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>listen</strong> <em>address</em> : <em>port</em> [ ssl ] [ backlog = <em>number</em> ] [ rcvbuf = <em>size</em> ] [ sndbuf = <em>size</em> ] [ bind ] [ ipv6only = on | off ] [ so_keepalive = on | off |[ <em>keepidle</em> ]:[ <em>keepintvl</em> ]:[ <em>keepcnt</em> ]];<br>  Default:  —  Context:  server<br>  设置服务器将接受请求的套接字的<em>address</em>和<em>port</em> 。 可以仅指定端口。 地址也可以是主机名，例如： </p>
<blockquote>
<p>listen 127.0.0.1:110; listen <em>:110; listen 110; # same as </em>:110 listen localhost:110;  IPv6地址（0.7.58）在方括号中指定： </p>
<p>listen [::1]:110; listen [::]:110;  UNIX域套接字（1.3.5）使用“ unix: ”前缀指定： </p>
<p>listen unix:/var/run/nginx.sock;  不同的服务器必须侦听不同的<em>address</em> ： <em>port</em>对。 </p>
</blockquote>
<p> ssl参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
<p> listen指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
<p> backlog = <em>number</em>  在listen()调用中设置backlog参数，该参数限制挂起连接队列的最大长度（1.9.2）。 默认情况下， backlog在FreeBSD，DragonFly BSD和macOS上设置为-1，在其他平台上设置为511。  rcvbuf = <em>size</em>  设置侦听套接字的接收缓冲区大小（ SO_RCVBUF选项）（1.11.13）。  sndbuf = <em>size</em>  设置侦听套接字的发送缓冲区大小（ SO_SNDBUF选项）（1.11.13）。  bind   此参数指示对给定地址：端口对进行单独的bind()调用。 事实是，如果有几个具有相同端口但不同地址的listen指令，并且其中一个listen指令侦听给定端口（ <em>: </em>port<em> ）的所有地址，则nginx将bind()仅限于</em>: <em>port</em> 。 应该注意的是，在这种情况下将进行getsockname()系统调用以确定接受连接的地址。 如果使用ipv6only或so_keepalive参数，那么对于给定的<em>address</em> ： <em>port</em>对将始终进行单独的bind()调用。  ipv6only = on | off  此参数确定（通过IPV6_V6ONLY套接字选项）侦听通配符地址[::]的IPv6套接字是仅接受IPv6连接还是仅接受IPv6和IPv4连接。 默认情况下，此参数处于启用状态。 它只能在开始时设置一次。  so_keepalive = on | off | [ <em>keepidle</em> ]：[ <em>keepintvl</em> ]：[ <em>keepcnt</em> ]  此参数配置侦听套接字的“TCP keepalive”行为。 如果省略此参数，则操作系统的设置将对套接字有效。 如果将其设置为值“ on ”，则为套接字打开SO_KEEPALIVE选项。 如果将其设置为值“ off ”，则为套接字关闭SO_KEEPALIVE选项。 某些操作系统支持使用TCP_KEEPIDLE ， TCP_KEEPINTVL和TCP_KEEPCNT套接字选项在每个套接字的基础上设置TCP keepalive参数。 在这样的系统上（目前，Linux 2.4 +，NetBSD 5+和FreeBSD 9.0-STABLE），可以使用<em>keepidle</em> ， <em>keepintvl</em>和<em>keepcnt</em>参数配置它们。 可以省略一个或两个参数，在这种情况下，相应套接字选项的系统默认设置将生效。 例如， </p>
<blockquote>
<p>so_keepalive=30m::10 将空闲超时（ TCP_KEEPIDLE ）设置为30分钟，将探测间隔（ TCP_KEEPINTVL ）保留为系统默认值，并将探测计数（ TCP_KEEPCNT ）设置为10个探测。  Syntax:  <strong>mail</strong> { … }<br>  Default:  —  Context:  main<br>  提供指定邮件服务器指令的配置文件上下文。 </p>
</blockquote>
<p> Syntax:  <strong>protocol</strong> imap | pop3 | smtp ;<br>  Default:  —  Context:  server<br>  设置代理服务器的协议。 支持的协议是IMAP ， POP3和SMTP 。 </p>
<p> 如果未设置该指令，则可以根据listen指令中指定的已知端口自动检测协议： </p>
<ul>
<li>imap ：143,993 </li>
<li>pop3 ：110,995 </li>
<li><p>smtp ：25,587,465<br>可以使用配置参数–without-mail_imap_module ， –without-mail_pop3_module和–without-mail_smtp_module禁用不必要的协议。 </p>
<p>Syntax:  <strong>resolver</strong> <em>address</em> … [ valid = <em>time</em> ];<br><strong>resolver</strong> off ;<br>Default:  resolver off;  Context:  mail , server<br>配置用于查找客户端主机名的名称服务器以将其传递给身份验证服务器 ，并在代理SMTP时配置XCLIENT命令。 例如： </p>
</li>
</ul>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353;  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。 如果未指定端口，则使用端口53。 以循环方式查询名称服务器。 </p>
<p> 在1.1.7版之前，只能配置一个名称服务器。 从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。  默认情况下，nginx使用响应的TTL值缓存答案。 可选的valid参数允许覆盖它： </p>
<p>resolver 127.0.0.1 [::1]:5353 valid=30s;<br> 在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。  特殊值off禁用解析。 </p>
</blockquote>
<p> Syntax:  <strong>resolver_timeout</strong> <em>time</em> ;<br>  Default:  resolver_timeout 30s;  Context:  mail , server<br>  设置DNS操作的超时，例如： </p>
<blockquote>
<p>resolver_timeout 5s;  Syntax:  <strong>server</strong> { … }<br>  Default:  —  Context:  mail<br>  设置服务器的配置。 </p>
</blockquote>
<p> Syntax:  <strong>server_name</strong> <em>name</em> ;<br>  Default:  server_name hostname;  Context:  mail , server<br>  设置使用的服务器名称： </p>
<ul>
<li>在初始POP3 / SMTP服务器问候语中; </li>
<li>在SASL CRAM-MD5认证期间的盐; </li>
<li><p>如果启用了XCLIENT命令的传递，则在连接到SMTP后端时在EHLO命令中。<br>如果未指定该指令，则使用计算机的主机名。 </p>
<p>Syntax:  <strong>timeout</strong> <em>time</em> ;<br>Default:  timeout 60s;  Context:  mail , server<br>设置代理到后端开始之前使用的超时。 </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_auth_http_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_auth_http_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_auth_http_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-auth-http-module"><a href="#Module-ngx-mail-auth-http-module" class="headerlink" title="Module ngx_mail_auth_http_module"></a>Module ngx_mail_auth_http_module</h2><p> Directives<br> auth_http<br> auth_http_header<br> auth_http_pass_client_cert<br> auth_http_timeout<br> Protocol   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>auth_http</strong> <em>URL</em> ;<br>  Default:  —  Context:  mail , server<br>  设置HTTP身份验证服务器的URL。 该协议如下所述 。 </p>
<p> Syntax:  <strong>auth_http_header</strong> <em>header</em> <em>value</em> ;<br>  Default:  —  Context:  mail , server<br>  将指定的标头附加到发送到身份验证服务器的请求。 此标头可用作共享密钥，以验证请求是否来自nginx。 例如： </p>
<blockquote>
<p>auth_http_header X-Auth-Key “secret_string”;  Syntax:  <strong>auth_http_pass_client_cert</strong> on | off ;<br>  Default:  auth_http_pass_client_cert off;  Context:  mail , server<br>  该指令出现在1.7.11版本中。 </p>
</blockquote>
<p> 将具有PEM格式（urlencoded）的客户端证书的“Auth-SSL-Cert”标头附加到发送到身份验证服务器的请求。 </p>
<p> Syntax:  <strong>auth_http_timeout</strong> <em>time</em> ;<br>  Default:  auth_http_timeout 60s;  Context:  mail , server<br>  设置与身份验证服务器通信的超时。 </p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p> HTTP协议用于与身份验证服务器通信。 响应正文中的数据将被忽略，信息仅在标题中传递。 </p>
<p> 请求和响应的示例： </p>
<p> 请求： </p>
<blockquote>
<p>GET /auth HTTP/1.0 Host: localhost Auth-Method: plain # plain/apop/cram-md5/external Auth-User: user Auth-Pass: password Auth-Protocol: imap # imap/pop3/smtp Auth-Login-Attempt: 1 Client-IP: 192.0.2.42 Client-Host: client.example.org  反应良好： </p>
<p>HTTP/1.0 200 OK Auth-Status: OK Auth-Server: 198.51.100.1 Auth-Port: 143  不好的回应： </p>
<p>HTTP/1.0 200 OK Auth-Status: Invalid login or password Auth-Wait: 3  如果没有“Auth-Wait”标头，将返回错误并关闭连接。 当前实现为每次身份验证尝试分配内存。 仅在会话结束时释放内存。 因此，必须限制单个会话中无效身份验证尝试的次数 - 服务器必须在10-20次尝试后响应而不使用“Auth-Wait”标头（尝试号码在“Auth-Login-Attempt”标头中传递） 。 </p>
</blockquote>
<p> 使用APOP或CRAM-MD5时，请求 - 响应将如下所示： </p>
<blockquote>
<p>GET /auth HTTP/1.0 Host: localhost Auth-Method: apop Auth-User: user Auth-Salt: <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#50;&#51;&#56;&#x31;&#56;&#x38;&#48;&#55;&#51;&#x2e;&#x31;&#49;&#x36;&#51;&#54;&#57;&#50;&#x30;&#x30;&#57;&#64;&#109;&#x61;&#x69;&#x6c;&#46;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#50;&#51;&#56;&#x31;&#56;&#x38;&#48;&#55;&#51;&#x2e;&#x31;&#49;&#x36;&#51;&#54;&#57;&#50;&#x30;&#x30;&#57;&#64;&#109;&#x61;&#x69;&#x6c;&#46;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a> Auth-Pass: auth_response Auth-Protocol: imap Auth-Login-Attempt: 1 Client-IP: 192.0.2.42 Client-Host: client.example.org  反应良好： </p>
<p>HTTP/1.0 200 OK Auth-Status: OK Auth-Server: 198.51.100.1 Auth-Port: 143 Auth-Pass: plain-text-pass  如果响应中存在“Auth-User”标头，它将覆盖用于通过后端进行身份验证的用户名。 </p>
</blockquote>
<p> 对于SMTP，响应还考虑了“Auth-Error-Code”标头 - 如果存在，则在发生错误时用作响应代码。 否则，535 5.7.0代码将添加到“Auth-Status”标头中。 </p>
<p> 例如，如果从身份验证服务器收到以下响应： </p>
<blockquote>
<p>HTTP/1.0 200 OK Auth-Status: Temporary server problem, try again later Auth-Error-Code: 451 4.3.0 Auth-Wait: 3  然后SMTP客户端将收到错误 </p>
<p>451 4.3.0 Temporary server problem, try again later  如果代理SMTP不需要身份验证，请求将如下所示： </p>
<p>GET /auth HTTP/1.0 Host: localhost Auth-Method: none Auth-User: Auth-Pass: Auth-Protocol: smtp Auth-Login-Attempt: 1 Client-IP: 192.0.2.42 Client-Host: client.example.org Auth-SMTP-Helo: client.example.org Auth-SMTP-From: MAIL FROM: &lt;&gt; Auth-SMTP-To: RCPT TO: <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#112;&#x6f;&#x73;&#116;&#109;&#97;&#x73;&#116;&#x65;&#114;&#x40;&#x6d;&#97;&#105;&#108;&#x2e;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;">&#112;&#x6f;&#x73;&#116;&#109;&#97;&#x73;&#116;&#x65;&#114;&#x40;&#x6d;&#97;&#105;&#108;&#x2e;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a>  对于SSL / TLS客户端连接（1.7.11），添加了“Auth-SSL”标头，“Auth-SSL-Verify”将包含客户端证书验证的结果（如果已启用） ：“ SUCCESS ”，“ FAILED:如果证书不存在，则“和” NONE “。 </p>
<p> 在1.11.7版之前，“ FAILED ”结果不包含<em>reason</em>字符串。  当客户端证书存在时，其详细信息将在以下请求标头中传递：“Auth-SSL-Subject”，“Auth-SSL-Issuer”，“Auth-SSL-Serial”和“Auth-SSL-Fingerprint”。 如果启用了auth_http_pass_client_cert ，则证书本身将在“Auth-SSL-Cert”标头中传递。 请求如下： </p>
<p>GET /auth HTTP/1.0 Host: localhost Auth-Method: plain Auth-User: user Auth-Pass: password Auth-Protocol: imap Auth-Login-Attempt: 1 Client-IP: 192.0.2.42 Auth-SSL: on Auth-SSL-Verify: SUCCESS Auth-SSL-Subject: /CN=example.com Auth-SSL-Issuer: /CN=example.com Auth-SSL-Serial: C07AD56B846B5BFF Auth-SSL-Fingerprint: 29d6a80a123d13355ed16b4b04605e29cb55a5ad  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/websocket-nginx中文手册]]></title>
      <url>/ngx/http/websocket.html</url>
      <content type="html"><![CDATA[<p>http,websocket<br><a id="more"></a></p>
<h2 id="WebSocket代理"><a href="#WebSocket代理" class="headerlink" title=" WebSocket代理"></a> WebSocket代理</h2><p> 要将客户端和服务器之间的连接从HTTP / 1.1转换为WebSocket，请使用HTTP / 1.1中提供的协议交换机制。 </p>
<p> 然而，有一个微妙之处：由于“升级”是逐跳标头，因此它不会从客户端传递到代理服务器。 使用正向代理，客户端可以使用CONNECT方法来规避此问题。 但是，这不适用于反向代理，因为客户端不知道任何代理服务器，并且需要在代理服务器上进行特殊处理。 </p>
<p> 从版本1.3.13开始，nginx实现了特殊的操作模式，如果代理服务器返回带有代码101（交换协议）的响应，则允许在客户端和代理服务器之间建立隧道，并且客户端要求通过请求中的“升级”标头。 </p>
<p> 如上所述，包括“升级”和“连接”的逐跳头不会从客户端传递到代理服务器，因此为了让代理服务器知道客户端将协议切换到WebSocket的意图，这些头必须明确传递： </p>
<blockquote>
<p>location /chat/ { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection “upgrade”; }  一个更复杂的示例，其中对代理服务器的请求中的“连接”头字段的值取决于客户端请求头中是否存在“升级”字段： </p>
<p>http { map $http_upgrade $connection_upgrade { default upgrade; ‘’ close; } server { … location /chat/ { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } }  默认情况下，如果代理服务器在60秒内未传输任何数据，则将关闭连接。 使用proxy_read_timeout指令可以增加此超时。 或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/server_names-nginx中文手册]]></title>
      <url>/ngx/http/server_names.html</url>
      <content type="html"><![CDATA[<p>http,server_names<br><a id="more"></a></p>
<h2 id="服务器名称"><a href="#服务器名称" class="headerlink" title=" 服务器名称"></a> 服务器名称</h2><p> Wildcard names<br> Regular expressions names<br> Miscellaneous names<br> Internationalized names<br> Optimization<br> Compatibility<br> 服务器名称使用server_name指令定义，并确定用于给定请求的服务器块。 另请参阅“ nginx如何处理请求 ”。 可以使用确切名称，通配符名称或正则表达式来定义它们： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org; … } server { listen 80; server_name <em>.example.org; … } server { listen 80; server_name mail.</em>; … } server { listen 80; server_name ~^(?<user>.+).example.net$; … }  按名称搜索虚拟服务器时，如果name匹配多个指定的变体，例如通配符名称和正则表达式匹配，则将按以下优先顺序选择第一个匹配的变体： </user></p>
</blockquote>
<ol>
<li>确切的名字 </li>
<li>最长的通配符名称以星号开头，例如“ *.example.org ” </li>
<li>最长的通配符名称以星号结尾，例如“ mail.* ” </li>
<li><p>第一个匹配正则表达式（按配置文件中的出现顺序） </p>
<h4 id="通配符名称"><a href="#通配符名称" class="headerlink" title="通配符名称"></a>通配符名称</h4><p>通配符名称可能仅在名称的开头或结尾包含星号，并且仅在点边框上包含星号。 名称“ www.<em>.example.org ”和“ w</em>.example.org ”无效。 但是，可以使用正则表达式指定这些名称，例如“ ~^www..+.example.org$ ”和“ ~^w.<em>.example.org$ ”。 星号可以匹配多个名称部分。 名称“ </em>.example.org ”不仅匹配www.example.org还匹配www.sub.example.org 。 </p>
<p>“ .example.org ”形式的特殊通配符名称可用于匹配确切名称“ example.org ”和通配符名称“ *.example.org ”。 </p>
</li>
</ol>
<h4 id="正则表达式名称"><a href="#正则表达式名称" class="headerlink" title="正则表达式名称"></a>正则表达式名称</h4><p> nginx使用的正则表达式与Perl编程语言（PCRE）使用的正则表达式兼容。 要使用正则表达式，服务器名称必须以波浪号开头： </p>
<blockquote>
<p>server_name ~^www\d+.example.net$;  否则它将被视为一个确切的名称，或者如果表达式包含星号，则视为通配符名称（并且很可能是无效的名称）。 不要忘记设置“ ^ ”和“ $ ”锚点。 它们在语法上不是必需的，但在逻辑上是必需的。 另请注意，域名点应使用反斜杠进行转义。 应引用包含字符“ { ”和“ } ”的正则表达式： </p>
<p>server_name “~^(?<name>\w\d <strong>{</strong> 1,3 <strong>}</strong> +).example.net$”;  否则nginx将无法启动并显示错误消息： </name></p>
<p>directive “server_name” is not terminated by “;” in …  命名的正则表达式捕获稍后可以用作变量： </p>
<p>server { server_name ~^(www.)?( <strong>?<domain></domain></strong> .+)$; location / { root /sites/ <strong>$domain</strong> ; } }  PCRE库使用以下语法支持命名捕获： </p>
<p> ?&lt; <em>name</em> &gt; Perl 5.10 compatible syntax, supported since PCRE-7.0 ?’ <em>name</em> ‘ Perl 5.10 compatible syntax, supported since PCRE-7.0 ?P&lt; <em>name</em> &gt; Python compatible syntax, supported since PCRE-4.0 如果nginx无法启动并显示错误消息：<br>pcre_compile() failed: unrecognized character after (?&lt; in …  这意味着PCRE库已经过时了，应该尝试使用语法“ ?P&lt; <em>name</em> &gt; ”。 捕获也可以以数字形式使用： </p>
<p>server { server_name ~^(www.)?(.+)$; location / { root /sites/ <strong>$2</strong> ; } }  但是，这种用法应限于简单的情况（如上所述），因为数字参考可以很容易地被覆盖。 </p>
</blockquote>
<h4 id="杂项名称"><a href="#杂项名称" class="headerlink" title="杂项名称"></a>杂项名称</h4><p> 有一些服务器名称是专门处理的。 </p>
<p> 如果需要处理没有默认服务器块中“Host”头字段的请求 ，则应指定一个空名称： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org “”; … }  如果服务器块中未定义server_name ，则nginx使用空名称作为服务器名称。 </p>
<p> 在这种情况下，最高为0.8.48的nginx版本使用机器的主机名作为服务器名称。  如果服务器名称定义为“ $hostname ”（0.9.4），则使用计算机的主机名。 </p>
</blockquote>
<p> 如果有人使用IP地址而不是服务器名称发出请求，则“主机”请求标头字段将包含IP地址，并且可以使用IP地址作为服务器名称来处理请求： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org “” <strong>192.168.1.1</strong> ; … }  在catch-all服务器示例中，可以看到奇怪的名称“ _ ”： </p>
<p>server { listen 80 default_server; server_name _; return 444; }  这个名称没有什么特别之处，它只是无数域名之一，永远不会与任何真实姓名相交。 也可以使用诸如“ – ”和“ !@# ”之类的其他无效名称。 </p>
</blockquote>
<p> nginx版本高达0.6.25支持特殊名称“ <em> ”，它被错误地解释为一个包罗万象的名称。 它从不作为全能或通配符服务器名称运行。 相反，它提供了server_name_in_redirect指令现在提供的功能。 现在不推荐使用特殊名称“ </em> ”，并且应使用server_name_in_redirect指令。 请注意，无法使用server_name指令指定catch-all名称或缺省服务器。 这是listen指令的属性，而不是server_name指令的属性。 另请参阅“ nginx如何处理请求 ”。 可以定义侦听端口<em>：80和</em>：8080的服务器，并指示一个端口将是端口<em>的默认服务器：8080，而另一个将是端口</em>的默认值：80： </p>
<blockquote>
<p>server { listen 80; listen 8080 default_server; server_name example.net; … } server { listen 80 default_server; listen 8080; server_name example.org; … } ####  国际化名称</p>
</blockquote>
<p> 应使用server_name指令中的ASCII（Punycode）表示来指定国际化域名（ IDN ）： </p>
<blockquote>
<p>server { listen 80; server_name xn–e1afmkfd.xn–80akhbyknj4f; # пример.испытание … } ####  优化</p>
</blockquote>
<p> 确切名称，以星号开头的通配符名称以及以星号结尾的通配符名称存储在绑定到侦听端口的三个哈希表中。 散列表的大小在配置阶段进行了优化，因此可以找到最少CPU缓存未命中的名称。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> 首先搜索确切的名称哈希表。 如果未找到名称，则搜索带有以星号开头的通配符名称的哈希表。 如果在那里找不到名称，则搜索带有以星号结尾的通配符名称的哈希表。 </p>
<p> 搜索通配符名称哈希表比搜索确切名称哈希表要慢，因为域名部分会搜索名称。 请注意，特殊通配符形式“ .example.org ”存储在通配符名称哈希表中，而不是存储在精确名称哈希表中。 </p>
<p> 正则表达式是按顺序测试的，因此是最慢的方法，并且是不可伸缩的。 </p>
<p> 出于这些原因，最好在可能的情况下使用确切的名称。 例如，如果服务器的最常请求名称是example.org和www.example.org ，则明确定义它们会更有效： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org *.example.org; … }  而不是使用简化形式： </p>
<p>server { listen 80; server_name .example.org; … }  如果定义了大量服务器名称，或者定义了异常长的服务器名称，则可能需要在<em>http</em>级别调整server_names_hash_max_size和server_names_hash_bucket_size指令。 server_names_hash_bucket_size指令的默认值可能等于32或64，或其他值，具体取决于CPU缓存行大小。 如果默认值为32且服务器名称定义为“ too.long.server.name.example.org ”，则nginx将无法启动并显示错误消息： </p>
<p>could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32  在这种情况下，指令值应该增加到下一个2的幂： </p>
<p>http { server_names_hash_bucket_size 64; …  如果定义了大量服务器名称，则会显示另一条错误消息： </p>
<p>could not build the server_names_hash, you should increase either server_names_hash_max_size: 512 or server_names_hash_bucket_size: 32  在这种情况下，首先尝试将server_names_hash_max_size设置为接近服务器名称数的数字。 只有当这没有帮助时，或者如果nginx的开始时间长得令人无法接受，请尝试增加server_names_hash_bucket_size 。 </p>
</blockquote>
<p> 如果服务器是监听端口的唯一服务器，则nginx根本不会测试服务器名称（并且不会为监听端口构建哈希表）。 但是，有一个例外。 如果服务器名称是带捕获的正则表达式，则nginx必须执行表达式才能获取捕获。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>自0.9.4以来一直支持特殊服务器名称“ $hostname ”。 </li>
<li>默认服务器名称值是自0.8.48以来的空名称“”。 </li>
<li>自0.8.25起，支持命名正则表达式服务器名称捕获。 </li>
<li>自0.7.40起支持正则表达式服务器名称捕获。 </li>
<li>自0.7.12起，支持空服务器名称“”。 </li>
<li>支持使用通配符服务器名称或正则表达式作为自0.6.25以来的第一个服务器名称。 </li>
<li>自0.6.7起支持正则表达式服务器名称。 </li>
<li>自0.6.0以来一直支持通配符表单example.* 。 </li>
<li>从0.3.18开始支持特殊格式.example.org 。 </li>
<li>自0.1.13起支持通配符*.example.org 。<br>written by Igor Sysoev<br>edited by Brian Mercer  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/request_processing-nginx中文手册]]></title>
      <url>/ngx/http/request_processing.html</url>
      <content type="html"><![CDATA[<p>http,request_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理请求"><a href="#nginx如何处理请求" class="headerlink" title=" nginx如何处理请求"></a> nginx如何处理请求</h2><p> How to prevent processing requests with undefined server names<br> Mixed name-based and IP-based virtual servers<br> A simple PHP site configuration   </p>
<h4 id="基于名称的虚拟服务器"><a href="#基于名称的虚拟服务器" class="headerlink" title="基于名称的虚拟服务器"></a>基于名称的虚拟服务器</h4><p> nginx首先决定哪个<em>服务器</em>应该处理请求。 让我们从一个简单的配置开始，其中所有三个虚拟服务器都在端口*：80上侦听： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org; … } server { listen 80; server_name example.net www.example.net; … } server { listen 80; server_name example.com www.example.com; … }  在此配置中，nginx仅测试请求的标头字段“Host”，以确定请求应路由到哪个服务器。 如果其值与任何服务器名称都不匹配，或者请求根本不包含此标头字段，则nginx会将请求路由到此端口的默认服务器。 在上面的配置中，默认服务器是第一个 - 这是nginx的标准默认行为。 也可以使用listen指令中的default_server参数明确设置哪个服务器应该是默认的： </p>
<p>server { listen 80 <strong>default_server</strong> ; server_name example.net www.example.net; … }<br> default_server参数自版本0.8.21起可用。 在早期版本中，应使用default参数。  请注意，默认服务器是侦听端口的属性，而不是服务器名称的属性。 稍后会详细介绍。 </p>
</blockquote>
<h4 id="如何使用未定义的服务器名称防止处理请求"><a href="#如何使用未定义的服务器名称防止处理请求" class="headerlink" title="如何使用未定义的服务器名称防止处理请求"></a>如何使用未定义的服务器名称防止处理请求</h4><p> 如果不允许没有“Host”头字段的请求，则可以定义只删除请求的服务器： </p>
<blockquote>
<p>server { listen 80; server_name “”; return 444; }  这里，服务器名称设置为一个空字符串，它将匹配没有“Host”头字段的请求，并返回一个特殊的nginx非标准代码444来关闭连接。 </p>
<p> 从版本0.8.48开始，这是服务器名称的默认设置，因此可以省略server_name “” 。 在早期版本中，计算机的<em>主机名</em>用作默认服务器名称。 ####  基于名称的混合和基于IP的虚拟服务器</p>
</blockquote>
<p> 让我们看一个更复杂的配置，其中一些虚拟服务器监听不同的地址： </p>
<blockquote>
<p>server { listen 192.168.1.1:80; server_name example.org www.example.org; … } server { listen 192.168.1.1:80; server_name example.net www.example.net; … } server { listen 192.168.1.2:80; server_name example.com www.example.com; … }  在此配置中，nginx首先根据服务器块的listen指令测试请求的IP地址和端口。 然后，它针对与IP地址和端口匹配的服务器块的server_name条目测试请求的“Host”头字段。 如果未找到服务器名称，则默认服务器将处理该请求。 例如，在192.168.1.1:80端口上收到的www.example.com请求将由192.168.1.1:80端口的默认服务器处理，即由第一台服务器处理，因为没有www.example.com为此端口定义。 </p>
</blockquote>
<p> 如前所述，默认服务器是监听端口的属性，可以为不同的端口定义不同的默认服务器： </p>
<blockquote>
<p>server { listen 192.168.1.1:80; server_name example.org www.example.org; … } server { listen 192.168.1.1:80 <strong>default_server</strong> ; server_name example.net www.example.net; … } server { listen 192.168.1.2:80 <strong>default_server</strong> ; server_name example.com www.example.com; … } ####  一个简单的PHP站点配置</p>
</blockquote>
<p> 现在让我们看看nginx如何选择一个<em>位置</em>来处理一个典型的简单PHP站点的请求： </p>
<blockquote>
<p>server { listen 80; server_name example.org www.example.org; root /data/www; location / { index index.html index.php; } location ~* .(gif|jpg|png)$ { expires 30d; } location ~ .php$ { fastcgi_pass localhost:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } }  nginx首先搜索由文字字符串给出的最具体的前缀位置，而不管列出的顺序如何。 在上面的配置中，唯一的前缀位置是“ / ”，因为它匹配任何请求，它将被用作最后的手段。 然后nginx按照配置文件中列出的顺序检查正则表达式给出的位置。 第一个匹配表达式将停止搜索，nginx将使用此位置。 如果没有正则表达式与请求匹配，则nginx使用先前找到的最具体的前缀位置。 </p>
</blockquote>
<p> 请注意，所有类型的位置仅测试不带参数的请求行的URI部分。 这样做是因为查询字符串中的参数可以通过多种方式给出，例如： </p>
<blockquote>
<p>/index.php?user=john&amp;page=1 /index.php?page=1&amp;user=john  此外，任何人都可以在查询字符串中请求任何内容 </p>
<p>/index.php?page=1&amp;something+else&amp;user=john  现在让我们看看如何在上面的配置中处理请求： </p>
</blockquote>
<ul>
<li>请求“ /logo.gif ”首先与前缀位置“ / ”匹配，然后由正则表达式“ .(gif|jpg|png)$ ”匹配，因此，它由后一个位置处理。 使用指令“ root /data/www ”将请求映射到文件/data/www/logo.gif ，并将文件发送到客户端。 </li>
<li>请求“ /index.php ”也首先与前缀位置“ / ”匹配，然后由正则表达式“ .(php)$ ”匹配。 因此，它由后一个位置处理，请求被传递给侦听localhost：9000的FastCGI服务器。 fastcgi_param指令将FastCGI参数SCRIPT_FILENAME为“ /data/www/index.php服务器执行该文件。 变量$document_root等于root指令的值，变量$fastcgi_script_name等于请求URI，即“ /index.php ”。 </li>
<li>请求“ /about.html ”仅与前缀位置“ / ”匹配，因此，它在此位置处理。 使用指令“ root /data/www ”将请求映射到文件/data/www/about.html ，并将文件发送到客户端。 </li>
<li>处理请求“ / ”更复杂。 它仅与前缀位置“ / ”匹配，因此，它由此位置处理。 然后索引指令根据其参数和“ root /data/www ”指令测试索引文件是否存在。 如果文件/data/www/index.html不存在，并且文件/data/www/index.php存在，则该指令执行内部重定向到“ /index.php ”，并且nginx再次搜索位置如果请求是由客户发送的。 正如我们之前看到的，重定向的请求最终将由FastCGI服务器处理。<br>written by Igor Sysoev<br>edited by Brian Mercer  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_xslt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_xslt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_xslt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-xslt-module"><a href="#Module-ngx-http-xslt-module" class="headerlink" title="Module ngx_http_xslt_module"></a>Module ngx_http_xslt_module</h2><p> Example Configuration<br> Directives<br> xml_entities<br> xslt_last_modified<br> xslt_param<br> xslt_string_param<br> xslt_stylesheet<br> xslt_types<br> ngx_http_xslt_module （0.7.8+）是一个使用一个或多个XSLT样式表转换XML响应的过滤器。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_xslt_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要libxml2和libxslt库。 ####  示例配置</p>
<p>location / { xml_entities /site/dtd/entities.dtd; xslt_stylesheet /site/xslt/one.xslt param=value; xslt_stylesheet /site/xslt/two.xslt; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>xml_entities</strong> <em>path</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定声明字符实体的DTD文件。 此文件在配置阶段编译。 由于技术原因，模块无法使用已处理XML中声明的外部子集，因此将忽略该模块并使用特殊定义的文件。 此文件不应描述XML结构。 仅声明所需的字符实体就足够了，例如： </p>
<blockquote>
<p>&lt;!ENTITY nbsp “&#xa0;”&gt;  Syntax:  <strong>xslt_last_modified</strong> on | off ;<br>  Default:  xslt_last_modified off;  Context:  http , server , location<br>  该指令出现在1.5.1版本中。 </p>
</blockquote>
<p> 允许在XSLT转换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p> 默认情况下，在转换期间修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p> Syntax:  <strong>xslt_param</strong> <em>parameter</em> <em>value</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.1.18版中。 </p>
<p> 定义XSLT样式表的参数。 该<em>value</em>被视为XPath表达式。 该<em>value</em>可以包含变量。 要将字符串值传递给样式表，可以使用xslt_string_param指令。 </p>
<p> 可能有几个xslt_param指令。 当且仅当在当前级别上没有定义xslt_param和xslt_string_param指令时，这些指令才从前一级继承。 </p>
<p> Syntax:  <strong>xslt_string_param</strong> <em>parameter</em> <em>value</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.1.18版中。 </p>
<p> 定义XSLT样式表的字符串参数。 不解释<em>value</em>中的XPath表达式。 该<em>value</em>可以包含变量。 </p>
<p> 可能有几个xslt_string_param指令。 当且仅当在当前级别上没有定义xslt_param和xslt_string_param指令时，这些指令才从前一级继承。 </p>
<p> Syntax:  <strong>xslt_stylesheet</strong> <em>stylesheet</em> [ <em>parameter</em> = <em>value</em> …];<br>  Default:  —  Context:  location<br>  定义XSLT样式表及其可选参数。 样式表在配置阶段编译。 </p>
<p> 参数既可以单独指定，也可以使用“ : ”分隔符分组在一行中。 如果参数包含“ : ”字符，则应将其转义为“ %3A ”。 此外， libxslt要求将包含非字母数字字符的参数括在单引号或双引号中，例如： </p>
<blockquote>
<p>param1=’http%3A//www.example.com’:param2=value2  参数描述可以包含变量，例如，整行参数可以从单个变量中获取： </p>
<p>location / { xslt_stylesheet /site/xslt/one.xslt $arg_xslt_params param1=’$value1’:param2=value2 param3=value3; }  可以指定多个样式表。 它们将按指定的顺序依次应用。 </p>
</blockquote>
<p> Syntax:  <strong>xslt_types</strong> <em>mime-type</em> …;<br>  Default:  xslt_types text/xml;  Context:  http , server , location<br>  除了“ text/xml ”之外，还启用具有指定MIME类型的响应中的转换。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 如果转换结果是HTML响应，则其MIME类型将更改为“ text/html ”。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_v2_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_v2_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_v2_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-v2-module"><a href="#Module-ngx-http-v2-module" class="headerlink" title="Module ngx_http_v2_module"></a>Module ngx_http_v2_module</h2><p> Known Issues<br> Example Configuration<br> Directives<br> http2_body_preread_size<br> http2_chunk_size<br> http2_idle_timeout<br> http2_max_concurrent_pushes<br> http2_max_concurrent_streams<br> http2_max_field_size<br> http2_max_header_size<br> http2_max_requests<br> http2_push<br> http2_push_preload<br> http2_recv_buffer_size<br> http2_recv_timeout<br> Embedded Variables<br> ngx_http_v2_module模块（1.9.5）提供对HTTP / 2的支持并取代ngx_http_spdy_module模块。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_v2_module配置参数启用它。 </p>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p> 在版本1.9.14之前，无论proxy_request_buffering ， fastcgi_request_buffering ， uwsgi_request_buffering和scgi_request_buffering指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { listen 443 ssl http2; ssl_certificate server.crt; ssl_certificate_key server.key; }  请注意，通过TLS接受HTTP / 2连接需要“应用程序层协议协商”（ALPN）TLS扩展支持，该支持仅在OpenSSL版本1.0.2之后可用。 为此目的使用“下一协议协商”（NPN）TLS扩展（自OpenSSL版本1.0.1起可用）不能保证有效。 </p>
</blockquote>
<p> 另请注意，如果ssl_prefer_server_ciphers指令设置为值“ on ”，则应将密码配置为符合RFC 7540，附录A黑名单并由客户端支持。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>http2_body_preread_size</strong> <em>size</em> ;<br>  Default:  http2_body_preread_size 64k;  Context:  http , server<br>  该指令出现在1.11.0版本中。 </p>
<p> 设置在开始处理请求主体之前可以保存请求主体的每个请求的缓冲区<em>size</em> 。 </p>
<p> Syntax:  <strong>http2_chunk_size</strong> <em>size</em> ;<br>  Default:  http2_chunk_size 8k;  Context:  http , server , location<br>  设置响应主体被切片到的块的最大大小。 值太低会导致更高的开销。 由于HOL阻塞，太高的值会损害优先级。 </p>
<p> Syntax:  <strong>http2_idle_timeout</strong> <em>time</em> ;<br>  Default:  http2_idle_timeout 3m;  Context:  http , server<br>  设置关闭连接之前的不活动超时。 </p>
<p> Syntax:  <strong>http2_max_concurrent_pushes</strong> <em>number</em> ;<br>  Default:  http2_max_concurrent_pushes 10;  Context:  http , server<br>  该指令出现在1.13.9版中。 </p>
<p> 限制连接中的最大并发推送请求数。 </p>
<p> Syntax:  <strong>http2_max_concurrent_streams</strong> <em>number</em> ;<br>  Default:  http2_max_concurrent_streams 128;  Context:  http , server<br>  设置连接中的最大并发HTTP / 2流数。 </p>
<p> Syntax:  <strong>http2_max_field_size</strong> <em>size</em> ;<br>  Default:  http2_max_field_size 4k;  Context:  http , server<br>  限制HPACK压缩请求标头字段的最大大小。 该限制同样适用于名称和价值。 请注意，如果应用了霍夫曼编码，则解压缩的名称和值字符串的实际大小可能会更大。 对于大多数请求，默认限制应该足够。 </p>
<p> Syntax:  <strong>http2_max_header_size</strong> <em>size</em> ;<br>  Default:  http2_max_header_size 16k;  Context:  http , server<br>  在HPACK解压缩后限制整个请求标头列表的最大大小。 对于大多数请求，默认限制应该足够。 </p>
<p> Syntax:  <strong>http2_max_requests</strong> <em>number</em> ;<br>  Default:  http2_max_requests 1000;  Context:  http , server<br>  该指令出现在1.11.6版中。 </p>
<p> 设置可通过一个HTTP / 2连接提供的最大请求数（包括推送请求），之后下一个客户端请求将导致连接关闭以及建立新连接的需要。 </p>
<p> Syntax:  <strong>http2_push</strong> <em>uri</em> | off ;<br>  Default:  http2_push off;  Context:  http , server , location<br>  该指令出现在1.13.9版中。 </p>
<p> 先发制人地将请求发送（ 推送 ）到指定的<em>uri</em>以及对原始请求的响应。 仅处理具有绝对路径的相对URI，例如： </p>
<blockquote>
<p>http2_push /static/css/main.css;  <em>uri</em>值可以包含变量。 </p>
</blockquote>
<p> 可以在同一配置级别指定多个http2_push指令。 off参数取消了从先前配置级别继承的http2_push指令的效果。 </p>
<p> Syntax:  <strong>http2_push_preload</strong> on | off ;<br>  Default:  http2_push_preload off;  Context:  http , server , location<br>  该指令出现在1.13.9版中。 </p>
<p> 允许将“链接”响应头字段中指定的预加载链接自动转换为推送请求。 </p>
<p> Syntax:  <strong>http2_recv_buffer_size</strong> <em>size</em> ;<br>  Default:  http2_recv_buffer_size 256k;  Context:  http<br>  设置每个工作者输入缓冲区的大小。 </p>
<p> Syntax:  <strong>http2_recv_timeout</strong> <em>time</em> ;<br>  Default:  http2_recv_timeout 30s;  Context:  http , server<br>  设置从客户端获取更多数据的超时，然后关闭连接。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_v2_module模块支持以下嵌入变量： </p>
<p> $http2   协商协议标识符：“ h2 ”表示HTTP / 2通过TLS，“ h2c ”表示HTTP / 2通过明文TCP，否则为空字符串。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_uwsgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_uwsgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_uwsgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-uwsgi-module"><a href="#Module-ngx-http-uwsgi-module" class="headerlink" title="Module ngx_http_uwsgi_module"></a>Module ngx_http_uwsgi_module</h2><p> Example Configuration<br> Directives<br> uwsgi_bind<br> uwsgi_buffer_size<br> uwsgi_buffering<br> uwsgi_buffers<br> uwsgi_busy_buffers_size<br> uwsgi_cache<br> uwsgi_cache_background_update<br> uwsgi_cache_bypass<br> uwsgi_cache_key<br> uwsgi_cache_lock<br> uwsgi_cache_lock_age<br> uwsgi_cache_lock_timeout<br> uwsgi_cache_max_range_offset<br> uwsgi_cache_methods<br> uwsgi_cache_min_uses<br> uwsgi_cache_path<br> uwsgi_cache_purge<br> uwsgi_cache_revalidate<br> uwsgi_cache_use_stale<br> uwsgi_cache_valid<br> uwsgi_connect_timeout<br> uwsgi_force_ranges<br> uwsgi_hide_header<br> uwsgi_ignore_client_abort<br> uwsgi_ignore_headers<br> uwsgi_intercept_errors<br> uwsgi_limit_rate<br> uwsgi_max_temp_file_size<br> uwsgi_modifier1<br> uwsgi_modifier2<br> uwsgi_next_upstream<br> uwsgi_next_upstream_timeout<br> uwsgi_next_upstream_tries<br> uwsgi_no_cache<br> uwsgi_param<br> uwsgi_pass<br> uwsgi_pass_header<br> uwsgi_pass_request_body<br> uwsgi_pass_request_headers<br> uwsgi_read_timeout<br> uwsgi_request_buffering<br> uwsgi_send_timeout<br> uwsgi_socket_keepalive<br> uwsgi_ssl_certificate<br> uwsgi_ssl_certificate_key<br> uwsgi_ssl_ciphers<br> uwsgi_ssl_crl<br> uwsgi_ssl_name<br> uwsgi_ssl_password_file<br> uwsgi_ssl_protocols<br> uwsgi_ssl_server_name<br> uwsgi_ssl_session_reuse<br> uwsgi_ssl_trusted_certificate<br> uwsgi_ssl_verify<br> uwsgi_ssl_verify_depth<br> uwsgi_store<br> uwsgi_store_access<br> uwsgi_temp_file_write_size<br> uwsgi_temp_path<br> ngx_http_uwsgi_module模块允许将请求传递给uwsgi服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { include uwsgi_params; uwsgi_pass localhost:9000; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>uwsgi_bind</strong> <em>address</em> [ transparent ] | off ;<br>  Default:  —  Context:  http , server , location<br>  使用可选端口（1.11.2）从指定的本地IP地址发出到uwsgi服务器的传出连接。 参数值可以包含变量（1.3.12）。 特殊值off （1.3.12）取消了从先前配置级别继承的uwsgi_bind指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数（1.11.0）允许到uwsgi服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>uwsgi_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还需要配置内核路由表以拦截来自uwsgi服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_buffer_size</strong> <em>size</em> ;<br>  Default:  uwsgi_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从uwsgi服务器接收的响应的第一部分的缓冲区的<em>size</em> 。 这部分通常包含一个小的响应头。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 然而，它可以做得更小。 </p>
<p> Syntax:  <strong>uwsgi_buffering</strong> on | off ;<br>  Default:  uwsgi_buffering on;  Context:  http , server , location<br>  启用或禁用缓冲来自uwsgi服务器的响应。 </p>
<p> 启用缓冲后，nginx会尽快从uwsgi服务器接收响应，并将其保存到uwsgi_buffer_size和uwsgi_buffers指令设置的缓冲区中。 如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的临时文件中 。 写入临时文件由uwsgi_max_temp_file_size和uwsgi_temp_file_write_size指令控制。 </p>
<p> 禁用缓冲时，响应会在收到响应时立即同步传递给客户端。 nginx不会尝试从uwsgi服务器读取整个响应。 nginx一次可以从服务器接收的数据的最大大小由uwsgi_buffer_size指令设置。 </p>
<p> 也可以通过在“X-Accel-Buffering”响应头字段中传递“ yes ”或“ no ”来启用或禁用缓冲。 可以使用uwsgi_ignore_headers指令禁用此功能。 </p>
<p> Syntax:  <strong>uwsgi_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  uwsgi_buffers 8 4k|8k;  Context:  http , server , location<br>  设置用于从uwsgi服务器读取响应的缓冲区的<em>number</em>和<em>size</em> ，用于单个连接。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>uwsgi_busy_buffers_size</strong> <em>size</em> ;<br>  Default:  uwsgi_busy_buffers_size 8k|16k;  Context:  http , server , location<br>  当启用缓冲来自uwsgi服务器的响应时，限制可能忙于向客户端发送响应的缓冲区的总<em>size</em> ，而响应尚未完全读取。 同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。 默认情况下， <em>size</em>受uwsgi_buffer_size和uwsgi_buffers指令设置的两个缓冲区<em>size</em>的限制。 </p>
<p> Syntax:  <strong>uwsgi_cache</strong> <em>zone</em> | off ;<br>  Default:  uwsgi_cache off;  Context:  http , server , location<br>  定义用于缓存的共享内存区域。 可以在多个地方使用相同的区域。 参数值可以包含变量（1.7.9）。 off参数禁用从先前配置级别继承的高速缓存。 </p>
<p> Syntax:  <strong>uwsgi_cache_background_update</strong> on | off ;<br>  Default:  uwsgi_cache_background_update off;  Context:  http , server , location<br>  该指令出现在1.11.10版中。 </p>
<p> 允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。 请注意，在更新时必须允许使用陈旧的缓存响应。 </p>
<p> Syntax:  <strong>uwsgi_cache_bypass</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不从缓存中获取响应的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<blockquote>
<p>uwsgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment; uwsgi_cache_bypass $http_pragma $http_authorization;  可以与uwsgi_no_cache指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_cache_key</strong> <em>string</em> ;<br>  Default:  —  Context:  http , server , location<br>  例如，定义缓存的键 </p>
<blockquote>
<p>uwsgi_cache_key localhost:9000$request_uri;  Syntax:  <strong>uwsgi_cache_lock</strong> on | off ;<br>  Default:  uwsgi_cache_lock off;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
</blockquote>
<p> 启用后，通过将请求传递给uwsgi服务器，一次只允许一个请求填充根据uwsgi_cache_key指令标识的新缓存元素。 同一缓存元素的其他请求将等待响应出现在缓存中或缓存此元素的缓存锁定，直到uwsgi_cache_lock_timeout指令设置的时间。 </p>
<p> Syntax:  <strong>uwsgi_cache_lock_age</strong> <em>time</em> ;<br>  Default:  uwsgi_cache_lock_age 5s;  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 如果传递给uwsgi服务器以填充新缓存元素的最后一个请求在指定<em>time</em>内没有完成，则可以将另一个请求传递给uwsgi服务器。 </p>
<p> Syntax:  <strong>uwsgi_cache_lock_timeout</strong> <em>time</em> ;<br>  Default:  uwsgi_cache_lock_timeout 5s;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
<p> 设置uwsgi_cache_lock的超时。 当<em>time</em>到期时，请求将被传递给uwsgi服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p> 在1.7.8之前，可以缓存响应。  Syntax:  <strong>uwsgi_cache_max_range_offset</strong> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.11.6版中。 </p>
</blockquote>
<p> 设置字节范围请求的偏移量（以字节为单位）。 如果范围超出偏移量，则范围请求将传递给uwsgi服务器，并且不会缓存响应。 </p>
<p> Syntax:  <strong>uwsgi_cache_methods</strong> GET | HEAD | POST …;<br>  Default:  uwsgi_cache_methods GET HEAD;  Context:  http , server , location<br>  如果此指令中列出了客户端请求方法，则将缓存响应。 “ GET ”和“ HEAD ”方法总是添加到列表中，但建议明确指定它们。 另请参见uwsgi_no_cache指令。 </p>
<p> Syntax:  <strong>uwsgi_cache_min_uses</strong> <em>number</em> ;<br>  Default:  uwsgi_cache_min_uses 1;  Context:  http , server , location<br>  设置将缓存响应的请求<em>number</em> 。 </p>
<p> Syntax:  <strong>uwsgi_cache_path</strong> <em>path</em> [ levels = <em>levels</em> ] [ use_temp_path = on | off ] keys_zone = <em>name</em> : <em>size</em> [ inactive = <em>time</em> ] [ max_size = <em>size</em> ] [ manager_files = <em>number</em> ] [ manager_sleep = <em>time</em> ] [ manager_threshold = <em>time</em> ] [ loader_files = <em>number</em> ] [ loader_sleep = <em>time</em> ] [ loader_threshold = <em>time</em> ] [ purger = on | off ] [ purger_files = <em>number</em> ] [ purger_sleep = <em>time</em> ] [ purger_threshold = <em>time</em> ];<br>  Default:  —  Context:  http<br>  设置缓存的路径和其他参数。 缓存数据存储在文件中。 缓存中的文件名是将MD5功能应用于缓存键的结果 。 levels参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<blockquote>
<p>uwsgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;  缓存中的文件名如下所示： </p>
<p>/data/nginx/cache/ <strong>c</strong> / <strong>29</strong> /b7f54b2df7773722d382f4809d650 <strong>29c</strong>  首先将缓存的响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。 根据use_temp_path参数（1.7.10）设置临时文件的目录。 如果省略此参数或将其设置为on ，则将使用uwsgi_temp_path指令为给定位置设置的目录。 如果该值设置为off ，则临时文件将直接放入缓存目录中。 </p>
</blockquote>
<p> 此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<em>name</em>和<em>size</em>由keys_zone参数配置。 一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p> 作为商业订阅的一部分，共享存储器区域还存储扩展的高速缓存信息 ，因此，需要为相同数量的密钥指定更大的区域大小。 例如，一兆字节区域可以存储大约4000个密钥。  在inactive参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。 默认情况下， inactive设置为10分钟。 </p>
</blockquote>
<p> 特殊的“缓存管理器”进程监视max_size参数设置的最大缓存大小。 超过此大小时，它会删除最近最少使用的数据。 在manager_files ， manager_threshold和manager_sleep参数（1.11.5）配置的迭代中删除数据。 在一次迭代期间，不会删除manager_files项（默认情况下为100）。 一次迭代的持续时间受manager_threshold参数限制（默认情况下为200毫秒）。 在迭代之间，由manager_sleep参数（默认为50毫秒）配置的暂停。 </p>
<p> 启动一分钟后，激活特殊的“缓存加载程序”进程。 它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。 加载也是在迭代中完成的。 在一次迭代期间，加载的loader_files项目不超过（默认情况下为100）。 此外，一次迭代的持续时间受loader_threshold参数限制（默认为200毫秒）。 在迭代之间，由loader_sleep参数（默认为50毫秒）配置暂停。 </p>
<p> 此外，以下参数作为我们商业订阅的一部分提供： </p>
<p> purger = on | off  指示缓存清除程序是否将从磁盘中删除与通配符密钥匹配的缓存条目（1.7.12）。 将参数设置为on （默认为off ）将激活“cache purger”进程，该进程将永久迭代所有缓存条目并删除与通配符键匹配的条目。  purger_files = <em>number</em>  设置在一次迭代（1.7.12）期间将扫描的项目数。 默认情况下， purger_files设置为10。  purger_threshold = <em>number</em>  设置一次迭代的持续时间（1.7.12）。 默认情况下， purger_threshold设置为50毫秒。  purger_sleep = <em>number</em>  设置迭代之间的暂停（1.7.12）。 默认情况下， purger_sleep设置为50毫秒。 </p>
<blockquote>
<p> 在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。 升级到较新的nginx版本之前，缓存的响应将被视为无效。  Syntax:  <strong>uwsgi_cache_purge</strong> string …;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 定义将请求视为缓存清除请求的条件。 如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应高速缓存键的高速缓存条目。 通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p> 如果清除请求的缓存键以星号（“ * ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。 但是，这些条目将保留在磁盘上，直到它们被删除为非活动状态 ，或由缓存清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p> 配置示例： </p>
<blockquote>
<p>uwsgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m; map $request_method $purge_method { PURGE 1; default 0; } server { … location / { uwsgi_pass backend; uwsgi_cache cache_zone; uwsgi_cache_key $uri; uwsgi_cache_purge $purge_method; } }<br> 此功能作为我们商业订阅的一部分提供。  Syntax:  <strong>uwsgi_cache_revalidate</strong> on | off ;<br>  Default:  uwsgi_cache_revalidate off;  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p> Syntax:  <strong>uwsgi_cache_use_stale</strong> error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | http_429 | off …;<br>  Default:  uwsgi_cache_use_stale off;  Context:  http , server , location<br>  确定在与uwsgi服务器通信期间发生错误时，在哪些情况下可以使用过时的缓存响应。 该指令的参数与uwsgi_next_upstream指令的参数匹配。 </p>
<p> 如果无法选择要处理请求的uwsgi服务器，则error参数还允许使用过时的缓存响应。 </p>
<p> 此外，如果当前正在更新，则updating参数允许使用过时的缓存响应。 这允许在更新缓存数据时最小化对uwsgi服务器的访问次数。 </p>
<p> 在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。 这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ stale-while-revalidate ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 </li>
<li><p>“Cache-Control”头字段的“ stale-if-error ”扩展允许在出现错误时使用陈旧的缓存响应。<br>要在填充新缓存元素时最小化对uwsgi服务器的访问次数，可以使用uwsgi_cache_lock指令。 </p>
<p>Syntax:  <strong>uwsgi_cache_valid</strong> [ <em>code</em> …] <em>time</em> ;<br>Default:  —  Context:  http , server , location<br>设置不同响应代码的缓存时间。 例如，以下指令 </p>
</li>
</ul>
<blockquote>
<p>uwsgi_cache_valid 200 302 10m; uwsgi_cache_valid 404 1m;  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
</blockquote>
<p> 如果仅指定了缓存<em>time</em> </p>
<blockquote>
<p>uwsgi_cache_valid 5m;  然后只缓存200,301和302个响应。 </p>
</blockquote>
<p> 此外，可以指定any参数来缓存任何响应： </p>
<blockquote>
<p>uwsgi_cache_valid 200 302 10m; uwsgi_cache_valid 301 1h; uwsgi_cache_valid any 1m;  缓存的参数也可以直接在响应头中设置。 这比使用该指令设置缓存时间具有更高的优先级。 </p>
</blockquote>
<ul>
<li>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。 零值禁用响应的缓存。 如果值以@前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 </li>
<li>如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 </li>
<li>如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 </li>
<li><p>如果标题包含具有特殊值“ * ”的“Vary”字段，则不会缓存此类响应（1.7.7）。 如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用uwsgi_ignore_headers指令禁用这些响应头字段中的一个或多个的处理。 </p>
<p>Syntax:  <strong>uwsgi_connect_timeout</strong> <em>time</em> ;<br>Default:  uwsgi_connect_timeout 60s;  Context:  http , server , location<br>定义与uwsgi服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
<p>Syntax:  <strong>uwsgi_force_ranges</strong> on | off ;<br>Default:  uwsgi_force_ranges off;  Context:  http , server , location<br>该指令出现在1.7.7版本中。 </p>
<p>无论这些响应中的“Accept-Ranges”字段如何，都可以对来自uwsgi服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p>Syntax:  <strong>uwsgi_hide_header</strong> <em>field</em> ;<br>Default:  —  Context:  http , server , location<br>默认情况下，nginx不会从uwsgi服务器对客户端的响应中传递标题字段“Status”和“X-Accel -…”。 uwsgi_hide_header指令设置了不会传递的其他字段。 相反，如果需要允许传递字段，则可以使用uwsgi_pass_header指令。 </p>
<p>Syntax:  <strong>uwsgi_ignore_client_abort</strong> on | off ;<br>Default:  uwsgi_ignore_client_abort off;  Context:  http , server , location<br>确定客户端在不等待响应的情况下关闭连接时是否应关闭与uwsgi服务器的连接。 </p>
<p>Syntax:  <strong>uwsgi_ignore_headers</strong> <em>field</em> …;<br>Default:  —  Context:  http , server , location<br>禁用从uwsgi服务器处理某些响应头字段。 可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li><p>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应缓存的参数; </p>
</li>
<li>“X-Accel-Redirect”执行内部重定向到指定的URI; </li>
<li>“X-Accel-Limit-Rate”设置向客户端传输响应的速率限制 ; </li>
<li>“X-Accel-Buffering”启用或禁用缓冲响应; </li>
<li><p>“X-Accel-Charset”设置了所需的响应字符集 。<br>Syntax:  <strong>uwsgi_intercept_errors</strong> on | off ;<br>Default:  uwsgi_intercept_errors off;  Context:  http , server , location<br>确定代码大于或等于300的uwsgi服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用error_page指令进行处理。 </p>
<p>Syntax:  <strong>uwsgi_limit_rate</strong> <em>rate</em> ;<br>Default:  uwsgi_limit_rate 0;  Context:  http , server , location<br>该指令出现在1.7.7版本中。 </p>
<p>限制从uwsgi服务器读取响应的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据请求设置限制，因此如果nginx同时打开两个到uwsgi服务器的连接，则总速率将是指定限制的两倍。 仅当启用了来自uwsgi服务器的响应缓冲时 ，该限制才有效。 </p>
<p>Syntax:  <strong>uwsgi_max_temp_file_size</strong> <em>size</em> ;<br>Default:  uwsgi_max_temp_file_size 1024m;  Context:  http , server , location<br>当启用缓冲来自uwsgi服务器的响应，并且整个响应不适合uwsgi_buffer_size和uwsgi_buffers指令设置的缓冲区时，响应的一部分可以保存到临时文件中。 该指令设置临时文件的最大<em>size</em> 。 一次写入临时文件的数据大小由uwsgi_temp_file_write_size指令设置。 </p>
<p>零值禁用缓冲对临时文件的响应。 </p>
</li>
</ul>
<blockquote>
<p> 此限制不适用于将缓存或存储在磁盘上的响应。  Syntax:  <strong>uwsgi_modifier1</strong> <em>number</em> ;<br>  Default:  uwsgi_modifier1 0;  Context:  http , server , location<br>  设置uwsgi数据包标头中 modifier1字段的值 。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_modifier2</strong> <em>number</em> ;<br>  Default:  uwsgi_modifier2 0;  Context:  http , server , location<br>  设置uwsgi数据包标头中 modifier2字段的值 。 </p>
<p> Syntax:  <strong>uwsgi_next_upstream</strong> error | timeout | invalid_header | http_500 | http_503 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>  Default:  uwsgi_next_upstream error timeout;  Context:  http , server , location<br>  指定应将请求传递到下一个服务器的情况： </p>
<p> error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_header   服务器返回空或无效响应;  http_500   服务器返回代码为500的响应;  http_503   服务器返回代码为503的响应;  http_403   服务器返回代码为403的响应;  http_404   服务器返回代码为404的响应;  http_429   服务器返回代码为429的响应（1.11.13）;  non_idempotent   通常，如果请求已发送到上游服务器，则使用非幂等方法（ POST ， LOCK ， PATCH ）的请求不会传递给下一个服务器（1.9.13）; 启用此选项显式允许重试此类请求;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p> 该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_header情况始终被视为不成功的尝试，即使它们未在指令中指定。 http_500 ， http_503和http_429情况仅在指令中指定http_429被视为不成功尝试。 http_403和http_404情况从未被视为不成功的尝试。 </p>
<p> 将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>uwsgi_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  uwsgi_next_upstream_timeout 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p> Syntax:  <strong>uwsgi_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  uwsgi_next_upstream_tries 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>uwsgi_no_cache</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不将响应保存到缓存的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<blockquote>
<p>uwsgi_no_cache $cookie_nocache $arg_nocache$arg_comment; uwsgi_no_cache $http_pragma $http_authorization;  可以与uwsgi_cache_bypass指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_param</strong> <em>parameter</em> <em>value</em> [ if_not_empty ];<br>  Default:  —  Context:  http , server , location<br>  设置应传递给uwsgi服务器的参数。 该<em>value</em>可以包含文本，变量及其组合。 当且仅当在当前级别上没有定义uwsgi_param指令时，这些指令才从先前级别继承。 </p>
<p> 标准CGI环境变量应作为uwsgi标头提供，请参阅分发中提供的uwsgi_params文件： </p>
<blockquote>
<p>location / { include uwsgi_params; … }  如果使用if_not_empty （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<p>uwsgi_param HTTPS $https if_not_empty;  Syntax:  <strong>uwsgi_pass</strong> [ <em>protocol</em> ://] <em>address</em> ;<br>  Default:  —  Context:  location , if in location<br>  设置uwsgi服务器的协议和地址。 作为<em>protocol</em> ，可以指定“ suwsgi ”或“ suwsgi ”（安全的suwsgi over SSL）。 地址可以指定为域名或IP地址，以及端口： </p>
<p>uwsgi_pass localhost:9000; uwsgi_pass uwsgi://localhost:9000; uwsgi_pass suwsgi://[2001:db8::1]:9090;  或者作为UNIX域套接字路径： </p>
<p>uwsgi_pass unix:/tmp/uwsgi.socket;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> 参数值可以包含变量。 在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用解析器确定。 </p>
<blockquote>
<p> 从版本1.5.8开始支持安全的uwsgi协议。  Syntax:  <strong>uwsgi_pass_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  允许将来自uwsgi服务器的其他禁用的头字段传递给客户端。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_pass_request_body</strong> on | off ;<br>  Default:  uwsgi_pass_request_body on;  Context:  http , server , location<br>  指示是否将原始请求正文传递给uwsgi服务器。 另请参见uwsgi_pass_request_headers指令。 </p>
<p> Syntax:  <strong>uwsgi_pass_request_headers</strong> on | off ;<br>  Default:  uwsgi_pass_request_headers on;  Context:  http , server , location<br>  指示原始请求的标头字段是否传递给uwsgi服务器。 另请参见uwsgi_pass_request_body指令。 </p>
<p> Syntax:  <strong>uwsgi_read_timeout</strong> <em>time</em> ;<br>  Default:  uwsgi_read_timeout 60s;  Context:  http , server , location<br>  定义从uwsgi服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果uwsgi服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>uwsgi_request_buffering</strong> on | off ;<br>  Default:  uwsgi_request_buffering on;  Context:  http , server , location<br>  该指令出现在1.7.11版本中。 </p>
<p> 启用或禁用客户端请求正文的缓冲。 </p>
<p> 启用缓冲后，在将请求发送到uwsgi服务器之前，将从客户端读取整个请求正文。 </p>
<p> 禁用缓冲时，请求主体在收到时立即发送到uwsgi服务器。 在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给下一个服务器 。 </p>
<p> 当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p> Syntax:  <strong>uwsgi_send_timeout</strong> <em>time</em> ;<br>  Default:  uwsgi_send_timeout 60s;  Context:  http , server , location<br>  设置将请求传输到uwsgi服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果uwsgi服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>uwsgi_socket_keepalive</strong> on | off ;<br>  Default:  uwsgi_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
<p> 为uwsgi服务器的传出连接配置“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>uwsgi_ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有PEM格式的证书的<em>file</em> ，该证书用于对安全的uwsgi服务器进行身份验证。 </p>
<p> Syntax:  <strong>uwsgi_ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有PEM格式的密钥的<em>file</em> ，用于对安全的uwsgi服务器进行身份验证。 </p>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> （1.7.9），该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>uwsgi_ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  uwsgi_ssl_ciphers DEFAULT;  Context:  http , server , location<br>  该指令出现在1.5.8版本中。 </p>
<p> 指定对安全的uwsgi服务器的请求的启用密码。 密码以OpenSSL库理解的格式指定。 </p>
<p> 可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> Syntax:  <strong>uwsgi_ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证受保护的uwsgi服务器的证书。 </p>
<p> Syntax:  <strong>uwsgi_ssl_name</strong> <em>name</em> ;<br>  Default:  uwsgi_ssl_name host from uwsgi_pass;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 允许覆盖用于验证安全uwsgi服务器证书的服务器名称，并在与安全uwsgi服务器建立连接时通过SNI传递。 </p>
<p> 默认情况下，使用uwsgi_pass的主机部分。 </p>
<p> Syntax:  <strong>uwsgi_ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> Syntax:  <strong>uwsgi_ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  uwsgi_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  http , server , location<br>  该指令出现在1.5.8版本中。 </p>
<p> 为安全的uwsgi服务器启用指定的协议。 </p>
<p> Syntax:  <strong>uwsgi_ssl_server_name</strong> on | off ;<br>  Default:  uwsgi_ssl_server_name off;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 在与安全的uwsgi服务器建立连接时，启用或禁用通过TLS服务器名称指示扩展 （SNI，RFC 6066）传递服务器名称。 </p>
<p> Syntax:  <strong>uwsgi_ssl_session_reuse</strong> on | off ;<br>  Default:  uwsgi_ssl_session_reuse on;  Context:  http , server , location<br>  该指令出现在1.5.8版本中。 </p>
<p> 确定在使用安全的uwsgi服务器时是否可以重用SSL会话。 如果日志中出现“ SSL3_GET_FINISHED:digest check failed ”错误，请尝试禁用会话重用。 </p>
<p> Syntax:  <strong>uwsgi_ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证安全uwsgi服务器的证书。 </p>
<p> Syntax:  <strong>uwsgi_ssl_verify</strong> on | off ;<br>  Default:  uwsgi_ssl_verify off;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 启用或禁用安全uwsgi服务器证书的验证。 </p>
<p> Syntax:  <strong>uwsgi_ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  uwsgi_ssl_verify_depth 1;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 在安全的uwsgi服务器证书链中设置验证深度。 </p>
<p> Syntax:  <strong>uwsgi_store</strong> on | off | <em>string</em> ;<br>  Default:  uwsgi_store off;  Context:  http , server , location<br>  允许将文件保存到磁盘。 on参数使用与指令别名或root对应的路径保存文件。 off参数禁用文件保存。 此外，可以使用带变量的<em>string</em>显式设置文件名： </p>
<blockquote>
<p>uwsgi_store /data/www$original_uri;  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。 首先将响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，保存的文件和保存临时文件的目录（由uwsgi_temp_path指令设置）都放在同一文件系统上。 </p>
</blockquote>
<p> 该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<blockquote>
<p>location /images/ { root /data/www; error_page 404 = /fetch$uri; } location /fetch/ { internal; uwsgi_pass backend:9000; … uwsgi_store on; uwsgi_store_access user:rw group:rw all:r; uwsgi_temp_path /data/temp; alias /data/www/; }  Syntax:  <strong>uwsgi_store_access</strong> <em>users</em> : <em>permissions</em> …;<br>  Default:  uwsgi_store_access user:rw;  Context:  http , server , location<br>  为新创建的文件和目录设置访问权限，例如： </p>
<p>uwsgi_store_access user:rw group:rw all:r;  如果指定了任何group或all访问权限，则可以省略user权限： </p>
<p>uwsgi_store_access group:rw all:r;  Syntax:  <strong>uwsgi_temp_file_write_size</strong> <em>size</em> ;<br>  Default:  uwsgi_temp_file_write_size 8k|16k;  Context:  http , server , location<br>  当启用从uwsgi服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<em>size</em> 。 默认情况下， <em>size</em>受uwsgi_buffer_size和uwsgi_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由uwsgi_max_temp_file_size指令设置。 </p>
</blockquote>
<p> Syntax:  <strong>uwsgi_temp_path</strong> <em>path</em> [ <em>level1</em> [ <em>level2</em> [ <em>level3</em> ]]];<br>  Default:  uwsgi_temp_path uwsgi_temp;  Context:  http , server , location<br>  定义用于存储临时文件的目录，其中包含从uwsgi服务器接收的数据。 在指定目录下最多可以使用三级子目录层次结构。 例如，在以下配置中 </p>
<blockquote>
<p>uwsgi_temp_path /spool/nginx/uwsgi_temp 1 2;  临时文件可能如下所示： </p>
<p>/spool/nginx/uwsgi_temp/ <strong>7</strong> / <strong>45</strong> /00000123 <strong>457</strong>  另请参见uwsgi_cache_path指令的use_temp_path参数。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_userid_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_userid_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_userid_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-userid-module"><a href="#Module-ngx-http-userid-module" class="headerlink" title="Module ngx_http_userid_module"></a>Module ngx_http_userid_module</h2><p> Example Configuration<br> Directives<br> userid<br> userid_domain<br> userid_expires<br> userid_mark<br> userid_name<br> userid_p3p<br> userid_path<br> userid_service<br> Embedded Variables<br> ngx_http_userid_module模块设置适合客户端识别的cookie。 可以使用嵌入变量$ uid_got和$ uid_set记录已接收和设置的cookie。 该模块与Apache的mod_uid模块兼容。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>userid on; userid_name uid; userid_domain example.com; userid_path /; userid_expires 365d; userid_p3p ‘policyref=”/w3c/p3p.xml”, CP=”CUR ADM OUR NOR STA NID”‘; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>userid</strong> on | v1 | log | off ;<br>  Default:  userid off;  Context:  http , server , location<br>  启用或禁用设置cookie并记录收到的cookie： </p>
<p> on   可以设置版本2 cookie并记录收到的cookie;  v1   可以设置版本1 cookie并记录收到的cookie;  log   禁用cookie的设置，但允许记录收到的cookie;  off   禁用cookie的设置和记录收到的cookie。  Syntax:  <strong>userid_domain</strong> <em>name</em> | none ;<br>  Default:  userid_domain none;  Context:  http , server , location<br>  定义为其设置cookie的域。 none参数禁用cookie的域设置。 </p>
<p> Syntax:  <strong>userid_expires</strong> <em>time</em> | max | off ;<br>  Default:  userid_expires off;  Context:  http , server , location<br>  设置浏览器保留cookie的时间。 参数max将导致cookie在“ 31 Dec 2037 23:55:55 GMT ”到期。 参数off将导致cookie在浏览器会话结束时到期。 </p>
<p> Syntax:  <strong>userid_mark</strong> <em>letter</em> | <em>digit</em> | = | off ;<br>  Default:  userid_mark off;  Context:  http , server , location<br>  如果参数未off ，则启用cookie标记机制并设置用作标记的字符。 此机制用于在保留客户端标识符的同时添加或更改userid_p3p和/或cookie过期时间。 标记可以是英文字母（区分大小写），数字或“ = ”字符的任何字母。 </p>
<p> 如果设置了标记，则将其与cookie中传递的客户端标识符的base64表示中的第一个填充符号进行比较。 如果它们不匹配，则会使用指定的标记，到期时间和“P3P”标头重新发送cookie。 </p>
<p> Syntax:  <strong>userid_name</strong> <em>name</em> ;<br>  Default:  userid_name uid;  Context:  http , server , location<br>  设置cookie名称。 </p>
<p> Syntax:  <strong>userid_p3p</strong> <em>string</em> | none ;<br>  Default:  userid_p3p none;  Context:  http , server , location<br>  设置将与cookie一起发送的“P3P”标题字段的值。 如果指令设置为特殊值none ，则不会在响应中发送“P3P”标头。 </p>
<p> Syntax:  <strong>userid_path</strong> <em>path</em> ;<br>  Default:  userid_path /;  Context:  http , server , location<br>  定义cookie的设置路径。 </p>
<p> Syntax:  <strong>userid_service</strong> <em>number</em> ;<br>  Default:  userid_service IP address of the server;  Context:  http , server , location<br>  如果标识符由多个服务器（服务）发出，则应为每个服务分配其自己的<em>number</em>以确保客户端标识符是唯一的。 对于版本1 cookie，默认值为零。 对于版本2 cookie，默认值是由服务器IP地址的最后四个八位字节组成的数字。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_userid_module模块支持以下嵌入变量： </p>
<p> $uid_got   Cookie名称和已接收的客户端标识符。  $uid_reset   如果变量设置为非空字符串不是“ 0 ”，则重置客户端标识符。 特殊值“ log ”还导致将关于重置标识符的消息输出到error_log 。  $uid_set   Cookie名称和已发送的客户端标识符。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-module"><a href="#Module-ngx-http-upstream-module" class="headerlink" title="Module ngx_http_upstream_module"></a>Module ngx_http_upstream_module</h2><p> Example Configuration<br> Directives<br> upstream<br> server<br> zone<br> state<br> hash<br> ip_hash<br> keepalive<br> keepalive_requests<br> keepalive_timeout<br> ntlm<br> least_conn<br> least_time<br> queue<br> random<br> sticky<br> sticky_cookie_insert<br> Embedded Variables<br> ngx_http_upstream_module模块用于定义可由proxy_pass ， fastcgi_pass ， uwsgi_pass ， scgi_pass ， memcached_pa​​ss和grpc_pass指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>upstream <strong>backend</strong> { server backend1.example.com weight=5; server backend2.example.com:8080; server unix:/tmp/backend3; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; } server { location / { proxy_pass http:// <strong>backend</strong> ; } }  具有定期运行状况检查的动态可配置组可作为我们商业订阅的一部分： </p>
<p>resolver 10.0.0.1; upstream <strong>dynamic</strong> { zone upstream_dynamic 64k; server backend1.example.com weight=5; server backend2.example.com:8080 fail_timeout=5s slow_start=30s; server 192.0.2.1 max_fails=3; server backend3.example.com resolve; server backend4.example.com service=http resolve; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; } server { location / { proxy_pass http:// <strong>dynamic</strong> ; health_check; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>upstream</strong> <em>name</em> { … }<br>  Default:  —  Context:  http<br>  定义一组服务器。 服务器可以侦听不同的端口。 此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p> 例： </p>
<blockquote>
<p>upstream backend { server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup; }  默认情况下，使用加权循环平衡方法在服务器之间分配请求。 在上面的示例中，每个7个请求将按如下方式分发：5个请求转到backend1.example.com ，1个请求转发给第二个和第三个服务器。 如果在与服务器通信期间发生错误，请求将被传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。 如果无法从任何服务器获得成功的响应，则客户端将接收与最后一个服务器的通信结果。 </p>
</blockquote>
<p> Syntax:  <strong>server</strong> <em>address</em> [ <em>parameters</em> ];<br>  Default:  —  Context:  upstream<br>  定义服务器的<em>address</em>和其他<em>parameters</em> 。 可以将地址指定为域名或IP地址，带有可选端口，或者指定为“ unix: ”前缀后指定的UNIX域套接字路径。 如果未指定端口，则使用端口80。 解析为多个IP地址的域名一次定义多个服务器。 </p>
<p> 可以定义以下参数： </p>
<p> weight = <em>number</em>  设置服务器的权重，默认为1。  max_conns = <em>number</em>  限制与代理服务器的最大并发活动连接<em>number</em> （1.11.5）。 默认值为零，表示没有限制。 如果服务器组不驻留在共享内存中 ，则每个工作进程的限制都有效。 </p>
<blockquote>
<p> 如果启用了空闲keepalive连接，多个工作程序和共享内存 ，则代理服务器的活动和空闲连接总数可能会超过max_conns值。<br> 自版本1.5.9和版本1.11.5之前，此参数作为我们的商业订阅的一部分提供。  max_fails = <em>number</em>  设置在fail_timeout参数设置的持续时间内发生的与服务器通信的不成功尝试次数，以考虑服务器在fail_timeout参数设置的持续时间内不可用。 默认情况下，不成功尝试次数设置为1.零值禁用尝试的计费。 被认为是不成功的尝试由proxy_next_upstream ， fastcgi_next_upstream ， uwsgi_next_upstream ， scgi_next_upstream ， memcached_next_upstream和grpc_next_upstream指令定义。  fail_timeout = <em>time</em>  套 *  指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; </p>
<ul>
<li>以及服务器被视为不可用的时间段。<br>默认情况下，参数设置为10秒。  backup   将服务器标记为备份服务器。 当主服务器不可用时，它将被传递请求。  down   将服务器标记为永久不可用。  此外，以下参数作为我们商业订阅的一部分提供： </li>
</ul>
</blockquote>
<p> resolve   监视与服务器域名对应的IP地址的更改，并自动修改上游配置，而无需重新启动nginx（1.5.12）。 服务器组必须驻留在共享内存中 。  要使此参数起作用，必须在http块中指定解析程序指令。 例： </p>
<blockquote>
<p>http { resolver 10.0.0.1; upstream u { zone …; … server example.com resolve; } }  route = <em>string</em>  设置服务器路由名称。  service = <em>name</em>  能够解析DNS SRV记录并设置服务<em>name</em> （1.9.13）。 要使此参数起作用，必须为服务器指定resolve参数并指定不带端口号的主机名。  如果服务名称不包含点（“ . ”），则构造符合RFC的名称，并将TCP协议添加到服务前缀。 例如，要查找_http._tcp.backend.example.com SRV记录，必须指定该指令： </p>
<p>server backend.example.com service=http resolve;  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。 例如，要查找_http._tcp.backend.example.com和server1.backend.example.com SRV记录，必须指定指令： </p>
<p>server backend.example.com service=_http._tcp resolve; server example.com service=server1.backend resolve;  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。 如果为服务器指定了backup参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
</blockquote>
<p> slow_start = <em>time</em>  设置服务器将其权重从零恢复到标称值的时间，当不健康的服务器变得健康时 ，或者服务器在一段时间被认为不可用后变得可用时。 默认值为零，即禁用慢启动。 </p>
<blockquote>
<p> 该参数不能与hash和ip_hash负载平衡方法一起使用。  drain   使服务器进入“排水”模式（1.13.6）。 在此模式下，只有绑定到服务器的请求才会被代理。<br> 在1.13.6版之前，只能使用API模块更改参数。<br> 如果组中只有一个服务器，则忽略max_fails ， fail_timeout和slow_start参数，并且永远不会将此类服务器视为不可用。  Syntax:  <strong>zone</strong> <em>name</em> [ <em>size</em> ];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.9.0版本中。 </p>
</blockquote>
<p> 定义共享内存区域的<em>name</em>和<em>size</em> ，该区域保持组工作进程之间共享的组配置和运行时状态。 几个组可能共享同一个区域。 在这种情况下，仅指定一次<em>size</em>就足够了。 </p>
<p> 此外，作为我们商业订阅的一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。 可通过API模块（1.13.3）访问该配置。 </p>
<blockquote>
<p> 在1.13.3版之前，只能通过upstream_conf处理的特殊位置访问配置。  Syntax:  <strong>state</strong> <em>file</em> ;<br>  Default:  —  Context:  upstream<br>  该指令出现在1.9.7版中。 </p>
</blockquote>
<p> 指定保持动态可配置组状态的<em>file</em> 。 </p>
<p> 例子： </p>
<blockquote>
<p>state /var/lib/nginx/state/servers.conf; # path for Linux state /var/db/nginx/state/servers.conf; # path for FreeBSD  该状态目前仅限于具有其参数的服务器列表。 解析配置时会读取文件，每次更改上游配置时都会更新该文件。 应避免直接更改文件内容。 该指令不能与server指令一起使用。 </p>
<p> 配置重新加载或二进制升级期间所做的更改可能会丢失。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>hash</strong> <em>key</em> [ consistent ];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.7.2版本中。 </p>
</blockquote>
<p> 指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<em>key</em> 。 <em>key</em>可以包含文本，变量及其组合。 请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。 该方法与Cache :: Memcached Perl库兼容。 </p>
<p> 如果指定了consistent参数，则将使用ketama一致性哈希方法。 该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。 这有助于为缓存服务器实现更高的缓存命中率。 该方法与Cache :: Memcached :: Fast Perl库兼容，并将<em>ketama_points</em>参数设置为160。 </p>
<p> Syntax:  <strong>ip_hash</strong> ;<br>  Default:  —  Context:  upstream<br>  指定组应使用负载平衡方法，其中请求根据客户端IP地址在服务器之间分配。 客户端IPv4地址的前三个八位字节或整个IPv6地址用作散列密钥。 该方法确保来自同一客户端的请求将始终传递到同一服务器，除非此服务器不可用。 在后一种情况下，客户端请求将被传递到另一个服务器。 最有可能的是，它也将始终是同一台服务器。 </p>
<blockquote>
<p> 从版本1.3.2和1.2.2开始支持IPv6地址。  如果需要临时删除其中一个服务器，则应使用down参数对其进行标记，以保留客户端IP地址的当前哈希值。 </p>
</blockquote>
<p> 例： </p>
<blockquote>
<p>upstream backend { ip_hash; server backend1.example.com; server backend2.example.com; server backend3.example.com <strong>down</strong> ; server backend4.example.com; }<br> 在版本1.3.1和1.2.2之前，无法使用ip_hash负载平衡方法为服务器指定权重。  Syntax:  <strong>keepalive</strong> <em>connections</em> ;<br>  Default:  —  Context:  upstream<br>  该指令出现在1.1.4版中。 </p>
</blockquote>
<p> 激活缓存以连接到上游服务器。 </p>
<p> <em>connections</em>参数设置在每个工作进程的缓存中保留的上游服务器的最大空闲keepalive连接数。 超过此数量时，将关闭最近最少使用的连接。 </p>
<blockquote>
<p> 应特别注意的是， keepalive指令不限制nginx工作进程可以打开的上游服务器的连接总数。 <em>connections</em>参数应设置为足够小的数字，以便上游服务器也可以处理新的传入连接。  使用keepalive连接的memcached上游示例配置： </p>
<p>upstream memcached_backend { server 127.0.0.1:11211; server 10.0.0.2:11211; keepalive 32; } server { … location /memcached/ { set $memcached_key $uri; memcached_pass memcached_backend; } }  对于HTTP， proxy_http_version指令应设置为“ 1.1 ”，并且应清除“Connection”头字段： </p>
<p>upstream http_backend { server 127.0.0.1:8080; keepalive 16; } server { … location /http/ { proxy_pass <a href="http://http\_backend" target="_blank" rel="noopener">http://http\_backend</a>; proxy_http_version 1.1; proxy_set_header Connection “”; … } }<br> 或者，可以通过将“Connection：Keep-Alive”头字段传递给上游服务器来使用HTTP / 1.0持久连接，但不建议使用此方法。  对于FastCGI服务器，需要设置fastcgi_keep_conn才能使keepalive连接正常工作： </p>
<p>upstream fastcgi_backend { server 127.0.0.1:9000; keepalive 8; } server { … location /fastcgi/ { fastcgi_pass fastcgi_backend; fastcgi_keep_conn on; … } }<br> 使用除默认循环方法之外的负载平衡器方法时，必须在keepalive指令之前激活它们。<br> SCGI和uwsgi协议没有keepalive连接的概念。  Syntax:  <strong>keepalive_requests</strong> <em>number</em> ;<br>  Default:  keepalive_requests 100;  Context:  upstream<br>  该指令出现在1.15.3版中。 </p>
</blockquote>
<p> 设置可通过一个keepalive连接提供的最大请求数。 在发出最大请求数后，将关闭连接。 </p>
<p> Syntax:  <strong>keepalive_timeout</strong> <em>timeout</em> ;<br>  Default:  keepalive_timeout 60s;  Context:  upstream<br>  该指令出现在1.15.3版中。 </p>
<p> 设置超时，在此期间与上游服务器的空闲keepalive连接将保持打开状态。 </p>
<p> Syntax:  <strong>ntlm</strong> ;<br>  Default:  —  Context:  upstream<br>  该指令出现在1.9.2版本中。 </p>
<p> 允许使用NTLM身份验证代理请求。 一旦客户端发送具有以“ Negotiate ”或“ NTLM ”开头的“Authorization”头字段值的请求，上游连接就绑定到客户端连接。 进一步的客户端请求将通过相同的上游连接进行代理，从而保持身份验证上下文。 </p>
<p> 为了使NTLM身份验证起作用，必须启用与上游服务器的keepalive连接。 proxy_http_version指令应设置为“ 1.1 ”，并且应清除“Connection”头字段： </p>
<blockquote>
<p>upstream http_backend { server 127.0.0.1:8080; ntlm; } server { … location /http/ { proxy_pass <a href="http://http\_backend" target="_blank" rel="noopener">http://http\_backend</a>; proxy_http_version 1.1; proxy_set_header Connection “”; … } }<br> 使用除默认循环方法之外的负载平衡器方法时，必须在ntlm指令之前激活它们。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>least_conn</strong> ;<br>  Default:  —  Context:  upstream<br>  该指令出现在1.3.1和1.2.2版本中。 </p>
</blockquote>
<p> 指定组应使用负载平衡方法，其中将请求传递到具有最少活动连接的服务器，同时考虑服务器的权重。 如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p> Syntax:  <strong>least_time</strong> header | last_byte [ inflight ];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.7.10版本中。 </p>
<p> 指定组应使用负载平衡方法，其中请求以最少的平均响应时间和最少的活动连接传递给服务器，同时考虑服务器的权重。 如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p> 如果指定了header参数，则使用接收响应头的时间。 如果指定了last_byte参数，则使用接收完整响应的时间。 如果指定了inflight参数（1.11.6），则还会考虑不完整的请求。 </p>
<blockquote>
<p> 在1.11.6版之前，默认情况下会考虑不完整的请求。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>queue</strong> <em>number</em> [ timeout = <em>time</em> ];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.5.12版本中。 </p>
</blockquote>
<p> 如果在处理请求时无法立即选择上游服务器，则请求将被放入队列中。 该指令指定了可以同时在队列中的最大请求<em>number</em> 。 如果队列已满，或者在timeout参数中指定的时间段内无法选择要传递请求的服务器，则会将502（错误网关）错误返回给客户端。 </p>
<p> timeout参数的默认值为60秒。 </p>
<blockquote>
<p> 使用除默认循环方法之外的负载平衡器方法时，必须在queue指令之前激活它们。<br> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>random</strong> [ two [ <em>method</em> ]];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.15.1版本中。 </p>
</blockquote>
<p> 指定组应使用负载平衡方法，其中将请求传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p> 可选的two参数指示nginx随机选择两个服务器，然后使用指定的method选择服务器。 默认方法是least_conn ，它将请求传递给活动连接数最少的服务器。 </p>
<p> least_time方法将请求传递给具有最少平均响应时间和最少活动连接数的服务器。 如果指定了least_time=header ，则使用接收响应头的时间。 如果指定了least_time=last_byte ，则使用接收完整响应的时间。 </p>
<blockquote>
<p> least_time方法可作为我们商业订阅的一部分。  Syntax:  <strong>sticky</strong> cookie <em>name</em> [ expires= <em>time</em> ] [ domain= <em>domain</em> ] [ httponly ] [ secure ] [ path= <em>path</em> ];<br> <strong>sticky</strong> route <em>$variable</em> …;<br> <strong>sticky</strong> learn create= <em>$variable</em> lookup= <em>$variable</em> zone= <em>name</em> : <em>size</em> [ timeout= <em>time</em> ] [ header ] [ sync ];<br>  Default:  —  Context:  upstream<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 启用会话关联，这会将来自同一客户端的请求传递到一组服务器中的同一服务器。 有三种方法可供选择： </p>
<p> cookie   使用cookie方法时，有关指定服务器的信息将在nginx生成的HTTP cookie中传递： </p>
<blockquote>
<p>upstream backend { server backend1.example.com; server backend2.example.com; sticky cookie srv_id expires=1h domain=.example.com path=/; }  来自尚未绑定到特定服务器的客户端的请求将传递到由配置的balance方法选择的服务器。 使用此cookie的进一步请求将传递到指定的服务器。 如果指定的服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
</blockquote>
<p> 第一个参数设置要设置或检查的cookie的名称。 cookie值是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。 但是，如果指定了server指令的“ route ”参数，则cookie值将是“ route ”参数的值： </p>
<blockquote>
<p>upstream backend { server backend1.example.com route= <strong>a</strong> ; server backend2.example.com route= <strong>b</strong> ; sticky cookie srv_id expires=1h domain=.example.com path=/; }  在这种情况下，“ srv_id ”cookie的值将是<em>a</em>或<em>b</em> 。 </p>
</blockquote>
<p> 其他参数可能如下： </p>
<p> expires= <em>time</em>  设置浏览器保留cookie的时间。 特殊值max将导致cookie在“ 31 Dec 2037 23:55:55 GMT ”到期。 如果未指定参数，则会导致cookie在浏览器会话结束时到期。  domain= <em>domain</em>  定义为其设置cookie的<em>domain</em> 。 参数值可以包含变量（1.11.5）。  httponly   将HttpOnly属性添加到cookie（1.7.11）。  secure   将Secure属性添加到cookie（1.7.11）。  path= <em>path</em>  定义cookie的设置<em>path</em> 。  如果省略任何参数，则不会设置相应的cookie字段。 </p>
<p> route   使用route方法时，代理服务器在收到第一个请求时为客户端分配路由。 来自此客户端的所有后续请求将在cookie或URI中携带路由信息。 将此信息与服务器指令的“ route ”参数进行比较，以标识应将请求代理到的服务器。 如果未指定“ route ”参数，则路由名称将是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。 如果指定的服务器无法处理请求，则配置的平衡方法将选择新服务器，就好像请求中没有路由信息一样。 </p>
<p> route方法的参数指定可能包含路由信息的变量。 第一个非空变量用于查找匹配服务器。 </p>
<p> 例： </p>
<blockquote>
<p>map $cookie_jsessionid $route_cookie { ~.+.(?P<route>\w+)$ $route; } map $request_uri $route_uri { ~jsessionid=.+.(?P<route>\w+)$ $route; } upstream backend { server backend1.example.com route=a; server backend2.example.com route=b; sticky route $route_cookie $route_uri; }  这里，路由取自“ JSESSIONID ”cookie（如果请求中存在）。 否则，使用来自URI的路由。 </route></route></p>
</blockquote>
<p> learn   当使用learn方法（1.7.1）时，nginx会分析上游服务器响应并学习通常在HTTP cookie中传递的服务器启动的会话。 </p>
<blockquote>
<p>upstream backend { server backend1.example.com:8080; server backend2.example.com:8081; sticky learn create=$upstream_cookie_examplecookie lookup=$cookie_examplecookie zone=client_sessions:1m; }  在该示例中，上游服务器通过在响应中设置cookie“ EXAMPLECOOKIE ”来创建会话。 使用此cookie的进一步请求将传递到同一服务器。 如果服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
</blockquote>
<p> 参数create和lookup指定分别指示如何创建新会话和搜索现有会话的变量。 两个参数可以多次指定，在这种情况下使用第一个非空变量。 </p>
<p> 会话存储在共享内存区域中，其<em>name</em>和<em>size</em>由zone参数配置。 一兆字节区域可以在64位平台上存储大约4000个会话。 在timeout参数指定的时间内未访问的会话将从区域中删除。 默认情况下， timeout设置为10分钟。 </p>
<p> header参数（1.13.1）允许在从上游服务器接收响应头之后立即创建会话。 </p>
<p> sync参数（1.13.8）启用共享内存区域的同步 。 </p>
<blockquote>
<p> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>sticky_cookie_insert</strong> <em>name</em> [ expires= <em>time</em> ] [ domain= <em>domain</em> ] [ path= <em>path</em> ];<br>  Default:  —  Context:  upstream<br>  从1.5.7版开始，该指令已过时。 应该使用具有新语法的等效粘性指令： </p>
<p> sticky cookie <em>name</em> [ expires= <em>time</em> ] [ domain= <em>domain</em> ] [ path= <em>path</em> ]; ####  嵌入式变量</p>
</blockquote>
<p> ngx_http_upstream_module模块支持以下嵌入变量： </p>
<p> $upstream_addr   保留IP地址和端口，或上游服务器的UNIX域套接字的路径。 如果在请求处理期间联系了多个服务器，则它们的地址用逗号分隔，例如“ 192.168.1.1:80, 192.168.1.2:80, unix:/tmp/sock ”。 如果从一个服务器组到另一个服务器组的内部重定向发生，由“X-Accel-Redirect”或error_page启动 ，则来自不同组的服务器地址用冒号分隔，例如“ 192.168.1.1:80, 192.168.1.2:80, unix:/tmp/sock : 192.168.10.1:80, 192.168.10.2:80 “。 如果无法选择服务器，则变量将保留服务器组的名称。  $upstream_bytes_received   从上游服务器（1.11.4）接收的字节数。 来自多个连接的值由逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_bytes_sent   发送到上游服务器的字节数（1.15.8）。 来自多个连接的值由逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_cache_status   保持访问响应缓存的状态（0.8.3）。 状态可以是“ MISS ”，“ BYPASS ”，“ EXPIRED ”，“ STALE ”，“ UPDATING ”，“ REVALIDATED ”或“ HIT ”。  $upstream_connect_time   保留与上游服务器建立连接所花费的时间（1.9.1）; 时间以秒为单位，分辨率为毫秒。 在SSL的情况下，包括握手时间。 几个连接的时间用逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_cookie_ <em>name</em>  上游服务器在“Set-Cookie”响应头字段（1.7.1）中发送的具有指定<em>name</em>的cookie。 仅保存最后一台服务器响应中的cookie。  $upstream_header_time   保留从上游服务器接收响应头所花费的时间（1.7.10）; 时间以秒为单位，分辨率为毫秒。 几个响应的时间用逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_http_ <em>name</em>  保留服务器响应头字段。 例如，“Server”响应头字段可通过$upstream_http_server变量获得。 将头字段名称转换为变量名称的规则与以“ $ http_ ”前缀开头的变量相同。 仅保存最后一个服务器响应中的标头字段。  $upstream_queue_time   保留请求在上游队列中花费的时间（1.13.9）; 时间以秒为单位，分辨率为毫秒。 几个响应的时间用逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_response_length   保持从上游服务器获得的响应长度（0.7.27）; 长度以字节为单位。 几个响应的长度用逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_response_time   保留从上游服务器接收响应所花费的时间; 时间以秒为单位，分辨率为毫秒。 几个响应的时间用逗号和冒号分隔，如$ upstream_addr变量中的地址。  $upstream_status   保留从上游服务器获得的响应的状态代码。 几个响应的状态代码用逗号和冒号分隔，如$ upstream_addr变量中的地址。 如果无法选择服务器，则变量将保留502（错误网关）状态代码。  $upstream_trailer_ <em>name</em>  保留从上游服务器（1.13.10）获得的响应结束的字段。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-hc-module"><a href="#Module-ngx-http-upstream-hc-module" class="headerlink" title="Module ngx_http_upstream_hc_module"></a>Module ngx_http_upstream_hc_module</h2><p> Example Configuration<br> Directives<br> health_check<br> match<br> ngx_http_upstream_hc_module模块允许对周围位置中引用的组中的服务器进行定期运行状况检查。 服务器组必须驻留在共享内存中 。 </p>
<p> 如果运行状况检查失败，则服务器将被视为运行状况不佳。 如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。 客户端请求不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p> 请注意，与健康检查一起使用时，大多数变量都将具有空值。<br> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>upstream dynamic { zone upstream_dynamic 64k; server backend1.example.com weight=5; server backend2.example.com:8080 fail_timeout=5s slow_start=30s; server 192.0.2.1 max_fails=3; server backup1.example.com:8080 backup; server backup2.example.com:8080 backup; } server { location / { proxy_pass <a href="http://dynamic" target="_blank" rel="noopener">http://dynamic</a>; health_check; } }  使用此配置，nginx将每隔五秒向backend组中的每个服务器发送“ / ”请求。 如果发生任何通信错误或超时，或者代理服务器使用2xx或3xx以外的状态代码进行响应，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
</blockquote>
<p> 可以配置运行状况检查以测试响应的状态代码，某些标题字段及其值的存在以及正文内容。 测试使用match伪指令单独配置，并在health_check指令的match参数中引用： </p>
<blockquote>
<p>http { server { … location / { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; health_check match=welcome; } } match welcome { status 200; header Content-Type = text/html; body ~ “Welcome to nginx!”; } }  此配置显示，为了通过运行状况检查，对运行状况检查请求的响应应该成功，状态为200，并包含“ Welcome to nginx! “ 在身体里。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>health_check</strong> [ <em>parameters</em> ];<br>  Default:  —  Context:  location<br>  启用对周围位置中引用的组中的服务器的定期运行状况检查。 </p>
<p> 支持以下可选参数： </p>
<p> interval = <em>time</em>  设置两次连续运行状况检查之间的间隔，默认为5秒。  jitter = <em>time</em>  设置每个健康检查随机延迟的时间，默认情况下，没有延迟。  fails = <em>number</em>  设置特定服务器的连续失败运行状况检查的数量，在此之后，此服务器将被视为运行状况不佳，默认情况下为1。  passes = <em>number</em>  设置特定服务器的连续传递运行状况检查的数量，在此之后服务器将被视为运行状况，默认情况下为1。  uri = <em>uri</em>  定义健康检查请求中使用的URI，默认情况下为“ / ”。  mandatory   设置服务器的初始“检查”状态，直到第一次健康检查完成（1.11.7）。 客户端请求不会传递到处于“检查”状态的服务器。 如果未指定参数，则服务器最初将被视为健康。  match = <em>name</em>  指定配置响应应传递的测试的match块，以便进行运行状况检查。 默认情况下，响应的状态代码应为2xx或3xx。  port = <em>number</em>  定义连接到服务器以执行运行状况检查时使用的端口（1.9.7）。 默认情况下，等于服务器端口。  Syntax:  <strong>match</strong> <em>name</em> { … }<br>  Default:  —  Context:  http<br>  定义用于验证对运行状况检查请求的响应的命名测试集。 </p>
<p> 可以在响应中测试以下项目： </p>
<p> status 200;   状态是200  status ! 500;   状态不是500  status 200 204;   状态为200或204  status ! 301 302;   状态既不是301也不是302  status 200-399;   状态在200到399之间  status ! 400-599;   状态不在400到599之间  status 301-303 307;   状态为301,302,303或307  header Content-Type = text/html;   header包含值为text/html “Content-Type”  header Content-Type != text/html;   header包含“Content-Type”，其值不是text/html  header Connection ~ close;   header包含“Connection”，其值与正则表达式close匹配  header Connection !~ close;   header包含“Connection”，其值与正则表达式close不匹配  header Host;   标头包含“主机”  header ! X-Accel-Redirect;   标头缺少“X-Accel-Redirect”  body ~ “Welcome to nginx!”;   正文表达“ Welcome to nginx! ”  body !~ “Welcome to nginx!”;   正文表达式不符合“ Welcome to nginx! ”  如果指定了多个测试，则响应仅在匹配所有测试时才匹配。 </p>
<blockquote>
<p> 仅检查响应体的前256k。  例子： </p>
<h1 id="status-is-200-content-type-is-“text-html”-and-body-contains-“Welcome-to-nginx-”-match-welcome-status-200-header-Content-Type-text-html-body-“Welcome-to-nginx-”"><a href="#status-is-200-content-type-is-“text-html”-and-body-contains-“Welcome-to-nginx-”-match-welcome-status-200-header-Content-Type-text-html-body-“Welcome-to-nginx-”" class="headerlink" title="status is 200, content type is “text/html”, # and body contains “Welcome to nginx!” match welcome { status 200; header Content-Type = text/html; body ~ “Welcome to nginx!”; }"></a>status is 200, content type is “text/html”, # and body contains “Welcome to nginx!” match welcome { status 200; header Content-Type = text/html; body ~ “Welcome to nginx!”; }</h1><h1 id="status-is-not-one-of-301-302-303-or-307-and-header-does-not-have-“Refresh-”-match-not-redirect-status-301-303-307-header-Refresh"><a href="#status-is-not-one-of-301-302-303-or-307-and-header-does-not-have-“Refresh-”-match-not-redirect-status-301-303-307-header-Refresh" class="headerlink" title="status is not one of 301, 302, 303, or 307, and header does not have “Refresh:” match not_redirect { status ! 301-303 307; header ! Refresh; }"></a>status is not one of 301, 302, 303, or 307, and header does not have “Refresh:” match not_redirect { status ! 301-303 307; header ! Refresh; }</h1><h1 id="status-ok-and-not-in-maintenance-mode-match-server-ok-status-200-399-body-“maintenance-mode”"><a href="#status-ok-and-not-in-maintenance-mode-match-server-ok-status-200-399-body-“maintenance-mode”" class="headerlink" title="status ok and not in maintenance mode match server_ok { status 200-399; body !~ “maintenance mode”; }"></a>status ok and not in maintenance mode match server_ok { status 200-399; body !~ “maintenance mode”; }</h1></blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_conf_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_conf_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_conf_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-conf-module"><a href="#Module-ngx-http-upstream-conf-module" class="headerlink" title="Module ngx_http_upstream_conf_module"></a>Module ngx_http_upstream_conf_module</h2><p> Example Configuration<br> Directives<br> upstream_conf<br> ngx_http_upstream_conf_module模块允许通过简单的HTTP接口即时配置上游服务器组，而无需重新启动nginx。 http或流服务器组必须驻留在共享内存中。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供，直到1.13.10。 它被1.13.3中的ngx_http_api_module模块取代。 ####  示例配置</p>
<p>upstream backend { zone upstream_backend 64k; … } server { location /upstream_conf { <strong>upstream_conf</strong> ; allow 127.0.0.1; deny all; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>upstream_conf</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的上游配置的HTTP接口。 应限制访问此位置。 </p>
<p> 配置命令可用于： </p>
<ul>
<li>查看组配置; </li>
<li>查看，修改或删除服务器; </li>
<li>添加新服务器。 </li>
</ul>
<blockquote>
<p> 由于组中的地址不需要是唯一的，因此组中的特定服务器由其ID引用。 添加新服务器或查看组配置时，会自动分配ID并显示ID。  配置命令由作为请求参数传递的参数组成，例如： </p>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend</a>  支持以下参数： </p>
</blockquote>
<p> stream=   选择流上游服务器组。 如果没有此参数，请选择http上游服务器组。  upstream= <em>name</em>  选择要使用的组。 此参数是必需的。  id= <em>number</em>  选择用于查看，修改或删除的服务器。  remove=   从组中删除服务器。  add=   向组中添加新服务器。  backup=   需要添加备份服务器。 </p>
<blockquote>
<p> 在1.7.2版之前，还需要backup=来查看，修改或删除现有备份服务器。  server= <em>address</em>  与http或流上游服务器的“ address ”参数相同。  添加服务器时，可以将其指定为域名。 在这种情况下，将监视与域名对应的IP地址的更改并自动应用于上游配置，而无需重新启动nginx（1.7.2）。 这需要http或流块中的“ resolver ”指令。 另请参阅http或流上游服务器的“ resolve ”参数。 </p>
</blockquote>
<p> service= <em>name</em>  与http或流上游服务器的“ service ”参数相同（1.9.13）。  weight= <em>number</em>  与http或流上游服务器的“ weight ”参数相同。  max_conns= <em>number</em>  与http或流上游服务器的“ max_conns ”参数相同。  max_fails= <em>number</em>  与http或流上游服务器的“ max_fails ”参数相同。  fail_timeout= <em>time</em>  与http或流上游服务器的“ fail_timeout ”参数相同。  slow_start= <em>time</em>  与http或流上游服务器的“ slow_start ”参数相同。  down=   与http或流上游服务器的“ down ”参数相同。  drain=   将http上游服务器置于“排空”模式（1.7.5）。 在此模式下，只有绑定到服务器的请求才会被代理。  up=   与http或流上游服务器的“ down ”参数相反。  route= <em>string</em>  与http上游服务器的“ route ”参数相同。  前三个参数选择一个对象。 这可以是整个http或流上游服务器组，也可以是特定服务器。 如果没有其他参数，则会显示所选组或服务器的配置。 </p>
<p> 例如，要查看整个组的配置，请发送： </p>
<blockquote>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend</a>  要查看特定服务器的配置，还要指定其ID： </p>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42</a>  要添加新服务器，请在“ server= ”参数中指定其地址。 如果未指定其他参数，将添加服务器，并将其他参数设置为其默认值（请参阅http或流 “ server ”指令）。 </p>
</blockquote>
<p> 例如，要添加新的主服务器，请发送： </p>
<blockquote>
<p><a href="http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080</a>  要添加新的备份服务器，请发送： </p>
<p><a href="http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;backup=&amp;server=127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;backup=&amp;server=127.0.0.1:8080</a>  要添加新的主服务器，请将其参数设置为非默认值并将其标记为“ down ”，发送： </p>
<p><a href="http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080&amp;weight=2&amp;down=" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080&amp;weight=2&amp;down=</a>  要删除服务器，请指定其ID： </p>
<p><a href="http://127.0.0.1/upstream\_conf?remove=&amp;upstream=backend&amp;id=42" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?remove=&amp;upstream=backend&amp;id=42</a>  要将现有服务器标记为“ down ”，请发送： </p>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;down=" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;down=</a>  要修改现有服务器的地址，请发送： </p>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;server=192.0.2.3:8123" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;server=192.0.2.3:8123</a>  要修改现有服务器的其他参数，请发送： </p>
<p><a href="http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;max\_fails=3&amp;weight=4" target="_blank" rel="noopener">http://127.0.0.1/upstream\_conf?upstream=backend&amp;id=42&amp;max\_fails=3&amp;weight=4</a>  以上示例适用于http上游服务器组。 流上游服务器组的类似示例需要“ stream= ”参数。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_sub_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_sub_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_sub_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-sub-module"><a href="#Module-ngx-http-sub-module" class="headerlink" title="Module ngx_http_sub_module"></a>Module ngx_http_sub_module</h2><p> Example Configuration<br> Directives<br> sub_filter<br> sub_filter_last_modified<br> sub_filter_once<br> sub_filter_types<br> ngx_http_sub_module模块是一个过滤器，它通过将一个指定的字符串替换为另一个来修改响应。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_sub_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { sub_filter ‘&lt;a href=”<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a>‘ ‘&lt;a href=”<a href="https://$host/" target="_blank" rel="noopener">https://$host/</a>‘; sub_filter ‘&lt;img src=”<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a>‘ ‘&lt;img src=”<a href="https://$host/" target="_blank" rel="noopener">https://$host/</a>‘; sub_filter_once on; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>sub_filter</strong> <em>string</em> <em>replacement</em> ;<br>  Default:  —  Context:  http , server , location<br>  设置要替换的字符串和替换字符串。 忽略大小写匹配的字符串匹配。 要替换的字符串（1.9.4）和替换字符串可以包含变量。 可以在一个配置级别（1.9.4）上指定几个sub_filter指令。 当且仅当在当前级别上没有定义sub_filter指令时，这些指令才从前一级继承。 </p>
<p> Syntax:  <strong>sub_filter_last_modified</strong> on | off ;<br>  Default:  sub_filter_last_modified off;  Context:  http , server , location<br>  该指令出现在1.5.1版本中。 </p>
<p> 允许在替换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p> 默认情况下，在处理期间修改响应的内容时，将删除标头字段。 </p>
<p> Syntax:  <strong>sub_filter_once</strong> on | off ;<br>  Default:  sub_filter_once on;  Context:  http , server , location<br>  指示是查找要重复替换的每个字符串。 </p>
<p> Syntax:  <strong>sub_filter_types</strong> <em>mime-type</em> …;<br>  Default:  sub_filter_types text/html;  Context:  http , server , location<br>  除了“ text/html ”之外，还在具有指定MIME类型的响应中启用字符串替换。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_stub_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_stub_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_stub_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-stub-status-module"><a href="#Module-ngx-http-stub-status-module" class="headerlink" title="Module ngx_http_stub_status_module"></a>Module ngx_http_stub_status_module</h2><p> Example Configuration<br> Directives<br> stub_status<br> Data<br> Embedded Variables<br> ngx_http_stub_status_module模块提供对基本状态信息的访问。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_stub_status_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location = /basic_status { stub_status; }  此配置创建一个简单的网页，其基本状态数据可能如下所示： </p>
<p>Active connections: 291 server accepts handled requests 16630948 16630948 31070465 Reading: 6 Writing: 179 Waiting: 106 ####  指令</p>
</blockquote>
<p> Syntax:  <strong>stub_status</strong> ;<br>  Default:  —  Context:  server , location<br>  可从周围位置访问基本状态信息。 </p>
<blockquote>
<p> 在1.7.5之前的版本中，指令语法需要任意参数，例如“ stub_status on ”。 ####  数据</p>
</blockquote>
<p> 提供以下状态信息： </p>
<p> Active connections   当前活动客户端连接数，包括Waiting连接。  accepts   已接受的客户端连接总数。  handled   处理的连接总数。 通常，参数值与accept相同，除非已达到某些资源限制（例如， worker_connections限制）。  requests   客户端请求的总数。  Reading   nginx正在读取请求标头的当前连接数。  Writing   nginx将响应写回客户端的当前连接数。  Waiting   当前等待请求的空闲客户端连接数。 ####  嵌入式变量</p>
<p> ngx_http_stub_status_module模块支持以下嵌入变量（1.3.14）： </p>
<p> $connections_active   与Active connections值相同;  $connections_reading   与Reading值相同;  $connections_writing   与Writing值相同;  $connections_waiting   与Waiting值相同。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-status-module"><a href="#Module-ngx-http-status-module" class="headerlink" title="Module ngx_http_status_module"></a>Module ngx_http_status_module</h2><p> Example Configuration<br> Directives<br> status<br> status_format<br> status_zone<br> Data<br> Compatibility<br> ngx_http_status_module模块提供对各种状态信息的访问。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供，直到1.13.10。 它被1.13.3中的ngx_http_api_module模块取代。 ####  示例配置</p>
<p>http { upstream <strong>backend</strong> { <strong>zone</strong> http_backend 64k; server backend1.example.com weight=5; server backend2.example.com; } proxy_cache_path /data/nginx/cache_backend keys_zone= <strong>cache_backend</strong> :10m; server { server_name backend.example.com; location / { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_cache cache_backend; health_check; } <strong>status_zone server_backend;</strong> } server { listen 127.0.0.1; location /upstream_conf { upstream_conf; } location /status { status; } location = /status.html { } } } stream { upstream <strong>backend</strong> { <strong>zone</strong> stream_backend 64k; server backend1.example.com:12345 weight=5; server backend2.example.com:12345; } server { listen 127.0.0.1:12345; proxy_pass backend; <strong>status_zone server_backend;</strong> health_check; } }  使用此配置的状态请求示例： </p>
<p><a href="http://127.0.0.1/status" target="_blank" rel="noopener">http://127.0.0.1/status</a> <a href="http://127.0.0.1/status/nginx\_version" target="_blank" rel="noopener">http://127.0.0.1/status/nginx\_version</a> <a href="http://127.0.0.1/status/caches/cache\_backend" target="_blank" rel="noopener">http://127.0.0.1/status/caches/cache\_backend</a> <a href="http://127.0.0.1/status/upstreams" target="_blank" rel="noopener">http://127.0.0.1/status/upstreams</a> <a href="http://127.0.0.1/status/upstreams/backend" target="_blank" rel="noopener">http://127.0.0.1/status/upstreams/backend</a> <a href="http://127.0.0.1/status/upstreams/backend/peers/1" target="_blank" rel="noopener">http://127.0.0.1/status/upstreams/backend/peers/1</a> <a href="http://127.0.0.1/status/upstreams/backend/peers/1/weight" target="_blank" rel="noopener">http://127.0.0.1/status/upstreams/backend/peers/1/weight</a> <a href="http://127.0.0.1/status/stream" target="_blank" rel="noopener">http://127.0.0.1/status/stream</a> <a href="http://127.0.0.1/status/stream/upstreams" target="_blank" rel="noopener">http://127.0.0.1/status/stream/upstreams</a> <a href="http://127.0.0.1/status/stream/upstreams/backend" target="_blank" rel="noopener">http://127.0.0.1/status/stream/upstreams/backend</a> <a href="http://127.0.0.1/status/stream/upstreams/backend/peers/1" target="_blank" rel="noopener">http://127.0.0.1/status/stream/upstreams/backend/peers/1</a> <a href="http://127.0.0.1/status/stream/upstreams/backend/peers/1/weight" target="_blank" rel="noopener">http://127.0.0.1/status/stream/upstreams/backend/peers/1/weight</a>  简单监视页面随附此发行版一起提供，可在默认配置中以“ /status.html ”身份访问。 它需要配置位置“ /status ”和“ /status.html ”，如上所示。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>status</strong> ;<br>  Default:  —  Context:  location<br>  可以从周围的位置访问状态信息。 应限制访问此位置。 </p>
<p> Syntax:  <strong>status_format</strong> json ;<br> <strong>status_format</strong> jsonp [ <em>callback</em> ];<br>  Default:  status_format json;  Context:  http , server , location<br>  默认情况下，状态信息以JSON格式输出。 </p>
<p> 或者，数据可以输出为JSONP。 <em>callback</em>参数指定回调函数的名称。 该值可以包含变量。 如果省略参数，或者计算的值是空字符串，则使用“ ngx_status_jsonp_callback ”。 </p>
<p> Syntax:  <strong>status_zone</strong> <em>zone</em> ;<br>  Default:  —  Context:  server<br>  允许在指定<em>zone</em>收集虚拟http或流 （1.7.11）服务器状态信息。 多个服务器可能共享同一个区域。 </p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p> 提供以下状态信息： </p>
<p> version   提供的数据集的版本。 目前的版本是8。  nginx_version   nginx的版本。  nginx_build   nginx构建的名称。  address   接受状态请求的服务器的地址。  generation   配置重新加载的总数。  load_timestamp   上次重新加载配置的时间，自Epoch以来的毫秒数。  timestamp   Epoch以来的当前时间（以毫秒为单位）。  pid   处理状态请求的工作进程的ID。  ppid   启动工作进程的主进程的ID。  processes   respawned   异常终止和重生的子进程的总数。  connections   accepted   已接受的客户端连接总数。  dropped   已删除的客户端连接总数。  active   当前活动客户端连接数。  idle   当前空闲客户端连接数。  ssl   handshakes   成功的SSL握手总数。  handshakes_failed   失败的SSL握手总数。  session_reuses   SSL握手期间会话​​重用的总次数。  requests   total   客户端请求的总数。  current   当前的客户端请求数。  server_zones   对于每个status_zone ：  processing   当前正在处理的客户端请求数。  requests   从客户端收到的客户端请求总数。  responses   total   发送给客户端的响应总数。  1xx ， 2xx ， 3xx ， 4xx ， 5xx  状态代码为1xx，2xx，3xx，4xx和5xx的响应数。  discarded   未发送响应而完成的请求总数。  received   从客户端收到的总字节数。  sent   发送给客户端的总字节数。  slabs   对于使用slab分配器的每个共享内存区域：  pages   used   当前使用的内存页数。  free   当前可用内存页数。  slots   对于每个内存插槽大小（8,16,32,64,128等），提供以下数据：  used   当前使用的内存插槽数。  free   当前可用内存插槽的数量。  reqs   分配指定大小内存的总尝试次数。  fails   分配指定大小内存的尝试失败次数。  upstreams   对于每个动态可配置 组 ，提供以下数据：  peers   对于每个服务器 ，提供以下数据：  id   服务器的ID。  server   服务器的地址 。  name   server指令中指定的服务器名称。  service   server指令的服务参数值。  backup   一个布尔值，指示服务器是否为备份服务器。  weight   服务器的重量 。  state   当前状态，可以是“ up ”，“ draining ”，“ down ”，“ unavail ”，“ checking ”或“ unhealthy ”之一。  active   当前活动连接数。  max_conns   服务器的max_conns限制。  requests   转发到此服务器的客户端请求总数。  responses   total   从此服务器获取的响应总数。  1xx ， 2xx ， 3xx ， 4xx ， 5xx  状态代码为1xx，2xx，3xx，4xx和5xx的响应数。  sent   发送到此服务器的总字节数。  received   从此服务器接收的总字节数。  fails   与服务器通信失败的总次数。  unavail   由于尝试达到max_fails阈值的次数不成功，服务器因客户端请求（状态为“ unavail ”）而变为不可用的次数。  health_checks   checks   进行的健康检查请求总数。  fails   健康检查失败的次数。  unhealthy   服务器变得不健康的次数（状态“ unhealthy ”）。  last_passed   布尔值，指示上次运行状况检查请求是否成功并通过了测试 。  downtime   服务器处于“ unavail ”，“ checking ”和“ unhealthy ”状态的总时间。  downstart   服务器变为“ unavail ”，“ checking ”或“ unhealthy ”时的时间（自Epoch以来的毫秒数）。  selected   上次选择服务器处理请求时的时间（自Epoch以来的毫秒数）（1.7.5）。  header_time   从服务器获取响应头的平均时间（1.7.10）。 在1.11.6版之前，该字段仅在使用least_time负载平衡方法时可用。  response_time   从服务器获得完整响应的平均时间（1.7.10）。 在1.11.6版之前，该字段仅在使用least_time负载平衡方法时可用。  keepalive   当前空闲keepalive连接数。  zombies   从组中删除但仍处理活动客户端请求的当前服务器数。  zone   保持组配置和运行时状态的共享内存区域的名称。  queue   对于请求队列 ，提供以下数据：  size   队列中当前的请求数。  max_size   可以同时在队列中的最大请求数。  overflows   由于队列溢出而拒绝的请求总数。  caches   对于每个缓存（由proxy_cache_path等配置）：  size   缓存的当前大小。  max_size   配置中指定的高速缓存的最大大小限制。  cold   一个布尔值，指示“缓存加载器”进程是否仍在将数据从磁盘加载到缓存中。  hit ， stale ， updating ， revalidated  responses   从缓存中读取的响应总数（由于proxy_cache_use_stale等而导致的命中或过时响应）。  bytes   从缓存中读取的总字节数。  miss ， expired ， bypass  responses   未从缓存中获取的响应总数（由于proxy_cache_bypass等而导致的未命中，到期或绕过）。  bytes   从代理服务器读取的总字节数。  responses_written   写入缓存的响应总数。  bytes_written   写入缓存的总字节数。  stream   server_zones   对于每个status_zone ：  processing   当前正在处理的客户端连接数。  connections   从客户端接受的连接总数。  sessions   total   已完成的客户会话总数。  2xx ， 4xx ， 5xx  已完成的会话数， 状态代码为 2xx，4xx或5xx。  discarded   在不创建会话的情况下完成的连接总数。  received   从客户端收到的总字节数。  sent   发送给客户端的总字节数。  upstreams   对于每个动态可配置 组 ，提供以下数据：  peers   对于每个服务器 ，提供以下数据：  id   服务器的ID。  server   服务器的地址 。  name   server指令中指定的服务器名称。  service   server指令的服务参数值。  backup   一个布尔值，指示服务器是否为备份服务器。  weight   服务器的重量 。  state   当前状态，可以是“ up ”，“ down ”，“ unavail ”，“ checking ”或“ unhealthy ”之一。  active   当前的连接数。  max_conns   服务器的max_conns限制。  connections   转发到此服务器的客户端连接总数。  connect_time   连接上游服务器的平均时间。 在1.11.6版之前，该字段仅在使用least_time负载平衡方法时可用。  first_byte_time   接收第一个数据字节的平均时间。 在1.11.6版之前，该字段仅在使用least_time负载平衡方法时可用。  response_time   接收最后一个数据字节的平均时间。 在1.11.6版之前，该字段仅在使用least_time负载平衡方法时可用。  sent   发送到此服务器的总字节数。  received   从此服务器接收的总字节数。  fails   与服务器通信失败的总次数。  unavail   由于尝试达到max_fails阈值的次数不成功，服务器无法进行客户端连接（状态为“ unavail ”）的次数。  health_checks   checks   进行的健康检查请求总数。  fails   健康检查失败的次数。  unhealthy   服务器变得不健康的次数（状态“ unhealthy ”）。  last_passed   布尔值，指示上次运行状况检查请求是否成功并通过了测试 。  downtime   服务器处于“ unavail ”，“ checking ”和“ unhealthy ”状态的总时间。  downstart   服务器变为“ unavail ”，“ checking ”或“ unhealthy ”时的时间（自Epoch以来的毫秒数）。  selected   上次选择服务器以处理连接时的时间（自Epoch以来的毫秒数）。  zombies   当前从组中删除但仍处理活动客户端连接的服务器数。  zone   保持组配置和运行时状态的共享内存区域的名称。 ####  兼容性</p>
<ul>
<li>版本 8中添加了http和流上游中的区域字段。 </li>
<li>版本 8中添加了slab状态数据。 </li>
<li>版本 8中添加了检查状态。 </li>
<li>版本 8中添加了http和流上游中的名称和服务字段。 </li>
<li>版本 8中添加了nginx_build和ppid字段。 </li>
<li>版本 7中添加了会话状态数据和流server_zones中的丢弃字段。 </li>
<li>僵尸字段是从版本 6中的nginx 调试版本移动的。 </li>
<li>版本 6中添加了ssl状态数据。 </li>
<li>server_zones中的丢弃字段已在版本 6中添加。 </li>
<li>队列状态数据已在版本 6中添加。 </li>
<li>pid字段已在版本 6中添加。 </li>
<li>上游中的服务器列表已移至版本 6中的对等项 。 </li>
<li>在版本 5中删除了上游服务器的keepalive字段。 </li>
<li>流状态数据已在版本 5中添加。 </li>
<li>生成字段已在版本 5中添加。 </li>
<li>进程中重新生成的字段已在版本 5中添加。 </li>
<li>版本 5中添加了上游中的header_time和response_time字段。 </li>
<li>版本 4中添加了上游中的选定字段。 </li>
<li>版本 4中添加了上游的排水状态。 </li>
<li>上游中的id和max_conns字段已在版本 3中添加。 </li>
<li>版本 3中添加了缓存中revalidated字段。 </li>
<li>版本 2中添加了server_zones ， caches和load_timestamp状态数据。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssl-module"><a href="#Module-ngx-http-ssl-module" class="headerlink" title="Module ngx_http_ssl_module"></a>Module ngx_http_ssl_module</h2><p> Example Configuration<br> Directives<br> ssl<br> ssl_buffer_size<br> ssl_certificate<br> ssl_certificate_key<br> ssl_ciphers<br> ssl_client_certificate<br> ssl_crl<br> ssl_dhparam<br> ssl_early_data<br> ssl_ecdh_curve<br> ssl_password_file<br> ssl_prefer_server_ciphers<br> ssl_protocols<br> ssl_session_cache<br> ssl_session_ticket_key<br> ssl_session_tickets<br> ssl_session_timeout<br> ssl_stapling<br> ssl_stapling_file<br> ssl_stapling_responder<br> ssl_stapling_verify<br> ssl_trusted_certificate<br> ssl_verify_client<br> ssl_verify_depth<br> Error Processing<br> Embedded Variables<br> ngx_http_ssl_module模块为HTTPS提供必要的支持。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_ssl_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要OpenSSL库。 ####  示例配置</p>
</blockquote>
<p> 为减少处理器负载，建议使用 </p>
<ul>
<li>设置工作进程数等于处理器数， </li>
<li>启用保持活动连接， </li>
<li>启用共享会话缓存， </li>
<li>禁用内置会话缓存， </li>
<li>并可能增加会话生命周期 （默认为5分钟）： </li>
</ul>
<blockquote>
<p> <strong>worker_processes auto;</strong> http { … server { listen 443 ssl; <strong>keepalive_timeout 70;</strong> ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5; ssl_certificate /usr/local/nginx/conf/cert.pem; ssl_certificate_key /usr/local/nginx/conf/cert.key; <strong>ssl_session_cache shared:SSL:10m;</strong> <strong>ssl_session_timeout 10m;</strong> … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ssl</strong> on | off ;<br>  Default:  ssl off;  Context:  http , server<br>  该指令在1.15.0版本中已过时。 应该使用listen指令的ssl参数。 </p>
<p> Syntax:  <strong>ssl_buffer_size</strong> <em>size</em> ;<br>  Default:  ssl_buffer_size 16k;  Context:  http , server<br>  该指令出现在1.5.9版本中。 </p>
<p> 设置用于发送数据的缓冲区的大小。 </p>
<p> 默认情况下，缓冲区大小为16k，这对应于发送大响应时的最小开销。 要最小化第一个字节的时间，使用较小的值可能是有益的，例如： </p>
<blockquote>
<p>ssl_buffer_size 4k;  Syntax:  <strong>ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  指定具有给定虚拟服务器的PEM格式的证书的<em>file</em> 。 如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。 PEM格式的密钥可以放在同一文件中。 </p>
</blockquote>
<p> 从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<blockquote>
<p>server { listen 443 ssl; server_name example.com; ssl_certificate example.com.rsa.crt; ssl_certificate_key example.com.rsa.key; ssl_certificate example.com.ecdsa.crt; ssl_certificate_key example.com.ecdsa.key; … }<br> 只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链 。 对于旧版本，只能使用一个证书链。  应该记住，由于HTTPS协议对最大互操作性的限制，虚拟服务器应该监听不同的IP地址 。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  指定具有给定虚拟服务器的PEM格式的密钥的<em>file</em> 。 </p>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> （1.7.9），该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  ssl_ciphers HIGH:!aNULL:!MD5;  Context:  http , server<br>  指定启用的密码。 密码以OpenSSL库理解的格式指定，例如： </p>
<blockquote>
<p>ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;  可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> 以前版本的nginx默认使用不同的密码。  Syntax:  <strong>ssl_client_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  如果启用了ssl_stapling，则指定具有PEM格式的可信CA证书的<em>file</em> ，该证书用于验证客户端证书和OCSP响应。 </p>
</blockquote>
<p> 证书列表将发送给客户。 如果不需要，可以使用ssl_trusted_certificate指令。 </p>
<p> Syntax:  <strong>ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在0.8.7版本中。 </p>
<p> 指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证客户端证书。 </p>
<p> Syntax:  <strong>ssl_dhparam</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在0.7.2版本中。 </p>
<p> 为DHE密码指定具有DH参数的<em>file</em> 。 </p>
<p> 默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p> 在1.11.0版之前，默认使用内置参数。  Syntax:  <strong>ssl_early_data</strong> on | off ;<br>  Default:  ssl_early_data off;  Context:  http , server<br>  该指令出现在1.15.3版中。 </p>
</blockquote>
<p> 启用或禁用TLS 1.3 早期数据 。 </p>
<blockquote>
<p> 在早期数据中发送的请求会受到重播攻击 。 为了防止应用程序层发生此类攻击，应使用$ ssl_early_data变量。<br>proxy_set_header Early-Data $ssl_early_data;<br> 使用OpenSSL 1.1.1或更高版本（1.15.4）和BoringSSL时，支持该指令。  Syntax:  <strong>ssl_ecdh_curve</strong> <em>curve</em> ;<br>  Default:  ssl_ecdh_curve auto;  Context:  http , server<br>  该指令出现在1.1.0和1.0.6版本中。 </p>
</blockquote>
<p> 指定ECDHE密码的<em>curve</em> 。 </p>
<p> 使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<blockquote>
<p>ssl_ecdh_curve prime256v1:secp384r1;  特殊值auto （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的prime256v1 。 </p>
<p> 在版本1.11.0之前，默认使用prime256v1曲线。  Syntax:  <strong>ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在1.7.3版本中。 </p>
</blockquote>
<p> 指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> 例： </p>
<blockquote>
<p>http { ssl_password_file /etc/keys/global.pass; … server { server_name www1.example.com; ssl_certificate_key /etc/keys/first.key; } server { server_name www2.example.com; # named pipe can also be used instead of a file ssl_password_file /etc/keys/fifo; ssl_certificate_key /etc/keys/second.key; } }  Syntax:  <strong>ssl_prefer_server_ciphers</strong> on | off ;<br>  Default:  ssl_prefer_server_ciphers off;  Context:  http , server<br>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  http , server<br>  启用指定的协议。 </p>
<blockquote>
<p> TLSv1.1和TLSv1.2参数（ TLSv1.2 ）仅在使用OpenSSL 1.0.1或更高版本时有效。<br> 仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， TLSv1.3参数（1.13.0）才有效。  Syntax:  <strong>ssl_session_cache</strong> off | none | [ builtin [: <em>size</em> ]] [ shared : <em>name</em> : <em>size</em> ];<br>  Default:  ssl_session_cache none;  Context:  http , server<br>  设置存储会话参数的缓存的类型和大小。 缓存可以是以下任何类型： </p>
</blockquote>
<p> off   严格禁止使用会话缓存：nginx明确告诉客户端会话可能不会被重用。  none   轻轻地禁止使用会话缓存：nginx告诉客户端会话可以重用，但实际上并不会将会话参数存储在缓存中。  builtin   一个用OpenSSL构建的缓存; 仅由一个工作进程使用。 缓存大小在会话中指定。 如果未给出大小，则等于20480个会话。 使用内置缓存可能会导致内存碎片。  shared   所有工作进程之间共享的缓存。 高速缓存大小以字节为单位指定; 一兆字节可以存储大约4000个会话。 每个共享缓存都应具有任意名称。 可以在多个虚拟服务器中使用具有相同名称的缓存。  两种缓存类型可以同时使用，例如： </p>
<blockquote>
<p>ssl_session_cache builtin:1000 shared:SSL:10m;  但只使用没有内置缓存的共享缓存应该更有效。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_ticket_key</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在1.5.7版本中。 </p>
<p> 设置具有用于加密和解密TLS会话票证的密钥的<em>file</em> 。 如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。 默认情况下，使用随机生成的密钥。 </p>
<p> 如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。 这允许配置键旋转，例如： </p>
<blockquote>
<p>ssl_session_ticket_key current.key; ssl_session_ticket_key previous.key;  该<em>file</em>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<p>openssl rand 80 &gt; ticket.key  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_session_tickets</strong> on | off ;<br>  Default:  ssl_session_tickets on;  Context:  http , server<br>  该指令出现在1.5.9版本中。 </p>
<p> 通过TLS会话票证启用或禁用会话恢复。 </p>
<p> Syntax:  <strong>ssl_session_timeout</strong> <em>time</em> ;<br>  Default:  ssl_session_timeout 5m;  Context:  http , server<br>  指定客户端可以重用会话参数的时间。 </p>
<p> Syntax:  <strong>ssl_stapling</strong> on | off ;<br>  Default:  ssl_stapling off;  Context:  http , server<br>  该指令出现在1.3.7版本中。 </p>
<p> 启用或禁用服务器对OCSP响应的装订 。 例： </p>
<blockquote>
<p>ssl_stapling on; resolver 192.0.2.1;  要使OCSP装订起作用，应该知道服务器证书颁发者的证书。 如果ssl_certificate文件不包含中间证书，则服务器证书颁发者的证书应存在于ssl_trusted_certificate文件中。 </p>
</blockquote>
<p> 要解析OCSP响应程序主机名，还应指定解析程序指令。 </p>
<p> Syntax:  <strong>ssl_stapling_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在1.3.7版本中。 </p>
<p> 设置后，将从指定的<em>file</em>获取装订的OCSP响应，而不是查询服务器证书中指定的OCSP响应程序。 </p>
<p> 该文件应为DER格式，由“ openssl ocsp ”命令生成。 </p>
<p> Syntax:  <strong>ssl_stapling_responder</strong> <em>url</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在1.3.7版本中。 </p>
<p> 覆盖“ Authority Information Access ”证书扩展中指定的OCSP响应程序的URL。 </p>
<p> 仅支持“ http:// ”OCSP响应者： </p>
<blockquote>
<p>ssl_stapling_responder <a href="http://ocsp.example.com/" target="_blank" rel="noopener">http://ocsp.example.com/</a>;  Syntax:  <strong>ssl_stapling_verify</strong> on | off ;<br>  Default:  ssl_stapling_verify off;  Context:  http , server<br>  该指令出现在1.3.7版本中。 </p>
</blockquote>
<p> 启用或禁用服务器对OCSP响应的验证。 </p>
<p> 要使验证生效，应使用ssl_trusted_certificate指令将服务器证书颁发者的证书，根证书和所有中间证书配置为受信任。 </p>
<p> Syntax:  <strong>ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server<br>  该指令出现在1.3.7版本中。 </p>
<p> 如果启用了ssl_stapling，则指定具有PEM格式的可信CA证书的<em>file</em> ，该证书用于验证客户端证书和OCSP响应。 </p>
<p> 与ssl_client_certificate设置的证书不同 ，这些证书的列表不会发送给客户端。 </p>
<p> Syntax:  <strong>ssl_verify_client</strong> on | off | optional | optional_no_ca ;<br>  Default:  ssl_verify_client off;  Context:  http , server<br>  启用客户端证书验证。 验证结果存储在$ ssl_client_verify变量中。 </p>
<p> optional参数（0.8.7+）请求客户端证书，并在证书存在时验证它。 </p>
<p> optional_no_ca参数（1.3.8,1.2.5）请求客户端证书，但不要求它由受信任的CA证书签名。 这适用于nginx外部的服务执行实际证书验证的情况。 可以通过$ ssl_client_cert变量访问证书的内容。 </p>
<p> Syntax:  <strong>ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  ssl_verify_depth 1;  Context:  http , server<br>  设置客户端证书链中的验证深度。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p> ngx_http_ssl_module模块支持几个非标准错误代码，可以使用error_page指令用于重定向： </p>
<p> 495  客户端证书验证期间发生错误;  496  客户未提交所需证书;  497  已将常规请求发送到HTTPS端口。  重定向发生在完全解析请求并且变量（例如$request_uri ， $uri ， $args和其他变量）可用之后。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_ssl_module模块支持几个嵌入变量： </p>
<p> $ssl_cipher   返回用于建立的SSL连接的密码字符串;  $ssl_ciphers   返回客户端支持的密码列表（1.11.7）。 已知密码按名称列出，未知以十六进制显示，例如： </p>
<blockquote>
<p>AES128-SHA:AES256-SHA:0x00ff<br> 仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。 对于旧版本，该变量仅适用于新会话，仅列出已知密码。  $ssl_client_escaped_cert   以PEM格式（urlencoded）返回已建立SSL连接的客户端证书（1.13.5）;  $ssl_client_cert   为已建立的SSL连接返回PEM格式的客户端证书，除了第一行前面的每一行都带有制表符; 这适用于proxy_set_header指令;<br> 不推荐使用该变量，应该使用$ssl_client_escaped_cert变量。  $ssl_client_fingerprint   返回已建立SSL连接的客户端证书的SHA1指纹（1.7.1）;  $ssl_client_i_dn   根据RFC 2253 （1.11.6），为已建立的SSL连接返回客户端证书的“issuer DN”字符串;  $ssl_client_i_dn_legacy   返回已建立SSL连接的客户端证书的“issuer DN”字符串;<br> 在1.11.6版之前，变量名称为$ssl_client_i_dn 。  $ssl_client_raw_cert   返回已建立SSL连接的PEM格式的客户端证书;  $ssl_client_s_dn   根据RFC 2253 （1.11.6），为已建立的SSL连接返回客户端证书的“subject DN”字符串;  $ssl_client_s_dn_legacy   返回已建立SSL连接的客户端证书的“subject DN”字符串;<br> 在1.11.6版之前，变量名称为$ssl_client_s_dn 。  $ssl_client_serial   返回已建立的SSL连接的客户端证书的序列号;  $ssl_client_v_end   返回客户端证书的结束日期（1.11.7）;  $ssl_client_v_remain   返回客户端证书到期前的天数（1.11.7）;  $ssl_client_v_start   返回客户端证书的开始日期（1.11.7）;  $ssl_client_verify   返回客户端证书验证的结果：“ SUCCESS ”，“ FAILED: <em>reason</em> ”，如果证书不存在则返回“ NONE ”;<br> 在1.11.7版之前，“ FAILED ”结果不包含<em>reason</em>字符串。  $ssl_curves   返回客户端支持的曲线列表（1.11.7）。 已知曲线按名称列出，未知以十六进制显示，例如：<br>0x001d:prime256v1:secp521r1:secp384r1<br> 仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。 对于旧版本，变量值将为空字符串。<br> 该变量仅适用于新会话。  $ssl_early_data   如果使用TLS 1.3 早期数据并且握手未完成则返回“ 1 ”，否则返回“”（1.15.3）。  $ssl_protocol   返回已建立的SSL连接的协议;  $ssl_server_name   返回通过SNI （1.7.0）请求的服务器名称;  $ssl_session_id   返回已建立的SSL连接的会话标识;  $ssl_session_reused   如果重用SSL会话，则返回“ r ”，或“ . “否则（1.5.11）。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssi-module"><a href="#Module-ngx-http-ssi-module" class="headerlink" title="Module ngx_http_ssi_module"></a>Module ngx_http_ssi_module</h2><p> Example Configuration<br> Directives<br> ssi<br> ssi_last_modified<br> ssi_min_file_chunk<br> ssi_silent_errors<br> ssi_types<br> ssi_value_length<br> SSI Commands<br> Embedded Variables<br> ngx_http_ssi_module模块是一个过滤器，用于处理通过它的响应中的SSI（服务器端包含）命令。 目前，支持的SSI命令列表不完整。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { ssi on; … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ssi</strong> on | off ;<br>  Default:  ssi off;  Context:  http , server , location , if in location<br>  启用或禁用响应中SSI命令的处理。 </p>
<p> Syntax:  <strong>ssi_last_modified</strong> on | off ;<br>  Default:  ssi_last_modified off;  Context:  http , server , location<br>  该指令出现在1.5.1版本中。 </p>
<p> 允许在SSI处理期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p> 默认情况下，在处理过程中修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p> Syntax:  <strong>ssi_min_file_chunk</strong> size ;<br>  Default:  ssi_min_file_chunk 1k;  Context:  http , server , location<br>  设置存储在磁盘上的响应部分的最小<em>size</em> ，从使用sendfile发送它们开始是有意义的。 </p>
<p> Syntax:  <strong>ssi_silent_errors</strong> on | off ;<br>  Default:  ssi_silent_errors off;  Context:  http , server , location<br>  如果启用，则在SSI处理期间发生[an error occurred while processing the directive] ，禁止输出“ [an error occurred while processing the directive] ”字符串。 </p>
<p> Syntax:  <strong>ssi_types</strong> <em>mime-type</em> …;<br>  Default:  ssi_types text/html;  Context:  http , server , location<br>  除了“ text/html ”之外，还可以在具有指定MIME类型的响应中处理SSI命令。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 </p>
<p> Syntax:  <strong>ssi_value_length</strong> <em>length</em> ;<br>  Default:  ssi_value_length 256;  Context:  http , server , location<br>  设置SSI命令中参数值的最大长度。 </p>
<h4 id="SSI命令"><a href="#SSI命令" class="headerlink" title="SSI命令"></a>SSI命令</h4><p> SSI命令具有以下通用格式： </p>
<blockquote>
<p><!--# command parameter1=value1 parameter2=value2 ... -->  支持以下命令： </p>
</blockquote>
<p> block   定义可在include命令中用作存根的块。 该块可以包含其他SSI命令。 该命令具有以下参数：  name   块名称。  例： </p>
<blockquote>
<!--# block name="one" --> stub <!--# endblock -->  config   设置SSI处理期间使用的一些参数，即：  errmsg   在SSI处理期间发生错误时输出的字符串。 默认情况下，输出以下字符串：<br>[an error occurred while processing the directive]  timefmt   传递给strftime()函数的格式字符串，用于输出日期和时间。 默认情况下，使用以下格式：<br>“%A, %d-%b-%Y %H:%M:%S %Z”  “ %s ”格式适合以秒为单位输出时间。  echo   输出变量的值。 该命令具有以下参数：  var   变量名称。  encoding   编码方法。 可能的值包括none ， url和entity 。 默认情况下，使用entity 。  default   一个非标准参数，如果未定义变量，则设置要输出的字符串。 默认情况下，输出“ (none) ”。 命令<br><!--# echo var="name" default=" **no** " -->  替换以下命令序列：<br><!--# if expr="$name" --><!--# echo var="name" --><!--# else --> <strong>no</strong> <!--# endif -->  if   执行条件包含。 支持以下命令：<br><!--# if expr="..." --> … <!--# elif expr="..." --> … <!--# else --> … <!--# endif -->  目前仅支持一级嵌套。 该命令具有以下参数：  expr   表达。 表达式可以是： *  变量存在检查：<br><!--# if expr="$name" --> 
<ul>
<li>变量与文本的比较： <!--# if expr="$name = *text* " --> <!--# if expr="$name != *text* " --> </li>
<li>变量与正则表达式的比较： <!--# if expr="$name = / *text* /" --> <!--# if expr="$name != / *text* /" --> 
如果<em>text</em>包含变量，则替换它们的值。 正则表达式可以包含以后可以通过变量使用的位置和命名捕获，例如：<br><!--# if expr="$name = /(.+)@(?P<domain>.+)/" --> <!--# echo var="1" --> <!--# echo var="domain" --> <!--# endif -->  include   将另一个请求的结果包含在响应中。 该命令具有以下参数：  file   指定包含的文件，例如：<br><!--# include file="footer.html" -->  virtual   指定包含的请求，例如：<br><!--# include virtual="/remote/body.php?argument=value" -->  在一个页面上指定并由代理或FastCGI / uwsgi / SCGI / gRPC服务器处理的多个请求并行运行。 如果需要顺序处理，则应使用wait参数。  stub   一个非标准参数，用于命名块，如果包含的请求导致空体或在请求处理期间发生错误，则将输出其内容，例如：<br><!--# block name="one" -->&nbsp;<!--# endblock --> <!--# include virtual="/remote/body.php?argument=value" stub="one" -->  替换块内容在包含的请求上下文中处理。  wait   一个非标准参数，指示在继续进行SSI处理之前等待请求完全完成，例如：<br><!--# include virtual="/remote/body.php?argument=value" wait="yes" -->  set   一个非标准参数，指示将请求处理的成功结果写入指定变量，例如：<br><!--# include virtual="/remote/body.php?argument=value" set="one" -->  响应的最大大小由subrequest_output_buffer_size指令（1.13.10）设置：<br>location /remote/ { subrequest_output_buffer_size 64k; … }  在版本1.13.10之前，只有使用ngx_http_proxy_module ， ngx_http_memcached_module ， ngx_http_fastcgi_module （1.5.6）， ngx_http_uwsgi_module （1.5.6）和ngx_http_scgi_module （1.5.6）模块获得的响应结果才能写入变量。 响应的最大大小是使用proxy_buffer_size ， memcached_buffer_size ， fastcgi_buffer_size ， uwsgi_buffer_size和scgi_buffer_size指令设置的。  set   设置变量的值。 该命令具有以下参数：  var   变量名称。  value   变量值。 如果指定的值包含变量，则替换它们的值。 ####  嵌入式变量</li>
</ul>
</blockquote>
<p> ngx_http_ssi_module模块支持两个嵌入变量： </p>
<p> $date_local   当地时区的当前时间。 该格式由config命令和timefmt参数设置。  $date_gmt   格林威治标准时间当前时间 该格式由config命令和timefmt参数设置。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-split-clients-module"><a href="#Module-ngx-http-split-clients-module" class="headerlink" title="Module ngx_http_split_clients_module"></a>Module ngx_http_split_clients_module</h2><p> Example Configuration<br> Directives<br> split_clients<br> ngx_http_split_clients_module模块创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>http { split_clients “${remote_addr}AAA” $variant { 0.5% .one; 2.0% .two; * “”; } server { location / { index index${variant}.html; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>split_clients</strong> <em>string</em> <em>$variable</em> { … }<br>  Default:  —  Context:  http<br>  为A / B测试创建变量，例如： </p>
<blockquote>
<p>split_clients “${remote_addr}AAA” $variant { 0.5% .one; 2.0% .two; * “”; }  使用MurmurHash2对原始字符串的值进行哈希处理。 在给出的示例中，从0到21474835（0.5％）的哈希值对应于$variant变量的值”.one” ，从21474836到107374180（2％）的哈希值对应于值”.two”和哈希值从107374181到4294967295的值对应于值”” （空字符串）。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_spdy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_spdy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_spdy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-spdy-module"><a href="#Module-ngx-http-spdy-module" class="headerlink" title="Module ngx_http_spdy_module"></a>Module ngx_http_spdy_module</h2><p> Known Issues<br> Example Configuration<br> Directives<br> spdy_chunk_size<br> spdy_headers_comp<br> Embedded Variables<br> ngx_http_spdy_module模块为SPDY提供实验支持。 目前，已实施SPDY协议草案3.1 。 </p>
<blockquote>
<p> 在1.5.10版之前，实施了SPDY协议草案2 。  默认情况下不构建此模块，应使用–with-http_spdy_module配置参数启用它。 </p>
<p> 该模块已被1.9.5中的ngx_http_v2_module模块取代。 ####  已知的问题</p>
</blockquote>
<p> 该模块是实验性的，需要注意的是经纪人。 </p>
<p> SPDY协议的当前实现不支持“服务器推送”。 </p>
<p> 在1.5.9之前的版本中，SPDY连接中的响应不能受速率限制 。 </p>
<p> 无论proxy_request_buffering ， fastcgi_request_buffering ， uwsgi_request_buffering和scgi_request_buffering指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { listen 443 ssl spdy; ssl_certificate server.crt; ssl_certificate_key server.key; … }<br> 请注意，为了在同一端口上同时接受HTTPS和SPDY连接，所使用的OpenSSL库应支持“Next Protocol Negotiation”TLS扩展，自Ope​​nSSL 1.0.1版开始可用。 ####  指令</p>
</blockquote>
<p> Syntax:  <strong>spdy_chunk_size</strong> <em>size</em> ;<br>  Default:  spdy_chunk_size 8k;  Context:  http , server , location<br>  该指令出现在1.5.9版本中。 </p>
<p> 设置响应主体被切片到的块的最大大小。 值太低会导致更高的开销。 由于HOL阻塞，太高的值会损害优先级。 </p>
<p> Syntax:  <strong>spdy_headers_comp</strong> <em>level</em> ;<br>  Default:  spdy_headers_comp 0;  Context:  http , server<br>  设置响应的标头压缩<em>level</em> ，范围从1（最快，压缩程度较低）到9（最慢，最佳压缩）。 特殊值0关闭标头压缩。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_spdy_module模块支持以下嵌入变量： </p>
<p> $spdy   SPDY连接的SPDY协议版本，否则为空字符串;  $spdy_request_priority   请求SPDY连接的优先级，否则请求空字符串。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_slice_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_slice_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_slice_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-slice-module"><a href="#Module-ngx-http-slice-module" class="headerlink" title="Module ngx_http_slice_module"></a>Module ngx_http_slice_module</h2><p> Example Configuration<br> Directives<br> slice<br> Embedded Variables<br> ngx_http_slice_module模块（1.9.8）是一个过滤器，它将请求拆分为子请求，每个子请求都返回一定范围的响应。 过滤器提供更有效的大响应缓存。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_slice_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { <strong>slice</strong> 1m; proxy_cache cache; proxy_cache_key $uri$is_args$args <strong>$slice_range</strong> ; proxy_set_header Range <strong>$slice_range</strong> ; proxy_cache_valid 200 206 1h; proxy_pass <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a>; }  在此示例中，响应被拆分为1兆字节的可缓存切片。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>slice</strong> <em>size</em> ;<br>  Default:  slice 0;  Context:  http , server , location<br>  设置切片的<em>size</em> 。 零值禁用将响应拆分为切片。 请注意，值太低可能会导致内存使用过多并打开大量文件。 </p>
<p> 为了使子请求返回所需的范围， $slice_range变量应作为Range请求头字段传递给代理服务器。 如果启用了缓存 ，则应将$slice_range添加到缓存键，并启用具有206状态代码的响应缓存。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_slice_module模块支持以下嵌入变量： </p>
<p> $slice_range   HTTP字节范围格式的当前切片范围，例如， bytes=0-1048575 。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_session_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_session_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_session_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-session-log-module"><a href="#Module-ngx-http-session-log-module" class="headerlink" title="Module ngx_http_session_log_module"></a>Module ngx_http_session_log_module</h2><p> Example Configuration<br> Directives<br> session_log<br> session_log_format<br> session_log_zone<br> Embedded Variables<br> ngx_http_session_log_module模块启用日志记录会话（即多个HTTP请求的聚合），而不是单个HTTP请求。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
</blockquote>
<p> 以下配置根据请求客户端地址和“User-Agent”请求标头字段设置会话日志并将请求映射到会话： </p>
<blockquote>
<p> session_log_zone /path/to/log format=combined zone=one:1m timeout=30s md5=$binary_remote_addr$http_user_agent; location /media/ { session_log one; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>session_log</strong> <em>name</em> | off ;<br>  Default:  session_log off;  Context:  http , server , location<br>  允许使用指定的会话日志。 特殊值off取消从先前配置级别继承的所有session_log指令。 </p>
<p> Syntax:  <strong>session_log_format</strong> <em>name</em> <em>string</em> …;<br>  Default:  session_log_format combined “…”;  Context:  http<br>  指定日志的输出格​​式。 $body_bytes_sent变量的值在会话中的所有请求中聚合。 可用于记录的所有其他变量的值对应于会话中的第一个请求。 </p>
<p> Syntax:  <strong>session_log_zone</strong> <em>path</em> zone = <em>name</em> : <em>size</em> [ format = <em>format</em> ] [ timeout = <em>time</em> ] [ id = <em>id</em> ] [ md5 = <em>md5</em> ] ;<br>  Default:  —  Context:  http<br>  设置日志文件的路径，并配置用于存储当前活动会话的共享内存区域。 </p>
<p> 只要会话中的最后一个请求自指定timeout （默认为30秒）以来经过的时间，会话就被视为活动状态。 会话不再处于活动状态时，会将其写入日志。 </p>
<p> id参数标识请求映射到的会话。 id参数设置为MD5哈希的十六进制表示（例如，使用变量从cookie获取）。 如果未指定此参数或不表示有效的MD5哈希，则nginx将根据md5参数的值计算MD5哈希，并使用此哈希创建新会话。 id和md5参数都可以包含变量。 </p>
<p> format参数设置session_log_format指令配置的自定义会话日志格式。 如果未指定format，则使用预定义的“ combined ”格式。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_session_log_module模块支持两个嵌入变量： </p>
<p> $session_log_id   当前会话ID;  $session_log_binary_id   二进制形式的当前会话ID（16字节）。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_secure_link_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_secure_link_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_secure_link_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-secure-link-module"><a href="#Module-ngx-http-secure-link-module" class="headerlink" title="Module ngx_http_secure_link_module"></a>Module ngx_http_secure_link_module</h2><p> Directives<br> secure_link<br> secure_link_md5<br> secure_link_secret<br> Embedded Variables<br> ngx_http_secure_link_module模块（0.7.18）用于检查请求链路的真实性，保护资源免受未经授权的访问，并限制链路生存期。 </p>
<p> 通过将请求中传递的校验和值与为请求计算的值进行比较来验证所请求链接的真实性。 如果链接的生命周期有限且时间已过，则该链接将被视为过时。 这些检查的状态在$secure_link变量中可用。 </p>
<p> 该模块提供两种备选操作模式。 第一种模式由secure_link_secret指令启用，用于检查请求链接的真实性以及保护资源免受未经授权的访问。 第二种模式（0.8.50）由secure_link和secure_link_md5指令启用，也用于限制链接的生命周期。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_secure_link_module配置参数启用它。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>secure_link</strong> <em>expression</em> ;<br>  Default:  —  Context:  http , server , location<br>  定义一个包含变量的字符串，从中提取链接的校验和值和生命周期。 </p>
<p> <em>expression</em>中使用的变量通常与请求相关联; 见下面的例子 。 </p>
<p> 将从字符串中提取的校验和值与secure_link_md5指令定义的表达式的MD5哈希值进行比较。 如果校验和不同，则$secure_link变量设置为空字符串。 如果校验和相同，则检查链路生存期。 如果链接的生命周期有限且时间已过，则$secure_link变量设置为“ 0 ”。 否则，它被设置为“ 1 ”。 请求中传递的MD5哈希值在base64url中编码。 </p>
<p> 如果链接的生命周期有限，则到期时间设置为自Epoch（Thu，1970年1月1日1970:00 00:00:00 GMT）以来的秒数。 该值在MD5哈希之后的表达式中指定，并以逗号分隔。 请求中传递的到期时间可通过$secure_link_expires变量获得，以便在secure_link_md5指令中使用。 如果未指定到期时间，则链接具有无限生存期。 </p>
<p> Syntax:  <strong>secure_link_md5</strong> <em>expression</em> ;<br>  Default:  —  Context:  http , server , location<br>  定义将为其计算MD5哈希值并与请求中传递的值进行比较的表达式。 </p>
<p> 表达式应包含链接（资源）和秘密成分的安全部分。 如果链接的生命周期有限，则表达式还应包含$secure_link_expires 。 </p>
<p> 为防止未经授权的访问，表达式可能包含有关客户端的一些信息，例如其地址和浏览器版本。 </p>
<p> 例： </p>
<blockquote>
<p>location /s/ { secure_link $arg_md5,$arg_expires; secure_link_md5 “$secure_link_expires$uri$remote_addr secret”; if ($secure_link = “”) { return 403; } if ($secure_link = “0”) { return 410; } … }  “ /s/link?md5=_e4Nc3iduzkWRm01TBBNYw&amp;expires=2147483647 ”链接限制对IP地址为127.0.0.1的客户端的“ /s/link ”访问。 该链接的使用寿命有限，直到2038年1月19日（GMT）。 </p>
</blockquote>
<p> 在UNIX上， <em>md5</em>请求参数值可以获取为： </p>
<blockquote>
<p>echo -n ‘2147483647/s/link127.0.0.1 secret’ | \ openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d =  Syntax:  <strong>secure_link_secret</strong> <em>word</em> ;<br>  Default:  —  Context:  location<br>  定义用于检查所请求链接的真实性的密码。 </p>
</blockquote>
<p> 请求链接的完整URI如下所示： </p>
<blockquote>
<p>/ <em>prefix</em> / <em>hash</em> / <em>link</em>  <em>hash</em>是为链接和秘密字的串联计算的MD5哈希的十六进制表示，而<em>prefix</em>是没有斜杠的任意字符串。 </p>
</blockquote>
<p> 如果请求的链接通过了真实性检查，则$secure_link变量将设置为从请求URI中提取的链接。 否则， $secure_link变量设置为空字符串。 </p>
<p> 例： </p>
<blockquote>
<p>location /p/ { secure_link_secret secret; if ($secure_link = “”) { return 403; } rewrite ^ /secure/$secure_link; } location /secure/ { internal; }  “ /p/5e814704a28d9bc1914ff19fa0c4a00a/link ”的请求将在内部重定向到“ /secure/link ”。 </p>
</blockquote>
<p> 在UNIX上，此示例的哈希值可以获得为： </p>
<blockquote>
<p>echo -n ‘linksecret’ | openssl md5 -hex ####  嵌入式变量</p>
</blockquote>
<p> $secure_link   链接检查的状态。 具体值取决于所选的操作模式。  $secure_link_expires   请求中传递的链接的生命周期; 仅用于secure_link_md5指令。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_scgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_scgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_scgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-scgi-module"><a href="#Module-ngx-http-scgi-module" class="headerlink" title="Module ngx_http_scgi_module"></a>Module ngx_http_scgi_module</h2><p> Example Configuration<br> Directives<br> scgi_bind<br> scgi_buffer_size<br> scgi_buffering<br> scgi_buffers<br> scgi_busy_buffers_size<br> scgi_cache<br> scgi_cache_background_update<br> scgi_cache_bypass<br> scgi_cache_key<br> scgi_cache_lock<br> scgi_cache_lock_age<br> scgi_cache_lock_timeout<br> scgi_cache_max_range_offset<br> scgi_cache_methods<br> scgi_cache_min_uses<br> scgi_cache_path<br> scgi_cache_purge<br> scgi_cache_revalidate<br> scgi_cache_use_stale<br> scgi_cache_valid<br> scgi_connect_timeout<br> scgi_force_ranges<br> scgi_hide_header<br> scgi_ignore_client_abort<br> scgi_ignore_headers<br> scgi_intercept_errors<br> scgi_limit_rate<br> scgi_max_temp_file_size<br> scgi_next_upstream<br> scgi_next_upstream_timeout<br> scgi_next_upstream_tries<br> scgi_no_cache<br> scgi_param<br> scgi_pass<br> scgi_pass_header<br> scgi_pass_request_body<br> scgi_pass_request_headers<br> scgi_read_timeout<br> scgi_request_buffering<br> scgi_send_timeout<br> scgi_socket_keepalive<br> scgi_store<br> scgi_store_access<br> scgi_temp_file_write_size<br> scgi_temp_path<br> ngx_http_scgi_module模块允许将请求传递给SCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { include scgi_params; scgi_pass localhost:9000; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>scgi_bind</strong> <em>address</em> [ transparent ] | off ;<br>  Default:  —  Context:  http , server , location<br>  使用可选端口（1.11.2）从指定的本地IP地址发出到SCGI服务器的传出连接。 参数值可以包含变量（1.3.12）。 特殊值off （1.3.12）取消了从先前配置级别继承的scgi_bind指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数（1.11.0）允许到SCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>scgi_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还需要配置内核路由表以拦截来自SCGI服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>scgi_buffer_size</strong> <em>size</em> ;<br>  Default:  scgi_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从SCGI服务器接收的响应的第一部分的缓冲区的<em>size</em> 。 这部分通常包含一个小的响应头。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 然而，它可以做得更小。 </p>
<p> Syntax:  <strong>scgi_buffering</strong> on | off ;<br>  Default:  scgi_buffering on;  Context:  http , server , location<br>  启用或禁用缓冲来自SCGI服务器的响应。 </p>
<p> 启用缓冲后，nginx会尽快从SCGI服务器接收响应，并将其保存到scgi_buffer_size和scgi_buffers指令设置的缓冲区中。 如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的临时文件中 。 写入临时文件由scgi_max_temp_file_size和scgi_temp_file_write_size指令控制。 </p>
<p> 禁用缓冲时，响应会在收到响应时立即同步传递给客户端。 nginx不会尝试从SCGI服务器读取整个响应。 nginx一次可以从服务器接收的数据的最大大小由scgi_buffer_size指令设置。 </p>
<p> 也可以通过在“X-Accel-Buffering”响应头字段中传递“ yes ”或“ no ”来启用或禁用缓冲。 可以使用scgi_ignore_headers指令禁用此功能。 </p>
<p> Syntax:  <strong>scgi_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  scgi_buffers 8 4k|8k;  Context:  http , server , location<br>  设置用于从SCGI服务器读取响应的缓冲区的<em>number</em>和<em>size</em> ，用于单个连接。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>scgi_busy_buffers_size</strong> <em>size</em> ;<br>  Default:  scgi_busy_buffers_size 8k|16k;  Context:  http , server , location<br>  当启用来自SCGI服务器的响应缓冲时，限制在响应尚未完全读取时可能忙于向客户端发送响应的缓冲区的总<em>size</em> 。 同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。 默认情况下， <em>size</em>受scgi_buffer_size和scgi_buffers指令设置的两个缓冲区的大小限制。 </p>
<p> Syntax:  <strong>scgi_cache</strong> <em>zone</em> | off ;<br>  Default:  scgi_cache off;  Context:  http , server , location<br>  定义用于缓存的共享内存区域。 可以在多个地方使用相同的区域。 参数值可以包含变量（1.7.9）。 off参数禁用从先前配置级别继承的高速缓存。 </p>
<p> Syntax:  <strong>scgi_cache_background_update</strong> on | off ;<br>  Default:  scgi_cache_background_update off;  Context:  http , server , location<br>  该指令出现在1.11.10版中。 </p>
<p> 允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。 请注意，在更新时必须允许使用陈旧的缓存响应。 </p>
<p> Syntax:  <strong>scgi_cache_bypass</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不从缓存中获取响应的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<blockquote>
<p>scgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment; scgi_cache_bypass $http_pragma $http_authorization;  可以与scgi_no_cache指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>scgi_cache_key</strong> <em>string</em> ;<br>  Default:  —  Context:  http , server , location<br>  例如，定义缓存的键 </p>
<blockquote>
<p>scgi_cache_key localhost:9000$request_uri;  Syntax:  <strong>scgi_cache_lock</strong> on | off ;<br>  Default:  scgi_cache_lock off;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
</blockquote>
<p> 启用后，通过将请求传递给SCGI服务器，一次只允许一个请求填充根据scgi_cache_key指令标识的新缓存元素。 同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到scgi_cache_lock_timeout指令设置的时间。 </p>
<p> Syntax:  <strong>scgi_cache_lock_age</strong> <em>time</em> ;<br>  Default:  scgi_cache_lock_age 5s;  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 如果传递给SCGI服务器以填充新缓存元素的最后一个请求在指定<em>time</em>内没有完成，则可以将另一个请求传递给SCGI服务器。 </p>
<p> Syntax:  <strong>scgi_cache_lock_timeout</strong> <em>time</em> ;<br>  Default:  scgi_cache_lock_timeout 5s;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
<p> 设置scgi_cache_lock的超时。 当<em>time</em>到期时，请求将被传递给SCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p> 在1.7.8之前，可以缓存响应。  Syntax:  <strong>scgi_cache_max_range_offset</strong> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.11.6版中。 </p>
</blockquote>
<p> 设置字节范围请求的偏移量（以字节为单位）。 如果范围超出偏移量，则范围请求将传递给SCGI服务器，并且不会缓存响应。 </p>
<p> Syntax:  <strong>scgi_cache_methods</strong> GET | HEAD | POST …;<br>  Default:  scgi_cache_methods GET HEAD;  Context:  http , server , location<br>  如果此指令中列出了客户端请求方法，则将缓存响应。 “ GET ”和“ HEAD ”方法总是添加到列表中，但建议明确指定它们。 另请参见scgi_no_cache指令。 </p>
<p> Syntax:  <strong>scgi_cache_min_uses</strong> <em>number</em> ;<br>  Default:  scgi_cache_min_uses 1;  Context:  http , server , location<br>  设置将缓存响应的请求<em>number</em> 。 </p>
<p> Syntax:  <strong>scgi_cache_path</strong> <em>path</em> [ levels = <em>levels</em> ] [ use_temp_path = on | off ] keys_zone = <em>name</em> : <em>size</em> [ inactive = <em>time</em> ] [ max_size = <em>size</em> ] [ manager_files = <em>number</em> ] [ manager_sleep = <em>time</em> ] [ manager_threshold = <em>time</em> ] [ loader_files = <em>number</em> ] [ loader_sleep = <em>time</em> ] [ loader_threshold = <em>time</em> ] [ purger = on | off ] [ purger_files = <em>number</em> ] [ purger_sleep = <em>time</em> ] [ purger_threshold = <em>time</em> ];<br>  Default:  —  Context:  http<br>  设置缓存的路径和其他参数。 缓存数据存储在文件中。 缓存中的文件名是将MD5功能应用于缓存键的结果 。 levels参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<blockquote>
<p>scgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;  缓存中的文件名如下所示： </p>
<p>/data/nginx/cache/ <strong>c</strong> / <strong>29</strong> /b7f54b2df7773722d382f4809d650 <strong>29c</strong>  首先将缓存的响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。 根据use_temp_path参数（1.7.10）设置临时文件的目录。 如果省略此参数或将其设置为on ，则将使用scgi_temp_path指令为给定位置设置的目录。 如果该值设置为off ，则临时文件将直接放入缓存目录中。 </p>
</blockquote>
<p> 此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<em>name</em>和<em>size</em>由keys_zone参数配置。 一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p> 作为商业订阅的一部分，共享存储器区域还存储扩展的高速缓存信息 ，因此，需要为相同数量的密钥指定更大的区域大小。 例如，一兆字节区域可以存储大约4000个密钥。  在inactive参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。 默认情况下， inactive设置为10分钟。 </p>
</blockquote>
<p> 特殊的“缓存管理器”进程监视max_size参数设置的最大缓存大小。 超过此大小时，它会删除最近最少使用的数据。 在manager_files ， manager_threshold和manager_sleep参数（1.11.5）配置的迭代中删除数据。 在一次迭代期间，不会删除manager_files项（默认情况下为100）。 一次迭代的持续时间受manager_threshold参数限制（默认情况下为200毫秒）。 在迭代之间，由manager_sleep参数（默认为50毫秒）配置的暂停。 </p>
<p> 启动一分钟后，激活特殊的“缓存加载程序”进程。 它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。 加载也是在迭代中完成的。 在一次迭代期间，加载的loader_files项目不超过（默认情况下为100）。 此外，一次迭代的持续时间受loader_threshold参数限制（默认为200毫秒）。 在迭代之间，由loader_sleep参数（默认为50毫秒）配置暂停。 </p>
<p> 此外，以下参数作为我们商业订阅的一部分提供： </p>
<p> purger = on | off  指示缓存清除程序是否将从磁盘中删除与通配符密钥匹配的缓存条目（1.7.12）。 将参数设置为on （默认为off ）将激活“cache purger”进程，该进程将永久迭代所有缓存条目并删除与通配符键匹配的条目。  purger_files = <em>number</em>  设置在一次迭代（1.7.12）期间将扫描的项目数。 默认情况下， purger_files设置为10。  purger_threshold = <em>number</em>  设置一次迭代的持续时间（1.7.12）。 默认情况下， purger_threshold设置为50毫秒。  purger_sleep = <em>number</em>  设置迭代之间的暂停（1.7.12）。 默认情况下， purger_sleep设置为50毫秒。 </p>
<blockquote>
<p> 在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。 升级到较新的nginx版本之前，缓存的响应将被视为无效。  Syntax:  <strong>scgi_cache_purge</strong> string …;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 定义将请求视为缓存清除请求的条件。 如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应高速缓存键的高速缓存条目。 通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p> 如果清除请求的缓存键以星号（“ * ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。 但是，这些条目将保留在磁盘上，直到它们被删除为非活动状态 ，或由缓存清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p> 配置示例： </p>
<blockquote>
<p>scgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m; map $request_method $purge_method { PURGE 1; default 0; } server { … location / { scgi_pass backend; scgi_cache cache_zone; scgi_cache_key $uri; scgi_cache_purge $purge_method; } }<br> 此功能作为我们商业订阅的一部分提供。  Syntax:  <strong>scgi_cache_revalidate</strong> on | off ;<br>  Default:  scgi_cache_revalidate off;  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p> Syntax:  <strong>scgi_cache_use_stale</strong> error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | http_429 | off …;<br>  Default:  scgi_cache_use_stale off;  Context:  http , server , location<br>  确定在与SCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。 该指令的参数与scgi_next_upstream指令的参数匹配。 </p>
<p> 如果无法选择处理请求的SCGI服务器，则error参数还允许使用过时的缓存响应。 </p>
<p> 此外，如果当前正在更新，则updating参数允许使用过时的缓存响应。 这允许在更新缓存数据时最小化对SCGI服务器的访问次数。 </p>
<p> 在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。 这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ stale-while-revalidate ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 </li>
<li><p>“Cache-Control”头字段的“ stale-if-error ”扩展允许在出现错误时使用陈旧的缓存响应。<br>要在填充新缓存元素时最小化对SCGI服务器的访问次数，可以使用scgi_cache_lock指令。 </p>
<p>Syntax:  <strong>scgi_cache_valid</strong> [ <em>code</em> …] <em>time</em> ;<br>Default:  —  Context:  http , server , location<br>设置不同响应代码的缓存时间。 例如，以下指令 </p>
</li>
</ul>
<blockquote>
<p>scgi_cache_valid 200 302 10m; scgi_cache_valid 404 1m;  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
</blockquote>
<p> 如果仅指定了缓存<em>time</em> </p>
<blockquote>
<p>scgi_cache_valid 5m;  然后只缓存200,301和302个响应。 </p>
</blockquote>
<p> 此外，可以指定any参数来缓存任何响应： </p>
<blockquote>
<p>scgi_cache_valid 200 302 10m; scgi_cache_valid 301 1h; scgi_cache_valid any 1m;  缓存的参数也可以直接在响应头中设置。 这比使用该指令设置缓存时间具有更高的优先级。 </p>
</blockquote>
<ul>
<li>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。 零值禁用响应的缓存。 如果值以@前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 </li>
<li>如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 </li>
<li>如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 </li>
<li><p>如果标题包含具有特殊值“ * ”的“Vary”字段，则不会缓存此类响应（1.7.7）。 如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用scgi_ignore_headers指令禁用这些响应头字段中的一个或多个的处理。 </p>
<p>Syntax:  <strong>scgi_connect_timeout</strong> <em>time</em> ;<br>Default:  scgi_connect_timeout 60s;  Context:  http , server , location<br>定义与SCGI服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
<p>Syntax:  <strong>scgi_force_ranges</strong> on | off ;<br>Default:  scgi_force_ranges off;  Context:  http , server , location<br>该指令出现在1.7.7版本中。 </p>
<p>无论来自这些响应中的“Accept-Ranges”字段，都可以对来自SCGI服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p>Syntax:  <strong>scgi_hide_header</strong> <em>field</em> ;<br>Default:  —  Context:  http , server , location<br>默认情况下，nginx不会将SCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。 scgi_hide_header指令设置不会传递的其他字段。 相反，如果需要允许传递字段，则可以使用scgi_pass_header指令。 </p>
<p>Syntax:  <strong>scgi_ignore_client_abort</strong> on | off ;<br>Default:  scgi_ignore_client_abort off;  Context:  http , server , location<br>确定客户端在不等待响应的情况下关闭连接时是否应关闭与SCGI服务器的连接。 </p>
<p>Syntax:  <strong>scgi_ignore_headers</strong> <em>field</em> …;<br>Default:  —  Context:  http , server , location<br>禁用从SCGI服务器处理某些响应头字段。 可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li><p>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应缓存的参数; </p>
</li>
<li>“X-Accel-Redirect”执行内部重定向到指定的URI; </li>
<li>“X-Accel-Limit-Rate”设置向客户端传输响应的速率限制 ; </li>
<li>“X-Accel-Buffering”启用或禁用缓冲响应; </li>
<li><p>“X-Accel-Charset”设置了所需的响应字符集 。<br>Syntax:  <strong>scgi_intercept_errors</strong> on | off ;<br>Default:  scgi_intercept_errors off;  Context:  http , server , location<br>确定代码大于或等于300的SCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用error_page指令进行处理。 </p>
<p>Syntax:  <strong>scgi_limit_rate</strong> <em>rate</em> ;<br>Default:  scgi_limit_rate 0;  Context:  http , server , location<br>该指令出现在1.7.7版本中。 </p>
<p>限制从SCGI服务器读取响应的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据请求设置限制，因此如果nginx同时打开两个到SCGI服务器的连接，则总速率将是指定限制的两倍。 仅当启用了来自SCGI服务器的响应缓冲时 ，该限制才有效。 </p>
<p>Syntax:  <strong>scgi_max_temp_file_size</strong> <em>size</em> ;<br>Default:  scgi_max_temp_file_size 1024m;  Context:  http , server , location<br>当启用来自SCGI服务器的响应缓冲 ，并且整个响应不适合scgi_buffer_size和scgi_buffers指令设置的缓冲区时，响应的一部分可以保存到临时文件中。 该指令设置临时文件的最大<em>size</em> 。 一次写入临时文件的数据大小由scgi_temp_file_write_size指令设置。 </p>
<p>零值禁用缓冲对临时文件的响应。 </p>
</li>
</ul>
<blockquote>
<p> 此限制不适用于将缓存或存储在磁盘上的响应。  Syntax:  <strong>scgi_next_upstream</strong> error | timeout | invalid_header | http_500 | http_503 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>  Default:  scgi_next_upstream error timeout;  Context:  http , server , location<br>  指定应将请求传递到下一个服务器的情况： </p>
</blockquote>
<p> error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_header   服务器返回空或无效响应;  http_500   服务器返回代码为500的响应;  http_503   服务器返回代码为503的响应;  http_403   服务器返回代码为403的响应;  http_404   服务器返回代码为404的响应;  http_429   服务器返回代码为429的响应（1.11.13）;  non_idempotent   通常，如果请求已发送到上游服务器，则使用非幂等方法（ POST ， LOCK ， PATCH ）的请求不会传递给下一个服务器（1.9.13）; 启用此选项显式允许重试此类请求;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p> 该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_header情况始终被视为不成功的尝试，即使它们未在指令中指定。 http_500 ， http_503和http_429情况仅在指令中指定http_429被视为不成功尝试。 http_403和http_404情况从未被视为不成功的尝试。 </p>
<p> 将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>scgi_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  scgi_next_upstream_timeout 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p> Syntax:  <strong>scgi_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  scgi_next_upstream_tries 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>scgi_no_cache</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不将响应保存到缓存的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<blockquote>
<p>scgi_no_cache $cookie_nocache $arg_nocache$arg_comment; scgi_no_cache $http_pragma $http_authorization;  可以与scgi_cache_bypass指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>scgi_param</strong> <em>parameter</em> <em>value</em> [ if_not_empty ];<br>  Default:  —  Context:  http , server , location<br>  设置应传递给SCGI服务器的参数。 该<em>value</em>可以包含文本，变量及其组合。 当且仅当在当前级别上没有定义scgi_param指令时，这些指令才从先前级别继承。 </p>
<p> 标准CGI环境变量应作为SCGI头提供，请参阅分发中提供的scgi_params文件： </p>
<blockquote>
<p>location / { include scgi_params; … }  如果使用if_not_empty （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<p>scgi_param HTTPS $https if_not_empty;  Syntax:  <strong>scgi_pass</strong> <em>address</em> ;<br>  Default:  —  Context:  location , if in location<br>  设置SCGI服务器的地址。 地址可以指定为域名或IP地址，以及端口： </p>
<p>scgi_pass localhost:9000;  或者作为UNIX域套接字路径： </p>
<p>scgi_pass unix:/tmp/scgi.socket;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> 参数值可以包含变量。 在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用解析器确定。 </p>
<p> Syntax:  <strong>scgi_pass_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  允许将已禁用的头字段从SCGI服务器传递到客户端。 </p>
<p> Syntax:  <strong>scgi_pass_request_body</strong> on | off ;<br>  Default:  scgi_pass_request_body on;  Context:  http , server , location<br>  指示是否将原始请求正文传递给SCGI服务器。 另请参见scgi_pass_request_headers指令。 </p>
<p> Syntax:  <strong>scgi_pass_request_headers</strong> on | off ;<br>  Default:  scgi_pass_request_headers on;  Context:  http , server , location<br>  指示原始请求的标头字段是否传递给SCGI服务器。 另请参见scgi_pass_request_body指令。 </p>
<p> Syntax:  <strong>scgi_read_timeout</strong> <em>time</em> ;<br>  Default:  scgi_read_timeout 60s;  Context:  http , server , location<br>  定义从SCGI服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果SCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>scgi_request_buffering</strong> on | off ;<br>  Default:  scgi_request_buffering on;  Context:  http , server , location<br>  该指令出现在1.7.11版本中。 </p>
<p> 启用或禁用客户端请求正文的缓冲。 </p>
<p> 启用缓冲后，在将请求发送到SCGI服务器之前，将从客户端读取整个请求正文。 </p>
<p> 禁用缓冲时，请求主体在收到时立即发送到SCGI服务器。 在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给下一个服务器 。 </p>
<p> 当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p> Syntax:  <strong>scgi_send_timeout</strong> <em>time</em> ;<br>  Default:  scgi_send_timeout 60s;  Context:  http , server , location<br>  设置将请求发送到SCGI服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果SCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>scgi_socket_keepalive</strong> on | off ;<br>  Default:  scgi_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
<p> 配置与SCGI服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>scgi_store</strong> on | off | <em>string</em> ;<br>  Default:  scgi_store off;  Context:  http , server , location<br>  允许将文件保存到磁盘。 on参数使用与指令别名或root对应的路径保存文件。 off参数禁用文件保存。 此外，可以使用带变量的<em>string</em>显式设置文件名： </p>
<blockquote>
<p>scgi_store /data/www$original_uri;  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。 首先将响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，由scgi_temp_path指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
</blockquote>
<p> 该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<blockquote>
<p>location /images/ { root /data/www; error_page 404 = /fetch$uri; } location /fetch/ { internal; scgi_pass backend:9000; … scgi_store on; scgi_store_access user:rw group:rw all:r; scgi_temp_path /data/temp; alias /data/www/; }  Syntax:  <strong>scgi_store_access</strong> <em>users</em> : <em>permissions</em> …;<br>  Default:  scgi_store_access user:rw;  Context:  http , server , location<br>  为新创建的文件和目录设置访问权限，例如： </p>
<p>scgi_store_access user:rw group:rw all:r;  如果指定了任何group或all访问权限，则可以省略user权限： </p>
<p>scgi_store_access group:rw all:r;  Syntax:  <strong>scgi_temp_file_write_size</strong> <em>size</em> ;<br>  Default:  scgi_temp_file_write_size 8k|16k;  Context:  http , server , location<br>  当启用从SCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<em>size</em> 。 默认情况下， <em>size</em>由scgi_buffer_size和scgi_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由scgi_max_temp_file_size指令设置。 </p>
</blockquote>
<p> Syntax:  <strong>scgi_temp_path</strong> <em>path</em> [ <em>level1</em> [ <em>level2</em> [ <em>level3</em> ]]];<br>  Default:  scgi_temp_path scgi_temp;  Context:  http , server , location<br>  定义用于存储包含从SCGI服务器接收的数据的临时文件的目录。 在指定目录下最多可以使用三级子目录层次结构。 例如，在以下配置中 </p>
<blockquote>
<p>scgi_temp_path /spool/nginx/scgi_temp 1 2;  临时文件可能如下所示： </p>
<p>/spool/nginx/scgi_temp/ <strong>7</strong> / <strong>45</strong> /00000123 <strong>457</strong>  另请参见scgi_cache_path指令的use_temp_path参数。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_rewrite_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_rewrite_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_rewrite_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-rewrite-module"><a href="#Module-ngx-http-rewrite-module" class="headerlink" title="Module ngx_http_rewrite_module"></a>Module ngx_http_rewrite_module</h2><p> Directives<br> break<br> if<br> return<br> rewrite<br> rewrite_log<br> set<br> uninitialized_variable_warn<br> Internal Implementation<br> ngx_http_rewrite_module模块用于使用PCRE正则表达式更改请求URI，返回重定向和有条件地选择配置。 </p>
<p> break ， if ， return ， rewrite和set指令按以下顺序处理： </p>
<ul>
<li>在服务器级别指定的此模块的指令是按顺序执行的; </li>
<li>反复： <ul>
<li>基于请求URI搜索位置 ; </li>
<li>在找到的位置内指定的该模块的指令是顺序执行的; </li>
<li>如果重写请求URI，则重复循环，但不超过10次 。 </li>
</ul>
</li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>break</strong> ;<br>  Default:  —  Context:  server , location , if<br>  停止处理当前的ngx_http_rewrite_module指令集。 </p>
<p> 如果在该位置内指定了指令，则在该位置继续进一步处理该请求。 </p>
<p> 例： </p>
<blockquote>
<p>if ($slow) { limit_rate 10k; break; }  Syntax:  <strong>if</strong> ( <em>condition</em> ) { … }<br>  Default:  —  Context:  server , location<br>  评估指定的<em>condition</em> 。 如果为true，则执行在大括号内指定的此模块指令，并在if指令内为该请求分配配置。 if指令内的配置继承自先前的配置级别。 </p>
</blockquote>
<p> 条件可以是以下任何一种： </p>
<ul>
<li>变量名; 如果变量的值为空字符串或“ 0 ”，则为false; <blockquote>
<p> 在版本1.0.1之前，任何以“ 0 ”开头的字符串都被视为错误值。 </p>
</blockquote>
</li>
<li>使用“ = ”和“ != ”运算符比较变量和字符串; </li>
<li>使用“ ~ ”（对于区分大小写的匹配）和“ ~<em> ”（对于不区分大小写的匹配）运算符，将变量与正则表达式进行匹配。 正则表达式可以包含可供以后在$1 .. $9变量中重用的捕获。 负操作符“ !~ ”和“ !~</em> ”也可用。 如果正则表达式包含“ } ”或“ ; “字符，整个表达式应该用单引号或双引号括起来。 </li>
<li>使用“ -f ”和“ !-f ”运算符检查文件是否存在; </li>
<li>使用“ -d ”和“ !-d ”运算符检查目录是否存在; </li>
<li>使用“ -e ”和“ !-e ”运算符检查文件，目录或符号链接是否存在; </li>
<li>使用“ -x ”和“ !-x ”运算符检查可执行文件。<br>例子： </li>
</ul>
<blockquote>
<p>if ($http_user_agent ~ MSIE) { rewrite ^(.<em>)$ /msie/$1 break; } if ($http_cookie ~</em> “id=([^;]+)(?:;|$)”) { set $id $1; } if ($request_method = POST) { return 405; } if ($slow) { limit_rate 10k; } if ($invalid_referer) { return 403; }<br> $invalid_referer嵌入变量的值由valid_referers指令设置。  Syntax:  <strong>return</strong> <em>code</em> [ <em>text</em> ];<br> <strong>return</strong> <em>code</em> <em>URL</em> ;<br> <strong>return</strong> <em>URL</em> ;<br>  Default:  —  Context:  server , location , if<br>  停止处理并将指定的<em>code</em>返回给客户端。 非标准代码444在不发送响应头的情况下关闭连接。 </p>
</blockquote>
<p> 从版本0.8.42开始，可以指定重定向URL（对于代码301,302,303,307和308）或响应正文<em>text</em> （对于其他代码）。 响应正文文本和重定向URL可以包含变量。 作为特殊情况，可以将重定向URL指定为此服务器的本地URI，在这种情况下，根据请求方案（ $scheme ）以及server_name_in_redirect和port_in_redirect指令形成完整重定向URL。 </p>
<p> 另外，可以将用于具有代码302的临时重定向的<em>URL</em>指定为唯一参数。 这样的参数应该以“ http:// ”，“ https:// ”或“ $scheme ”字符串开头。 <em>URL</em>可以包含变量。 </p>
<blockquote>
<p> 在版本0.7.51之前只能返回以下代码：204,400,402-406,408,410,411,413,416和500-504。<br> 在版本1.1.16和1.0.13之前，代码307不被视为重定向。<br> 在版本1.13.0之前，代码308不被视为重定向。  另请参见error_page指令。 </p>
</blockquote>
<p> Syntax:  <strong>rewrite</strong> <em>regex</em> <em>replacement</em> [ <em>flag</em> ];<br>  Default:  —  Context:  server , location , if<br>  如果指定的正则表达式与请求URI匹配，则URI将根据<em>replacement</em>字符串中的指定进行更改。 rewrite指令按照它们在配置文件中的出现顺序依次执行。 可以使用标志终止对指令的进一步处理。 如果替换字符串以“ http:// ”，“ https:// ”或“ $scheme ”开头，则处理停止并将重定向返回给客户端。 </p>
<p> 可选的<em>flag</em>参数可以是以下之一： </p>
<p> last   停止处理当前的ngx_http_rewrite_module指令集并开始搜索与更改的URI匹配的新位置;  break   与break指令一样，停止处理当前的ngx_http_rewrite_module指令集;  redirect   返回带有302代码的临时重定向; 如果替换字符串不以“ http:// ”，“ https:// ”或“ $scheme ”开头，则使用;  permanent   返回301代码的永久重定向。  完整重定向URL根据请求方案（ $scheme ）以及server_name_in_redirect和port_in_redirect指令形成。 </p>
<p> 例： </p>
<blockquote>
<p>server { … rewrite ^(/download/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 last; rewrite ^(/download/.</em>)/audio/(.<em>)..</em>$ $1/mp3/$2.ra last; return 403; … }  但是如果这些指令放在“ /download/ ”位置， last标志应该用break替换，否则nginx会生成10个周期并返回500错误： </p>
<p>location /download/ { rewrite ^(/download/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 break; rewrite ^(/download/.</em>)/audio/(.<em>)..</em>$ $1/mp3/$2.ra break; return 403; }  如果<em>replacement</em>字符串包含新请求参数，则先前的请求参数将附加在它们之后。 如果这是不希望的，在替换字符串的末尾加上一个问号可以避免附加它们，例如： </p>
<p>rewrite ^/users/(.*)$ /show?user=$1? last;  如果正则表达式包含“ } ”或“ ; “字符，整个表达式应该用单引号或双引号括起来。 </p>
</blockquote>
<p> Syntax:  <strong>rewrite_log</strong> on | off ;<br>  Default:  rewrite_log off;  Context:  http , server , location , if<br>  启用或禁用将ngx_http_rewrite_module模块指令处理结果记录到notice级别的error_log中。 </p>
<p> Syntax:  <strong>set</strong> <em>$variable</em> <em>value</em> ;<br>  Default:  —  Context:  server , location , if<br>  设置指定<em>variable</em>的<em>value</em> 。 该<em>value</em>可以包含文本，变量及其组合。 </p>
<p> Syntax:  <strong>uninitialized_variable_warn</strong> on | off ;<br>  Default:  uninitialized_variable_warn on;  Context:  http , server , location , if<br>  控制是否记录有关未初始化变量的警告。 </p>
<h4 id="内部实施"><a href="#内部实施" class="headerlink" title="内部实施"></a>内部实施</h4><p> ngx_http_rewrite_module模块指令在配置阶段编译为在请求处理期间解释的内部指令。 解释器是一个简单的虚拟堆栈机器。 </p>
<p> 例如，指令 </p>
<blockquote>
<p>location /download/ { if ($forbidden) { return 403; } if ($slow) { limit_rate 10k; } rewrite ^/(download/.<em>)/media/(.</em>)..*$ /$1/mp3/$2.mp3 break; }  将被翻译成这些说明： </p>
<p>variable $forbidden check against zero return 403 end of code variable $slow check against zero match of regular expression copy “/“ copy $1 copy “/mp3/“ copy $2 copy “.mp3” end of regular expression end of code  请注意，上面的limit_rate指令没有说明，因为它与ngx_http_rewrite_module模块无关。 为if块创建单独的配置。 如果条件成立，则为此配置分配一个请求，其中limit_rate等于10k。 </p>
</blockquote>
<p> 指令 </p>
<blockquote>
<p>rewrite ^/(download/.<em>)/media/(.</em>)..*$ /$1/mp3/$2.mp3 break;  如果正则表达式中的第一个斜杠放在括号内，则可以通过一条指令变小： </p>
<p>rewrite ^( <strong>/</strong> download/.<em>)/media/(.</em>)..*$ $1/mp3/$2.mp3 break;  相应的说明将如下所示： </p>
<p>match of regular expression copy $1 copy “/mp3/“ copy $2 copy “.mp3” end of regular expression end of code  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_referer_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_referer_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_referer_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-referer-module"><a href="#Module-ngx-http-referer-module" class="headerlink" title="Module ngx_http_referer_module"></a>Module ngx_http_referer_module</h2><p> Example Configuration<br> Directives<br> referer_hash_bucket_size<br> referer_hash_max_size<br> valid_referers<br> Embedded Variables<br> ngx_http_referer_module模块用于阻止对“Referer”头字段中具有无效值的请求访问站点。 应该记住，使用适当的“Referer”字段值来构造请求非常容易，因此本模块的预期目的不是要彻底阻止此类请求，而是阻止常规浏览器发送的请求的大量流量。 还应该考虑到，即使对于有效请求，常规浏览器也可能不发送“Referer”字段。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>valid_referers none blocked server_names <em>.example.com example.</em> www.example.org/galleries/ ~.google.; if ($invalid_referer) { return 403; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>referer_hash_bucket_size</strong> <em>size</em> ;<br>  Default:  referer_hash_bucket_size 64;  Context:  server , location<br>  该指令出现在1.0.5版本中。 </p>
<p> 设置有效引用散列表的存储区大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>referer_hash_max_size</strong> <em>size</em> ;<br>  Default:  referer_hash_max_size 2048;  Context:  server , location<br>  该指令出现在1.0.5版本中。 </p>
<p> 设置有效引用者哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>valid_referers</strong> none | blocked | server_names | <em>string</em> …;<br>  Default:  —  Context:  server , location<br>  指定将导致嵌入的$invalid_referer变量设置为空字符串的“Referer”请求标头字段值。 否则，变量将设置为“ 1 ”。 搜索匹配不区分大小写。 </p>
<p> 参数可以如下： </p>
<p> none   请求标头中缺少“Referer”字段;  blocked   “Referer”字段出现在请求标头中，但其值已被防火墙或代理服务器删除; 这些值是不以“ http:// ”或“ https:// ”开头的字符串;  server_names   “Referer”请求头字段包含一个服务器名称;  任意字串  定义服务器名称和可选的URI前缀。 服务器名称的开头或结尾可以包含“ * ”。 在检查期间，“Referer”字段中的服务器端口被忽略;  正则表达式  第一个符号应为“ ~ ”。 应该注意的是，表达式将与“ http:// ”或“ https:// ”之后的文本匹配。  例： </p>
<blockquote>
<p>valid_referers none blocked server_names <em>.example.com example.</em> www.example.org/galleries/ ~.google.; ####  嵌入式变量</p>
</blockquote>
<p> $invalid_referer   空字符串，如果“Referer”请求标头字段值被认为有效 ，否则为“ 1 ”。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_realip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_realip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-realip-module"><a href="#Module-ngx-http-realip-module" class="headerlink" title="Module ngx_http_realip_module"></a>Module ngx_http_realip_module</h2><p> Example Configuration<br> Directives<br> set_real_ip_from<br> real_ip_header<br> real_ip_recursive<br> Embedded Variables<br> ngx_http_realip_module模块用于将客户端地址和可选端口更改为在指定的头字段中发送的端口。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_realip_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>set_real_ip_from 192.168.1.0/24; set_real_ip_from 192.168.2.1; set_real_ip_from 2001:0db8::/32; real_ip_header X-Forwarded-For; real_ip_recursive on; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>set_real_ip_from</strong> <em>address</em> | <em>CIDR</em> | unix: ;<br>  Default:  —  Context:  http , server , location<br>  定义已知可发送正确替换地址的可信地址。 如果指定了特殊值unix:则所有UNIX域套接字都将受信任。 也可以使用主机名（1.13.1）指定可信地址。 </p>
<blockquote>
<p> 从版本1.3.0和1.2.1开始支持IPv6地址。  Syntax:  <strong>real_ip_header</strong> <em>field</em> | X-Real-IP | X-Forwarded-For | proxy_protocol ;<br>  Default:  real_ip_header X-Real-IP;  Context:  http , server , location<br>  定义请求标头字段，其值将用于替换客户端地址。 </p>
</blockquote>
<p> 包含可选端口的请求标头字段值也用于替换客户端端口（1.11.0）。 应根据RFC 3986指定地址和端口。 </p>
<p> proxy_protocol参数（1.5.12）将客户端地址更改为PROXY协议头中的地址。 必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> Syntax:  <strong>real_ip_recursive</strong> on | off ;<br>  Default:  real_ip_recursive off;  Context:  http , server , location<br>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p> 如果禁用递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为real_ip_header指令定义的请求头字段中发送的最后一个地址。 如果启用了递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为请求头字段中发送的最后一个非受信任地址。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> $realip_remote_addr   保留原始客户地址（1.9.7）  $realip_remote_port   保留原始客户端端口（1.11.0）  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_random_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_random_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_random_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-random-index-module"><a href="#Module-ngx-http-random-index-module" class="headerlink" title="Module ngx_http_random_index_module"></a>Module ngx_http_random_index_module</h2><p> Example Configuration<br> Directives<br> random_index<br> ngx_http_random_index_module模块处理以斜杠字符（’ / ‘）结尾的请求，并在目录中选择一个随机文件作为索引文件。 在ngx_http_index_module模块之前处理该模块。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_random_index_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { random_index on; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>random_index</strong> on | off ;<br>  Default:  random_index off;  Context:  location<br>  启用或禁用周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_proxy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_proxy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-proxy-module"><a href="#Module-ngx-http-proxy-module" class="headerlink" title="Module ngx_http_proxy_module"></a>Module ngx_http_proxy_module</h2><p> Example Configuration<br> Directives<br> proxy_bind<br> proxy_buffer_size<br> proxy_buffering<br> proxy_buffers<br> proxy_busy_buffers_size<br> proxy_cache<br> proxy_cache_background_update<br> proxy_cache_bypass<br> proxy_cache_convert_head<br> proxy_cache_key<br> proxy_cache_lock<br> proxy_cache_lock_age<br> proxy_cache_lock_timeout<br> proxy_cache_max_range_offset<br> proxy_cache_methods<br> proxy_cache_min_uses<br> proxy_cache_path<br> proxy_cache_purge<br> proxy_cache_revalidate<br> proxy_cache_use_stale<br> proxy_cache_valid<br> proxy_connect_timeout<br> proxy_cookie_domain<br> proxy_cookie_path<br> proxy_force_ranges<br> proxy_headers_hash_bucket_size<br> proxy_headers_hash_max_size<br> proxy_hide_header<br> proxy_http_version<br> proxy_ignore_client_abort<br> proxy_ignore_headers<br> proxy_intercept_errors<br> proxy_limit_rate<br> proxy_max_temp_file_size<br> proxy_method<br> proxy_next_upstream<br> proxy_next_upstream_timeout<br> proxy_next_upstream_tries<br> proxy_no_cache<br> proxy_pass<br> proxy_pass_header<br> proxy_pass_request_body<br> proxy_pass_request_headers<br> proxy_read_timeout<br> proxy_redirect<br> proxy_request_buffering<br> proxy_send_lowat<br> proxy_send_timeout<br> proxy_set_body<br> proxy_set_header<br> proxy_socket_keepalive<br> proxy_ssl_certificate<br> proxy_ssl_certificate_key<br> proxy_ssl_ciphers<br> proxy_ssl_crl<br> proxy_ssl_name<br> proxy_ssl_password_file<br> proxy_ssl_protocols<br> proxy_ssl_server_name<br> proxy_ssl_session_reuse<br> proxy_ssl_trusted_certificate<br> proxy_ssl_verify<br> proxy_ssl_verify_depth<br> proxy_store<br> proxy_store_access<br> proxy_temp_file_write_size<br> proxy_temp_path<br> Embedded Variables<br> ngx_http_proxy_module模块允许将请求传递到另一台服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { proxy_pass <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a>; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>proxy_bind</strong> <em>address</em> [ transparent ] | off ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在0.8.22版本中。 </p>
<p> 使与可选端口（1.11.2）的指定本地IP地址建立到代理服务器的传出连接。 参数值可以包含变量（1.3.12）。 特殊值off （1.3.12）取消了从先前配置级别继承的proxy_bind指令的效果，允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>proxy_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_buffer_size</strong> <em>size</em> ;<br>  Default:  proxy_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从代理服务器接收的响应的第一部分的缓冲区的<em>size</em> 。 这部分通常包含一个小的响应头。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 然而，它可以做得更小。 </p>
<p> Syntax:  <strong>proxy_buffering</strong> on | off ;<br>  Default:  proxy_buffering on;  Context:  http , server , location<br>  启用或禁用来自代理服务器的响应缓冲。 </p>
<p> 启用缓冲后，nginx会尽快从代理服务器接收响应，并将其保存到proxy_buffer_size和proxy_buffers指令设置的缓冲区中。 如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的临时文件中 。 写入临时文件由proxy_max_temp_file_size和proxy_temp_file_write_size指令控制。 </p>
<p> 禁用缓冲时，响应会在收到响应时立即同步传递给客户端。 nginx不会尝试从代理服务器读取整个响应。 nginx一次可以从服务器接收的数据的最大大小由proxy_buffer_size指令设置。 </p>
<p> 也可以通过在“X-Accel-Buffering”响应头字段中传递“ yes ”或“ no ”来启用或禁用缓冲。 可以使用proxy_ignore_headers指令禁用此功能。 </p>
<p> Syntax:  <strong>proxy_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  proxy_buffers 8 4k|8k;  Context:  http , server , location<br>  设置用于从代理服务器读取响应的缓冲区的<em>number</em>和<em>size</em> ，用于单个连接。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>proxy_busy_buffers_size</strong> <em>size</em> ;<br>  Default:  proxy_busy_buffers_size 8k|16k;  Context:  http , server , location<br>  当启用来自代理服务器的响应缓冲时，限制可能忙于向响应客户端发送响应的缓冲区的总<em>size</em> ，而响应尚未完全读取。 同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。 默认情况下， <em>size</em>由proxy_buffer_size和proxy_buffers指令设置的两个缓冲区的大小限制。 </p>
<p> Syntax:  <strong>proxy_cache</strong> <em>zone</em> | off ;<br>  Default:  proxy_cache off;  Context:  http , server , location<br>  定义用于缓存的共享内存区域。 可以在多个地方使用相同的区域。 参数值可以包含变量（1.7.9）。 off参数禁用从先前配置级别继承的高速缓存。 </p>
<p> Syntax:  <strong>proxy_cache_background_update</strong> on | off ;<br>  Default:  proxy_cache_background_update off;  Context:  http , server , location<br>  该指令出现在1.11.10版中。 </p>
<p> 允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。 请注意，在更新时必须允许使用陈旧的缓存响应。 </p>
<p> Syntax:  <strong>proxy_cache_bypass</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不从缓存中获取响应的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<blockquote>
<p>proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment; proxy_cache_bypass $http_pragma $http_authorization;  可以与proxy_no_cache指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_cache_convert_head</strong> on | off ;<br>  Default:  proxy_cache_convert_head on;  Context:  http , server , location<br>  该指令出现在1.9.7版中。 </p>
<p> 启用或禁用将“ HEAD ”方法转换为“ GET ”以进行缓存。 禁用转换时，应将缓存键配置为包含$request_method 。 </p>
<p> Syntax:  <strong>proxy_cache_key</strong> <em>string</em> ;<br>  Default:  proxy_cache_key $scheme$proxy_host$request_uri;  Context:  http , server , location<br>  例如，定义缓存的键 </p>
<blockquote>
<p>proxy_cache_key “$host$request_uri $cookie_user”;  默认情况下，指令的值接近字符串 </p>
<p>proxy_cache_key $scheme$proxy_host$uri$is_args$args;  Syntax:  <strong>proxy_cache_lock</strong> on | off ;<br>  Default:  proxy_cache_lock off;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
</blockquote>
<p> 启用后，通过将请求传递给代理服务器，一次只允许一个请求填充根据proxy_cache_key指令标识的新缓存元素。 同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到proxy_cache_lock_timeout指令设置的时间。 </p>
<p> Syntax:  <strong>proxy_cache_lock_age</strong> <em>time</em> ;<br>  Default:  proxy_cache_lock_age 5s;  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 如果传递给代理服务器以填充新缓存元素的最后一个请求在指定<em>time</em>内没有完成，则可以将另一个请求传递给代理服务器。 </p>
<p> Syntax:  <strong>proxy_cache_lock_timeout</strong> <em>time</em> ;<br>  Default:  proxy_cache_lock_timeout 5s;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
<p> 设置proxy_cache_lock的超时。 当<em>time</em>到期时，请求将被传递给代理服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p> 在1.7.8之前，可以缓存响应。  Syntax:  <strong>proxy_cache_max_range_offset</strong> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.11.6版中。 </p>
</blockquote>
<p> 设置字节范围请求的偏移量（以字节为单位）。 如果范围超出偏移量，则范围请求将传递到代理服务器，并且不会缓存响应。 </p>
<p> Syntax:  <strong>proxy_cache_methods</strong> GET | HEAD | POST …;<br>  Default:  proxy_cache_methods GET HEAD;  Context:  http , server , location<br>  该指令出现在0.7.59版本中。 </p>
<p> 如果此指令中列出了客户端请求方法，则将缓存响应。 “ GET ”和“ HEAD ”方法总是添加到列表中，但建议明确指定它们。 另请参见proxy_no_cache指令。 </p>
<p> Syntax:  <strong>proxy_cache_min_uses</strong> <em>number</em> ;<br>  Default:  proxy_cache_min_uses 1;  Context:  http , server , location<br>  设置将缓存响应的请求<em>number</em> 。 </p>
<p> Syntax:  <strong>proxy_cache_path</strong> <em>path</em> [ levels = <em>levels</em> ] [ use_temp_path = on | off ] keys_zone = <em>name</em> : <em>size</em> [ inactive = <em>time</em> ] [ max_size = <em>size</em> ] [ manager_files = <em>number</em> ] [ manager_sleep = <em>time</em> ] [ manager_threshold = <em>time</em> ] [ loader_files = <em>number</em> ] [ loader_sleep = <em>time</em> ] [ loader_threshold = <em>time</em> ] [ purger = on | off ] [ purger_files = <em>number</em> ] [ purger_sleep = <em>time</em> ] [ purger_threshold = <em>time</em> ];<br>  Default:  —  Context:  http<br>  设置缓存的路径和其他参数。 缓存数据存储在文件中。 缓存中的文件名是将MD5功能应用于缓存键的结果 。 levels参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<blockquote>
<p>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;  缓存中的文件名如下所示： </p>
<p>/data/nginx/cache/ <strong>c</strong> / <strong>29</strong> /b7f54b2df7773722d382f4809d650 <strong>29c</strong>  首先将缓存的响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。 临时文件的目录是根据use_temp_path参数（1.7.10）设置的。 如果省略此参数或将其设置为on ，则将使用proxy_temp_path指令为给定位置设置的目录。 如果该值设置为off ，则临时文件将直接放入缓存目录中。 </p>
</blockquote>
<p> 此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<em>name</em>和<em>size</em>由keys_zone参数配置。 一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p> 作为商业订阅的一部分，共享存储器区域还存储扩展的高速缓存信息 ，因此，需要为相同数量的密钥指定更大的区域大小。 例如，一兆字节区域可以存储大约4000个密钥。  在inactive参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。 默认情况下， inactive设置为10分钟。 </p>
</blockquote>
<p> 特殊的“缓存管理器”进程监视max_size参数设置的最大缓存大小。 超过此大小时，它会删除最近最少使用的数据。 在manager_files ， manager_threshold和manager_sleep参数（1.11.5）配置的迭代中删除数据。 在一次迭代期间，不会删除manager_files项（默认情况下为100）。 一次迭代的持续时间受manager_threshold参数限制（默认情况下为200毫秒）。 在迭代之间，由manager_sleep参数（默认为50毫秒）配置的暂停。 </p>
<p> 启动一分钟后，激活特殊的“缓存加载程序”进程。 它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。 加载也是在迭代中完成的。 在一次迭代期间，加载的loader_files项目不超过（默认情况下为100）。 此外，一次迭代的持续时间受loader_threshold参数限制（默认为200毫秒）。 在迭代之间，由loader_sleep参数（默认为50毫秒）配置暂停。 </p>
<p> 此外，以下参数作为我们商业订阅的一部分提供： </p>
<p> purger = on | off  指示缓存清除程序是否将从磁盘中删除与通配符密钥匹配的缓存条目（1.7.12）。 将参数设置为on （默认为off ）将激活“cache purger”进程，该进程将永久迭代所有缓存条目并删除与通配符键匹配的条目。  purger_files = <em>number</em>  设置在一次迭代（1.7.12）期间将扫描的项目数。 默认情况下， purger_files设置为10。  purger_threshold = <em>number</em>  设置一次迭代的持续时间（1.7.12）。 默认情况下， purger_threshold设置为50毫秒。  purger_sleep = <em>number</em>  设置迭代之间的暂停（1.7.12）。 默认情况下， purger_sleep设置为50毫秒。 </p>
<blockquote>
<p> 在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。 升级到较新的nginx版本之前，缓存的响应将被视为无效。  Syntax:  <strong>proxy_cache_purge</strong> string …;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 定义将请求视为缓存清除请求的条件。 如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应高速缓存键的高速缓存条目。 通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p> 如果清除请求的缓存键以星号（“ * ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。 但是，这些条目将保留在磁盘上，直到它们被删除为非活动状态 ，或由缓存清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p> 配置示例： </p>
<blockquote>
<p>proxy_cache_path /data/nginx/cache keys_zone=cache_zone:10m; map $request_method $purge_method { PURGE 1; default 0; } server { … location / { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }<br> 此功能作为我们商业订阅的一部分提供。  Syntax:  <strong>proxy_cache_revalidate</strong> on | off ;<br>  Default:  proxy_cache_revalidate off;  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p> Syntax:  <strong>proxy_cache_use_stale</strong> error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | off …;<br>  Default:  proxy_cache_use_stale off;  Context:  http , server , location<br>  确定在与代理服务器通信期间可以在哪些情况下使用过时的缓存响应。 该指令的参数与proxy_next_upstream指令的参数匹配。 </p>
<p> 如果无法选择代理服务器来处理请求，则error参数还允许使用过时的缓存响应。 </p>
<p> 此外，如果当前正在更新，则updating参数允许使用过时的缓存响应。 这允许在更新缓存数据时最小化对代理服务器的访问次数。 </p>
<p> 在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。 这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ stale-while-revalidate ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 </li>
<li><p>“Cache-Control”头字段的“ stale-if-error ”扩展允许在出现错误时使用陈旧的缓存响应。<br>要在填充新缓存元素时最小化对代理服务器的访问次数，可以使用proxy_cache_lock指令。 </p>
<p>Syntax:  <strong>proxy_cache_valid</strong> [ <em>code</em> …] <em>time</em> ;<br>Default:  —  Context:  http , server , location<br>设置不同响应代码的缓存时间。 例如，以下指令 </p>
</li>
</ul>
<blockquote>
<p>proxy_cache_valid 200 302 10m; proxy_cache_valid 404 1m;  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
</blockquote>
<p> 如果仅指定了缓存<em>time</em> </p>
<blockquote>
<p>proxy_cache_valid 5m;  然后只缓存200,301和302个响应。 </p>
</blockquote>
<p> 此外，可以指定any参数来缓存任何响应： </p>
<blockquote>
<p>proxy_cache_valid 200 302 10m; proxy_cache_valid 301 1h; proxy_cache_valid any 1m;  缓存的参数也可以直接在响应头中设置。 这比使用该指令设置缓存时间具有更高的优先级。 </p>
</blockquote>
<ul>
<li>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。 零值禁用响应的缓存。 如果值以@前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 </li>
<li>如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 </li>
<li>如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 </li>
<li><p>如果标题包含具有特殊值“ * ”的“Vary”字段，则不会缓存此类响应（1.7.7）。 如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用proxy_ignore_headers指令禁用这些响应头字段中的一个或多个的处理。 </p>
<p>Syntax:  <strong>proxy_connect_timeout</strong> <em>time</em> ;<br>Default:  proxy_connect_timeout 60s;  Context:  http , server , location<br>定义与代理服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
<p>Syntax:  <strong>proxy_cookie_domain</strong> off ;<br><strong>proxy_cookie_domain</strong> <em>domain</em> <em>replacement</em> ;<br>Default:  proxy_cookie_domain off;  Context:  http , server , location<br>该指令出现在1.1.15版中。 </p>
<p>设置应在代理服务器响应的“Set-Cookie”标头字段的domain属性中更改的文本。 假设代理服务器返回带有“ domain=localhost ”属性的“Set-Cookie”头字段。 指令 </p>
</li>
</ul>
<blockquote>
<p>proxy_cookie_domain localhost example.org;  将此属性重写为“ domain=example.org ”。 </p>
</blockquote>
<p> <em>domain</em>开头处的点和<em>replacement</em>字符串以及domain属性将被忽略。 匹配不区分大小写。 </p>
<p> <em>domain</em>和<em>replacement</em>字符串可以包含变量： </p>
<blockquote>
<p>proxy_cookie_domain www.$host $host;  也可以使用正则表达式指定该指令。 在这种情况下， <em>domain</em>应该从“ ~ ”符号开始。 正则表达式可以包含命名和位置捕获， <em>replacement</em>可以引用它们： </p>
<p>proxy_cookie_domain ~.(?P<sl\_domain>[-0-9a-z]+.[a-z]+)$ $sl_domain;  可能有几个proxy_cookie_domain指令： </sl\_domain></p>
<p>proxy_cookie_domain localhost example.org; proxy_cookie_domain ~.([a-z]+.[a-z]+)$ $1;  off参数取消所有proxy_cookie_domain指令对当前级别的影响： </p>
<p>proxy_cookie_domain off; proxy_cookie_domain localhost example.org; proxy_cookie_domain www.example.org example.org;  Syntax:  <strong>proxy_cookie_path</strong> off ;<br> <strong>proxy_cookie_path</strong> <em>path</em> <em>replacement</em> ;<br>  Default:  proxy_cookie_path off;  Context:  http , server , location<br>  该指令出现在1.1.15版中。 </p>
</blockquote>
<p> 设置应在代理服务器响应的“Set-Cookie”标头字段的path属性中更改的文本。 假设代理服务器返回带有属性“ path=/two/some/uri/ ”的“Set-Cookie”头字段。 指令 </p>
<blockquote>
<p>proxy_cookie_path /two/ /;  将此属性重写为“ path=/some/uri/ ”。 </p>
</blockquote>
<p> <em>path</em>和<em>replacement</em>字符串可以包含变量： </p>
<blockquote>
<p>proxy_cookie_path $uri /some$uri;  也可以使用正则表达式指定该指令。 在这种情况下， <em>path</em>应该从用于区分大小写匹配的“ ~ ”符号开始，或者从用于区分大小写匹配的“ ~<em> ”符号开始。 正则表达式可以包含命名和位置捕获， </em>replacement*可以引用它们： </p>
<p>proxy_cookie_path ~*^/user/([^/]+) /u/$1;  可能有几个proxy_cookie_path指令： </p>
<p>proxy_cookie_path /one/ /; proxy_cookie_path / /two/;  off参数取消所有proxy_cookie_path指令对当前级别的影响： </p>
<p>proxy_cookie_path off; proxy_cookie_path /two/ /; proxy_cookie_path ~<em>^/user/([^/]+) /u/$1;  Syntax:  <em>*proxy_force_ranges</em></em> on | off ;<br>  Default:  proxy_force_ranges off;  Context:  http , server , location<br>  该指令出现在1.7.7版本中。 </p>
</blockquote>
<p> 无论代理服务器中的“Accept-Ranges”字段如何，都可以对代理服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p> Syntax:  <strong>proxy_headers_hash_bucket_size</strong> <em>size</em> ;<br>  Default:  proxy_headers_hash_bucket_size 64;  Context:  http , server , location<br>  设置proxy_hide_header和proxy_set_header指令使用的哈希表的桶<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>proxy_headers_hash_max_size</strong> <em>size</em> ;<br>  Default:  proxy_headers_hash_max_size 512;  Context:  http , server , location<br>  设置proxy_hide_header和proxy_set_header指令使用的哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>proxy_hide_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  默认情况下，nginx不会从代理服务器对客户端的响应中传递标题字段“Date”，“Server”，“X-Pad”和“X-Accel -…”。 proxy_hide_header指令设置不会传递的其他字段。 相反，如果需要允许传递字段，则可以使用proxy_pass_header指令。 </p>
<p> Syntax:  <strong>proxy_http_version</strong> 1.0 | 1.1 ;<br>  Default:  proxy_http_version 1.0;  Context:  http , server , location<br>  该指令出现在1.1.4版中。 </p>
<p> 设置代理的HTTP协议版本。 默认情况下，使用版本1.0。 建议将1.1版与keepalive连接和NTLM身份验证配合使用 。 </p>
<p> Syntax:  <strong>proxy_ignore_client_abort</strong> on | off ;<br>  Default:  proxy_ignore_client_abort off;  Context:  http , server , location<br>  确定在客户端关闭连接而不等待响应时是否应关闭与代理服务器的连接。 </p>
<p> Syntax:  <strong>proxy_ignore_headers</strong> <em>field</em> …;<br>  Default:  —  Context:  http , server , location<br>  禁用从代理服务器处理某些响应头字段。 可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p> 如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应缓存的参数; </li>
<li>“X-Accel-Redirect”执行内部重定向到指定的URI; </li>
<li>“X-Accel-Limit-Rate”设置向客户端传输响应的速率限制 ; </li>
<li>“X-Accel-Buffering”启用或禁用缓冲响应; </li>
<li><p>“X-Accel-Charset”设置了所需的响应字符集 。<br>Syntax:  <strong>proxy_intercept_errors</strong> on | off ;<br>Default:  proxy_intercept_errors off;  Context:  http , server , location<br>确定代码大于或等于300的代理响应是应该传递给客户端还是被拦截并重定向到nginx以便使用error_page指令进行处理。 </p>
<p>Syntax:  <strong>proxy_limit_rate</strong> <em>rate</em> ;<br>Default:  proxy_limit_rate 0;  Context:  http , server , location<br>该指令出现在1.7.7版本中。 </p>
<p>限制从代理服务器读取响应的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据请求设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。 仅当启用了代理服务器的响应缓冲时 ，此限制才有效。 </p>
<p>Syntax:  <strong>proxy_max_temp_file_size</strong> <em>size</em> ;<br>Default:  proxy_max_temp_file_size 1024m;  Context:  http , server , location<br>当启用来自代理服务器的响应缓冲 ，并且整个响应不适合proxy_buffer_size和proxy_buffers指令设置的缓冲区时，响应的一部分可以保存到临时文件中。 该指令设置临时文件的最大<em>size</em> 。 一次写入临时文件的数据大小由proxy_temp_file_write_size指令设置。 </p>
<p>零值禁用缓冲对临时文件的响应。 </p>
</li>
</ul>
<blockquote>
<p> 此限制不适用于将缓存或存储在磁盘上的响应。  Syntax:  <strong>proxy_method</strong> <em>method</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定在转发到代理服务器的请求中使用的HTTP <em>method</em> ，而不是客户端请求中的方法。 参数值可以包含变量（1.11.6）。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_next_upstream</strong> error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>  Default:  proxy_next_upstream error timeout;  Context:  http , server , location<br>  指定应将请求传递到下一个服务器的情况： </p>
<p> error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_header   服务器返回空或无效响应;  http_500   服务器返回代码为500的响应;  http_502   服务器返回代码为502的响应;  http_503   服务器返回代码为503的响应;  http_504   服务器返回代码504的响应;  http_403   服务器返回代码为403的响应;  http_404   服务器返回代码为404的响应;  http_429   服务器返回代码为429的响应（1.11.13）;  non_idempotent   通常，如果请求已发送到上游服务器，则使用非幂等方法（ POST ， LOCK ， PATCH ）的请求不会传递给下一个服务器（1.9.13）; 启用此选项显式允许重试此类请求;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p> 该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_header情况始终被视为不成功的尝试，即使它们未在指令中指定。 http_500 ， http_502 ， http_503 ， http_504和http_429情况仅在指令中指定http_429被视为不成功尝试。 http_403和http_404情况从未被视为不成功的尝试。 </p>
<p> 将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>proxy_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  proxy_next_upstream_timeout 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p> Syntax:  <strong>proxy_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  proxy_next_upstream_tries 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>proxy_no_cache</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不将响应保存到缓存的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<blockquote>
<p>proxy_no_cache $cookie_nocache $arg_nocache$arg_comment; proxy_no_cache $http_pragma $http_authorization;  可以与proxy_cache_bypass指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_pass</strong> <em>URL</em> ;<br>  Default:  —  Context:  location , if in location , limit_except<br>  设置代理服务器的协议和地址以及应映射位置的可选URI。 作为协议，可以指定“ http ”或“ https ”。 可以将地址指定为域名或IP地址，以及可选端口： </p>
<blockquote>
<p>proxy_pass <a href="http://localhost:8000/uri/" target="_blank" rel="noopener">http://localhost:8000/uri/</a>;  或者作为在单词“ unix ”之后指定并用冒号括起来的UNIX域套接字路径： </p>
<p>proxy_pass <a href="http://unix:/tmp/backend.socket:/uri/" target="_blank" rel="noopener">http://unix:/tmp/backend.socket:/uri/</a>;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> 参数值可以包含变量。 在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用解析器确定。 </p>
<p> 请求URI按如下方式传递给服务器： </p>
<ul>
<li>如果使用URI指定了proxy_pass指令，那么当请求传递给服务器时，与该位置匹配的规范化请求URI的一部分将被指令中指定的URI替换： <blockquote>
<p>location /name/ { proxy_pass <a href="http://127.0.0.1/remote/" target="_blank" rel="noopener">http://127.0.0.1/remote/</a>; } </p>
</blockquote>
</li>
<li><p>如果指定了proxy_pass而没有URI，则请求URI将以与处理原始请求时客户端发送的格式相同的形式传递给服务器，或者在处理更改的URI时传递完整的规范化请求URI： </p>
<blockquote>
<p>location /some/path/ { proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>; }<br> 在版本1.1.12之前，如果指定了proxy_pass而没有URI，则在某些情况下可能会传递原始请求URI而不是更改的URI。<br>在某些情况下，无法确定要替换的请求URI的部分： </p>
</blockquote>
</li>
<li><p>使用正则表达式指定位置时，以及在命名位置内指定位置。  在这些情况下，应指定proxy_pass而不使用URI。 </p>
</li>
</ul>
<ul>
<li>使用rewrite指令在代理位置内更改URI时，将使用相同的配置来处理请求（ break ）： <blockquote>
<p>location /name/ { rewrite /name/([^/]+) /users?name=$1 break; proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>; }  在这种情况下，将忽略指令中指定的URI，并将完整更改的请求URI传递给服务器。 </p>
</blockquote>
</li>
</ul>
<ul>
<li><p>在proxy_pass中使用变量时： </p>
<blockquote>
<p>location /name/ { proxy_pass <a href="http://127.0.0.1$request\_uri" target="_blank" rel="noopener">http://127.0.0.1$request\_uri</a>; }  在这种情况下，如果在指令中指定了URI，则将其原样传递给服务器，替换原始请求URI。<br>WebSocket代理需要特殊配置，从版本1.3.13开始支持。 </p>
</blockquote>
<p>Syntax:  <strong>proxy_pass_header</strong> <em>field</em> ;<br>Default:  —  Context:  http , server , location<br>允许将已禁用的头字段从代理服务器传递到客户端。 </p>
<p>Syntax:  <strong>proxy_pass_request_body</strong> on | off ;<br>Default:  proxy_pass_request_body on;  Context:  http , server , location<br>指示是否将原始请求正文传递给代理服务器。 </p>
</li>
</ul>
<blockquote>
<p>location /x-accel-redirect-here/ { proxy_method GET; proxy_pass_request_body off; proxy_set_header Content-Length “”; proxy_pass … }  另请参阅proxy_set_header和proxy_pass_request_headers指令。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_pass_request_headers</strong> on | off ;<br>  Default:  proxy_pass_request_headers on;  Context:  http , server , location<br>  指示是否将原始请求的标头字段传递给代理服务器。 </p>
<blockquote>
<p>location /x-accel-redirect-here/ { proxy_method GET; proxy_pass_request_headers off; proxy_pass_request_body off; proxy_pass … }  另请参阅proxy_set_header和proxy_pass_request_body指令。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_read_timeout</strong> <em>time</em> ;<br>  Default:  proxy_read_timeout 60s;  Context:  http , server , location<br>  定义从代理服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果代理服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>proxy_redirect</strong> default ;<br> <strong>proxy_redirect</strong> off ;<br> <strong>proxy_redirect</strong> <em>redirect</em> <em>replacement</em> ;<br>  Default:  proxy_redirect default;  Context:  http , server , location<br>  设置应在代理服务器响应的“位置”和“刷新”标头字段中更改的文本。 假设代理服务器返回标题字段“ Location: <a href="http://localhost:8000/two/some/uri/" target="_blank" rel="noopener">http://localhost:8000/two/some/uri/</a> ”。 指令 </p>
<blockquote>
<p>proxy_redirect <a href="http://localhost:8000/two/" target="_blank" rel="noopener">http://localhost:8000/two/</a> <a href="http://frontend/one/" target="_blank" rel="noopener">http://frontend/one/</a>;  将此字符串重写为“ Location: <a href="http://frontend/one/some/uri/" target="_blank" rel="noopener">http://frontend/one/some/uri/</a> ”。 </p>
</blockquote>
<p> <em>replacement</em>字符串中可能省略了服务器名称： </p>
<blockquote>
<p>proxy_redirect <a href="http://localhost:8000/two/" target="_blank" rel="noopener">http://localhost:8000/two/</a> /;  然后将插入主服务器的名称和端口（如果与80不同）。 </p>
</blockquote>
<p> default参数指定的默认替换使用location和proxy_pass指令的参数。 因此，以下两种配置是等效的： </p>
<blockquote>
<p>location /one/ { proxy_pass <a href="http://upstream:port/two/" target="_blank" rel="noopener">http://upstream:port/two/</a>; proxy_redirect default;<br>location /one/ { proxy_pass <a href="http://upstream:port/two/" target="_blank" rel="noopener">http://upstream:port/two/</a>; proxy_redirect <a href="http://upstream:port/two/" target="_blank" rel="noopener">http://upstream:port/two/</a> /one/;  如果使用变量指定proxy_pass，则不允许使用default参数。 </p>
</blockquote>
<p> <em>replacement</em>字符串可以包含变量： </p>
<blockquote>
<p>proxy_redirect <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> <a href="http://$host:$server\_port/" target="_blank" rel="noopener">http://$host:$server\_port/</a>;  <em>redirect</em>还可以包含（1.1.11）变量： </p>
<p>proxy_redirect <a href="http://$proxy\_host:8000/" target="_blank" rel="noopener">http://$proxy\_host:8000/</a> /;  可以使用正则表达式指定（1.1.11）指令。 在这种情况下， <em>redirect</em>应该以“ ~ ”符号开头，以区分大小写的匹配，或者使用“ ~<em> ”符号以区分大小写匹配。 正则表达式可以包含命名和位置捕获， </em>replacement*可以引用它们： </p>
<p>proxy_redirect ~^(<a href="http://[^:]+):\d+(/.+)$" target="_blank" rel="noopener">http://[^:]+):\d+(/.+)$</a> $1$2; proxy_redirect ~*/user/([^/]+)/(.+)$ <a href="http://$1.example.com/$2" target="_blank" rel="noopener">http://$1.example.com/$2</a>;  可能有几个proxy_redirect指令： </p>
<p>proxy_redirect default; proxy_redirect <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> /; proxy_redirect <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> /;  off参数取消所有proxy_redirect指令对当前级别的影响： </p>
<p>proxy_redirect off; proxy_redirect default; proxy_redirect <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> /; proxy_redirect <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> /;  使用此指令，还可以将主机名添加到代理服务器发出的相对重定向： </p>
<p>proxy_redirect / /;  Syntax:  <strong>proxy_request_buffering</strong> on | off ;<br>  Default:  proxy_request_buffering on;  Context:  http , server , location<br>  该指令出现在1.7.11版本中。 </p>
</blockquote>
<p> 启用或禁用客户端请求正文的缓冲。 </p>
<p> 启用缓冲后，在将请求发送到代理服务器之前，将从客户端读取整个请求正文。 </p>
<p> 禁用缓冲时，请求主体在收到时立即发送到代理服务器。 在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给下一个服务器 。 </p>
<p> 当使用HTTP / 1.1分块传输编码发送原始请求主体时，无论指令值如何，都将缓冲请求主体，除非为代理启用了HTTP / 1.1。 </p>
<p> Syntax:  <strong>proxy_send_lowat</strong> <em>size</em> ;<br>  Default:  proxy_send_lowat 0;  Context:  http , server , location<br>  如果指令设置为非零值，则nginx将尝试通过使用kqueue方法的NOTE_LOWAT标志或具有指定<em>size</em>的SO_SNDLOWAT套接字选项来最小化到代理服务器的传出连接上的发送操作数。 </p>
<p> 在Linux，Solaris和Windows上忽略此指令。 </p>
<p> Syntax:  <strong>proxy_send_timeout</strong> <em>time</em> ;<br>  Default:  proxy_send_timeout 60s;  Context:  http , server , location<br>  设置将请求传输到代理服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果代理服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>proxy_set_body</strong> <em>value</em> ;<br>  Default:  —  Context:  http , server , location<br>  允许重新定义传递给代理服务器的请求正文。 该<em>value</em>可以包含文本，变量及其组合。 </p>
<p> Syntax:  <strong>proxy_set_header</strong> <em>field</em> <em>value</em> ;<br>  Default:  proxy_set_header Host $proxy_host;proxy_set_header Connection close;  Context:  http , server , location<br>  允许将字段重新定义或附加到传递给代理服务器的请求标头。 该<em>value</em>可以包含文本，变量及其组合。 当且仅当在当前级别上没有定义proxy_set_header指令时，这些指令才从先前级别继承。 默认情况下，只重新定义了两个字段： </p>
<blockquote>
<p>proxy_set_header Host $proxy_host; proxy_set_header Connection close;  如果启用了缓存，则标题字段为“If-Modified-Since”，“If-Unmodified-Since”，“If-None-Match”，“If-Match”，“Range”和“If-Range”来自原始请求不会传递给代理服务器。 </p>
</blockquote>
<p> 未更改的“主机”请求标头字段可以像这样传递： </p>
<blockquote>
<p>proxy_set_header Host $http_host;  但是，如果客户端请求标头中不存在此字段，则不会传递任何内容。 在这种情况下，最好使用$host变量 - 它的值等于“Host”请求头字段中的服务器名称，或者如果此字段不存在则等于主服务器名称： </p>
<p>proxy_set_header Host $host;  此外，服务器名称可以与代理服务器的端口一起传递： </p>
<p>proxy_set_header Host $host:$proxy_port;  如果标头字段的值为空字符串，则此字段将不会传递给代理服务器： </p>
<p>proxy_set_header Accept-Encoding “”;  Syntax:  <strong>proxy_socket_keepalive</strong> on | off ;<br>  Default:  proxy_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
</blockquote>
<p> 配置到代理服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>proxy_ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有PEM格式的证书的<em>file</em> ，该证书用于对代理的HTTPS服务器进行身份验证。 </p>
<p> Syntax:  <strong>proxy_ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有PEM格式的密钥的<em>file</em> ，用于对代理的HTTPS服务器进行身份验证。 </p>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> （1.7.9），该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>proxy_ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  proxy_ssl_ciphers DEFAULT;  Context:  http , server , location<br>  该指令出现在1.5.6版本中。 </p>
<p> 指定对代理HTTPS服务器的请求的已启用密码。 密码以OpenSSL库理解的格式指定。 </p>
<p> 可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> Syntax:  <strong>proxy_ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证代理HTTPS服务器的证书。 </p>
<p> Syntax:  <strong>proxy_ssl_name</strong> <em>name</em> ;<br>  Default:  proxy_ssl_name $proxy_host;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 允许覆盖用于验证代理HTTPS服务器证书的服务器名称，并在与代理HTTPS服务器建立连接时通过SNI传递 。 </p>
<p> 默认情况下，使用proxy_pass URL的主机部分。 </p>
<p> Syntax:  <strong>proxy_ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> Syntax:  <strong>proxy_ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  http , server , location<br>  该指令出现在1.5.6版本中。 </p>
<p> 为代理HTTPS服务器的请求启用指定的协议。 </p>
<p> Syntax:  <strong>proxy_ssl_server_name</strong> on | off ;<br>  Default:  proxy_ssl_server_name off;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 在与代理的HTTPS服务器建立连接时，启用或禁用通过TLS服务器名称指示扩展 （SNI，RFC 6066）传递服务器名称。 </p>
<p> Syntax:  <strong>proxy_ssl_session_reuse</strong> on | off ;<br>  Default:  proxy_ssl_session_reuse on;  Context:  http , server , location<br>  确定在使用代理服务器时是否可以重用SSL会话。 如果日志中出现“ SSL3_GET_FINISHED:digest check failed ”错误，请尝试禁用会话重用。 </p>
<p> Syntax:  <strong>proxy_ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证代理HTTPS服务器的证书。 </p>
<p> Syntax:  <strong>proxy_ssl_verify</strong> on | off ;<br>  Default:  proxy_ssl_verify off;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 启用或禁用代理HTTPS服务器证书的验证。 </p>
<p> Syntax:  <strong>proxy_ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  proxy_ssl_verify_depth 1;  Context:  http , server , location<br>  该指令出现在1.7.0版本中。 </p>
<p> 在代理的HTTPS服务器证书链中设置验证深度。 </p>
<p> Syntax:  <strong>proxy_store</strong> on | off | <em>string</em> ;<br>  Default:  proxy_store off;  Context:  http , server , location<br>  允许将文件保存到磁盘。 on参数使用与指令别名或root对应的路径保存文件。 off参数禁用文件保存。 此外，可以使用带变量的<em>string</em>显式设置文件名： </p>
<blockquote>
<p>proxy_store /data/www$original_uri;  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。 首先将响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，由proxy_temp_path指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
</blockquote>
<p> 该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<blockquote>
<p>location /images/ { root /data/www; error_page 404 = /fetch$uri; } location /fetch/ { internal; proxy_pass <a href="http://backend/" target="_blank" rel="noopener">http://backend/</a>; proxy_store on; proxy_store_access user:rw group:rw all:r; proxy_temp_path /data/temp; alias /data/www/; }  或者像这样： </p>
<p>location /images/ { root /data/www; error_page 404 = @fetch; } location @fetch { internal; proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_store on; proxy_store_access user:rw group:rw all:r; proxy_temp_path /data/temp; root /data/www; }  Syntax:  <strong>proxy_store_access</strong> <em>users</em> : <em>permissions</em> …;<br>  Default:  proxy_store_access user:rw;  Context:  http , server , location<br>  为新创建的文件和目录设置访问权限，例如： </p>
<p>proxy_store_access user:rw group:rw all:r;  如果指定了任何group或all访问权限，则可以省略user权限： </p>
<p>proxy_store_access group:rw all:r;  Syntax:  <strong>proxy_temp_file_write_size</strong> <em>size</em> ;<br>  Default:  proxy_temp_file_write_size 8k|16k;  Context:  http , server , location<br>  当启用从代理服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<em>size</em> 。 默认情况下， <em>size</em>由proxy_buffer_size和proxy_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由proxy_max_temp_file_size指令设置。 </p>
</blockquote>
<p> Syntax:  <strong>proxy_temp_path</strong> <em>path</em> [ <em>level1</em> [ <em>level2</em> [ <em>level3</em> ]]];<br>  Default:  proxy_temp_path proxy_temp;  Context:  http , server , location<br>  定义用于存储临时文件的目录，其中包含从代理服务器接收的数据。 在指定目录下最多可以使用三级子目录层次结构。 例如，在以下配置中 </p>
<blockquote>
<p>proxy_temp_path /spool/nginx/proxy_temp 1 2;  临时文件可能如下所示： </p>
<p>/spool/nginx/proxy_temp/ <strong>7</strong> / <strong>45</strong> /00000123 <strong>457</strong>  另请参阅proxy_cache_path指令的use_temp_path参数。 </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_proxy_module模块支持嵌入式变量，这些变量可用于使用proxy_set_header指令组合头： </p>
<p> $proxy_host   proxy_pass指令中指定的代理服务器的名称和端口;  $proxy_port   proxy_pass指令中指定的代理服务器的端口，或协议的默认端口;  $proxy_add_x_forwarded_for   “X-Forwarded-For”客户端请求头字段，其中附加了$remote_addr变量，以逗号分隔。 如果客户端请求标头中不存在“X-Forwarded-For”字段，则$proxy_add_x_forwarded_for变量等于$remote_addr变量。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_perl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_perl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_perl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-perl-module"><a href="#Module-ngx-http-perl-module" class="headerlink" title="Module ngx_http_perl_module"></a>Module ngx_http_perl_module</h2><p> Known Issues<br> Example Configuration<br> Directives<br> perl<br> perl_modules<br> perl_require<br> perl_set<br> Calling Perl from SSI<br> The $r Request Object Methods<br> ngx_http_perl_module模块用于在Perl中实现位置和变量处理程序，并将Perl调用插入到SSI中。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_perl_module配置参数启用它。 </p>
<blockquote>
<p> 此模块需要Perl 5.6.1或更高版本。 C编译器应该与用于构建Perl的编译器兼容。 ####  已知的问题</p>
</blockquote>
<p> 该模块是实验性的，需要注意的是经纪人。 </p>
<p> 为了让Perl在重新配置期间重新编译已修改的模块，它应该使用-Dusemultiplicity=yes或-Dusethreads=yes参数-Dusethreads=yes 。 另外，为了使Perl在运行时泄漏更少的内存，应该使用-Dusemymalloc=no参数构建它。 要在已构建的Perl中检查这些参数的值（在示例中指定了首选值），请运行： </p>
<blockquote>
<p>$ perl -V:usemultiplicity -V:usemymalloc usemultiplicity=’define’; usemymalloc=’n’;  请注意，在使用新的-Dusemultiplicity=yes或-Dusethreads=yes参数重建Perl之后，还必须重建所有二进制Perl模块 - 它们将停止使用新的Perl。 </p>
</blockquote>
<p> 每次重新配置后，主进程和工作进程都有可能增大。 如果主进程增长到不可接受的大小，则可以在不更改可执行文件的情况下应用实时升级过程。 </p>
<p> 当Perl模块执行长时间运行的操作（例如解析域名，连接到另一个服务器或查询数据库）时，将不会处理分配给当前工作进程的其他请求。 因此，建议仅执行具有可预测和短执行时间的此类操作，例如访问本地文件系统。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>http { perl_modules perl/lib; perl_require hello.pm; perl_set $msie6 ‘ sub { my $r = shift; my $ua = $r-&gt;header_in(“User-Agent”); return “” if $ua =~ /Opera/; return “1” if $ua =~ / MSIE [6-9].\d+/; return “”; } ‘; server { location / { perl hello::handler; } }  perl/lib/hello.pm模块： </p>
<p>package hello; use nginx; sub handler { my $r = shift; $r-&gt;send_http_header(“text/html”); return OK if $r-&gt;header_only; $r-&gt;print(“hello!\n<br>“); if (-f $r-&gt;filename or -d _) { $r-&gt;print($r-&gt;uri, “ exists!\n”); } return OK; } 1; __END__ ####  指令</p>
</blockquote>
<p> Syntax:  <strong>perl</strong> <em>module</em> :: <em>function</em> |’sub { … }’;<br>  Default:  —  Context:  location , limit_except<br>  为给定位置设置Perl处理程序。 </p>
<p> Syntax:  <strong>perl_modules</strong> <em>path</em> ;<br>  Default:  —  Context:  http<br>  为Perl模块设置其他路径。 </p>
<p> Syntax:  <strong>perl_require</strong> <em>module</em> ;<br>  Default:  —  Context:  http<br>  定义将在每次重新配置期间加载的模块的名称。 可以存在几个perl_require指令。 </p>
<p> Syntax:  <strong>perl_set</strong> <em>$variable</em> <em>module</em> :: <em>function</em> |’sub { … }’;<br>  Default:  —  Context:  http<br>  为指定的变量安装Perl处理程序。 </p>
<h4 id="从SSI调用Perl"><a href="#从SSI调用Perl" class="headerlink" title="从SSI调用Perl"></a>从SSI调用Perl</h4><p> 调用Perl的SSI命令具有以下格式： </p>
<blockquote>
<p><!--# perl sub=" *module* :: *function* " arg=" *parameter1* " arg=" *parameter2* " ... --> ####  $ r请求对象方法</p>
</blockquote>
<p> $r-&gt;args   返回请求参数。  $r-&gt;filename   返回与请求URI对应的文件名。  $r-&gt;has_request_body( <em>handler</em> )   如果请求中没有正文，则返回0。 如果有正文，则为请求设置指定的处理程序，并返回1。 在读取请求主体后，nginx将调用指定的处理程序。 请注意，处理函数应该通过引用传递。 例： </p>
<blockquote>
<p>package hello; use nginx; sub handler { my $r = shift; if ($r-&gt;request_method ne “POST”) { return DECLINED; } if ($r-&gt;has_request_body( <strong>\&amp;post</strong> )) { return OK; } return HTTP_BAD_REQUEST; } sub <strong>post</strong> { my $r = shift; $r-&gt;send_http_header; $r-&gt;print(“request_body: \””, $r-&gt;request_body, “\”<br>“); $r-&gt;print(“request_body_file: \””, $r-&gt;request_body_file, “\”<br>\n”); return OK; } 1; __END__  $r-&gt;allow_ranges   在发送响应时允许使用字节范围。  $r-&gt;discard_request_body   指示nginx丢弃请求正文。  $r-&gt;header_in( <em>field</em> )   返回指定的客户端请求标头字段的值。  $r-&gt;header_only   确定是应将整个响应还是仅应将其标头发送给客户端。  $r-&gt;header_out( <em>field</em> , <em>value</em> )   为指定的响应头字段设置一个值。  $r-&gt;internal_redirect( <em>uri</em> )   内部重定向到指定的<em>uri</em> 。 Perl处理程序执行完成后发生实际重定向。<br> 目前不支持重定向到命名位置。  $r-&gt;log_error( <em>errno</em> , <em>message</em> )   将指定的<em>message</em>写入error_log 。 如果<em>errno</em>不为零，则错误代码及其描述将附加到消息中。  $r-&gt;print( <em>text</em> , …)   将数据传递给客户端。  $r-&gt;request_body   如果客户端请求正文尚未写入临时文件，则返回该请求正文。 要确保客户端请求正文在内存中，其大小应受client_max_body_size限制，并且应使用client_body_buffer_size设置足够的缓冲区大小。  $r-&gt;request_body_file   返回客户端请求正文的文件名。 处理完毕后，应删除该文件。 要始终将请求主体写入文件，应启用client_body_in_file_only 。  $r-&gt;request_method   返回客户端请求HTTP方法。  $r-&gt;remote_addr   返回客户端IP地址。  $r-&gt;flush   立即将数据发送到客户端。  $r-&gt;sendfile( <em>name</em> [, <em>offset</em> [, <em>length</em> ]])   将指定的文件内容发送给客户端。 可选参数指定要传输的数据的初始偏移量和长度。 实际的数据传输发生在Perl处理程序完成之后。  $r-&gt;send_http_header([ <em>type</em> ])   将响应头发送给客户端。 可选的<em>type</em>参数设置“Content-Type”响应头字段的值。 如果该值为空字符串，则不会发送“Content-Type”标头字段。  $r-&gt;status( <em>code</em> )   设置响应代码。  $r-&gt;sleep( <em>milliseconds</em> , <em>handler</em> )   设置指定的处理程序并停止指定时间的请求处理。 与此同时，nginx继续处理其他请求。 经过指定的时间后，nginx将调用已安装的处理程序。 请注意，处理函数应该通过引用传递。 为了在处理程序之间传递数据，应该使用$r-&gt;variable() 。 例：<br>package hello; use nginx; sub handler { my $r = shift; $r-&gt;discard_request_body; $r-&gt;variable(“var”, “OK”); $r-&gt;sleep(1000, <strong>\&amp;next</strong> ); return OK; } sub <strong>next</strong> { my $r = shift; $r-&gt;send_http_header; $r-&gt;print($r-&gt;variable(“var”)); return OK; } 1; __END__  $r-&gt;unescape( <em>text</em> )   解码以“％XX”形式编码的文本。  $r-&gt;uri   返回请求URI。  $r-&gt;variable( <em>name</em> [, <em>value</em> ])   返回或设置指定变量的值。 变量是每个请求的本地变量。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mp4_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mp4_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mp4_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mp4-module"><a href="#Module-ngx-http-mp4-module" class="headerlink" title="Module ngx_http_mp4_module"></a>Module ngx_http_mp4_module</h2><p> Example Configuration<br> Directives<br> mp4<br> mp4_buffer_size<br> mp4_max_buffer_size<br> mp4_limit_rate<br> mp4_limit_rate_after<br> ngx_http_mp4_module模块为MP4文件提供伪流服务器端支持。 此类文件通常具有.mp4 ， .m4v或.m4a文件扩展名。 </p>
<p> 伪流与兼容的Flash播放器结合使用。 播放器使用查询字符串参数中指定的开始时间（仅命名为start并以秒为单位指定）向服务器发送HTTP请求，服务器以流响应，使其起始位置对应于请求的时间，例如： </p>
<blockquote>
<p><a href="http://example.com/elephants\_dream.mp4?start=238.88" target="_blank" rel="noopener">http://example.com/elephants\_dream.mp4?start=238.88</a>  这允许在任何时间执行随机搜索，或者在时间线的中间开始回放。 </p>
</blockquote>
<p> 为了支持搜索，基于H.264的格式将元数据存储在所谓的“moov原子”中。 它是文件的一部分，用于保存整个文件的索引信息。 </p>
<p> 要开始播放，播放器首先需要读取元数据。 这是通过使用start=0参数发送特殊请求来完成的。 许多编码软件在文件末尾插入元数据。 这对于伪流是次优的，因为播放器必须在开始播放之前下载整个文件。 如果元数据位于文件的开头，则nginx只需开始发回文件内容就足够了。 如果元数据位于文件末尾，则nginx必须读取整个文件并准备新流，以便元数据位于媒体数据之前。 这涉及一些CPU，内存和磁盘I / O开销，因此最好事先准备一个用于伪流的原始文件 ，而不是让nginx在每个这样的请求上执行此操作。 </p>
<p> 该模块还支持HTTP请求的end参数（1.5.13），该请求设置回放的结束点。 end参数可以使用start参数指定，也可以单独指定： </p>
<blockquote>
<p><a href="http://example.com/elephants\_dream.mp4?start=238.88&amp;end=555.55" target="_blank" rel="noopener">http://example.com/elephants\_dream.mp4?start=238.88&amp;end=555.55</a>  对于具有非零start或end参数的匹配请求，nginx将从文件中读取元数据，准备具有所请求时间范围的流，并将其发送到客户端。 这具有与上述相同的开销。 </p>
</blockquote>
<p> 如果匹配请求不包含start和end参数，则没有开销，并且文件仅作为静态资源发送。 一些播放器也支持字节范围请求，因此不需要此模块。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_mp4_module配置参数启用它。 </p>
<blockquote>
<p> 如果以前使用过第三方mp4模块，则应禁用它。  ngx_http_flv_module模块提供了对FLV文件的类似伪流支持。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location /video/ { mp4; mp4_buffer_size 1m; mp4_max_buffer_size 5m; mp4_limit_rate on; mp4_limit_rate_after 30s; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>mp4</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的模块处理。 </p>
<p> Syntax:  <strong>mp4_buffer_size</strong> <em>size</em> ;<br>  Default:  mp4_buffer_size 512K;  Context:  http , server , location<br>  设置用于处理MP4文件的缓冲区的初始<em>size</em> 。 </p>
<p> Syntax:  <strong>mp4_max_buffer_size</strong> <em>size</em> ;<br>  Default:  mp4_max_buffer_size 10M;  Context:  http , server , location<br>  在元数据处理期间，可能需要更大的缓冲区。 它的大小不能超过指定的<em>size</em> ，否则nginx将返回500（内部服务器错误）服务器错误，并记录以下消息： </p>
<blockquote>
<p>“/some/movie/file.mp4” mp4 moov atom is too large: 12583268, you may want to increase mp4_max_buffer_size  Syntax:  <strong>mp4_limit_rate</strong> on | off | <em>factor</em> ;<br>  Default:  mp4_limit_rate off;  Context:  http , server , location<br>  限制向客户端传输的响应速率。 根据所服务的MP4文件的平均比特率限制速率。 要计算速率，比特率乘以指定的<em>factor</em> 。 特殊值“ on ”对应于因子1.1。 特殊值“ off ”禁用速率限制。 根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<p> 该指令作为我们商业订阅的一部分提供。  Syntax:  <strong>mp4_limit_rate_after</strong> <em>time</em> ;<br>  Default:  mp4_limit_rate_after 60s;  Context:  http , server , location<br>  设置媒体数据的初始量（以回放时间测量），之后对客户端的进一步传输将是速率限制的。 </p>
<p> 该指令作为我们商业订阅的一部分提供。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mirror_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mirror_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mirror_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mirror-module"><a href="#Module-ngx-http-mirror-module" class="headerlink" title="Module ngx_http_mirror_module"></a>Module ngx_http_mirror_module</h2><p> Example Configuration<br> Directives<br> mirror<br> mirror_request_body<br> ngx_http_mirror_module模块（1.13.4）通过创建后台镜像子请求来实现原始请求的镜像。 忽略对镜像子请求的响应。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { mirror /mirror; proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; } location = /mirror { internal; proxy_pass <a href="http://test\_backend$request\_uri" target="_blank" rel="noopener">http://test\_backend$request\_uri</a>; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>mirror</strong> <em>uri</em> | off ;<br>  Default:  mirror off;  Context:  http , server , location<br>  设置将镜像原始请求的URI。 可以在同一级别指定多个镜像。 </p>
<p> Syntax:  <strong>mirror_request_body</strong> on | off ;<br>  Default:  mirror_request_body on;  Context:  http , server , location<br>  指示是否镜像客户端请求正文。 启用后，将在创建镜像子请求之前读取客户端请求正文。 在这种情况下，将禁用由proxy_request_buffering ， fastcgi_request_buffering ， scgi_request_buffering和uwsgi_request_buffering指令设置的无缓冲客户机请求正文代理。 </p>
<blockquote>
<p>location / { mirror /mirror; mirror_request_body off; proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; } location = /mirror { internal; proxy_pass <a href="http://log\_backend" target="_blank" rel="noopener">http://log\_backend</a>; proxy_pass_request_body off; proxy_set_header Content-Length “”; proxy_set_header X-Original-URI $request_uri; }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_memcached_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_memcached_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_memcached_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-memcached-module"><a href="#Module-ngx-http-memcached-module" class="headerlink" title="Module ngx_http_memcached_module"></a>Module ngx_http_memcached_module</h2><p> Example Configuration<br> Directives<br> memcached_bind<br> memcached_buffer_size<br> memcached_connect_timeout<br> memcached_force_ranges<br> memcached_gzip_flag<br> memcached_next_upstream<br> memcached_next_upstream_timeout<br> memcached_next_upstream_tries<br> memcached_pass<br> memcached_read_timeout<br> memcached_send_timeout<br> memcached_socket_keepalive<br> Embedded Variables<br> ngx_http_memcached_module模块用于从memcached服务器获取响应。 密钥在$memcached_key变量中设置。 响应应该通过nginx外部的方式预先存储在memcached中。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { location / { set $memcached_key “$uri?$args”; memcached_pass host:11211; error_page 404 502 504 = @fallback; } location @fallback { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>memcached_bind</strong> <em>address</em> [ transparent  ] | off ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在0.8.22版本中。 </p>
<p> 使用可选端口（1.11.2）从指定的本地IP地址发出到memcached服务器的传出连接。 参数值可以包含变量（1.3.12）。 特殊值off （1.3.12）取消了从先前配置级别继承的memcached_bind指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数（1.11.0）允许到memcached服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>memcached_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还必须配置内核路由表以拦截来自memcached服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>memcached_buffer_size</strong> <em>size</em> ;<br>  Default:  memcached_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从memcached服务器接收的响应的缓冲区的<em>size</em> 。 一旦收到响应，响应就会同步传递给客户端。 </p>
<p> Syntax:  <strong>memcached_connect_timeout</strong> <em>time</em> ;<br>  Default:  memcached_connect_timeout 60s;  Context:  http , server , location<br>  定义与memcached服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
<p> Syntax:  <strong>memcached_force_ranges</strong> on | off ;<br>  Default:  memcached_force_ranges off;  Context:  http , server , location<br>  该指令出现在1.7.7版本中。 </p>
<p> 无论来自这些响应中的“Accept-Ranges”字段，都可以对来自memcached服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p> Syntax:  <strong>memcached_gzip_flag</strong> <em>flag</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.3.6版本中。 </p>
<p> 如果设置了<em>flag</em> ，则在memcached服务器响应中启用<em>flag</em>存在的测试，并将“ Content-Encoding ”响应头字段设置为“ gzip ”。 </p>
<p> Syntax:  <strong>memcached_next_upstream</strong> error | timeout | invalid_response | not_found | off …;<br>  Default:  memcached_next_upstream error timeout;  Context:  http , server , location<br>  指定应将请求传递到下一个服务器的情况： </p>
<p> error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_response   服务器返回空或无效响应;  not_found   在服务器上找不到响应;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p> 该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_response情况始终被视为不成功的尝试，即使它们未在指令中指定。 not_found情况从未被视为不成功的尝试。 </p>
<p> 将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>memcached_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  memcached_next_upstream_timeout 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p> Syntax:  <strong>memcached_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  memcached_next_upstream_tries 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>memcached_pass</strong> <em>address</em> ;<br>  Default:  —  Context:  location , if in location<br>  设置memcached服务器地址。 地址可以指定为域名或IP地址，以及端口： </p>
<blockquote>
<p>memcached_pass localhost:11211;  或者作为UNIX域套接字路径： </p>
<p>memcached_pass unix:/tmp/memcached.socket;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> Syntax:  <strong>memcached_read_timeout</strong> <em>time</em> ;<br>  Default:  memcached_read_timeout 60s;  Context:  http , server , location<br>  定义从memcached服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果memcached服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>memcached_send_timeout</strong> <em>time</em> ;<br>  Default:  memcached_send_timeout 60s;  Context:  http , server , location<br>  设置将请求传输到memcached服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果memcached服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>memcached_socket_keepalive</strong> on | off ;<br>  Default:  memcached_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
<p> 配置到memcached服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> $memcached_key   定义用于从memcached服务器获取响应的密钥。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_map_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_map_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-map-module"><a href="#Module-ngx-http-map-module" class="headerlink" title="Module ngx_http_map_module"></a>Module ngx_http_map_module</h2><p> Example Configuration<br> Directives<br> map<br> map_hash_bucket_size<br> map_hash_max_size<br> ngx_http_map_module模块创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>map $http_host $name { hostnames; default 0; example.com 1; <em>.example.com 1; example.org 2; </em>.example.org 2; .example.net 3; wap.* 4; } map $http_user_agent $mobile { default 0; “~Opera Mini” 1; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>map</strong> <em>string</em> <em>$variable</em> { … }<br>  Default:  —  Context:  http<br>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p> 在0.9.0版之前，只能在第一个参数中指定单个变量。<br> 由于变量仅在使用时进行评估，因此即使是大量“ map ”变量的声明也不会增加请求处理的额外成本。  地图块内的参数指定源和结果值之间的映射。 </p>
</blockquote>
<p> 源值指定为字符串或正则表达式（0.9.6）。 </p>
<p> 字符串匹配忽略大小写。 </p>
<p> 对于区分大小写的匹配，正则表达式应该从“ ~ ”符号开始，或者对于不区分大小写的匹配，应该从“ ~* ”符号（1.0.4）开始。 正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p> 如果源值与下面描述的特殊参数名称之一匹配，则应使用“ \ ”符号作为前缀。 </p>
<p> 结果值可以包含文本，变量（0.9.0）及其组合（1.11.0）。 </p>
<p> 还支持以下特殊参数： </p>
<p> default <em>value</em>  如果源值与任何指定的变量都不匹配，则设置结果值。 如果未指定default，则默认结果值将为空字符串。  hostnames   表示源值可以是带有前缀或后缀掩码的主机名： </p>
<blockquote>
<p><em>.example.com 1; example.</em> 1;  以下两条记录<br>example.com 1; <em>.example.com 1;  可以合并：<br>.example.com 1;  应在值列表之前指定此参数。  include </em>file*  包含一个包含值的文件。 可能有几个夹杂物。  volatile   表示该变量不可缓存（1.11.7）。  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
</blockquote>
<ol>
<li>没有掩码的字符串值 </li>
<li>带有前缀掩码的最长字符串值，例如“ *.example.com ” </li>
<li>带有后缀掩码的最长字符串值，例如“ mail.* ” </li>
<li>第一个匹配正则表达式（按配置文件中的出现顺序） </li>
<li><p>默认值<br>Syntax:  <strong>map_hash_bucket_size</strong> <em>size</em> ;<br>Default:  map_hash_bucket_size 32|64|128;  Context:  http<br>设置映射变量哈希表的存储区大小。 默认值取决于处理器的缓存行大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p>Syntax:  <strong>map_hash_max_size</strong> <em>size</em> ;<br>Default:  map_hash_max_size 2048;  Context:  http<br>设置映射变量哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-log-module"><a href="#Module-ngx-http-log-module" class="headerlink" title="Module ngx_http_log_module"></a>Module ngx_http_log_module</h2><p> Example Configuration<br> Directives<br> access_log<br> log_format<br> open_log_file_cache<br> ngx_http_log_module模块以指定的格式写入请求日志。 </p>
<p> 请求记录在处理结束的位置的上下文中。 如果在请求处理期间发生内部重定向 ，则它可能与原始位置不同。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>log_format compression ‘$remote_addr - $remote_user [$time_local] ‘ ‘“$request” $status $bytes_sent ‘ ‘“$http_referer” “$http_user_agent” “$gzip_ratio”‘; access_log /spool/logs/nginx-access.log compression buffer=32k; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>access_log</strong> <em>path</em> [ <em>format</em> [ buffer = <em>size</em> ] [ gzip[= <em>level</em> ] ] [ flush = <em>time</em> ] [ if = <em>condition</em> ]];<br> <strong>access_log</strong> off ;<br>  Default:  access_log logs/access.log combined;  Context:  http , server , location , if in location , limit_except<br>  设置缓冲日志写入的路径，格式和配置。 可以在同一级别指定多个日志。 可以通过在第一个参数中指定“ syslog: ”前缀来配置记录到syslog 。 特殊值off取消当前级别的所有access_log指令。 如果未指定格式，则使用预定义的“ combined ”格式。 </p>
<p> 如果使用buffer或gzip （1.3.10,1.2.7）参数，则将缓冲写入日志。 </p>
<blockquote>
<p> 缓冲区大小不得超过磁盘文件的原子写入大小。 对于FreeBSD，这个大小是无限的。  启用缓冲后，数据将写入文件： </p>
</blockquote>
<ul>
<li>如果下一个日志行不适合缓冲区; </li>
<li>如果缓冲的数据早于flush参数（1.3.10,1.2.7）指定的数据; </li>
<li><p>当工作进程重新打开日志文件或正在关闭时。<br>如果使用gzip参数，则在写入文件之前将压缩缓冲的数据。 压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。 默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ zcat ”解压缩或读取。 </p>
<p>例： </p>
</li>
</ul>
<blockquote>
<p>access_log /path/to/log.gz combined gzip flush=5m;<br> 要使gzip压缩起作用，必须使用zlib库构建nginx。  文件路径可以包含变量（0.7.6+），但是这样的日志有一些约束： </p>
</blockquote>
<ul>
<li>工作进程使用其凭据的用户应具有在具有此类日志的目录中创建文件的权限; </li>
<li>缓冲写入不起作用; </li>
<li>每个日志写入都会打开和关闭该文件。 但是，由于常用文件的描述符可以存储在缓存中 ，因此写入旧文件可以在open_log_file_cache指令的valid参数指定的时间内继续写入 </li>
<li>在每个日志写入期间，检查是否存在请求的根目录 ，如果它不存在，则不会创建日志。 因此，在同一级别指定root和access_log是个好主意： <blockquote>
<p>server { root /spool/vhost/data/$host; access_log /spool/vhost/logs/$host; …<br>if参数（1.7.0）启用条件记录。 如果<em>condition</em>评估为“0”或空字符串，则不会记录请求。 在以下示例中，将不记录响应代码为2xx和3xx的请求： </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>map $status $loggable { ~^[23] 0; default 1; } access_log /path/to/access.log combined if=$loggable;  Syntax:  <strong>log_format</strong> <em>name</em> [ escape = default | json | none ] <em>string</em> …;<br>  Default:  log_format combined “…”;  Context:  http<br>  指定日志格式。 </p>
</blockquote>
<p> escape参数（1.11.8）允许设置在变量中转义的json或default字符，默认情况下，使用default转义。 none值（1.13.10）禁用转义。 </p>
<p> 日志格式可以包含公共变量，以及仅在日志写入时存在的变量： </p>
<p> $bytes_sent   发送到客户端的字节数  $connection   连接序列号  $connection_requests   通过连接发出的当前请求数（1.1.18）  $msec   以秒为单位的时间，日志写入时的分辨率为毫秒  $pipe   “ p ”如果请求是流水线的，“ . “ 除此以外  $request_length   请求长度（包括请求行，标题和请求正文）  $request_time   以毫秒为单位请求处理时间（以秒为单位）; 从客户端读取第一个字节之间经过的时间，并将最后一个字节发送到客户端后的日志写入  $status   回应状态  $time_iso8601   当地时间采用ISO 8601标准格式  $time_local   通用日志格式的本地时间 </p>
<blockquote>
<p> 在现代nginx版本变量$ status （ 1.3.2,1.2.2 ）， $ bytes_sent （ 1.3.8,1.2.5 ）， $ connection （ 1.3.8,1.2.5 ）， $ connection_requests （ 1.3.8,1.2 ） .5）， $ msec （1.3.9,1.2.6）， $ request_time （1.3.9,1.2.6）， $ pipe （1.3.12,1.2.7）， $ request_length （1.3.12,1.2.7） ）， $ time_iso8601 （ 1.3.12,1.2.7 ）和$ time_local （1.3.12,1.2.7）也可用作公共变量。  发送到客户端的标题行具有前缀“ sent_http_ ”，例如$sent_http_content_range 。 </p>
</blockquote>
<p> 配置始终包含预定义的“ combined ”格式： </p>
<blockquote>
<p>log_format combined ‘$remote_addr - $remote_user [$time_local] ‘ ‘“$request” $status $body_bytes_sent ‘ ‘“$http_referer” “$http_user_agent”‘;  Syntax:  <strong>open_log_file_cache</strong> max = <em>N</em> [ inactive = <em>time</em> ] [ min_uses = <em>N</em> ] [ valid = <em>time</em> ];<br> <strong>open_log_file_cache</strong> off ;<br>  Default:  open_log_file_cache off;  Context:  http , server , location<br>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。 该指令具有以下参数： </p>
</blockquote>
<p> max   设置缓存中的最大描述符数; 如果缓存变满，则最近最少使用（LRU）描述符将被关闭  inactive   如果在此期间没有访问权限，则设置关闭缓存描述符的时间; 默认情况下，10秒  min_uses   设置在inactive参数定义的时间内使文件使用的最小数量，以使描述符在缓存中保持打开状态; 默认情况下，1  valid   设置应该检查文件是否仍然存在同名的时间; 默认情况下，60秒  off   禁用缓存  用法示例： </p>
<blockquote>
<p>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_req_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_req_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_req_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-req-module"><a href="#Module-ngx-http-limit-req-module" class="headerlink" title="Module ngx_http_limit_req_module"></a>Module ngx_http_limit_req_module</h2><p> Example Configuration<br> Directives<br> limit_req<br> limit_req_log_level<br> limit_req_status<br> limit_req_zone<br> ngx_http_limit_req_module模块（0.7.21）用于限制每个定义密钥的请求处理速率，特别是来自单个IP地址的请求的处理速率。 使用“漏桶”方法进行限制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; … server { … location /search/ { limit_req zone=one burst=5; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>limit_req</strong> zone = <em>name</em> [ burst = <em>number</em> ] [ nodelay | delay = <em>number</em> ];<br>  Default:  —  Context:  http , server , location<br>  设置共享内存区域和请求的最大突发大小。 如果请求速率超过为区域配置的速率，则延迟其处理，以便以定义的速率处理请求。 过多的请求被延迟，直到它们的数量超过最大突发大小，在这种情况下请求以错误终止。 默认情况下，最大突发大小等于零。 例如，指令 </p>
<blockquote>
<p>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { location /search/ { limit_req zone=one burst=5; }  允许每秒平均不超过1个请求，突发不超过5个请求。 </p>
</blockquote>
<p> 如果不希望在请求受限的情况下延迟过多的请求，则应使用参数nodelay ： </p>
<blockquote>
<p>limit_req zone=one burst=5 nodelay;  delay参数（1.15.7）指定过多请求被延迟的限制。 默认值为零，即所有过多的请求都会延迟。 </p>
</blockquote>
<p> 可能有几个limit_req指令。 例如，以下配置将限制来自单个IP地址的请求的处理速率，同时限制虚拟服务器的请求处理速率： </p>
<blockquote>
<p>limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s; limit_req_zone $server_name zone=perserver:10m rate=10r/s; server { … limit_req zone=perip burst=5 nodelay; limit_req zone=perserver burst=10; }  当且仅当当前级别上没有limit_req指令时，这些指令才从先前级别继承。 </p>
</blockquote>
<p> Syntax:  <strong>limit_req_log_level</strong> info | notice | warn | error ;<br>  Default:  limit_req_log_level error;  Context:  http , server , location<br>  该指令出现在0.8.18版本中。 </p>
<p> 为服务器因速率超过或延迟请求处理而拒绝处理请求的情况设置所需的日志记录级别。 延迟的记录水平比拒绝的记录水平低一个点; 例如，如果指定了“ limit_req_log_level notice ”，则会使用info级别记录延迟。 </p>
<p> Syntax:  <strong>limit_req_status</strong> <em>code</em> ;<br>  Default:  limit_req_status 503;  Context:  http , server , location<br>  该指令出现在1.3.15版本中。 </p>
<p> 设置要响应拒绝的请求而返回的状态代码。 </p>
<p> Syntax:  <strong>limit_req_zone</strong> <em>key</em> zone = <em>name</em> : <em>size</em> rate = <em>rate</em> [ sync ];<br>  Default:  —  Context:  http<br>  设置共享内存区域的参数，该区域将保留各种键的状态。 特别是，状态存储当前的过多请求数。 <em>key</em>可以包含文本，变量及其组合。 具有空键值的请求不计算在内。 </p>
<blockquote>
<p> 在1.7.6版之前， <em>key</em>可以只包含一个变量。  用法示例： </p>
<p>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;  这里，状态保持在10兆字节区域“1”，并且该区域的平均请求处理速率不能超过每秒1个请求。 </p>
</blockquote>
<p> 客户端IP地址用作密钥。 请注意，此处使用$binary_remote_addr变量而不是$remote_addr 。 对于IPv4地址， $binary_remote_addr变量的大小始终为4个字节，对于IPv6地址，则为16个字节。 存储状态在32位平台上总是占用64个字节，在64位平台上占用128个字节。 一兆字节区域可以保留大约16,000个64字节状态或大约8千个128字节状态。 </p>
<p> 如果区域存储耗尽，则删除最近最少使用的状态。 即使在此之后无法创建新状态，该请求也会因错误而终止。 </p>
<p> 速率以每秒请求数（r / s）指定。 如果需要每秒少于一个请求的速率，则在每分钟请求（r / m）中指定。 例如，每秒半请求为30r / m。 </p>
<p> sync参数（1.15.3）启用共享内存区域的同步 。 </p>
<blockquote>
<p> sync参数作为我们商业订阅的一部分提供。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-conn-module"><a href="#Module-ngx-http-limit-conn-module" class="headerlink" title="Module ngx_http_limit_conn_module"></a>Module ngx_http_limit_conn_module</h2><p> Example Configuration<br> Directives<br> limit_conn<br> limit_conn_log_level<br> limit_conn_status<br> limit_conn_zone<br> limit_zone<br> ngx_http_limit_conn_module模块用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<p> 并非所有连接都被计算在内 仅当连接具有服务器正在处理的请求并且已经读取了整个请求标头时才计算连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>http { limit_conn_zone $binary_remote_addr zone=addr:10m; … server { … location /download/ { limit_conn addr 1; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>limit_conn</strong> <em>zone</em> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  设置共享内存区域和给定键值的最大允许连接数。 超过此限制时，服务器将返回错误以回复请求。 例如，指令 </p>
<blockquote>
<p>limit_conn_zone $binary_remote_addr zone=addr:10m; server { location /download/ { limit_conn addr 1; }  每次只允许一个IP地址连接一个。 </p>
<p> 在HTTP / 2和SPDY中，每个并发请求被视为单独的连接。  可能有几个limit_conn指令。 例如，以下配置将限制每个客户端IP与服务器的连接数，同时限制与虚拟服务器的连接总数： </p>
<p>limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server { … limit_conn perip 10; limit_conn perserver 100; }  当且仅当当前级别上没有limit_conn指令时，这些指令才从前一级继承。 </p>
</blockquote>
<p> Syntax:  <strong>limit_conn_log_level</strong> info | notice | warn | error ;<br>  Default:  limit_conn_log_level error;  Context:  http , server , location<br>  该指令出现在0.8.18版本中。 </p>
<p> 为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p> Syntax:  <strong>limit_conn_status</strong> <em>code</em> ;<br>  Default:  limit_conn_status 503;  Context:  http , server , location<br>  该指令出现在1.3.15版本中。 </p>
<p> 设置要响应拒绝的请求而返回的状态代码。 </p>
<p> Syntax:  <strong>limit_conn_zone</strong> <em>key</em> zone = <em>name</em> : <em>size</em> ;<br>  Default:  —  Context:  http<br>  设置共享内存区域的参数，该区域将保留各种键的状态。 特别是，状态包括当前的连接数。 <em>key</em>可以包含文本，变量及其组合。 具有空键值的请求不计算在内。 </p>
<blockquote>
<p> 在1.7.6版之前， <em>key</em>可以只包含一个变量。  用法示例： </p>
<p>limit_conn_zone $binary_remote_addr zone=addr:10m;  这里，客户端IP地址用作密钥。 请注意，此处使用$binary_remote_addr变量而不是$remote_addr 。 $remote_addr变量的大小可以在7到15个字节之间变化。 存储状态在32位平台上占用32或64字节的内存，在64位平台上占用64字节。 对于IPv4地址， $binary_remote_addr变量的大小始终为4个字节，对于IPv6地址，则为16个字节。 存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。 一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。 如果区域存储空间耗尽，服务器将向所有其他请求返回错误 。 </p>
</blockquote>
<p> Syntax:  <strong>limit_zone</strong> <em>name</em> <em>$variable</em> <em>size</em> ;<br>  Default:  —  Context:  http<br>  该指令在1.1.8版本中已过时，已在1.7.6版本中删除。 应使用具有更改语法的等效limit_conn_zone指令： </p>
<blockquote>
<p> limit_conn_zone <em>$variable</em> zone = <em>name</em> ： <em>size</em> ;  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_keyval_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_keyval_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-keyval-module"><a href="#Module-ngx-http-keyval-module" class="headerlink" title="Module ngx_http_keyval_module"></a>Module ngx_http_keyval_module</h2><p> Example Configuration<br> Directives<br> keyval<br> keyval_zone<br> ngx_http_keyval_module模块（1.13.3）创建的变量的值取自API管理的键值对。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>http { keyval_zone zone=one:32k state=one.keyval; keyval $arg_text $text zone=one; … server { … location / { return 200 $text; } location /api { api write=on; } } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>keyval</strong> <em>key</em> <em>$variable</em> zone = <em>name</em> ;<br>  Default:  —  Context:  http<br>  创建一个新的<em>$variable</em>其值由<em>key</em>数据库中的键查找。 字符串匹配忽略大小写。 数据库存储在zone参数指定的共享内存区域中。 </p>
<p> Syntax:  <strong>keyval_zone</strong> zone = <em>name</em> : <em>size</em> [ state = <em>file</em> ] [ timeout = <em>time</em> ] [ sync ];<br>  Default:  —  Context:  http<br>  设置保留键值数据库的共享内存区域的<em>name</em>和<em>size</em> 。 键值对由API管理。 </p>
<p> 可选的state参数指定一个<em>file</em> ，该<em>file</em>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p> 可选的timeout参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p> 可选的sync参数（1.15.0）可以同步共享内存区域。 同步需要设置超时参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_js_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_js_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-js-module"><a href="#Module-ngx-http-js-module" class="headerlink" title="Module ngx_http_js_module"></a>Module ngx_http_js_module</h2><p> Example Configuration<br> Directives<br> js_content<br> js_include<br> js_set<br> Request Argument<br> ngx_http_js_module模块用于在njs中实现位置和变量处理程序 - 这是JavaScript语言的一个子集。 </p>
<p> 默认情况下不构建此模块。 可在此处下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>load_module modules/ngx_http_js_module.so; … http { js_include http.js; js_set $foo foo; js_set $summary summary; server { listen 8000; location / { add_header X-Foo $foo; js_content baz; } location = /summary { return 200 $summary; } location = /hello { js_content hello; } } }  http.js文件： </p>
<p>function foo(r) { r.log(“hello from foo() handler”); return “foo”; } function summary(r) { var a, s, h; s = “JS summary\n\n”; s += “Method: “ + r.method + “\n”; s += “HTTP version: “ + r.httpVersion + “\n”; s += “Host: “ + r.headersIn.host + “\n”; s += “Remote Address: “ + r.remoteAddress + “\n”; s += “URI: “ + r.uri + “\n”; s += “Headers:\n”; for (h in r.headersIn) { s += “ header ‘“ + h + “‘ is ‘“ + r.headersIn[h] + “‘\n”; } s += “Args:\n”; for (a in r.args) { s += “ arg ‘“ + a + “‘ is ‘“ + r.args[a] + “‘\n”; } return s; } function baz(r) { r.status = 200; r.headersOut.foo = 1234; r.headersOut[‘Content-Type’] = “text/plain; charset=utf-8”; r.headersOut[‘Content-Length’] = 15; r.sendHeader(); r.send(“nginx”); r.send(“java”); r.send(“script”); r.finish(); } function hello(r) { r.return(200, “Hello world!”); } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>js_content</strong> <em>function</em> ;<br>  Default:  —  Context:  location , limit_except<br>  将njs函数设置为位置内容处理程序。 </p>
<p> Syntax:  <strong>js_include</strong> <em>file</em> ;<br>  Default:  —  Context:  http<br>  指定在njs中实现位置和变量处理程序的文件。 </p>
<p> Syntax:  <strong>js_set</strong> <em>$variable</em> <em>function</em> ;<br>  Default:  —  Context:  http<br>  为指定的变量设置njs函数。 </p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p> 每个HTTP njs处理程序都接收一个参数，一个请求对象 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-index-module"><a href="#Module-ngx-http-index-module" class="headerlink" title="Module ngx_http_index_module"></a>Module ngx_http_index_module</h2><p> Example Configuration<br> Directives<br> index<br> ngx_http_index_module模块处理以斜杠字符（’ / ‘）结尾的请求。 这些请求也可以由ngx_http_autoindex_module和ngx_http_random_index_module模块处理。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { index index.$geo.html index.html; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>index</strong> <em>file</em> …;<br>  Default:  index index.html;  Context:  http , server , location<br>  定义将用作索引的文件。 <em>file</em>名可以包含变量。 按指定顺序检查文件。 列表的最后一个元素可以是具有绝对路径的文件。 例： </p>
<blockquote>
<p>index index.$geo.html index.0.html /index.html;  应该注意，使用索引文件会导致内部重定向，并且可以在不同的位置处理请求。 例如，使用以下配置： </p>
<p>location = / { index index.html; } location / { … }  “ / ”请求实际上将在第二个位置处理为“ /index.html ”。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_image_filter_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_image_filter_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_image_filter_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-image-filter-module"><a href="#Module-ngx-http-image-filter-module" class="headerlink" title="Module ngx_http_image_filter_module"></a>Module ngx_http_image_filter_module</h2><p> Example Configuration<br> Directives<br> image_filter<br> image_filter_buffer<br> image_filter_interlace<br> image_filter_jpeg_quality<br> image_filter_sharpen<br> image_filter_transparency<br> image_filter_webp_quality<br> ngx_http_image_filter_module模块（0.7.54+）是一个过滤器，可以转换JPEG，GIF，PNG和WebP格式的图像。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_image_filter_module配置参数启用它。 </p>
<blockquote>
<p> 该模块使用libgd库。 建议使用最新版本的库。<br> WebP格式支持出现在1.11.6版中。 要以此格式转换图像，必须使用WebP支持编译libgd库。 ####  示例配置</p>
<p>location /img/ { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; image_filter resize 150 100; image_filter rotate 90; error_page 415 = /empty; } location = /empty { empty_gif; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>image_filter</strong> off ;<br> <strong>image_filter</strong> test ;<br> <strong>image_filter</strong> size ;<br> <strong>image_filter</strong> rotate 90 | 180 | 270 ;<br> <strong>image_filter</strong> resize <em>width</em> <em>height</em> ;<br> <strong>image_filter</strong> crop <em>width</em> <em>height</em> ;<br>  Default:  image_filter off;  Context:  location<br>  设置要对图像执行的转换类型： </p>
<p> off   关闭周围位置的模块处理。  test   确保响应是JPEG，GIF，PNG或WebP格式的图像。 否则，将返回415（不支持的媒体类型）错误。  size   以JSON格式输出有关图像的信息，例如： </p>
<blockquote>
<p>{ “img” : { “width”: 100, “height”: 100, “type”: “gif” } }  如果出现错误，输出如下：<br>{}  rotate 90 | 180 | 270  逆时针旋转图像指定的度数。 参数值可以包含变量。 此模式既可以单独使用，也可以与resize和crop变换一起使用。  resize <em>width</em> <em>height</em>  按比例将图像缩小到指定的大小。 要仅减少一个维度，可以将另一个维度指定为“ - ”。 如果出现错误，服务器将返回代码415（不支持的介质类型）。 参数值可以包含变量。 与rotate参数一起使用时，旋转会<strong>在</strong>缩小<strong>后</strong>发生。  crop <em>width</em> <em>height</em>  按比例将图像缩小到较大的边尺寸，并通过另一面裁剪外部边缘。 要仅减少一个维度，可以将另一个维度指定为“ - ”。 如果出现错误，服务器将返回代码415（不支持的介质类型）。 参数值可以包含变量。 与rotate参数一起使用时， rotate <strong>在</strong>缩小<strong>之前</strong>发生。  Syntax:  <strong>image_filter_buffer</strong> <em>size</em> ;<br>  Default:  image_filter_buffer 1M;  Context:  http , server , location<br>  设置用于读取图像的缓冲区的最大大小。 超出大小时，服务器返回错误415（不支持的介质类型）。 </p>
</blockquote>
<p> Syntax:  <strong>image_filter_interlace</strong> on | off ;<br>  Default:  image_filter_interlace off;  Context:  http , server , location<br>  该指令出现在1.3.15版本中。 </p>
<p> 如果启用，最终图像将被隔行扫描。 对于JPEG，最终图像将采用“渐进式JPEG”格式。 </p>
<p> Syntax:  <strong>image_filter_jpeg_quality</strong> <em>quality</em> ;<br>  Default:  image_filter_jpeg_quality 75;  Context:  http , server , location<br>  设置变换后的JPEG图像的所需<em>quality</em> 。 可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。 建议的最大值为95.参数值可以包含变量。 </p>
<p> Syntax:  <strong>image_filter_sharpen</strong> <em>percent</em> ;<br>  Default:  image_filter_sharpen 0;  Context:  http , server , location<br>  增加最终图像的清晰度。 锐度百分比可以超过100.零值禁用锐化。 参数值可以包含变量。 </p>
<p> Syntax:  <strong>image_filter_transparency</strong> on | off ;<br>  Default:  image_filter_transparency on;  Context:  http , server , location<br>  定义在使用调色板指定的颜色转换GIF图像或PNG图像时是否应保留透明度。 透明度的丧失导致图像质量更好。 始终保留PNG中的Alpha通道透明度。 </p>
<p> Syntax:  <strong>image_filter_webp_quality</strong> <em>quality</em> ;<br>  Default:  image_filter_webp_quality 80;  Context:  http , server , location<br>  该指令出现在1.11.6版中。 </p>
<p> 设置转换的WebP图像的所需<em>quality</em> 。 可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。 参数值可以包含变量。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_hls_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_hls_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_hls_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-hls-module"><a href="#Module-ngx-http-hls-module" class="headerlink" title="Module ngx_http_hls_module"></a>Module ngx_http_hls_module</h2><p> Example Configuration<br> Directives<br> hls<br> hls_buffers<br> hls_forward_args<br> hls_fragment<br> hls_mp4_buffer_size<br> hls_mp4_max_buffer_size<br> ngx_http_hls_module模块为MP4和MOV媒体文件提供HTTP实时流（HLS）服务器端支持。 此类文件通常具有.mp4 ， .m4v ， .m4a ， .mov或.qt文件扩展名。 该模块支持H.264视频编解码器，AAC和MP3音频编解码器。 </p>
<p> 对于每个媒体文件，支持两个URI： </p>
<ul>
<li><p>带有“ .m3u8 ”文件扩展名的播放列表URI。 URI可以接受可选参数： </p>
<ul>
<li>“ start ”和“ end ”以秒为单位定义播放列表边界（1.9.0）。 </li>
<li>“ offset ”将初始播放位置移动到以秒为单位的时间偏移（1.9.0）。 正值设置从播放列表开头的时间偏移量。 负值设置播放列表中最后一个片段末尾的时间偏移量。 </li>
<li>“ len ”以秒为单位定义片段长度。 </li>
</ul>
</li>
<li><p>带有“ .ts ”文件扩展名的片段URI。 URI可以接受可选参数： </p>
<ul>
<li>“ start ”和“ end ”以秒为单位定义片段边界。 </li>
</ul>
</li>
</ul>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>location / { hls; hls_fragment 5s; hls_buffers 10 10m; hls_mp4_buffer_size 1m; hls_mp4_max_buffer_size 5m; root /var/video/; }  使用此配置，“/ /var/video/test.mp4 ”文件支持以下URI： </p>
<p><a href="http://hls.example.com/test.mp4.m3u8?offset=1.000&amp;start=1.000&amp;end=2.200" target="_blank" rel="noopener">http://hls.example.com/test.mp4.m3u8?offset=1.000&amp;start=1.000&amp;end=2.200</a> <a href="http://hls.example.com/test.mp4.m3u8?len=8.000" target="_blank" rel="noopener">http://hls.example.com/test.mp4.m3u8?len=8.000</a> <a href="http://hls.example.com/test.mp4.ts?start=1.000&amp;end=2.200" target="_blank" rel="noopener">http://hls.example.com/test.mp4.ts?start=1.000&amp;end=2.200</a> ####  指令</p>
</blockquote>
<p> Syntax:  <strong>hls</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的HLS流。 </p>
<p> Syntax:  <strong>hls_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  hls_buffers 8 2m;  Context:  http , server , location<br>  设置用于读取和写入数据帧的缓冲区的最大<em>number</em>和<em>size</em> 。 </p>
<p> Syntax:  <strong>hls_forward_args</strong> on | off ;<br>  Default:  hls_forward_args off;  Context:  http , server , location<br>  该指令出现在1.5.12版本中。 </p>
<p> 将播放列表请求中的参数添加到片段的URI中。 这对于在请求片段时或在使用ngx_http_secure_link_module模块保护HLS流时执行客户端授权可能很有用。 </p>
<p> 例如，如果客户端请求播放列表<a href="http://example.com/hls/test.mp4.m3u8?a=1&amp;b=2" target="_blank" rel="noopener">http://example.com/hls/test.mp4.m3u8?a=1&amp;b=2</a> ，则参数a=1和b=2将添加到参数后的片段的URI中start和end ： </p>
<blockquote>
<p>#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:15 #EXT-X-PLAYLIST-TYPE:VOD #EXTINF:9.333, test.mp4.ts?start=0.000&amp;end=9.333&amp;a=1&amp;b=2 #EXTINF:7.167, test.mp4.ts?start=9.333&amp;end=16.500&amp;a=1&amp;b=2 #EXTINF:5.416, test.mp4.ts?start=16.500&amp;end=21.916&amp;a=1&amp;b=2 #EXTINF:5.500, test.mp4.ts?start=21.916&amp;end=27.416&amp;a=1&amp;b=2 #EXTINF:15.167, test.mp4.ts?start=27.416&amp;end=42.583&amp;a=1&amp;b=2 #EXTINF:9.626, test.mp4.ts?start=42.583&amp;end=52.209&amp;a=1&amp;b=2 #EXT-X-ENDLIST  如果使用ngx_http_secure_link_module模块保护HLS流，则不应在secure_link_md5表达式中使用$uri ，因为这会在请求片段时导致错误。 应该使用基URI而不是$uri （ $hls_uri中为$hls_uri ）： </p>
<p>http { … map $uri $hls_uri { ~^(?<base\_uri>.<em>).m3u8$ $base_uri; ~^(?<base\_uri>.</base\_uri></em>).ts$ $base_uri; default $uri; } server { … location /hls/ { hls; hls_forward_args on; alias /var/videos/; secure_link $arg_md5,$arg_expires; secure_link_md5 “$secure_link_expires$hls_uri$remote_addr secret”; if ($secure_link = “”) { return 403; } if ($secure_link = “0”) { return 410; } } } }  Syntax:  <strong>hls_fragment</strong> <em>time</em> ;<br>  Default:  hls_fragment 5s;  Context:  http , server , location<br>  为没有“ len ”参数的请求的播放列表URI定义默认片段长度。 </base\_uri></p>
</blockquote>
<p> Syntax:  <strong>hls_mp4_buffer_size</strong> <em>size</em> ;<br>  Default:  hls_mp4_buffer_size 512k;  Context:  http , server , location<br>  设置用于处理MP4和MOV文件的缓冲区的初始<em>size</em> 。 </p>
<p> Syntax:  <strong>hls_mp4_max_buffer_size</strong> <em>size</em> ;<br>  Default:  hls_mp4_max_buffer_size 10m;  Context:  http , server , location<br>  在元数据处理期间，可能需要更大的缓冲区。 它的大小不能超过指定的<em>size</em> ，否则nginx将返回服务器错误500（内部服务器错误），并记录以下消息： </p>
<blockquote>
<p>“/some/movie/file.mp4” mp4 moov atom is too large: 12583268, you may want to increase hls_mp4_max_buffer_size  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_headers_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_headers_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_headers_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-headers-module"><a href="#Module-ngx-http-headers-module" class="headerlink" title="Module ngx_http_headers_module"></a>Module ngx_http_headers_module</h2><p> Example Configuration<br> Directives<br> add_header<br> add_trailer<br> expires<br> ngx_http_headers_module模块允许将“Expires”和“Cache-Control”头字段以及任意字段添加到响应头。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>expires 24h; expires modified +24h; expires @24h; expires 0; expires -1; expires epoch; expires $expires; add_header Cache-Control private; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>add_header</strong> <em>name</em> <em>value</em> [ always ];<br>  Default:  —  Context:  http , server , location , if in location<br>  将指定字段添加到响应头，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1.16,1.0.13）或308（1.13） .0）。 该值可以包含变量。 </p>
<p> 可能有几个add_header指令。 当且仅当在当前级别上没有定义add_header指令时，这些指令才从前一级继承。 </p>
<p> 如果指定了always参数（1.7.5），则无论响应代码如何，都将添加标题字段。 </p>
<p> Syntax:  <strong>add_trailer</strong> <em>name</em> <em>value</em> [ always ];<br>  Default:  —  Context:  http , server , location , if in location<br>  该指令出现在1.13.2版中。 </p>
<p> 如果响应代码等于200,201,206,301,302,303,307或308，则将指定字段添加到响应的末尾。该值可以包含变量。 </p>
<p> 可能有几个add_trailer指令。 当且仅当在当前级别上没有定义add_trailer指令时，这些指令才从先前级别继承。 </p>
<p> 如果指定了always参数，则无论响应代码如何，都将添加指定的字段。 </p>
<p> Syntax:  <strong>expires</strong> [ modified ] <em>time</em> ;<br> <strong>expires</strong> epoch | max | off ;<br>  Default:  expires off;  Context:  http , server , location , if in location<br>  启用或禁用添加或修改“Expires”和“Cache-Control”响应头字段，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1。 16,1.0.13）或308（1.13.0）。 参数可以是正时间或负时间 。 </p>
<p> “Expires”字段中的时间计算为指令中指定的当前时间和<em>time</em>的总和。 如果使用modified参数（0.7.0,0.6.32），则计算时间为文件修改时间与指令中指定时间的总和。 </p>
<p> 此外，可以使用“ @ ”前缀（0.7.9,0.6.34）指定一天中的时间： </p>
<blockquote>
<p>expires @15h30m;  epoch参数对应于绝对时间“ Thu, 01 Jan 1970 00:00:01 GMT ”。 “Cache-Control”字段的内容取决于指定时间的符号： </p>
</blockquote>
<ul>
<li>时间是负面的 - “Cache-Control：no-cache”。 </li>
<li><p>时间为正或零 - “Cache-Control：max-age = <em>t</em> ”，其中<em>t</em>是指令中指定的时间，以秒为单位。<br>max参数将“Expires”设置为值“ Thu, 31 Dec 2037 23:55:55 GMT ”，并将“Cache-Control”设置为10年。 </p>
<p>off参数禁用添加或修改“Expires”和“Cache-Control”响应头字段。 </p>
<p>最后一个参数值可以包含变量（1.7.9）： </p>
</li>
</ul>
<blockquote>
<p>map $sent_http_content_type $expires { default off; application/pdf 42d; ~image/ max; } expires $expires;  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_static_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_static_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_static_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-static-module"><a href="#Module-ngx-http-gzip-static-module" class="headerlink" title="Module ngx_http_gzip_static_module"></a>Module ngx_http_gzip_static_module</h2><p> Example Configuration<br> Directives<br> gzip_static<br> ngx_http_gzip_static_module模块允许发送带有“ .gz ”文件扩展名的预压缩文件，而不是常规文件。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_gzip_static_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>gzip_static on; gzip_proxied expired no-cache no-store private auth; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>gzip_static</strong> on | off | always ;<br>  Default:  gzip_static off;  Context:  http , server , location<br>  启用（“ on ”）或禁用（“ off ”）检查预压缩文件是否存在。 还考虑了以下指令： gzip_http_version ， gzip_proxied ， gzip_disable和gzip_vary 。 </p>
<p> 使用“ always ”值（1.3.6），在所有情况下都使用gzip压缩文件，而不检查客户端是否支持它。 如果磁盘上没有未压缩的文件或者使用了ngx_http_gunzip_module，则非常有用。 </p>
<p> 可以使用gzip命令或任何其他兼容的文件压缩文件。 建议原始文件和压缩文件的修改日期和时间相同。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-module"><a href="#Module-ngx-http-gzip-module" class="headerlink" title="Module ngx_http_gzip_module"></a>Module ngx_http_gzip_module</h2><p> Example Configuration<br> Directives<br> gzip<br> gzip_buffers<br> gzip_comp_level<br> gzip_disable<br> gzip_http_version<br> gzip_min_length<br> gzip_proxied<br> gzip_types<br> gzip_vary<br> Embedded Variables<br> ngx_http_gzip_module模块是一个使用“gzip”方法压缩响应的过滤器。 这通常有助于将传输数据的大小减少一半甚至更多。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>gzip on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain application/xml;  $gzip_ratio变量可用于记录实现的压缩比。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>gzip</strong> on | off ;<br>  Default:  gzip off;  Context:  http , server , location , if in location<br>  启用或禁用gzipping响应。 </p>
<p> Syntax:  <strong>gzip_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  gzip_buffers 32 4k|16 8k;  Context:  http , server , location<br>  设置用于压缩响应的缓冲区的<em>number</em>和<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<blockquote>
<p> 在版本0.7.28之前，默认使用四个4K或8K缓冲区。  Syntax:  <strong>gzip_comp_level</strong> <em>level</em> ;<br>  Default:  gzip_comp_level 1;  Context:  http , server , location<br>  设置响应的gzip压缩<em>level</em> 。 可接受的值范围为1到9。 </p>
</blockquote>
<p> Syntax:  <strong>gzip_disable</strong> <em>regex</em> …;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在0.6.23版本中。 </p>
<p> 对具有与任何指定正则表达式匹配的“User-Agent”标头字段的请求禁用gzipping响应。 </p>
<p> 特殊掩码“ msie6 ”（0.7.12）对应于正则表达式“ MSIE [4-6]. “，但工作得更快。 从版本0.8.11开始，“ MSIE 6.0; … SV1 MSIE 6.0; … SV1此掩码中不包括“ MSIE 6.0; … SV1 ”。 </p>
<p> Syntax:  <strong>gzip_http_version</strong> 1.0 | 1.1 ;<br>  Default:  gzip_http_version 1.1;  Context:  http , server , location<br>  设置压缩响应所需的最低HTTP请求版本。 </p>
<p> Syntax:  <strong>gzip_min_length</strong> <em>length</em> ;<br>  Default:  gzip_min_length 20;  Context:  http , server , location<br>  设置将被gzip压缩的响应的最小长度。 长度仅由“Content-Length”响应头字段确定。 </p>
<p> Syntax:  <strong>gzip_proxied</strong> off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any …;<br>  Default:  gzip_proxied off;  Context:  http , server , location<br>  根据请求和响应启用或禁用对代理请求的响应的gzipping。 代理请求的事实由“Via”请求头字段的存在确定。 该指令接受多个参数： </p>
<p> off   禁用所有代理请求的压缩，忽略其他参数;  expired   如果响应头包含“Expires”字段，其值为禁用缓存，则启用压缩;  no-cache   如果响应头包含带有“ no-cache ”参数的“Cache-Control”字段，则启用压缩;  no-store   如果响应头包含带有“ no-store ”参数的“Cache-Control”字段，则启用压缩;  private   如果响应头包含带有“ private ”参数的“Cache-Control”字段，则启用压缩;  no_last_modified   如果响应头不包含“Last-Modified”字段，则启用压缩;  no_etag   如果响应头不包含“ETag”字段，则启用压缩;  auth   如果请求标头包含“授权”字段，则启用压缩;  any   为所有代理请求启用压缩。  Syntax:  <strong>gzip_types</strong> <em>mime-type</em> …;<br>  Default:  gzip_types text/html;  Context:  http , server , location<br>  除了“ text/html ”之外，还允许对指定的MIME类型进行gzipping响应。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 始终压缩“ text/html ”类型的响应。 </p>
<p> Syntax:  <strong>gzip_vary</strong> on | off ;<br>  Default:  gzip_vary off;  Context:  http , server , location<br>  如果指令gzip ， gzip_static或gunzip处于活动状态，则启用或禁用插入“Vary：Accept-Encoding”响应头字段。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> $gzip_ratio   达到的压缩比，计算为原始和压缩响应大小之间的比率。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gunzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gunzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gunzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gunzip-module"><a href="#Module-ngx-http-gunzip-module" class="headerlink" title="Module ngx_http_gunzip_module"></a>Module ngx_http_gunzip_module</h2><p> Example Configuration<br> Directives<br> gunzip<br> gunzip_buffers<br> ngx_http_gunzip_module模块是一个过滤器，它使用“ Content-Encoding: gzip ”解压缩响应，用于不支持“gzip”编码方法的客户端。 当需要存储压缩数据以节省空间并降低I / O成本时，该模块将非常有用。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_gunzip_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location /storage/ { gunzip on; … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>gunzip</strong> on | off ;<br>  Default:  gunzip off;  Context:  http , server , location<br>  启用或禁用对缺少gzip支持的客户端的gzip压缩解压缩。 如果启用，则在确定客户端是否支持gzip时还会考虑以下指令： gzip_http_version ， gzip_proxied和gzip_disable 。 另请参见gzip_vary指令。 </p>
<p> Syntax:  <strong>gunzip_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  gunzip_buffers 32 4k|16 8k;  Context:  http , server , location<br>  设置用于解压缩响应的缓冲区的<em>number</em>和<em>size</em> 。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_grpc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_grpc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_grpc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-grpc-module"><a href="#Module-ngx-http-grpc-module" class="headerlink" title="Module ngx_http_grpc_module"></a>Module ngx_http_grpc_module</h2><p> Example Configuration<br> Directives<br> grpc_bind<br> grpc_buffer_size<br> grpc_connect_timeout<br> grpc_hide_header<br> grpc_ignore_headers<br> grpc_intercept_errors<br> grpc_next_upstream<br> grpc_next_upstream_timeout<br> grpc_next_upstream_tries<br> grpc_pass<br> grpc_pass_header<br> grpc_read_timeout<br> grpc_send_timeout<br> grpc_set_header<br> grpc_socket_keepalive<br> grpc_ssl_certificate<br> grpc_ssl_certificate_key<br> grpc_ssl_ciphers<br> grpc_ssl_crl<br> grpc_ssl_name<br> grpc_ssl_password_file<br> grpc_ssl_protocols<br> grpc_ssl_server_name<br> grpc_ssl_session_reuse<br> grpc_ssl_trusted_certificate<br> grpc_ssl_verify<br> grpc_ssl_verify_depth<br> ngx_http_grpc_module模块允许将请求传递到gRPC服务器（1.13.10）。 该模块需要ngx_http_v2_module模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>server { listen 9000 http2; location / { grpc_pass 127.0.0.1:9000; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>grpc_bind</strong> <em>address</em> [ transparent  ] | off ;<br>  Default:  —  Context:  http , server , location<br>  使用可选端口从指定的本地IP地址发出到gRPC服务器的传出连接。 参数值可以包含变量。 特殊值off取消了从先前配置级别继承的grpc_bind指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数允许到gRPC服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>grpc_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要像指定transparent参数那样，工作进程从主进程继承CAP_NET_RAW功能。 还必须配置内核路由表以拦截来自gRPC服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>grpc_buffer_size</strong> <em>size</em> ;<br>  Default:  grpc_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从gRPC服务器接收的响应的缓冲区的<em>size</em> 。 一旦收到响应，响应就会同步传递给客户端。 </p>
<p> Syntax:  <strong>grpc_connect_timeout</strong> <em>time</em> ;<br>  Default:  grpc_connect_timeout 60s;  Context:  http , server , location<br>  定义与gRPC服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
<p> Syntax:  <strong>grpc_hide_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  默认情况下，nginx不会从gRPC服务器对客户端的响应中传递标题字段“Date”，“Server”和“X-Accel -…”。 grpc_hide_header指令设置了不会传递的其他字段。 相反，如果需要允许传递字段，则可以使用grpc_pass_header指令。 </p>
<p> Syntax:  <strong>grpc_ignore_headers</strong> <em>field</em> …;<br>  Default:  —  Context:  http , server , location<br>  禁用从gRPC服务器处理某些响应头字段。 可以忽略以下字段：“X-Accel-Redirect”和“X-Accel-Charset”。 </p>
<p> 如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Redirect”执行内部重定向到指定的URI; </li>
<li><p>“X-Accel-Charset”设置了所需的响应字符集 。<br>Syntax:  <strong>grpc_intercept_errors</strong> on | off ;<br>Default:  grpc_intercept_errors off;  Context:  http , server , location<br>确定代码大于或等于300的gRPC服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用error_page指令进行处理。 </p>
<p>Syntax:  <strong>grpc_next_upstream</strong> error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>Default:  grpc_next_upstream error timeout;  Context:  http , server , location<br>指定应将请求传递到下一个服务器的情况： </p>
<p>error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_header   服务器返回空或无效响应;  http_500   服务器返回代码为500的响应;  http_502   服务器返回代码为502的响应;  http_503   服务器返回代码为503的响应;  http_504   服务器返回代码504的响应;  http_403   服务器返回代码为403的响应;  http_404   服务器返回代码为404的响应;  http_429   服务器返回代码为429的响应;  non_idempotent   通常，如果请求已发送到上游服务器，则使用非幂等方法（ POST ， LOCK ， PATCH ）的请求不会传递到下一个服务器; 启用此选项显式允许重试此类请求;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_header情况始终被视为不成功的尝试，即使它们未在指令中指定。 http_500 ， http_502 ， http_503 ， http_504和http_429情况仅在指令中指定http_429被视为不成功尝试。 http_403和http_404情况从未被视为不成功的尝试。 </p>
<p>将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p>Syntax:  <strong>grpc_next_upstream_timeout</strong> <em>time</em> ;<br>Default:  grpc_next_upstream_timeout 0;  Context:  http , server , location<br>限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p>Syntax:  <strong>grpc_next_upstream_tries</strong> <em>number</em> ;<br>Default:  grpc_next_upstream_tries 0;  Context:  http , server , location<br>限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p>Syntax:  <strong>grpc_pass</strong> <em>address</em> ;<br>Default:  —  Context:  location , if in location<br>设置gRPC服务器地址。 地址可以指定为域名或IP地址，以及端口： </p>
</li>
</ul>
<blockquote>
<p>grpc_pass localhost:9000;  或者作为UNIX域套接字路径： </p>
<p>grpc_pass unix:/tmp/grpc.socket;  或者，可以使用“ grpc:// ”方案： </p>
<p>grpc_pass grpc://127.0.0.1:9000;  要通过SSL使用gRPC，应使用“ grpcs:// ”方案： </p>
<p>grpc_pass grpcs://127.0.0.1:443;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> Syntax:  <strong>grpc_pass_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  允许将其他禁用的头字段从gRPC服务器传递到客户端。 </p>
<p> Syntax:  <strong>grpc_read_timeout</strong> <em>time</em> ;<br>  Default:  grpc_read_timeout 60s;  Context:  http , server , location<br>  定义从gRPC服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果gRPC服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>grpc_send_timeout</strong> <em>time</em> ;<br>  Default:  grpc_send_timeout 60s;  Context:  http , server , location<br>  设置将请求发送到gRPC服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果gRPC服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>grpc_set_header</strong> <em>field</em> <em>value</em> ;<br>  Default:  grpc_set_header Content-Length $content_length;  Context:  http , server , location<br>  允许将字段重新定义或附加到传递给gRPC服务器的请求标头。 该<em>value</em>可以包含文本，变量及其组合。 当且仅当在当前级别上没有定义grpc_set_header指令时，这些指令才从前一级继承。 </p>
<p> 如果标头字段的值是空字符串，则该字段将不会传递给gRPC服务器： </p>
<blockquote>
<p>grpc_set_header Accept-Encoding “”;  Syntax:  <strong>grpc_socket_keepalive</strong> on | off ;<br>  Default:  grpc_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
</blockquote>
<p> 配置与gRPC服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>grpc_ssl_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定具有PEM格式的证书的<em>file</em> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p> Syntax:  <strong>grpc_ssl_certificate_key</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定具有PEM格式的密钥的<em>file</em> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p> 可以指定value engine ： <em>name</em> ： <em>id</em>而不是<em>file</em> ，该<em>file</em>从OpenSSL引擎<em>name</em>加载具有指定<em>id</em>密钥。 </p>
<p> Syntax:  <strong>grpc_ssl_ciphers</strong> <em>ciphers</em> ;<br>  Default:  grpc_ssl_ciphers DEFAULT;  Context:  http , server , location<br>  指定对gRPC SSL服务器的请求的已启用密码。 密码以OpenSSL库理解的格式指定。 </p>
<p> 可以使用“ openssl ciphers ”命令查看完整列表。 </p>
<p> Syntax:  <strong>grpc_ssl_crl</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定具有PEM格式的已吊销证书（CRL）的<em>file</em> ，用于验证 gRPC SSL服务器的证书。 </p>
<p> Syntax:  <strong>grpc_ssl_name</strong> <em>name</em> ;<br>  Default:  grpc_ssl_name host from grpc_pass;  Context:  http , server , location<br>  允许覆盖用于验证 gRPC SSL服务器证书的服务器名称，并在与gRPC SSL服务器建立连接时通过SNI传递 。 </p>
<p> 默认情况下，使用grpc_pass的主机部分。 </p>
<p> Syntax:  <strong>grpc_ssl_password_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定具有密钥密码的<em>file</em> ，其中每个密码在单独的行上指定。 在加载密钥时依次尝试密码短语。 </p>
<p> Syntax:  <strong>grpc_ssl_protocols</strong> [ SSLv2 ] [ SSLv3 ] [ TLSv1 ] [ TLSv1.1 ] [ TLSv1.2 ] [ TLSv1.3 ];<br>  Default:  grpc_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  Context:  http , server , location<br>  为gRPC SSL服务器的请求启用指定的协议。 </p>
<p> Syntax:  <strong>grpc_ssl_server_name</strong> on | off ;<br>  Default:  grpc_ssl_server_name off;  Context:  http , server , location<br>  在与gRPC SSL服务器建立连接时，启用或禁用通过TLS服务器名称指示扩展 （SNI，RFC 6066）传递服务器名称。 </p>
<p> Syntax:  <strong>grpc_ssl_session_reuse</strong> on | off ;<br>  Default:  grpc_ssl_session_reuse on;  Context:  http , server , location<br>  确定在使用gRPC服务器时是否可以重用SSL会话。 如果日志中出现“ SSL3_GET_FINISHED:digest check failed ”错误，请尝试禁用会话重用。 </p>
<p> Syntax:  <strong>grpc_ssl_trusted_certificate</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location<br>  指定具有PEM格式的可信CA证书的<em>file</em> ，用于验证 gRPC SSL服务器的证书。 </p>
<p> Syntax:  <strong>grpc_ssl_verify</strong> on | off ;<br>  Default:  grpc_ssl_verify off;  Context:  http , server , location<br>  启用或禁用gRPC SSL服务器证书的验证。 </p>
<p> Syntax:  <strong>grpc_ssl_verify_depth</strong> <em>number</em> ;<br>  Default:  grpc_ssl_verify_depth 1;  Context:  http , server , location<br>  设置gRPC SSL服务器证书链中的验证深度。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geo_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geo_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geo-module"><a href="#Module-ngx-http-geo-module" class="headerlink" title="Module ngx_http_geo_module"></a>Module ngx_http_geo_module</h2><p> Example Configuration<br> Directives<br> geo<br> ngx_http_geo_module模块使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>geo $geo { default 0; 127.0.0.1 2; 192.168.1.0/24 1; 10.1.0.0/16 1; ::1 2; 2001:0db8::/32 1; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>geo</strong> [ <em>$address</em> ] <em>$variable</em> { … }<br>  Default:  —  Context:  http<br>  描述指定变量的值对客户端IP地址的依赖性。 默认情况下，地址取自$remote_addr变量，但也可以从另一个变量（0.7.27）获取，例如： </p>
<blockquote>
<p>geo $arg_remote_addr $geo { …; }<br> 由于变量仅在使用时进行评估，因此即使存在大量已声明的“ geo ”变量也不会导致请求处理的任何额外成本。  如果变量的值不表示有效的IP地址，则使用“ 255.255.255.255 ”地址。 </p>
</blockquote>
<p> 地址指定为CIDR表示法中的前缀（包括单个地址）或范围（0.7.23）。 </p>
<blockquote>
<p> 从版本1.3.10和1.2.7开始支持IPv6前缀。  还支持以下特殊参数： </p>
</blockquote>
<p> delete   删除指定的网络（0.7.23）。  default   如果客户端地址与任何指定的地址不匹配，则设置为该变量的值。 当以CIDR表示法指定地址时，可以使用“ 0.0.0.0/0 ”和“ ::/0 ”而不是default 。 如果未指定default，则默认值为空字符串。  include   包括一个包含地址和值的文件。 可能有几个夹杂物。  proxy   定义可信地址（0.8.7,0.7.63）。 当请求来自可信地址时，将使用来自“X-Forwarded-For”请求头字段的地址。 与常规地址相反，可靠地址被顺序检查。 </p>
<blockquote>
<p> 从版本1.3.0和1.2.1开始支持受信任的IPv6地址。  proxy_recursive   启用递归地址搜索（1.3.0,1.2.1）。 如果禁用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用“X-Forwarded-For”中发送的最后一个地址。 如果启用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用在“X-Forwarded-For”中发送的最后一个不可信地址。  ranges   表示地址被指定为范围（0.7.23）。 这个参数应该是第一个。 要加快地理基地的加载速度，地址应按升序排列。  例： </p>
<p>geo $country { default ZZ; include conf/geo.conf; delete 127.0.0.0/16; proxy 192.168.100.0/24; proxy 2001:0db8::/32; 127.0.0.0/24 US; 127.0.0.1/32 RU; 10.1.0.0/16 RU; 192.168.1.0/24 UK; }  conf/geo.conf文件可以包含以下行： </p>
<p>10.2.0.0/16 RU; 192.168.2.0/24 RU;  使用最具体匹配的值。 例如，对于127.0.0.1地址，将选择值“ RU ”，而不是“ US ”。 </p>
</blockquote>
<p> 范围示例： </p>
<blockquote>
<p>geo $country { ranges; default ZZ; 127.0.0.0-127.0.0.0 US; 127.0.0.1-127.0.0.1 RU; 127.0.0.1-127.0.0.255 US; 10.1.0.0-10.1.255.255 RU; 192.168.1.0-192.168.1.255 UK; }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geoip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geoip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geoip-module"><a href="#Module-ngx-http-geoip-module" class="headerlink" title="Module ngx_http_geoip_module"></a>Module ngx_http_geoip_module</h2><p> Example Configuration<br> Directives<br> geoip_country<br> geoip_city<br> geoip_org<br> geoip_proxy<br> geoip_proxy_recursive<br> ngx_http_geoip_module模块（0.8.6+）使用预编译的MaxMind数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p> 使用支持IPv6的数据库（1.3.12,1.2.7）时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_geoip_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要MaxMind GeoIP库。 ####  示例配置</p>
<p>http { geoip_country GeoIP.dat; geoip_city GeoLiteCity.dat; geoip_proxy 192.168.100.0/24; geoip_proxy 2001:0db8::/32; geoip_proxy_recursive on; … ####  指令</p>
</blockquote>
<p> Syntax:  <strong>geoip_country</strong> <em>file</em> ;<br>  Default:  —  Context:  http<br>  指定用于根据客户端IP地址确定国家/地区的数据库。 使用此数据库时，以下变量可用： </p>
<p> $geoip_country_code   两个字母的国家/地区代码，例如“ RU ”，“ US ”。  $geoip_country_code3   三个字母的国家/地区代码，例如“ RUS ”，“ USA ”。  $geoip_country_name   国名，例如“ Russian Federation ”，“ United States ”。  Syntax:  <strong>geoip_city</strong> <em>file</em> ;<br>  Default:  —  Context:  http<br>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。 使用此数据库时，以下变量可用： </p>
<p> $geoip_area_code   电话区号（仅限美国）。 </p>
<blockquote>
<p> 此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。  $geoip_city_continent_code   两个字母的大陆代码，例如“ EU ”，“ NA ”。  $geoip_city_country_code   两个字母的国家/地区代码，例如“ RU ”，“ US ”。  $geoip_city_country_code3   三个字母的国家/地区代码，例如“ RUS ”，“ USA ”。  $geoip_city_country_name   国名，例如“ Russian Federation ”，“ United States ”。  $geoip_dma_code   根据Google AdWords API中的地理位置定位 ，美国的DMA区域代码（也称为“都市代码”）。  $geoip_latitude   纬度。  $geoip_longitude   经度。  $geoip_region   双符号国家区域代码（地区，领土，州，省，联邦土地等），例如“ 48 ”，“ DC ”。  $geoip_region_name   国家地区名称（地区，领土，州，省，联邦土地等），例如“ Moscow City ”，“ District of Columbia ”。  $geoip_city   城市名称，例如“ Moscow ”，“ Washington ”。  $geoip_postal_code   邮政编码。  Syntax:  <strong>geoip_org</strong> <em>file</em> ;<br>  Default:  —  Context:  http<br>  该指令出现在1.0.3版本中。 </p>
</blockquote>
<p> 指定用于根据客户端IP地址确定组织的数据库。 使用此数据库时，以下变量可用： </p>
<p> $geoip_org   组织名称，例如“墨尔本大学”。  Syntax:  <strong>geoip_proxy</strong> <em>address</em> | <em>CIDR</em> ;<br>  Default:  —  Context:  http<br>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p> 定义可信地址。 当请求来自可信地址时，将使用来自“X-Forwarded-For”请求头字段的地址。 </p>
<p> Syntax:  <strong>geoip_proxy_recursive</strong> on | off ;<br>  Default:  geoip_proxy_recursive off;  Context:  http<br>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p> 如果禁用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用“X-Forwarded-For”中发送的最后一个地址。 如果启用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用在“X-Forwarded-For”中发送的最后一个不可信地址。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_flv_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_flv_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_flv_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-flv-module"><a href="#Module-ngx-http-flv-module" class="headerlink" title="Module ngx_http_flv_module"></a>Module ngx_http_flv_module</h2><p> Example Configuration<br> Directives<br> flv<br> ngx_http_flv_module模块为Flash Video（FLV）文件提供伪流服务器端支持。 </p>
<p> 它特别通过请求URI的查询字符串中的start参数处理请求，方法是从请求的字节偏移量和前置FLV头开始发回文件的内容。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_flv_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location ~ .flv$ { flv; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>flv</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_fastcgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_fastcgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_fastcgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-fastcgi-module"><a href="#Module-ngx-http-fastcgi-module" class="headerlink" title="Module ngx_http_fastcgi_module"></a>Module ngx_http_fastcgi_module</h2><p> Example Configuration<br> Directives<br> fastcgi_bind<br> fastcgi_buffer_size<br> fastcgi_buffering<br> fastcgi_buffers<br> fastcgi_busy_buffers_size<br> fastcgi_cache<br> fastcgi_cache_background_update<br> fastcgi_cache_bypass<br> fastcgi_cache_key<br> fastcgi_cache_lock<br> fastcgi_cache_lock_age<br> fastcgi_cache_lock_timeout<br> fastcgi_cache_max_range_offset<br> fastcgi_cache_methods<br> fastcgi_cache_min_uses<br> fastcgi_cache_path<br> fastcgi_cache_purge<br> fastcgi_cache_revalidate<br> fastcgi_cache_use_stale<br> fastcgi_cache_valid<br> fastcgi_catch_stderr<br> fastcgi_connect_timeout<br> fastcgi_force_ranges<br> fastcgi_hide_header<br> fastcgi_ignore_client_abort<br> fastcgi_ignore_headers<br> fastcgi_index<br> fastcgi_intercept_errors<br> fastcgi_keep_conn<br> fastcgi_limit_rate<br> fastcgi_max_temp_file_size<br> fastcgi_next_upstream<br> fastcgi_next_upstream_timeout<br> fastcgi_next_upstream_tries<br> fastcgi_no_cache<br> fastcgi_param<br> fastcgi_pass<br> fastcgi_pass_header<br> fastcgi_pass_request_body<br> fastcgi_pass_request_headers<br> fastcgi_read_timeout<br> fastcgi_request_buffering<br> fastcgi_send_lowat<br> fastcgi_send_timeout<br> fastcgi_socket_keepalive<br> fastcgi_split_path_info<br> fastcgi_store<br> fastcgi_store_access<br> fastcgi_temp_file_write_size<br> fastcgi_temp_path<br> Parameters Passed to a FastCGI Server<br> Embedded Variables<br> ngx_http_fastcgi_module模块允许将请求传递给FastCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { fastcgi_pass localhost:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>fastcgi_bind</strong> <em>address</em> [ transparent ] | off ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在0.8.22版本中。 </p>
<p> 使用可选端口（1.11.2）从指定的本地IP地址发出到FastCGI服务器的传出连接。 参数值可以包含变量（1.3.12）。 特殊值off （1.3.12）取消了从先前配置级别继承的fastcgi_bind指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p> transparent参数（1.11.0）允许到FastCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<blockquote>
<p>fastcgi_bind $remote_addr transparent;  为了使此参数有效，通常需要使用超级用户权限运行nginx工作进程。 在Linux上，不需要（1.13.8），就像指定了transparent参数一样，工作进程从主进程继承CAP_NET_RAW功能。 还必须配置内核路由表以拦截来自FastCGI服务器的网络流量。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_buffer_size</strong> <em>size</em> ;<br>  Default:  fastcgi_buffer_size 4k|8k;  Context:  http , server , location<br>  设置用于读取从FastCGI服务器接收的响应的第一部分的缓冲区的<em>size</em> 。 这部分通常包含一个小的响应头。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 然而，它可以做得更小。 </p>
<p> Syntax:  <strong>fastcgi_buffering</strong> on | off ;<br>  Default:  fastcgi_buffering on;  Context:  http , server , location<br>  该指令出现在1.5.6版本中。 </p>
<p> 启用或禁用缓冲来自FastCGI服务器的响应。 </p>
<p> 启用缓冲后，nginx会尽快从FastCGI服务器接收响应，并将其保存到fastcgi_buffer_size和fastcgi_buffers指令设置的缓冲区中。 如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的临时文件中 。 写入临时文件由fastcgi_max_temp_file_size和fastcgi_temp_file_write_size指令控制。 </p>
<p> 禁用缓冲时，响应会在收到响应时立即同步传递给客户端。 nginx不会尝试从FastCGI服务器读取整个响应。 nginx一次可以从服务器接收的数据的最大大小由fastcgi_buffer_size指令设置。 </p>
<p> 也可以通过在“X-Accel-Buffering”响应头字段中传递“ yes ”或“ no ”来启用或禁用缓冲。 可以使用fastcgi_ignore_headers指令禁用此功能。 </p>
<p> Syntax:  <strong>fastcgi_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  fastcgi_buffers 8 4k|8k;  Context:  http , server , location<br>  设置用于从FastCGI服务器读取响应的缓冲区的<em>number</em>和<em>size</em> ，用于单个连接。 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 </p>
<p> Syntax:  <strong>fastcgi_busy_buffers_size</strong> <em>size</em> ;<br>  Default:  fastcgi_busy_buffers_size 8k|16k;  Context:  http , server , location<br>  当启用从FastCGI服务器缓冲响应时，限制可能忙于向响应客户端发送响应的缓冲区的总<em>size</em> ，而响应尚未完全读取。 同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。 默认情况下， <em>size</em>由fastcgi_buffer_size和fastcgi_buffers指令设置的两个缓冲区的大小限制。 </p>
<p> Syntax:  <strong>fastcgi_cache</strong> <em>zone</em> | off ;<br>  Default:  fastcgi_cache off;  Context:  http , server , location<br>  定义用于缓存的共享内存区域。 可以在多个地方使用相同的区域。 参数值可以包含变量（1.7.9）。 off参数禁用从先前配置级别继承的高速缓存。 </p>
<p> Syntax:  <strong>fastcgi_cache_background_update</strong> on | off ;<br>  Default:  fastcgi_cache_background_update off;  Context:  http , server , location<br>  该指令出现在1.11.10版中。 </p>
<p> 允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。 请注意，在更新时必须允许使用陈旧的缓存响应。 </p>
<p> Syntax:  <strong>fastcgi_cache_bypass</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不从缓存中获取响应的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<blockquote>
<p>fastcgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment; fastcgi_cache_bypass $http_pragma $http_authorization;  可以与fastcgi_no_cache指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_cache_key</strong> <em>string</em> ;<br>  Default:  —  Context:  http , server , location<br>  例如，定义缓存的键 </p>
<blockquote>
<p>fastcgi_cache_key localhost:9000$request_uri;  Syntax:  <strong>fastcgi_cache_lock</strong> on | off ;<br>  Default:  fastcgi_cache_lock off;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
</blockquote>
<p> 启用后，通过将请求传递给FastCGI服务器，一次只允许一个请求填充根据fastcgi_cache_key指令标识的新缓存元素。 同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到fastcgi_cache_lock_timeout指令设置的时间。 </p>
<p> Syntax:  <strong>fastcgi_cache_lock_age</strong> <em>time</em> ;<br>  Default:  fastcgi_cache_lock_age 5s;  Context:  http , server , location<br>  该指令出现在1.7.8版本中。 </p>
<p> 如果传递给FastCGI服务器以填充新缓存元素的最后一个请求在指定<em>time</em>内没有完成，则可以将另一个请求传递给FastCGI服务器。 </p>
<p> Syntax:  <strong>fastcgi_cache_lock_timeout</strong> <em>time</em> ;<br>  Default:  fastcgi_cache_lock_timeout 5s;  Context:  http , server , location<br>  该指令出现在1.1.12版本中。 </p>
<p> 为fastcgi_cache_lock设置超时。 当<em>time</em>到期时，请求将被传递给FastCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p> 在1.7.8之前，可以缓存响应。  Syntax:  <strong>fastcgi_cache_max_range_offset</strong> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.11.6版中。 </p>
</blockquote>
<p> 设置字节范围请求的偏移量（以字节为单位）。 如果范围超出偏移量，则范围请求将传递给FastCGI服务器，并且不会缓存响应。 </p>
<p> Syntax:  <strong>fastcgi_cache_methods</strong> GET | HEAD | POST …;<br>  Default:  fastcgi_cache_methods GET HEAD;  Context:  http , server , location<br>  该指令出现在0.7.59版本中。 </p>
<p> 如果此指令中列出了客户端请求方法，则将缓存响应。 “ GET ”和“ HEAD ”方法总是添加到列表中，但建议明确指定它们。 另请参见fastcgi_no_cache指令。 </p>
<p> Syntax:  <strong>fastcgi_cache_min_uses</strong> <em>number</em> ;<br>  Default:  fastcgi_cache_min_uses 1;  Context:  http , server , location<br>  设置将缓存响应的请求<em>number</em> 。 </p>
<p> Syntax:  <strong>fastcgi_cache_path</strong> <em>path</em> [ levels = <em>levels</em> ] [ use_temp_path = on | off ] keys_zone = <em>name</em> : <em>size</em> [ inactive = <em>time</em> ] [ max_size = <em>size</em> ] [ manager_files = <em>number</em> ] [ manager_sleep = <em>time</em> ] [ manager_threshold = <em>time</em> ] [ loader_files = <em>number</em> ] [ loader_sleep = <em>time</em> ] [ loader_threshold = <em>time</em> ] [ purger = on | off ] [ purger_files = <em>number</em> ] [ purger_sleep = <em>time</em> ] [ purger_threshold = <em>time</em> ];<br>  Default:  —  Context:  http<br>  设置缓存的路径和其他参数。 缓存数据存储在文件中。 缓存中的密钥和文件名都是将MD5功能应用于代理URL的结果。 levels参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<blockquote>
<p>fastcgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;  缓存中的文件名如下所示： </p>
<p>/data/nginx/cache/ <strong>c</strong> / <strong>29</strong> /b7f54b2df7773722d382f4809d650 <strong>29c</strong>  首先将缓存的响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。 根据use_temp_path参数（1.7.10）设置临时文件的目录。 如果省略此参数或将其设置为on ，则将使用fastcgi_temp_path指令为给定位置设置的目录。 如果该值设置为off ，则临时文件将直接放入缓存目录中。 </p>
</blockquote>
<p> 此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<em>name</em>和<em>size</em>由keys_zone参数配置。 一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p> 作为商业订阅的一部分，共享存储器区域还存储扩展的高速缓存信息 ，因此，需要为相同数量的密钥指定更大的区域大小。 例如，一兆字节区域可以存储大约4000个密钥。  在inactive参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。 默认情况下， inactive设置为10分钟。 </p>
</blockquote>
<p> 特殊的“缓存管理器”进程监视max_size参数设置的最大缓存大小。 超过此大小时，它会删除最近最少使用的数据。 在manager_files ， manager_threshold和manager_sleep参数（1.11.5）配置的迭代中删除数据。 在一次迭代期间，不会删除manager_files项（默认情况下为100）。 一次迭代的持续时间受manager_threshold参数限制（默认情况下为200毫秒）。 在迭代之间，由manager_sleep参数（默认为50毫秒）配置的暂停。 </p>
<p> 启动一分钟后，激活特殊的“缓存加载程序”进程。 它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。 加载也是在迭代中完成的。 在一次迭代期间，加载的loader_files项目不超过（默认情况下为100）。 此外，一次迭代的持续时间受loader_threshold参数限制（默认为200毫秒）。 在迭代之间，由loader_sleep参数（默认为50毫秒）配置暂停。 </p>
<p> 此外，以下参数作为我们商业订阅的一部分提供： </p>
<p> purger = on | off  指示缓存清除程序是否将从磁盘中删除与通配符密钥匹配的缓存条目（1.7.12）。 将参数设置为on （默认为off ）将激活“cache purger”进程，该进程将永久迭代所有缓存条目并删除与通配符键匹配的条目。  purger_files = <em>number</em>  设置在一次迭代（1.7.12）期间将扫描的项目数。 默认情况下， purger_files设置为10。  purger_threshold = <em>number</em>  设置一次迭代的持续时间（1.7.12）。 默认情况下， purger_threshold设置为50毫秒。  purger_sleep = <em>number</em>  设置迭代之间的暂停（1.7.12）。 默认情况下， purger_sleep设置为50毫秒。 </p>
<blockquote>
<p> 在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。 升级到较新的nginx版本之前，缓存的响应将被视为无效。  Syntax:  <strong>fastcgi_cache_purge</strong> string …;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 定义将请求视为缓存清除请求的条件。 如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应高速缓存键的高速缓存条目。 通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p> 如果清除请求的缓存键以星号（“ * ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。 但是，这些条目将保留在磁盘上，直到它们被删除为非活动状态 ，或由缓存清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p> 配置示例： </p>
<blockquote>
<p>fastcgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m; map $request_method $purge_method { PURGE 1; default 0; } server { … location / { fastcgi_pass backend; fastcgi_cache cache_zone; fastcgi_cache_key $uri; fastcgi_cache_purge $purge_method; } }<br> 此功能作为我们商业订阅的一部分提供。  Syntax:  <strong>fastcgi_cache_revalidate</strong> on | off ;<br>  Default:  fastcgi_cache_revalidate off;  Context:  http , server , location<br>  该指令出现在1.5.7版本中。 </p>
</blockquote>
<p> 使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p> Syntax:  <strong>fastcgi_cache_use_stale</strong> error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | http_429 | off …;<br>  Default:  fastcgi_cache_use_stale off;  Context:  http , server , location<br>  确定在与FastCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。 该指令的参数与fastcgi_next_upstream指令的参数匹配。 </p>
<p> 如果无法选择要处理请求的FastCGI服务器，则error参数还允许使用过时的缓存响应。 </p>
<p> 此外，如果当前正在更新，则updating参数允许使用过时的缓存响应。 这样可以在更新缓存数据时最大限度地减少对FastCGI服务器的访问次数。 </p>
<p> 在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。 这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ stale-while-revalidate ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 </li>
<li><p>“Cache-Control”头字段的“ stale-if-error ”扩展允许在出现错误时使用陈旧的缓存响应。<br>要在填充新缓存元素时最小化对FastCGI服务器的访问次数，可以使用fastcgi_cache_lock指令。 </p>
<p>Syntax:  <strong>fastcgi_cache_valid</strong> [ <em>code</em> …] <em>time</em> ;<br>Default:  —  Context:  http , server , location<br>设置不同响应代码的缓存时间。 例如，以下指令 </p>
</li>
</ul>
<blockquote>
<p>fastcgi_cache_valid 200 302 10m; fastcgi_cache_valid 404 1m;  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
</blockquote>
<p> 如果仅指定了缓存<em>time</em> </p>
<blockquote>
<p>fastcgi_cache_valid 5m;  然后只缓存200,301和302个响应。 </p>
</blockquote>
<p> 此外，可以指定any参数来缓存任何响应： </p>
<blockquote>
<p>fastcgi_cache_valid 200 302 10m; fastcgi_cache_valid 301 1h; fastcgi_cache_valid any 1m;  缓存的参数也可以直接在响应头中设置。 这比使用该指令设置缓存时间具有更高的优先级。 </p>
</blockquote>
<ul>
<li>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。 零值禁用响应的缓存。 如果值以@前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 </li>
<li>如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 </li>
<li>如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 </li>
<li><p>如果标题包含具有特殊值“ * ”的“Vary”字段，则不会缓存此类响应（1.7.7）。 如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用fastcgi_ignore_headers指令禁用这些响应头字段中的一个或多个的处理。 </p>
<p>Syntax:  <strong>fastcgi_catch_stderr</strong> <em>string</em> ;<br>Default:  —  Context:  http , server , location<br>设置要在从FastCGI服务器接收的响应的错误流中搜索的字符串。 如果找到该<em>string</em> ，则认为FastCGI服务器返回了无效响应 。 这允许在nginx中处理应用程序错误，例如： </p>
</li>
</ul>
<blockquote>
<p>location /php/ { fastcgi_pass backend:9000; … fastcgi_catch_stderr “PHP Fatal error”; fastcgi_next_upstream error timeout invalid_header; }  Syntax:  <strong>fastcgi_connect_timeout</strong> <em>time</em> ;<br>  Default:  fastcgi_connect_timeout 60s;  Context:  http , server , location<br>  定义与FastCGI服务器建立连接的超时。 应该注意，此超时通常不会超过75秒。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_force_ranges</strong> on | off ;<br>  Default:  fastcgi_force_ranges off;  Context:  http , server , location<br>  该指令出现在1.7.7版本中。 </p>
<p> 无论来自这些响应中的“Accept-Ranges”字段如何，都可以对来自FastCGI服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p> Syntax:  <strong>fastcgi_hide_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  默认情况下，nginx不会将FastCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。 fastcgi_hide_header指令设置不会传递的其他字段。 相反，如果需要允许传递字段，则可以使用fastcgi_pass_header指令。 </p>
<p> Syntax:  <strong>fastcgi_ignore_client_abort</strong> on | off ;<br>  Default:  fastcgi_ignore_client_abort off;  Context:  http , server , location<br>  确定客户端在不等待响应的情况下关闭连接时是否应关闭与FastCGI服务器的连接。 </p>
<p> Syntax:  <strong>fastcgi_ignore_headers</strong> <em>field</em> …;<br>  Default:  —  Context:  http , server , location<br>  禁用从FastCGI服务器处理某些响应头字段。 可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p> 如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应缓存的参数; </li>
<li>“X-Accel-Redirect”执行内部重定向到指定的URI; </li>
<li>“X-Accel-Limit-Rate”设置向客户端传输响应的速率限制 ; </li>
<li>“X-Accel-Buffering”启用或禁用缓冲响应; </li>
<li>“X-Accel-Charset”设置了所需的响应字符集 。<br>Syntax:  <strong>fastcgi_index</strong> <em>name</em> ;<br>Default:  —  Context:  http , server , location<br>在$fastcgi_script_name变量的值中设置将在以斜杠结尾的URI之后附加的文件名。 例如，使用这些设置 </li>
</ul>
<blockquote>
<p>fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;  和“ /page.php ”请求， SCRIPT_FILENAME参数将等于“ /home/www/scripts/php/page.php ”，并且使用“ / ”请求它将等于“ /home/www/scripts/php/index.php “。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_intercept_errors</strong> on | off ;<br>  Default:  fastcgi_intercept_errors off;  Context:  http , server , location<br>  确定代码大于或等于300的FastCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用error_page指令进行处理。 </p>
<p> Syntax:  <strong>fastcgi_keep_conn</strong> on | off ;<br>  Default:  fastcgi_keep_conn off;  Context:  http , server , location<br>  该指令出现在1.1.4版中。 </p>
<p> 默认情况下，FastCGI服务器将在发送响应后立即关闭连接。 但是，当此伪指令设置为on ，nginx将指示FastCGI服务器保持连接打开。 特别是，这对于FastCGI服务器的keepalive连接起作用是必要的。 </p>
<p> Syntax:  <strong>fastcgi_limit_rate</strong> <em>rate</em> ;<br>  Default:  fastcgi_limit_rate 0;  Context:  http , server , location<br>  该指令出现在1.7.7版本中。 </p>
<p> 限制从FastCGI服务器读取响应的速度。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据请求设置限制，因此如果nginx同时打开两个到FastCFI服务器的连接，则总速率将是指定限制的两倍。 仅当启用了对来自FastCGI服务器的响应的缓冲时 ，该限制才有效。 </p>
<p> Syntax:  <strong>fastcgi_max_temp_file_size</strong> <em>size</em> ;<br>  Default:  fastcgi_max_temp_file_size 1024m;  Context:  http , server , location<br>  当启用来自FastCGI服务器的响应缓冲 ，并且整个响应不适合fastcgi_buffer_size和fastcgi_buffers指令设置的缓冲区时，响应的一部分可以保存到临时文件中。 该指令设置临时文件的最大<em>size</em> 。 一次写入临时文件的数据大小由fastcgi_temp_file_write_size指令设置。 </p>
<p> 零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p> 此限制不适用于将缓存或存储在磁盘上的响应。  Syntax:  <strong>fastcgi_next_upstream</strong> error | timeout | invalid_header | http_500 | http_503 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>  Default:  fastcgi_next_upstream error timeout;  Context:  http , server , location<br>  指定应将请求传递到下一个服务器的情况： </p>
</blockquote>
<p> error   与服务器建立连接，向其传递请求或读取响应头时发生错误;  timeout   在与服务器建立连接，向其传递请求或读取响应头时发生超时;  invalid_header   服务器返回空或无效响应;  http_500   服务器返回代码为500的响应;  http_503   服务器返回代码为503的响应;  http_403   服务器返回代码为403的响应;  http_404   服务器返回代码为404的响应;  http_429   服务器返回代码为429的响应（1.11.13）;  non_idempotent   通常，如果请求已发送到上游服务器，则使用非幂等方法（ POST ， LOCK ， PATCH ）的请求不会传递给下一个服务器（1.9.13）; 启用此选项显式允许重试此类请求;  off   禁用将请求传递给下一个服务器。  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p> 该指令还定义了与服务器通信的不成功尝试 。 error ， timeout和invalid_header情况始终被视为不成功的尝试，即使它们未在指令中指定。 http_500 ， http_503和http_429情况仅在指令中指定http_429被视为不成功尝试。 http_403和http_404情况从未被视为不成功的尝试。 </p>
<p> 将请求传递到下一个服务器可能会受到尝试次数和时间的限制 。 </p>
<p> Syntax:  <strong>fastcgi_next_upstream_timeout</strong> <em>time</em> ;<br>  Default:  fastcgi_next_upstream_timeout 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制请求可以传递到下一个服务器的时间 。 0值关闭此限制。 </p>
<p> Syntax:  <strong>fastcgi_next_upstream_tries</strong> <em>number</em> ;<br>  Default:  fastcgi_next_upstream_tries 0;  Context:  http , server , location<br>  该指令出现在1.7.5版本中。 </p>
<p> 限制将请求传递到下一个服务器的可能尝试次数。 0值关闭此限制。 </p>
<p> Syntax:  <strong>fastcgi_no_cache</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  定义不将响应保存到缓存的条件。 如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<blockquote>
<p>fastcgi_no_cache $cookie_nocache $arg_nocache$arg_comment; fastcgi_no_cache $http_pragma $http_authorization;  可以与fastcgi_cache_bypass指令一起使用。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_param</strong> <em>parameter</em> <em>value</em> [ if_not_empty ];<br>  Default:  —  Context:  http , server , location<br>  设置应传递给FastCGI服务器的参数。 该<em>value</em>可以包含文本，变量及其组合。 当且仅当在当前级别上没有定义fastcgi_param指令时，这些指令才从前一级继承。 </p>
<p> 以下示例显示了PHP的最低必需设置： </p>
<blockquote>
<p>fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string;  SCRIPT_FILENAME参数在PHP中用于确定脚本名称， QUERY_STRING参数用于传递请求参数。 </p>
</blockquote>
<p> 对于处理POST请求的脚本，还需要以下三个参数： </p>
<blockquote>
<p>fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length;  如果PHP是使用–enable-force-cgi-redirect配置参数构建的，则还应使用值“200”传递REDIRECT_STATUS参数： </p>
<p>fastcgi_param REDIRECT_STATUS 200;  如果使用if_not_empty （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<p>fastcgi_param HTTPS $https if_not_empty;  Syntax:  <strong>fastcgi_pass</strong> <em>address</em> ;<br>  Default:  —  Context:  location , if in location<br>  设置FastCGI服务器的地址。 地址可以指定为域名或IP地址，以及端口： </p>
<p>fastcgi_pass localhost:9000;  或者作为UNIX域套接字路径： </p>
<p>fastcgi_pass unix:/tmp/fastcgi.socket;  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。 此外，可以将地址指定为服务器组 。 </p>
</blockquote>
<p> 参数值可以包含变量。 在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用解析器确定。 </p>
<p> Syntax:  <strong>fastcgi_pass_header</strong> <em>field</em> ;<br>  Default:  —  Context:  http , server , location<br>  允许将FastCGI服务器上禁用的标头字段传递给客户端。 </p>
<p> Syntax:  <strong>fastcgi_pass_request_body</strong> on | off ;<br>  Default:  fastcgi_pass_request_body on;  Context:  http , server , location<br>  指示是否将原始请求正文传递给FastCGI服务器。 另请参见fastcgi_pass_request_headers指令。 </p>
<p> Syntax:  <strong>fastcgi_pass_request_headers</strong> on | off ;<br>  Default:  fastcgi_pass_request_headers on;  Context:  http , server , location<br>  指示原始请求的标头字段是否传递给FastCGI服务器。 另请参见fastcgi_pass_request_body指令。 </p>
<p> Syntax:  <strong>fastcgi_read_timeout</strong> <em>time</em> ;<br>  Default:  fastcgi_read_timeout 60s;  Context:  http , server , location<br>  定义从FastCGI服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果FastCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>fastcgi_request_buffering</strong> on | off ;<br>  Default:  fastcgi_request_buffering on;  Context:  http , server , location<br>  该指令出现在1.7.11版本中。 </p>
<p> 启用或禁用客户端请求正文的缓冲。 </p>
<p> 启用缓冲后，在将请求发送到FastCGI服务器之前，将从客户端读取整个请求正文。 </p>
<p> 禁用缓冲时，请求主体在收到时立即发送到FastCGI服务器。 在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给下一个服务器 。 </p>
<p> Syntax:  <strong>fastcgi_send_lowat</strong> <em>size</em> ;<br>  Default:  fastcgi_send_lowat 0;  Context:  http , server , location<br>  如果指令设置为非零值，则nginx将尝试通过使用kqueue方法的NOTE_LOWAT标志或具有指定<em>size</em>的SO_SNDLOWAT套接字选项来最小化到FastCGI服务器的传出连接上的发送操作数。 </p>
<p> 在Linux，Solaris和Windows上忽略此指令。 </p>
<p> Syntax:  <strong>fastcgi_send_timeout</strong> <em>time</em> ;<br>  Default:  fastcgi_send_timeout 60s;  Context:  http , server , location<br>  设置将请求传输到FastCGI服务器的超时。 仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。 如果FastCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p> Syntax:  <strong>fastcgi_socket_keepalive</strong> on | off ;<br>  Default:  fastcgi_socket_keepalive off;  Context:  http , server , location<br>  该指令出现在1.15.6版中。 </p>
<p> 配置到FastCGI服务器的传出连接的“TCP keepalive”行为。 默认情况下，操作系统的设置对套接字有效。 如果指令设置为值“ on ”，则为套接字打开SO_KEEPALIVE套接字选项。 </p>
<p> Syntax:  <strong>fastcgi_split_path_info</strong> <em>regex</em> ;<br>  Default:  —  Context:  location<br>  定义捕获$fastcgi_path_info变量值的正则表达式。 正则表达式应该有两个捕获：第一个变为$fastcgi_script_name变量的值，第二个变为$fastcgi_path_info变量的值。 例如，使用这些设置 </p>
<blockquote>
<p>location ~ ^(.+.php)(.<em>)$ { fastcgi_split_path_info ^(.+.php)(.</em>)$; fastcgi_param SCRIPT_FILENAME /path/to/php$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info;  和“ /show.php/article/0001 ”请求， SCRIPT_FILENAME参数将等于“ /path/to/php/show.php参数将等于“ /article/0001 ”。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_store</strong> on | off | <em>string</em> ;<br>  Default:  fastcgi_store off;  Context:  http , server , location<br>  允许将文件保存到磁盘。 on参数使用与指令别名或root对应的路径保存文件。 off参数禁用文件保存。 此外，可以使用带变量的<em>string</em>显式设置文件名： </p>
<blockquote>
<p>fastcgi_store /data/www$original_uri;  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。 首先将响应写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，由fastcgi_temp_path指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
</blockquote>
<p> 该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<blockquote>
<p>location /images/ { root /data/www; error_page 404 = /fetch$uri; } location /fetch/ { internal; fastcgi_pass backend:9000; … fastcgi_store on; fastcgi_store_access user:rw group:rw all:r; fastcgi_temp_path /data/temp; alias /data/www/; }  Syntax:  <strong>fastcgi_store_access</strong> <em>users</em> : <em>permissions</em> …;<br>  Default:  fastcgi_store_access user:rw;  Context:  http , server , location<br>  为新创建的文件和目录设置访问权限，例如： </p>
<p>fastcgi_store_access user:rw group:rw all:r;  如果指定了任何group或all访问权限，则可以省略user权限： </p>
<p>fastcgi_store_access group:rw all:r;  Syntax:  <strong>fastcgi_temp_file_write_size</strong> <em>size</em> ;<br>  Default:  fastcgi_temp_file_write_size 8k|16k;  Context:  http , server , location<br>  当启用从FastCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<em>size</em> 。 默认情况下， <em>size</em>由fastcgi_buffer_size和fastcgi_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由fastcgi_max_temp_file_size指令设置。 </p>
</blockquote>
<p> Syntax:  <strong>fastcgi_temp_path</strong> <em>path</em> [ <em>level1</em> [ <em>level2</em> [ <em>level3</em> ]]];<br>  Default:  fastcgi_temp_path fastcgi_temp;  Context:  http , server , location<br>  定义用于存储临时文件的目录，其中包含从FastCGI服务器接收的数据。 在指定目录下最多可以使用三级子目录层次结构。 例如，在以下配置中 </p>
<blockquote>
<p>fastcgi_temp_path /spool/nginx/fastcgi_temp 1 2;  临时文件可能如下所示： </p>
<p>/spool/nginx/fastcgi_temp/ <strong>7</strong> / <strong>45</strong> /00000123 <strong>457</strong>  另请参见fastcgi_cache_path指令的use_temp_path参数。 </p>
</blockquote>
<h4 id="传递给FastCGI服务器的参数"><a href="#传递给FastCGI服务器的参数" class="headerlink" title="传递给FastCGI服务器的参数"></a>传递给FastCGI服务器的参数</h4><p> HTTP请求标头字段作为参数传递给FastCGI服务器。 在作为FastCGI服务器运行的应用程序和脚本中，这些参数通常可用作环境变量。 例如，“User-Agent”标头字段作为HTTP_USER_AGENT参数传递。 除HTTP请求头字段外，还可以使用fastcgi_param指令传递任意参数。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_fastcgi_module模块支持可用于使用fastcgi_param指令设置参数的嵌入变量： </p>
<p> $fastcgi_script_name   请求URI，或者，如果URI以斜杠结尾，请求带有由附加的fastcgi_index指令配置的索引文件名的URI。 此变量可用于设置确定PHP中脚本名称的SCRIPT_FILENAME和PATH_TRANSLATED参数。 例如，对于具有以下指令的“ /info/ ”请求 </p>
<blockquote>
<p>fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;  SCRIPT_FILENAME参数将等于“ /home/www/scripts/php/info/index.php ”。  使用fastcgi_split_path_info指令时， $fastcgi_script_name变量等于指令设置的第一个捕获的值。 </p>
</blockquote>
<p> $fastcgi_path_info   fastcgi_split_path_info指令设置的第二个捕获的值。 此变量可用于设置PATH_INFO参数。  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_f4f_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_f4f_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_f4f_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-f4f-module"><a href="#Module-ngx-http-f4f-module" class="headerlink" title="Module ngx_http_f4f_module"></a>Module ngx_http_f4f_module</h2><p> Example Configuration<br> Directives<br> f4f<br> f4f_buffer_size<br> ngx_http_f4f_module模块为Adobe HTTP动态流（HDS）提供服务器端支持。 </p>
<p> 该模块以“ /videoSeg1-Frag1 ”形式实现HTTP动态流式处理请求的处理 - 使用videoSeg1.f4x索引文件从videoSeg1.f4f文件中提取所需的片段。 该模块是Apache的Adobe f4f模块（HTTP Origin Module）的替代品。 </p>
<p> 需要使用Adobe的f4fpackager进行常规预处理，有关详细信息，请参阅相关文档。 </p>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>location /video/ { f4f; … } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>f4f</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的模块处理。 </p>
<p> Syntax:  <strong>f4f_buffer_size</strong> <em>size</em> ;<br>  Default:  f4f_buffer_size 512k;  Context:  http , server , location<br>  设置用于读取.f4x索引文件的缓冲区的<em>size</em> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_empty_gif_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_empty_gif_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_empty_gif_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-empty-gif-module"><a href="#Module-ngx-http-empty-gif-module" class="headerlink" title="Module ngx_http_empty_gif_module"></a>Module ngx_http_empty_gif_module</h2><p> Example Configuration<br> Directives<br> empty_gif<br> ngx_http_empty_gif_module模块发出单像素透明GIF。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location = /_.gif { empty_gif; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>empty_gif</strong> ;<br>  Default:  —  Context:  location<br>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_dav_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_dav_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_dav_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-dav-module"><a href="#Module-ngx-http-dav-module" class="headerlink" title="Module ngx_http_dav_module"></a>Module ngx_http_dav_module</h2><p> Example Configuration<br> Directives<br> create_full_put_path<br> dav_access<br> dav_methods<br> min_delete_depth<br> ngx_http_dav_module模块用于通过WebDAV协议进行文件管理自动化。 该模块处理HTTP和WebDAV方法PUT，DELETE，MKCOL，COPY和MOVE。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_dav_module配置参数启用它。 </p>
<blockquote>
<p> 需要其他WebDAV方法才能运行的WebDAV客户端不适用于此模块。 ####  示例配置</p>
<p>location / { root /data/www; client_body_temp_path /data/client_temp; dav_methods PUT DELETE MKCOL COPY MOVE; create_full_put_path on; dav_access group:rw all:r; limit_except GET { allow 192.168.1.0/32; deny all; } } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>create_full_put_path</strong> on | off ;<br>  Default:  create_full_put_path off;  Context:  http , server , location<br>  WebDAV规范仅允许在现有目录中创建文件。 该指令允许创建所有需要的中间目录。 </p>
<p> Syntax:  <strong>dav_access</strong> <em>users</em> : <em>permissions</em> …;<br>  Default:  dav_access user:rw;  Context:  http , server , location<br>  为新创建的文件和目录设置访问权限，例如： </p>
<blockquote>
<p>dav_access user:rw group:rw all:r;  如果指定了任何group或all访问权限，则可以省略user权限： </p>
<p>dav_access group:rw all:r;  Syntax:  <strong>dav_methods</strong> off | <em>method</em> …;<br>  Default:  dav_methods off;  Context:  http , server , location<br>  允许指定的HTTP和WebDAV方法。 参数off拒绝此模块处理的所有方法。 支持以下方法： PUT ， DELETE ， MKCOL ， COPY和MOVE 。 </p>
</blockquote>
<p> 使用PUT方法上载的文件首先写入临时文件，然后重命名该文件。 从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。 但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。 因此，建议对于任何给定位置，由client_body_temp_path指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p> 使用PUT方法创建文件时，可以通过在“Date”标题字段中传递修改日期来指定修改日期。 </p>
<p> Syntax:  <strong>min_delete_depth</strong> <em>number</em> ;<br>  Default:  min_delete_depth 0;  Context:  http , server , location<br>  允许DELETE方法删除文件，前提是请求路径中的元素数不小于指定的数。 例如，指令 </p>
<blockquote>
<p>min_delete_depth 4;  允许删除请求中的文件 </p>
<p>/users/00/00/name /users/00/00/name/pic.jpg /users/00/00/page.html  并否认删除 </p>
<p>/users/00/00  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_core_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_core_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-core-module"><a href="#Module-ngx-http-core-module" class="headerlink" title="Module ngx_http_core_module"></a>Module ngx_http_core_module</h2><p> Directives<br> absolute_redirect<br> aio<br> aio_write<br> alias<br> chunked_transfer_encoding<br> client_body_buffer_size<br> client_body_in_file_only<br> client_body_in_single_buffer<br> client_body_temp_path<br> client_body_timeout<br> client_header_buffer_size<br> client_header_timeout<br> client_max_body_size<br> connection_pool_size<br> default_type<br> directio<br> directio_alignment<br> disable_symlinks<br> error_page<br> etag<br> http<br> if_modified_since<br> ignore_invalid_headers<br> internal<br> keepalive_disable<br> keepalive_requests<br> keepalive_timeout<br> large_client_header_buffers<br> limit_except<br> limit_rate<br> limit_rate_after<br> lingering_close<br> lingering_time<br> lingering_timeout<br> listen<br> location<br> log_not_found<br> log_subrequest<br> max_ranges<br> merge_slashes<br> msie_padding<br> msie_refresh<br> open_file_cache<br> open_file_cache_errors<br> open_file_cache_min_uses<br> open_file_cache_valid<br> output_buffers<br> port_in_redirect<br> postpone_output<br> read_ahead<br> recursive_error_pages<br> request_pool_size<br> reset_timedout_connection<br> resolver<br> resolver_timeout<br> root<br> satisfy<br> send_lowat<br> send_timeout<br> sendfile<br> sendfile_max_chunk<br> server<br> server_name<br> server_name_in_redirect<br> server_names_hash_bucket_size<br> server_names_hash_max_size<br> server_tokens<br> subrequest_output_buffer_size<br> tcp_nodelay<br> tcp_nopush<br> try_files<br> types<br> types_hash_bucket_size<br> types_hash_max_size<br> underscores_in_headers<br> variables_hash_bucket_size<br> variables_hash_max_size<br> Embedded Variables   </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>absolute_redirect</strong> on | off ;<br>  Default:  absolute_redirect on;  Context:  http , server , location<br>  该指令出现在1.11.8版中。 </p>
<p> 如果禁用，nginx发出的重定向将是相对的。 </p>
<p> 另请参见server_name_in_redirect和port_in_redirect指令。 </p>
<p> Syntax:  <strong>aio</strong> on | off | threads [ = <em>pool</em> ];<br>  Default:  aio off;  Context:  http , server , location<br>  该指令出现在0.8.11版本中。 </p>
<p> 启用或禁用在FreeBSD和Linux上使用异步文件I / O（AIO）： </p>
<blockquote>
<p>location /video/ { aio on; output_buffers 1 64k; }  在FreeBSD上，可以从FreeBSD 4.3开始使用AIO。 在FreeBSD 11.0之前，AIO可以静态链接到内核： </p>
<p>options VFS_AIO  或作为内核可加载模块动态加载： </p>
<p>kldload aio  在Linux上，可以从内核版本2.6.22开始使用AIO。 此外，有必要启用directio ，否则读取将被阻止： </p>
<p>location /video/ { aio on; directio 512; output_buffers 1 128k; }  在Linux上， directio只能用于读取在512字节边界（或XFS为4K）上对齐的块。 在阻塞模式下读取文件的未对齐结束。 对于字节范围请求和不是从文件开头的FLV请求也是如此：在文件开头和结尾读取未对齐数据将被阻塞。 </p>
</blockquote>
<p> 当在Linux上启用AIO和sendfile时 ，AIO用于大于或等于directio指令中指定大小的文件，而sendfile用于较小大小的文件或禁用directio时。 </p>
<blockquote>
<p>location /video/ { sendfile on; aio on; directio 8m; }  最后，可以使用多线程（1.7.11）读取和发送文件，而不会阻止工作进程： </p>
<p>location /video/ { sendfile on; aio threads; }  读取和发送文件操作被卸载到指定池的线程。 如果省略池名称，则使用名称为“ default ”的池。 池名称也可以使用变量设置： </p>
<p>aio threads=pool$disk;  默认情况下，禁用多线程，应使用–with-threads配置参数启用它。 目前，多线程仅与epoll ， kqueue和eventport方法兼容。 只在Linux上支持多线程文件发送。 </p>
</blockquote>
<p> 另请参见sendfile指令。 </p>
<p> Syntax:  <strong>aio_write</strong> on | off ;<br>  Default:  aio_write off;  Context:  http , server , location<br>  该指令出现在1.9.13版本中。 </p>
<p> 如果启用了aio ，则指定是否用于写入文件。 目前，这仅在使用aio threads ，并且仅限于使用从代理服务器接收的数据编写临时文件。 </p>
<p> Syntax:  <strong>alias</strong> <em>path</em> ;<br>  Default:  —  Context:  location<br>  定义指定位置的替换。 例如，使用以下配置 </p>
<blockquote>
<p>location /i/ { alias /data/w3/images/; }  根据“ /i/top.gif ”的请求，将发送文件/data/w3/images/top.gif 。 </p>
</blockquote>
<p> <em>path</em>值可以包含变量， $document_root和$realpath_root除外。 </p>
<p> 如果在使用正则表达式定义的位置内使用alias则此类正则表达式应包含捕获，而alias应引用这些捕获（0.7.40），例如： </p>
<blockquote>
<p>location ~ ^/users/(.+.(?:gif|jpe?g|png))$ { alias /data/w3/images/$1; }  当location匹配指令值的最后一部分时： </p>
<p>location /images/ { alias /data/w3/images/; }  最好使用root指令： </p>
<p>location /images/ { root /data/w3; }  Syntax:  <strong>chunked_transfer_encoding</strong> on | off ;<br>  Default:  chunked_transfer_encoding on;  Context:  http , server , location<br>  允许在HTTP / 1.1中禁用分块传输编码。 尽管符合标准要求，但在使用软件无法支持分块编码时，它可能会派上用场。 </p>
</blockquote>
<p> Syntax:  <strong>client_body_buffer_size</strong> <em>size</em> ;<br>  Default:  client_body_buffer_size 8k|16k;  Context:  http , server , location<br>  设置读取客户端请求正文的缓冲区大小。 如果请求主体大于缓冲区，则整个主体或仅其部分被写入临时文件 。 默认情况下，缓冲区大小等于两个内存页。 这是x86上的8K，其他32位平台和x86-64。 在其他64位平台上通常为16K。 </p>
<p> Syntax:  <strong>client_body_in_file_only</strong> on | clean | off ;<br>  Default:  client_body_in_file_only off;  Context:  http , server , location<br>  确定nginx是否应将整个客户端请求主体保存到文件中。 该指令可以在调试期间使用，或者在使用$request_body_file变量或模块ngx_http_perl_module的$ r-&gt; request_body_file方法时使用。 </p>
<p> 设置为打开值on ，请求处理后不会删除临时文件。 </p>
<p> 值clean将导致删除请求处理后留下的临时文件。 </p>
<p> Syntax:  <strong>client_body_in_single_buffer</strong> on | off ;<br>  Default:  client_body_in_single_buffer off;  Context:  http , server , location<br>  确定nginx是否应将整个客户端请求主体保存在单个缓冲区中。 使用$request_body变量时，建议使用该指令，以保存所涉及的复制操作数。 </p>
<p> Syntax:  <strong>client_body_temp_path</strong> <em>path</em> [ <em>level1</em> [ <em>level2</em> [ <em>level3</em> ]]];<br>  Default:  client_body_temp_path client_body_temp;  Context:  http , server , location<br>  定义用于存储包含客户端请求主体的临时文件的目录。 在指定目录下最多可以使用三级子目录层次结构。 例如，在以下配置中 </p>
<blockquote>
<p>client_body_temp_path /spool/nginx/client_temp 1 2;  临时文件的路径可能如下所示： </p>
<p>/spool/nginx/client_temp/7/45/00000123457  Syntax:  <strong>client_body_timeout</strong> <em>time</em> ;<br>  Default:  client_body_timeout 60s;  Context:  http , server , location<br>  定义读取客户端请求正文的超时。 超时仅设置为两个连续读取操作之间的时间段，而不是整个请求主体的传输。 如果客户端在此时间内未传输任何内容，请求将以408（请求超时）错误终止。 </p>
</blockquote>
<p> Syntax:  <strong>client_header_buffer_size</strong> <em>size</em> ;<br>  Default:  client_header_buffer_size 1k;  Context:  http , server<br>  设置缓冲区大小以读取客户端请求标头。 对于大多数请求，1K字节的缓冲区就足够了。 但是，如果请求包含长cookie或来自WAP客户端，则可能不适合1K。 如果请求行或请求头字段不适合此缓冲区，则分配由large_client_header_buffers指令配置的较大缓冲区。 </p>
<p> Syntax:  <strong>client_header_timeout</strong> <em>time</em> ;<br>  Default:  client_header_timeout 60s;  Context:  http , server<br>  定义读取客户端请求标头的超时。 如果客户端在此时间内未传输整个标头，请求将以408（请求超时）错误终止。 </p>
<p> Syntax:  <strong>client_max_body_size</strong> <em>size</em> ;<br>  Default:  client_max_body_size 1m;  Context:  http , server , location<br>  设置客户端请求正文的最大允许大小，在“Content-Length”请求标头字段中指定。 如果请求中的大小超过配置的值，则会将413（请求实体太大）错误返回给客户端。 请注意，浏览器无法正确显示此错误。 将<em>size</em>设置为0将禁用检查客户端请求正文大小。 </p>
<p> Syntax:  <strong>connection_pool_size</strong> <em>size</em> ;<br>  Default:  connection_pool_size 256|512;  Context:  http , server<br>  允许精确调整每个连接的内存分配。 该指令对性能的影响最小，通常不应使用。 默认情况下，大小在32位平台上等于256字节，在64位平台上等于512字节。 </p>
<blockquote>
<p> 在1.9.8版之前，所有平台上的默认值均为256。  Syntax:  <strong>default_type</strong> <em>mime-type</em> ;<br>  Default:  default_type text/plain;  Context:  http , server , location<br>  定义响应的默认MIME类型。 可以使用types指令设置文件扩展名到MIME类型的映射。 </p>
</blockquote>
<p> Syntax:  <strong>directio</strong> <em>size</em> | off ;<br>  Default:  directio off;  Context:  http , server , location<br>  该指令出现在0.7.7版本中。 </p>
<p> 在读取大于或等于指定<em>size</em>文件时，允许使用O_DIRECT标志（FreeBSD，Linux）， F_NOCACHE标志（macOS）或directio()函数（Solaris）。 该指令自动禁用（0.7.15）对给定请求使用sendfile 。 它对于提供大型文件非常有用： </p>
<blockquote>
<p>directio 4m;  或者在Linux上使用aio时。 </p>
</blockquote>
<p> Syntax:  <strong>directio_alignment</strong> <em>size</em> ;<br>  Default:  directio_alignment 512;  Context:  http , server , location<br>  该指令出现在0.8.11版本中。 </p>
<p> 设置directio的对齐方式。 在大多数情况下，512字节对齐就足够了。 但是，在Linux下使用XFS时，需要将其增加到4K。 </p>
<p> Syntax:  <strong>disable_symlinks</strong> off ;<br> <strong>disable_symlinks</strong> on | if_not_owner [ from = <em>part</em> ];<br>  Default:  disable_symlinks off;  Context:  http , server , location<br>  该指令出现在1.1.15版中。 </p>
<p> 确定打开文件时应如何处理符号链接： </p>
<p> off   路径名中的符号链接是允许的，不会被选中。 这是默认行为。  on   如果路径名的任何组件是符号链接，则拒绝访问文件。  if_not_owner   如果路径名的任何组件是符号链接，并且链接指向的链接和对象具有不同的所有者，则拒绝访问文件。  from = <em>part</em>  检查符号链接（参数on和if_not_owner ）时，通常会检查路径名的所有组件。 通过另外指定from = <em>part</em>参数，可以避免检查路径名的初始部分中的符号链接。 在这种情况下，仅从指定的初始部分后面的路径名组件检查符号链接。 如果该值不是检查的路径名的初始部分，则检查整个路径名，就好像根本没有指定此参数一样。 如果值与整个文件名匹配，则不检查符号链接。 参数值可以包含变量。  例： </p>
<blockquote>
<p>disable_symlinks on from=$document_root;  该指令仅适用于具有openat()和fstatat()接口的系统。 这些系统包括FreeBSD，Linux和Solaris的现代版本。 </p>
</blockquote>
<p> 参数on和if_not_owner添加了处理开销。 </p>
<blockquote>
<p> 在不支持仅为搜索打开目录的系统上，要使用这些参数，需要工作进程对所有正在检查的目录具有读取权限。<br> ngx_http_autoindex_module ， ngx_http_random_index_module和ngx_http_dav_module模块当前忽略此指令。  Syntax:  <strong>error_page</strong> <em>code</em> … [ = [ <em>response</em> ]] <em>uri</em> ;<br>  Default:  —  Context:  http , server , location , if in location<br>  定义将为指定错误显示的URI。 <em>uri</em>值可以包含变量。 </p>
</blockquote>
<p> 例： </p>
<blockquote>
<p>error_page 404 /404.html; error_page 500 502 503 504 /50x.html;  这导致内部重定向到指定的<em>uri</em> ，客户端请求方法更改为“ GET ”（对于“ GET ”和“ HEAD ”以外的所有方法）。 </p>
</blockquote>
<p> 此外，可以使用“ = <em>response</em> ”语法将响应代码更改为另一个，例如： </p>
<blockquote>
<p>error_page 404 =200 /empty.gif;  如果代理服务器或FastCGI / uwsgi / SCGI / gRPC服务器处理错误响应，并且服务器可能返回不同的响应代码（例如，200,302,401或404），则可以使用代码进行响应收益： </p>
<p>error_page 404 = /404.php;  如果在内部重定向期间无需更改URI和方法，则可以将错误处理传递到命名位置： </p>
<p>location / { error_page 404 = @fallback; } location @fallback { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; }<br> 如果<em>uri</em>处理导致错误，则将上次发生的错误的状态代码返回给客户端。  也可以使用URL重定向进行错误处理： </p>
<p>error_page 403 <a href="http://example.com/forbidden.html" target="_blank" rel="noopener">http://example.com/forbidden.html</a>; error_page 404 =301 <a href="http://example.com/notfound.html" target="_blank" rel="noopener">http://example.com/notfound.html</a>;  在这种情况下，默认情况下，响应代码302返回给客户端。 它只能更改为重定向状态代码之一（301,302,303,307和308）。 </p>
<p> 在版本1.1.16和1.0.13之前，代码307不被视为重定向。<br> 在版本1.13.0之前，代码308不被视为重定向。  当且仅当在当前级别上没有定义error_page指令时，这些指令才从前一级继承。 </p>
</blockquote>
<p> Syntax:  <strong>etag</strong> on | off ;<br>  Default:  etag on;  Context:  http , server , location<br>  该指令出现在1.3.3版本中。 </p>
<p> 启用或禁用自动生成静态资源的“ETag”响应头字段。 </p>
<p> Syntax:  <strong>http</strong> { … }<br>  Default:  —  Context:  main<br>  提供指定HTTP服务器指令的配置文件上下文。 </p>
<p> Syntax:  <strong>if_modified_since</strong> off | exact | before ;<br>  Default:  if_modified_since exact;  Context:  http , server , location<br>  该指令出现在0.7.24版本中。 </p>
<p> 指定如何将响应的修改时间与“If-Modified-Since”请求标头字段中的时间进行比较： </p>
<p> off   忽略“If-Modified-Since”请求头字段（0.7.34）;  exact   完全符合;  before   响应的修改时间小于或等于“If-Modified-Since”请求头字段中的时间。  Syntax:  <strong>ignore_invalid_headers</strong> on | off ;<br>  Default:  ignore_invalid_headers on;  Context:  http , server<br>  控制是否应忽略具有无效名称的标头字段。 有效名称由英文字母，数字，连字符和可能的下划线组成（由underscores_in_headers指令控制）。 </p>
<p> 如果在服务器级别指定了该指令，则仅在服务器是默认服务器时使用其值。 指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p> Syntax:  <strong>internal</strong> ;<br>  Default:  —  Context:  location<br>  指定给定位置只能用于内部请求。 对于外部请求，返回客户端错误404（未找到）。 内部请求如下： </p>
<ul>
<li>由error_page ， index ， random_index和try_files指令重定向的请求; </li>
<li>来自上游服务器的“X-Accel-Redirect”响应头字段重定向的请求; </li>
<li>由ngx_http_ssi_module模块的“ include virtual ”命令， ngx_http_addition_module模块指令以及auth_request和mirror指令形成的子请求; </li>
<li>请求由重写指令更改。<br>例： </li>
</ul>
<blockquote>
<p>error_page 404 /404.html; location = /404.html { internal; }<br> 每个请求最多有10个内部重定向，以防止在错误配置中发生的请求处理周期。 如果达到此限制，则返回错误500（内部服务器错误）。 在这种情况下，可以在错误日志中看到“重写或内部重定向周期”消息。  Syntax:  <strong>keepalive_disable</strong> none | <em>browser</em> …;<br>  Default:  keepalive_disable msie6;  Context:  http , server , location<br>  禁用与行为不当的浏览器保持连接状态。 <em>browser</em>参数指定将受影响的浏览器。 一旦收到POST请求，值msie6将禁用与旧版本MSIE的保持活动连接。 值safari禁用与macOS和类似macOS的操作系统上的Safari和类似Safari的浏览器的保持活动连接。 值none与所有浏览器保持连接。 </p>
<p> 在版本1.1.18之前，值safari与所有操作系统上的所有Safari和类似Safari的浏览器相匹配，默认情况下禁用与它们保持连接的连接。  Syntax:  <strong>keepalive_requests</strong> <em>number</em> ;<br>  Default:  keepalive_requests 100;  Context:  http , server , location<br>  该指令出现在0.8.0版本中。 </p>
</blockquote>
<p> 设置可通过一个保持活动连接提供的最大请求数。 在发出最大请求数后，将关闭连接。 </p>
<p> Syntax:  <strong>keepalive_timeout</strong> <em>timeout</em> [ <em>header_timeout</em> ];<br>  Default:  keepalive_timeout 75s;  Context:  http , server , location<br>  第一个参数设置一个超时，在此期间保持活动的客户端连接将在服务器端保持打开状态。 零值禁用保持活动的客户端连接。 可选的第二个参数在“Keep-Alive：timeout = <em>time</em> ”响应头字段中设置一个值。 两个参数可能不同。 </p>
<p> Mozilla和Konqueror识别“Keep-Alive：timeout = <em>time</em> ”标题字段。 MSIE在大约60秒内自行关闭保持连接。 </p>
<p> Syntax:  <strong>large_client_header_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  large_client_header_buffers 4 8k;  Context:  http , server<br>  设置用于读取大客户机请求标头的缓冲区的最大<em>number</em>和<em>size</em> 。 请求行不能超过一个缓冲区的大小，否则会将414（Request-URI Too Large）错误返回给客户端。 请求头字段也不能超过一个缓冲区的大小，或者400（错误请求）错误返回给客户端。 缓冲区仅按需分配。 默认情况下，缓冲区大小等于8K字节。 如果在请求处理结束后连接转换为保持活动状态，则释放这些缓冲区。 </p>
<p> Syntax:  <strong>limit_except</strong> <em>method</em> … { … }<br>  Default:  —  Context:  location<br>  限制允许位置内的HTTP方法。 <em>method</em>参数可以是以下之一： GET ， HEAD ， POST ， PUT ， DELETE ， MKCOL ， COPY ， MOVE ， OPTIONS ， PROPFIND ， PROPPATCH ， LOCK ， UNLOCK或PATCH 。 允许GET方法也允许使用HEAD方法。 使用ngx_http_access_module ， ngx_http_auth_basic_module和ngx_http_auth_jwt_module （1.13.10）模块指令可以限制对其他方法的访问： </p>
<blockquote>
<p>limit_except GET { allow 192.168.1.0/32; deny all; }  请注意，这将限制对<strong>除</strong> GET和HEAD <strong>之外的</strong>所有方法的访问。 </p>
</blockquote>
<p> Syntax:  <strong>limit_rate</strong> <em>rate</em> ;<br>  Default:  limit_rate 0;  Context:  http , server , location , if in location<br>  限制向客户端传输的响应速率。 <em>rate</em>以每秒字节数指定。 零值禁用速率限制。 根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<p> 也可以在$limit_rate变量中设置速率限制。 在根据特定条件限制费率的情况下，它可能很有用： </p>
<blockquote>
<p>server { if ($slow) { set $limit_rate 4k; } … }  还可以在代理服务器响应的“X-Accel-Limit-Rate”头字段中设置速率限制。 可以使用proxy_ignore_headers ， fastcgi_ignore_headers ， uwsgi_ignore_headers和scgi_ignore_headers指令禁用此功能。 </p>
</blockquote>
<p> Syntax:  <strong>limit_rate_after</strong> <em>size</em> ;<br>  Default:  limit_rate_after 0;  Context:  http , server , location , if in location<br>  该指令出现在0.8.0版本中。 </p>
<p> 设置初始量，在此之后，对客户端的响应的进一步传输将受到速率限制。 </p>
<p> 例： </p>
<blockquote>
<p>location /flv/ { flv; limit_rate_after 500k; limit_rate 50k; }  Syntax:  <strong>lingering_close</strong> off | on | always ;<br>  Default:  lingering_close on;  Context:  http , server , location<br>  该指令出现在1.1.0和1.0.6版本中。 </p>
</blockquote>
<p> 控制nginx如何关闭客户端连接。 </p>
<p> 默认值“ on ”指示nginx在完全关闭连接之前等待并处理来自客户端的其他数据，但仅当启发式表明客户端可能正在发送更多数据时。 </p>
<p> 值“ always ”将导致nginx无条件地等待并处理其他客户端数据。 </p>
<p> 值“ off ”告诉nginx永远不要等待更多数据并立即关闭连接。 此行为会破坏协议，不应在正常情况下使用。 </p>
<p> Syntax:  <strong>lingering_time</strong> <em>time</em> ;<br>  Default:  lingering_time 30s;  Context:  http , server , location<br>  当lingering_close生效时，此指令指定nginx处理（读取和忽略）来自客户端的其他数据的最长时间。 之后，即使有更多数据，连接也将关闭。 </p>
<p> Syntax:  <strong>lingering_timeout</strong> <em>time</em> ;<br>  Default:  lingering_timeout 5s;  Context:  http , server , location<br>  当lingering_close生效时，此指令指定更多客户端数据到达的最长等待时间。 如果在此期间未收到数据，则关闭连接。 否则，将读取并忽略数据，并且nginx会再次开始等待更多数据。 重复“wait-read-ignore”循环，但不会超过lingering_time指令指定的循环。 </p>
<p> Syntax:  <strong>listen</strong> <em>address</em> [: <em>port</em> ] [ default_server ] [ ssl ] [ http2 | spdy ] [ proxy_protocol ] [ setfib = <em>number</em> ] [ fastopen = <em>number</em> ] [ backlog = <em>number</em> ] [ rcvbuf = <em>size</em> ] [ sndbuf = <em>size</em> ] [ accept_filter = <em>filter</em> ] [ deferred ] [ bind ] [ ipv6only = on | off ] [ reuseport ] [ so_keepalive = on | off |[ <em>keepidle</em> ]:[ <em>keepintvl</em> ]:[ <em>keepcnt</em> ]];<br> <strong>listen</strong> <em>port</em> [ default_server ] [ ssl ] [ http2 | spdy ] [ proxy_protocol ] [ setfib = <em>number</em> ] [ fastopen = <em>number</em> ] [ backlog = <em>number</em> ] [ rcvbuf = <em>size</em> ] [ sndbuf = <em>size</em> ] [ accept_filter = <em>filter</em> ] [ deferred ] [ bind ] [ ipv6only = on | off ] [ reuseport ] [ so_keepalive = on | off |[ <em>keepidle</em> ]:[ <em>keepintvl</em> ]:[ <em>keepcnt</em> ]];<br> <strong>listen</strong> unix: <em>path</em> [ default_server ] [ ssl ] [ http2 | spdy ] [ proxy_protocol ] [ backlog = <em>number</em> ] [ rcvbuf = <em>size</em> ] [ sndbuf = <em>size</em> ] [ accept_filter = <em>filter</em> ] [ deferred ] [ bind ] [ so_keepalive = on | off |[ <em>keepidle</em> ]:[ <em>keepintvl</em> ]:[ <em>keepcnt</em> ]];<br>  Default:  listen <em>:80 | </em>:8000;  Context:  server<br>  设置IP的<em>address</em>和<em>port</em> ，或服务器将接受请求的UNIX域套接字的<em>path</em> 。 可以指定<em>address</em>和<em>port</em> ，或仅指定<em>address</em>或仅<em>port</em> 。 <em>address</em>也可以是主机名，例如： </p>
<blockquote>
<p>listen 127.0.0.1:8000; listen 127.0.0.1; listen 8000; listen *:8000; listen localhost:8000;  IPv6地址（0.7.36）在方括号中指定： </p>
<p>listen [::]:8000; listen [::1];  UNIX域套接字（0.8.21）使用“ unix: ”前缀指定： </p>
<p>listen unix:/var/run/nginx.sock;  如果仅给出<em>address</em> ，则使用端口80。 </p>
</blockquote>
<p> 如果指令不存在，那么如果nginx以超级用户权限运行，则使用<em>:80 ，否则使用</em>:8000 。 </p>
<p> default_server参数（如果存在）将使服务器成为指定<em>address</em> ： <em>port</em>对的默认服务器。 如果没有任何指令具有default_server参数，则具有<em>address</em> ： <em>port</em>对的第一个服务器将成为该对的默认服务器。 </p>
<blockquote>
<p> 在0.8.21之前的版本中，此参数仅命名为default 。  ssl参数（0.7.14）允许指定此端口上接受的所有连接都应在SSL模式下工作。 这样可以为处理HTTP和HTTPS请求的服务器提供更紧凑的配置 。 </p>
</blockquote>
<p> http2参数（1.9.5）将端口配置为接受HTTP / 2连接。 通常，为了使其工作，也应该指定ssl参数，但是也可以将nginx配置为接受没有SSL的HTTP / 2连接。 </p>
<p> spdy参数（1.3.15-1.9.4）允许接受此端口上的SPDY连接。 通常，为了使其工作，还应指定ssl参数，但也可以将nginx配置为接受不带SSL的SPDY连接。 </p>
<p> proxy_protocol参数（1.5.12）允许指定此端口上接受的所有连接都应使用PROXY协议 。 </p>
<blockquote>
<p> 自版本1.13.11起支持PROXY协议版本2。  listen指令可以有几个特定于与套接字相关的系统调用的附加参数。 这些参数可以在任何listen指令中指定，但对于给定的<em>address</em>只能指定一次： <em>port</em>对。 </p>
<p> 在0.8.21之前的版本中，它们只能在listen指令中与default参数一起指定。  setfib = <em>number</em>  此参数（0.8.44）设置侦听套接字的关联路由表FIB（ SO_SETFIB选项）。 这目前仅适用于FreeBSD。  fastopen = <em>number</em>  为侦听套接字启用“ TCP Fast Open ”（1.5.8）并限制尚未完成三次握手的连接队列的最大长度。<br> 除非服务器可以处理多次使用数据的同一SYN数据包，否则不要启用此功能。  backlog = <em>number</em>  在listen()调用中设置backlog参数，该参数限制挂起连接队列的最大长度。 默认情况下， backlog在FreeBSD，DragonFly BSD和macOS上设置为-1，在其他平台上设置为511。  rcvbuf = <em>size</em>  设置侦听套接字的接收缓冲区大小（ SO_RCVBUF选项）。  sndbuf = <em>size</em>  设置侦听套接字的发送缓冲区大小（ SO_SNDBUF选项）。  accept_filter = <em>filter</em>  为侦听套接字设置接受过滤器的名称（ SO_ACCEPTFILTER选项），该套接字在将传入连接传递给accept()之前对其进行过滤。 这仅适用于FreeBSD和NetBSD 5.0+。 可能的值是dataready和httpready 。  deferred   指示在Linux上使用延迟的accept() （ TCP_DEFER_ACCEPT套接字选项）。  bind   指示对给定<em>address</em>进行单独的bind()调用： <em>port</em>对。 这很有用，因为如果有几个具有相同端口但不同地址的listen指令，并且其中一个listen指令侦听给定端口（ <em>: </em>port<em> ）的所有地址，则nginx将bind()仅限于</em>: <em>port</em> 。 应该注意的是，在这种情况下将进行getsockname()系统调用以确定接受连接的地址。 如果使用setfib ， backlog ， rcvbuf ， sndbuf ， accept_filter ， deferred ， ipv6only或so_keepalive参数，那么对于给定的<em>address</em> ： <em>port</em>对将始终进行单独的bind()调用。  ipv6only = on | off  此参数（0.7.42）确定（通过IPV6_V6ONLY套接字选项）侦听通配符地址[::]的IPv6套接字是仅接受IPv6连接还是仅接受IPv6和IPv4连接。 默认情况下，此参数处于启用状态。 它只能在开始时设置一次。<br> 在1.3.4版之前，如果省略此参数，则操作系统的设置对套接字有效。  reuseport   此参数（1.9.1）指示为每个工作进程创建一个单独的侦听套接字（使用Linux 3.9+和DragonFly BSD上的SO_REUSEPORT套接字选项，或FreeBSD 12+上的SO_REUSEPORT_LB ），允许内核在工作进程之间分配传入连接。 目前仅适用于Linux 3.9 +，DragonFly BSD和FreeBSD 12+（1.15.1）。<br> 不恰当地使用此选项可能会产生安全隐患 。  so_keepalive = on | off | [ <em>keepidle</em> ]：[ <em>keepintvl</em> ]：[ <em>keepcnt</em> ]  此参数（1.1.11）配置侦听套接字的“TCP keepalive”行为。 如果省略此参数，则操作系统的设置将对套接字有效。 如果将其设置为值“ on ”，则为套接字打开SO_KEEPALIVE选项。 如果将其设置为值“ off ”，则为套接字关闭SO_KEEPALIVE选项。 某些操作系统支持使用TCP_KEEPIDLE ， TCP_KEEPINTVL和TCP_KEEPCNT套接字选项在每个套接字的基础上设置TCP keepalive参数。 在这样的系统上（目前，Linux 2.4 +，NetBSD 5+和FreeBSD 9.0-STABLE），可以使用<em>keepidle</em> ， <em>keepintvl</em>和<em>keepcnt</em>参数配置它们。 可以省略一个或两个参数，在这种情况下，相应套接字选项的系统默认设置将生效。 例如，<br>so_keepalive=30m::10 将空闲超时（ TCP_KEEPIDLE ）设置为30分钟，将探测间隔（ TCP_KEEPINTVL ）保留为系统默认值，并将探测计数（ TCP_KEEPCNT ）设置为10个探测。  例： </p>
<p>listen 127.0.0.1 default_server accept_filter=dataready backlog=1024;  Syntax:  <strong>location</strong> [ = | ~ | ~<em> | ^~ ] </em>uri<em> { … }<br> <strong>location</strong> @ </em>name* { … }<br>  Default:  —  Context:  server , location<br>  根据请求URI设置配置。 </p>
</blockquote>
<p> 在解码以“ %XX ”形式编码的文本，解析对相对路径分量的引用之后，针对规范化的URI执行匹配. “和” .. “，并且可能将两个或多个相邻斜线压缩成单个斜线。 </p>
<p> 位置可以由前缀字符串或正则表达式定义。 正则表达式使用前面的“ ~* ”修饰符（用于不区分大小写的匹配）或“ ~ ”修饰符（用于区分大小写的匹配）指定。 为了找到与给定请求匹配的位置，nginx首先检查使用前缀字符串（前缀位置）定义的位置。 其中，选择并记住具有最长匹配前缀的位置。 然后按照它们在配置文件中的出现顺序检查正则表达式。 正则表达式的搜索在第一个匹配时终止，并使用相应的配置。 如果未找到与正则表达式的匹配，则使用先前记住的前缀位置的配置。 </p>
<p> 可以嵌套location块，但下面提到了一些例外情况。 </p>
<p> 对于不区分大小写的操作系统（如macOS和Cygwin），与前缀字符串匹配会忽略大小写（0.7.7）。 但是，比较仅限于一个字节的区域设置。 </p>
<p> 正则表达式可以包含稍后可以在其他指令中使用的捕获（0.7.40）。 </p>
<p> 如果最长匹配前缀位置具有“ ^~ ”修饰符，则不检查正则表达式。 </p>
<p> 此外，使用“ = ”修饰符可以定义URI和位置的精确匹配。 如果找到完全匹配，则搜索终止。 例如，如果频繁发生“ / ”请求，则定义“ location = / ”将加速这些请求的处理，因为搜索在第一次比较之后立即终止。 这样的位置显然不能包含嵌套位置。 </p>
<blockquote>
<p> 在0.7.1到0.8.41的版本中，如果请求与前缀位置匹配而没有“ = ”和“ ^~ ”修饰符，则搜索也会终止，并且不会检查正则表达式。  让我们通过一个例子来说明以上内容： </p>
<p>location = / { [ configuration A ] } location / { [ configuration B ] } location /documents/ { [ configuration C ] } location ^~ /images/ { [ configuration D ] } location ~* .(gif|jpg|jpeg)$ { [ configuration E ] }  “ / ”请求将匹配配置A，“/ /index.html ”请求将匹配配置B，“/ /documents/document.html ”请求将匹配配置C，“/ /images/1.gif ”请求将匹配配置D，“/ /documents/1.jpg ”请求将匹配配置E. </p>
</blockquote>
<p> “ @ ”前缀定义了命名位置。 这样的位置不用于常规请求处理，而是用于请求重定向。 它们不能嵌套，也不能包含嵌套位置。 </p>
<p> 如果位置由以斜杠字符结尾的前缀字符串定义，并且请求由proxy_pass ， fastcgi_pass ， uwsgi_pass ， scgi_pass ， memcached_pa​​ss或grpc_pass之一处理，则执行特殊处理。 为了响应URI等于此字符串但没有尾部斜杠的请求，带有代码301的永久重定向将返回到请求的URI，并附加斜杠。 如果不需要，可以像下面这样定义URI和位置的完全匹配： </p>
<blockquote>
<p>location /user/ { proxy_pass <a href="http://user.example.com" target="_blank" rel="noopener">http://user.example.com</a>; } location = /user { proxy_pass <a href="http://login.example.com" target="_blank" rel="noopener">http://login.example.com</a>; }  Syntax:  <strong>log_not_found</strong> on | off ;<br>  Default:  log_not_found on;  Context:  http , server , location<br>  启用或禁用将未找到的文件的错误记录到error_log中 。 </p>
</blockquote>
<p> Syntax:  <strong>log_subrequest</strong> on | off ;<br>  Default:  log_subrequest off;  Context:  http , server , location<br>  启用或禁用将子请求记录到access_log中 。 </p>
<p> Syntax:  <strong>max_ranges</strong> <em>number</em> ;<br>  Default:  —  Context:  http , server , location<br>  该指令出现在1.1.2版中。 </p>
<p> 限制字节范围请求中允许的最大范围数。 超出限制的请求将被处理，就像没有指定字节范围一样。 默认情况下，范围数量不受限制。 零值完全禁用字节范围支持。 </p>
<p> Syntax:  <strong>merge_slashes</strong> on | off ;<br>  Default:  merge_slashes on;  Context:  http , server<br>  启用或禁用将URI中的两个或多个相邻斜杠压缩为单个斜杠。 </p>
<p> 请注意，压缩对于正确匹配前缀字符串和正则表达式位置至关重要。 没有它，“ //scripts/one.php ”请求将不匹配 </p>
<blockquote>
<p>location /scripts/ { … }  并且可能被处理为静态文件。 所以它被转换为“ /scripts/one.php ”。 </p>
</blockquote>
<p> 如果URI包含base64编码的名称，则必须off压缩，因为base64在内部使用“ / ”字符。 但是，出于安全考虑，最好避免关闭压缩。 </p>
<p> 如果在服务器级别指定了该指令，则仅在服务器是默认服务器时使用其值。 指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p> Syntax:  <strong>msie_padding</strong> on | off ;<br>  Default:  msie_padding on;  Context:  http , server , location<br>  启用或禁用向状态大于400的MSIE客户端的响应添加注释，以将响应大小增加到512字节。 </p>
<p> Syntax:  <strong>msie_refresh</strong> on | off ;<br>  Default:  msie_refresh off;  Context:  http , server , location<br>  启用或禁用发布刷新而不是MSIE客户端的重定向。 </p>
<p> Syntax:  <strong>open_file_cache</strong> off ;<br> <strong>open_file_cache</strong> max = <em>N</em> [ inactive = <em>time</em> ];<br>  Default:  open_file_cache off;  Context:  http , server , location<br>  配置可以存储的缓存： </p>
<ul>
<li>打开文件描述符，它们的大小和修改时间; </li>
<li>关于目录存在的信息; </li>
<li><p>文件查找错误，例如“找不到文件”，“没有读取权限”等。 </p>
<blockquote>
<p> 应该通过open_file_cache_errors指令单独启用缓存错误。<br>该指令具有以下参数： </p>
</blockquote>
<p>max   设置缓存中的最大元素数; 在缓存溢出时，删除最近最少使用（LRU）的元素;  inactive   定义一个时间，如果在此期间未访问该元素，则从该缓存中删除该元素; 默认情况下，它是60秒;  off   禁用缓存。  例： </p>
</li>
</ul>
<blockquote>
<p>open_file_cache max=1000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on;  Syntax:  <strong>open_file_cache_errors</strong> on | off ;<br>  Default:  open_file_cache_errors off;  Context:  http , server , location<br>  通过open_file_cache启用或禁用文件查找错误的缓存。 </p>
</blockquote>
<p> Syntax:  <strong>open_file_cache_min_uses</strong> <em>number</em> ;<br>  Default:  open_file_cache_min_uses 1;  Context:  http , server , location<br>  设置在open_file_cache指令的inactive参数配置的时间段内文件访问的最小<em>number</em> ，这是文件描述符在缓存中保持打开所必需的。 </p>
<p> Syntax:  <strong>open_file_cache_valid</strong> <em>time</em> ;<br>  Default:  open_file_cache_valid 60s;  Context:  http , server , location<br>  设置应验证open_file_cache元素的时间。 </p>
<p> Syntax:  <strong>output_buffers</strong> <em>number</em> <em>size</em> ;<br>  Default:  output_buffers 2 32k;  Context:  http , server , location<br>  设置用于从磁盘读取响应的缓冲区的<em>number</em>和<em>size</em> 。 </p>
<blockquote>
<p> 在1.9.5版之前，默认值为1 32k。  Syntax:  <strong>port_in_redirect</strong> on | off ;<br>  Default:  port_in_redirect on;  Context:  http , server , location<br>  启用或禁用在nginx发出的绝对重定向中指定端口。 </p>
</blockquote>
<p> 在重定向中使用主服务器名称由server_name_in_redirect指令控制。 </p>
<p> Syntax:  <strong>postpone_output</strong> <em>size</em> ;<br>  Default:  postpone_output 1460;  Context:  http , server , location<br>  如果可能，客户端数据的传输将被推迟，直到nginx至少要发送<em>size</em>字节的数据。 零值禁用推迟数据传输。 </p>
<p> Syntax:  <strong>read_ahead</strong> <em>size</em> ;<br>  Default:  read_ahead 0;  Context:  http , server , location<br>  设置使用文件时内核的预读取量。 </p>
<p> 在Linux上，使用posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)系统调用，因此忽略<em>size</em>参数。 </p>
<p> 在FreeBSD上，使用了自FreeBSD 9.0-CURRENT以来支持的fcntl(O_READAHEAD, <em>size</em> )系统调用。 FreeBSD 7必须打补丁 。 </p>
<p> Syntax:  <strong>recursive_error_pages</strong> on | off ;<br>  Default:  recursive_error_pages off;  Context:  http , server , location<br>  使用error_page指令启用或禁用多个重定向。 此类重定向的数量有限 。 </p>
<p> Syntax:  <strong>request_pool_size</strong> <em>size</em> ;<br>  Default:  request_pool_size 4k;  Context:  http , server<br>  允许精确调整每个请求的内存分配。 该指令对性能的影响最小，通常不应使用。 </p>
<p> Syntax:  <strong>reset_timedout_connection</strong> on | off ;<br>  Default:  reset_timedout_connection off;  Context:  http , server , location<br>  启用或禁用重置超时连接。 重置如下进行。 在关闭套接字之前，在其上设置SO_LINGER选项，超时值为0.当套接字关闭时，TCP RST将发送到客户端，并释放此套接字占用的所有内存。 这有助于避免将已填充缓冲区的已关闭套接字保持在FIN_WAIT1状态很长时间。 </p>
<p> 应该注意，超时保持连接正常关闭。 </p>
<p> Syntax:  <strong>resolver</strong> <em>address</em> … [ valid = <em>time</em> ] [ ipv6 = on | off ];<br>  Default:  —  Context:  http , server , location<br>  将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353;  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。 如果未指定端口，则使用端口53。 以循环方式查询名称服务器。 </p>
<p> 在1.1.7版之前，只能配置一个名称服务器。 从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。  默认情况下，nginx将在解析时查找IPv4和IPv6地址。 如果不需要查找IPv6地址，可以指定ipv6=off参数。 </p>
<p> 从版本1.5.8开始支持将名称解析为IPv6地址。  默认情况下，nginx使用响应的TTL值缓存答案。 可选的valid参数允许覆盖它： </p>
<p>resolver 127.0.0.1 [::1]:5353 valid=30s;<br> 在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。<br> 为防止DNS欺骗，建议在正确安全的受信任本地网络中配置DNS服务器。  Syntax:  <strong>resolver_timeout</strong> <em>time</em> ;<br>  Default:  resolver_timeout 30s;  Context:  http , server , location<br>  设置名称解析的超时，例如： </p>
<p>resolver_timeout 5s;  Syntax:  <strong>root</strong> <em>path</em> ;<br>  Default:  root html;  Context:  http , server , location , if in location<br>  设置请求的根目录。 例如，使用以下配置 </p>
<p>location /i/ { root /data/w3; }  将发送/data/w3/i/top.gif文件以响应“ /i/top.gif ”请求。 </p>
</blockquote>
<p> <em>path</em>值可以包含变量， $document_root和$realpath_root除外。 </p>
<p> 仅通过向root指令的值添加URI来构造文件的路径。 如果必须修改URI，则应使用别名指令。 </p>
<p> Syntax:  <strong>satisfy</strong> all | any ;<br>  Default:  satisfy all;  Context:  http , server , location<br>  如果所有（ all ）或至少一个（ any ） ngx_http_access_module ， ngx_http_auth_basic_module ， ngx_http_auth_request_module或ngx_http_auth_jwt_module模块允许访问，则允许访问。 </p>
<p> 例： </p>
<blockquote>
<p>location / { satisfy any; allow 192.168.1.0/32; deny all; auth_basic “closed site”; auth_basic_user_file conf/htpasswd; }  Syntax:  <strong>send_lowat</strong> <em>size</em> ;<br>  Default:  send_lowat 0;  Context:  http , server , location<br>  如果指令设置为非零值，nginx将尝试通过使用kqueue方法的NOTE_LOWAT标志或SO_SNDLOWAT套接字选项来最小化客户端套接字上的发送操作数。 在这两种情况下都使用指定的<em>size</em> 。 </p>
</blockquote>
<p> 在Linux，Solaris和Windows上忽略此指令。 </p>
<p> Syntax:  <strong>send_timeout</strong> <em>time</em> ;<br>  Default:  send_timeout 60s;  Context:  http , server , location<br>  设置将响应传输到客户端的超时。 仅在两次连续写操作之间设置超时，而不是整个响应的传输。 如果客户端在此时间内未收到任何内容，则会关闭连接。 </p>
<p> Syntax:  <strong>sendfile</strong> on | off ;<br>  Default:  sendfile off;  Context:  http , server , location , if in location<br>  启用或禁用sendfile()的使用。 </p>
<p> 从nginx 0.8.12和FreeBSD 5.2.1开始， aio可用于预加载sendfile()数据： </p>
<blockquote>
<p>location /video/ { sendfile on; tcp_nopush on; aio on; }  在此配置中，使用SF_NODISKIO标志调用sendfile() ，这会导致它不阻塞磁盘I / O，而是报告数据不在内存中。 然后，nginx通过读取一个字节来启动异步数据加载。 在第一次读取时，FreeBSD内核将文件的前128K字节加载到内存中，尽管下一次读取只会以16K块的形式加载数据。 可以使用read_ahead指令更改此设置 。 </p>
<p> 在1.7.11版之前，可以使用aio sendfile;启用预加载aio sendfile; 。  Syntax:  <strong>sendfile_max_chunk</strong> <em>size</em> ;<br>  Default:  sendfile_max_chunk 0;  Context:  http , server , location<br>  设置为非零值时，限制可在单个sendfile()调用中传输的数据量。 没有限制，一个快速连接可能完全占用工作进程。 </p>
</blockquote>
<p> Syntax:  <strong>server</strong> { … }<br>  Default:  —  Context:  http<br>  设置虚拟服务器的配置。 基于IP（基于IP地址）和基于名称（基于“主机”请求标头字段）的虚拟服务器之间没有明确的区别。 相反， listen指令描述了应该接受服务器连接的所有地址和端口， server_name指令列出了所有服务器名称。 “ 如何nginx处理请求 ”文档中提供了示例配置。 </p>
<p> Syntax:  <strong>server_name</strong> <em>name</em> …;<br>  Default:  server_name “”;  Context:  server<br>  设置虚拟服务器的名称，例如： </p>
<blockquote>
<p>server { server_name example.com www.example.com; }  第一个名称成为主服务器名称。 </p>
</blockquote>
<p> 服务器名称可以包含替换名称的第一个或最后一个部分的星号（“ * ”）： </p>
<blockquote>
<p>server { server_name example.com <em>.example.com www.example.</em>; }  这些名称称为通配符名称。 </p>
</blockquote>
<p> 上面提到的前两个名称可以合二为一： </p>
<blockquote>
<p>server { server_name .example.com; }  也可以在服务器名称中使用正则表达式，在名称前面加上波浪号（“ ~ ”）： </p>
<p>server { server_name www.example.com ~^www\d+.example.com$; }  正则表达式可以包含以后可以在其他指令中使用的捕获（0.7.40）： </p>
<p>server { server_name ~^(www.)?(.+)$; location / { root /sites/$2; } } server { server_name _; location / { root /sites/default; } }  正则表达式中的命名捕获创建变量（0.8.25），以后可以在其他指令中使用它们： </p>
<p>server { server_name ~^(www.)?(?<domain>.+)$; location / { root /sites/$domain; } } server { server_name _; location / { root /sites/default; } }  如果指令的参数设置为“ $hostname ”（0.9.4），则插入机器的主机名。 </domain></p>
</blockquote>
<p> 也可以指定一个空的服务器名称（0.7.11）： </p>
<blockquote>
<p>server { server_name www.example.com “”; }  它允许此服务器处理请求而不使用“Host”头字段 - 而不是默认服务器 - 用于给定地址：端口对。 这是默认设置。 </p>
<p> 在0.8.48之前，默认使用机器的主机名。  在按名称搜索虚拟服务器期间，如果名称与多个指定的变体匹配（例如，通配符名称和正则表达式匹配），将按以下优先级顺序选择第一个匹配的变体： </p>
</blockquote>
<ol>
<li>确切的名字 </li>
<li>以星号开头的最长通配符名称，例如“ *.example.com ” </li>
<li>最长的通配符名称以星号结尾，例如“ mail.* ” </li>
<li><p>第一个匹配的正则表达式（按配置文件中的出现顺序）<br>服务器名称的详细描述在单独的服务器名称文档中提供。 </p>
<p>Syntax:  <strong>server_name_in_redirect</strong> on | off ;<br>Default:  server_name_in_redirect off;  Context:  http , server , location<br>在nginx发出的绝对重定向中启用或禁用server_name指令指定的主服务器名称。 禁用主服务器名称时，将使用“主机”请求标头字段中的名称。 如果此字段不存在，则使用服务器的IP地址。 </p>
<p>在重定向中使用端口由port_in_redirect指令控制。 </p>
<p>Syntax:  <strong>server_names_hash_bucket_size</strong> <em>size</em> ;<br>Default:  server_names_hash_bucket_size 32|64|128;  Context:  http<br>设置服务器名称哈希表的存储桶大小。 默认值取决于处理器缓存行的大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p>Syntax:  <strong>server_names_hash_max_size</strong> <em>size</em> ;<br>Default:  server_names_hash_max_size 512;  Context:  http<br>设置服务器名称哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p>Syntax:  <strong>server_tokens</strong> on | off | build | <em>string</em> ;<br>Default:  server_tokens on;  Context:  http , server , location<br>启用或禁用在错误页面和“服务器”响应头字段中发出nginx版本。 </p>
<p>build参数（1.11.10）允许发出构建名称和nginx版本。 </p>
<p>此外，作为商业订阅的一部分，从版本1.9.13开始，错误页面上的签名和“服务器”响应头字段值可以使用带变量的<em>string</em>显式设置。 空字符串禁用“服务器”字段的发射。 </p>
<p>Syntax:  <strong>subrequest_output_buffer_size</strong> <em>size</em> ;<br>Default:  subrequest_output_buffer_size 4k|8k;  Context:  http , server , location<br>该指令出现在1.13.10版本中。 </p>
<p>Sets the <em>size</em> of the buffer used for storing the response body of a subrequest. 默认情况下，缓冲区大小等于一个内存页面。 这是4K或8K，具体取决于平台。 然而，它可以做得更小。 </p>
<p>The directive is applicable only for subrequests with response bodies saved into memory. For example, such subrequests are created by SSI . </p>
<p>Syntax:  <strong>tcp_nodelay</strong> on | off ;<br>Default:  tcp_nodelay on;  Context:  http , server , location<br>启用或禁用TCP_NODELAY选项的使用。 The option is enabled when a connection is transitioned into the keep-alive state. Additionally, it is enabled on SSL connections, for unbuffered proxying, and for WebSocket proxying. </p>
<p>Syntax:  <strong>tcp_nopush</strong> on | off ;<br>Default:  tcp_nopush off;  Context:  http , server , location<br>Enables or disables the use of the TCP_NOPUSH socket option on FreeBSD or the TCP_CORK socket option on Linux. The options are enabled only when sendfile is used. Enabling the option allows </p>
</li>
</ol>
<ul>
<li>sending the response header and the beginning of a file in one packet, on Linux and FreeBSD 4.*; </li>
<li>sending a file in full packets.<br>Syntax:  <strong>try_files</strong> <em>file</em> … <em>uri</em> ;<br><strong>try_files</strong> <em>file</em> … = <em>code</em> ;<br>Default:  —  Context:  server , location<br>Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the <em>file</em> parameter according to the root and alias directives. It is possible to check directory’s existence by specifying a slash at the end of a name, eg “ $uri/ ”. If none of the files were found, an internal redirect to the <em>uri</em> specified in the last parameter is made. 例如： </li>
</ul>
<blockquote>
<p>location /images/ { try_files $uri /images/default.gif; } location = /images/default.gif { expires 30s; }  The last parameter can also point to a named location, as shown in examples below. Starting from version 0.7.51, the last parameter can also be a <em>code</em> : </p>
<p>location / { try_files $uri $uri/index.html $uri.html =404; }  Example in proxying Mongrel: </p>
<p>location / { try_files /system/maintenance.html $uri $uri/index.html $uri.html @mongrel; } location @mongrel { proxy_pass <a href="http://mongrel" target="_blank" rel="noopener">http://mongrel</a>; }  Example for Drupal/FastCGI: </p>
<p>location / { try_files $uri $uri/ @drupal; } location ~ .php$ { try_files $uri @drupal; fastcgi_pass …; fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param QUERY_STRING $args; … other fastcgi_param’s } location @drupal { fastcgi_pass …; fastcgi_param SCRIPT_FILENAME /path/to/index.php; fastcgi_param SCRIPT_NAME /index.php; fastcgi_param QUERY_STRING q=$uri&amp;$args; … other fastcgi_param’s }  In the following example, </p>
<p>location / { try_files $uri $uri/ @drupal; }  the try_files directive is equivalent to </p>
<p>location / { error_page 404 = @drupal; log_not_found off; }  And here, </p>
<p>location ~ .php$ { try_files $uri @drupal; fastcgi_pass …; fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name; … }  try_files checks the existence of the PHP file before passing the request to the FastCGI server. </p>
</blockquote>
<p> Example for Wordpress and Joomla: </p>
<blockquote>
<p>location / { try_files $uri $uri/ @wordpress; } location ~ .php$ { try_files $uri @wordpress; fastcgi_pass …; fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name; … other fastcgi_param’s } location @wordpress { fastcgi_pass …; fastcgi_param SCRIPT_FILENAME /path/to/index.php; … other fastcgi_param’s }  Syntax:  <strong>types</strong> { … }<br>  Default:  types { text/html html; image/gif gif; image/jpeg jpg; }  Context:  http , server , location<br>  Maps file name extensions to MIME types of responses. Extensions are case-insensitive. Several extensions can be mapped to one type, for example: </p>
<p>types { application/octet-stream bin exe dll; application/octet-stream deb; application/octet-stream dmg; }  A sufficiently full mapping table is distributed with nginx in the conf/mime.types file. </p>
</blockquote>
<p> To make a particular location emit the “ application/octet-stream ” MIME type for all requests, the following configuration can be used: </p>
<blockquote>
<p>location /download/ { types { } default_type application/octet-stream; }  Syntax:  <strong>types_hash_bucket_size</strong> <em>size</em> ;<br>  Default:  types_hash_bucket_size 64;  Context:  http , server , location<br>  Sets the bucket size for the types hash tables. 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Prior to version 1.5.13, the default value depended on the size of the processor’s cache line.  Syntax:  <strong>types_hash_max_size</strong> <em>size</em> ;<br>  Default:  types_hash_max_size 1024;  Context:  http , server , location<br>  Sets the maximum <em>size</em> of the types hash tables. 设置哈希表的详细信息在单独的文档中提供。 </p>
</blockquote>
<p> Syntax:  <strong>underscores_in_headers</strong> on | off ;<br>  Default:  underscores_in_headers off;  Context:  http , server<br>  Enables or disables the use of underscores in client request header fields. When the use of underscores is disabled, request header fields whose names contain underscores are marked as invalid and become subject to the ignore_invalid_headers directive. </p>
<p> If the directive is specified on the server level, its value is only used if a server is a default one. The value specified also applies to all virtual servers listening on the same address and port. </p>
<p> Syntax:  <strong>variables_hash_bucket_size</strong> <em>size</em> ;<br>  Default:  variables_hash_bucket_size 64;  Context:  http<br>  设置变量哈希表的桶大小。 设置哈希表的详细信息在单独的文档中提供。 </p>
<p> Syntax:  <strong>variables_hash_max_size</strong> <em>size</em> ;<br>  Default:  variables_hash_max_size 1024;  Context:  http<br>  设置变量哈希表的最大<em>size</em> 。 设置哈希表的详细信息在单独的文档中提供。 </p>
<blockquote>
<p> Prior to version 1.5.13, the default value was 512. ####  嵌入式变量</p>
</blockquote>
<p> The ngx_http_core_module module supports embedded variables with names matching the Apache Server variables. First of all, these are variables representing client request header fields, such as $http_user_agent , $http_cookie , and so on. Also there are other variables: </p>
<p> $arg_ <em>name</em>  argument <em>name</em> in the request line  $args   arguments in the request line  $binary_remote_addr   客户端地址采用二进制形式，值的长度始终为IPv4地址的4个字节或IPv6地址的16个字节  $body_bytes_sent   number of bytes sent to a client, not counting the response header; this variable is compatible with the “ %B ” parameter of the mod_log_config Apache module  $bytes_sent   number of bytes sent to a client (1.3.8, 1.2.5)  $connection   connection serial number (1.3.8, 1.2.5)  $connection_requests   current number of requests made through a connection (1.3.8, 1.2.5)  $content_length   “Content-Length” request header field  $content_type   “Content-Type” request header field  $cookie_ <em>name</em>  the <em>name</em> cookie  $document_root   root or alias directive’s value for the current request  $document_uri   same as $uri  $host   in this order of precedence: host name from the request line, or host name from the “Host” request header field, or the server name matching a request  $hostname   主机名  $http_ <em>name</em>  arbitrary request header field; the last part of a variable name is the field name converted to lower case with dashes replaced by underscores  $https   “ on ” if connection operates in SSL mode, or an empty string otherwise  $is_args   “ ? ” if a request line has arguments, or an empty string otherwise  $limit_rate   setting this variable enables response rate limiting; see limit_rate  $msec   current time in seconds with the milliseconds resolution (1.3.9, 1.2.6)  $nginx_version   nginx版本  $pid   工作进程的PID  $pipe   “ p ”如果请求是流水线的，“ . ” otherwise (1.3.12, 1.2.7)  $proxy_protocol_addr   client address from the PROXY protocol header, or an empty string otherwise (1.5.12)  必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> $proxy_protocol_port   client port from the PROXY protocol header, or an empty string otherwise (1.11.0)  必须先通过在listen指令中设置proxy_protocol参数来启用PROXY协议。 </p>
<p> $query_string   same as $args  $realpath_root   an absolute pathname corresponding to the root or alias directive’s value for the current request, with all symbolic links resolved to real paths  $remote_addr   客户地址  $remote_port   客户端端口  $remote_user   user name supplied with the Basic authentication  $request   full original request line  $request_body   请求机构  The variable’s value is made available in locations processed by the proxy_pass , fastcgi_pass , uwsgi_pass , and scgi_pass directives when the request body was read to a memory buffer . </p>
<p> $request_body_file   name of a temporary file with the request body  At the end of processing, the file needs to be removed. To always write the request body to a file, client_body_in_file_only needs to be enabled. When the name of a temporary file is passed in a proxied request or in a request to a FastCGI/uwsgi/SCGI server, passing the request body should be disabled by the proxy_pass_request_body off , fastcgi_pass_request_body off , uwsgi_pass_request_body off , or scgi_pass_request_body off directives, respectively. </p>
<p> $request_completion   “ OK ” if a request has completed, or an empty string otherwise  $request_filename   file path for the current request, based on the root or alias directives, and the request URI  $request_id   unique request identifier generated from 16 random bytes, in hexadecimal (1.11.0)  $request_length   request length (including request line, header, and request body) (1.3.12, 1.2.7)  $request_method   request method, usually “ GET ” or “ POST ”  $request_time   request processing time in seconds with a milliseconds resolution (1.3.9, 1.2.6); time elapsed since the first bytes were read from the client  $request_uri   full original request URI (with arguments)  $scheme   request scheme, “ http ” or “ https ”  $sent_http_ <em>name</em>  arbitrary response header field; the last part of a variable name is the field name converted to lower case with dashes replaced by underscores  $sent_trailer_ <em>name</em>  arbitrary field sent at the end of the response (1.13.2); the last part of a variable name is the field name converted to lower case with dashes replaced by underscores  $server_addr   an address of the server which accepted a request  计算此变量的值通常需要一次系统调用。 为避免系统调用， listen指令必须指定地址并使用bind参数。 </p>
<p> $server_name   name of the server which accepted a request  $server_port   port of the server which accepted a request  $server_protocol   request protocol, usually “ HTTP/1.0 ”, “ HTTP/1.1 ”, or “ HTTP/2.0 ”  $status   response status (1.3.2, 1.2.2)  $tcpinfo_rtt , $tcpinfo_rttvar , $tcpinfo_snd_cwnd , $tcpinfo_rcv_space  information about the client TCP connection; available on systems that support the TCP_INFO socket option  $time_iso8601   local time in the ISO 8601 standard format (1.3.12, 1.2.7)  $time_local   local time in the Common Log Format (1.3.12, 1.2.7)  $uri   current URI in request, normalized  The value of $uri may change during request processing, eg when doing internal redirects, or when using index files. </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_charset_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_charset_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_charset_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-charset-module"><a href="#Module-ngx-http-charset-module" class="headerlink" title="Module ngx_http_charset_module"></a>Module ngx_http_charset_module</h2><p> Example Configuration<br> Directives<br> charset<br> charset_map<br> charset_types<br> override_charset<br> source_charset<br> ngx_http_charset_module模块将指定的字符集添加到“Content-Type”响应头字段。 此外，该模块可以将数据从一个字符集转换为另一个字符集，但有一些限制： </p>
<ul>
<li>转换是以一种方式执行的 - 从服务器到客户端， </li>
<li>只能转换单字节字符集 </li>
<li>或者来自UTF-8的单字节字符集。 <h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4></li>
</ul>
<blockquote>
<p>include conf/koi-win; charset windows-1251; source_charset koi8-r; ####  指令</p>
</blockquote>
<p> Syntax:  <strong>charset</strong> <em>charset</em> | off ;<br>  Default:  charset off;  Context:  http , server , location , if in location<br>  将指定的charset添加到“Content-Type”响应头字段。 如果此charset与source_charset指令中指定的charset不同，则执行转换。 </p>
<p> 参数off取消将charset添加到“Content-Type”响应头字段。 </p>
<p> 可以使用变量定义charset： </p>
<blockquote>
<p>charset $charset;  在这种情况下，变量的所有可能值需要以charset_map ， charset或source_charset指令的形式存在于配置中至少一次。 对于utf-8 ， windows-1251和koi8-r charsets，将文件conf/koi-win ， conf/koi-utf和conf/win-utf包含在conf/koi-win就足够了。 对于其他字符集，只需制作虚构的转换表即可，例如： </p>
<p>charset_map iso-8859-5 _ { }  此外，可以在“X-Accel-Charset”响应头字段中设置字符集。 可以使用proxy_ignore_headers ， fastcgi_ignore_headers ， uwsgi_ignore_headers ， scgi_ignore_headers和grpc_ignore_headers指令禁用此功能。 </p>
</blockquote>
<p> Syntax:  <strong>charset_map</strong> <em>charset1</em> <em>charset2</em> { … }<br>  Default:  —  Context:  http<br>  描述从一个字符集到另一个字符集的转换表。 使用相同的数据构建反向转换表。 字符代码以十六进制给出。 80-FF范围内的缺失字符被替换为“ ? ”。 从UTF-8转换时，单字节字符集中缺少的字符将替换为“ &#XXXX; ”。 </p>
<p> 例： </p>
<blockquote>
<p>charset_map koi8-r windows-1251 { C0 FE ; # small yu C1 E0 ; # small a C2 E1 ; # small b C3 F6 ; # small ts … }  在将转换表描述为UTF-8时，应在第二列中给出UTF-8字符集的代码，例如： </p>
<p>charset_map koi8-r utf-8 { C0 D18E ; # small yu C1 D0B0 ; # small a C2 D0B1 ; # small b C3 D186 ; # small ts … }  在分配文件conf/koi-win ， conf/koi-utf和conf/win-utf中提供了从koi8-r到windows-1251 ，从koi8-r和windows-1251到utf-8完整转换表。 </p>
</blockquote>
<p> Syntax:  <strong>charset_types</strong> <em>mime-type</em> …;<br>  Default:  charset_types text/html text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml;  Context:  http , server , location<br>  该指令出现在0.7.9版本中。 </p>
<p> 除了“ text/html ”之外，还可以在具有指定MIME类型的响应中启用模块处理。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 </p>
<blockquote>
<p> 在版本1.5.4之前，“ application/x-javascript ”被用作默认MIME类型而不是“ application/javascript ”。  Syntax:  <strong>override_charset</strong> on | off ;<br>  Default:  override_charset off;  Context:  http , server , location , if in location<br>  确定当答案已在“Content-Type”响应头字段中携带字符集时，是否应对从代理或FastCGI / uwsgi / SCGI / gRPC服务器接收的答案执行转换。 如果启用了转换，则将接收到的响应中指定的字符集用作源字符集。 </p>
<p> 应当注意，如果在子请求中接收到响应，则始终执行从响应字符集到主请求字符集的转换，而不管override_charset指令设置如何。  Syntax:  <strong>source_charset</strong> <em>charset</em> ;<br>  Default:  —  Context:  http , server , location , if in location<br>  定义响应的源字符集。 如果此charset与charset指令中指定的charset不同，则执行转换。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_browser_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_browser_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_browser_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-browser-module"><a href="#Module-ngx-http-browser-module" class="headerlink" title="Module ngx_http_browser_module"></a>Module ngx_http_browser_module</h2><p> Example Configuration<br> Directives<br> ancient_browser<br> ancient_browser_value<br> modern_browser<br> modern_browser_value<br> ngx_http_browser_module模块创建的变量的值取决于“User-Agent”请求标头字段的值： </p>
<p> $modern_browser   如果浏览器被识别为现代，则等于modern_browser_value指令设置的值;  $ancient_browser   如果浏览器被识别为古代，则等于ancient_browser_value指令设置的值;  $msie   如果浏览器被识别为任何版本的MSIE，则等于“1”。 ####  示例配置</p>
<p> 选择索引文件： </p>
<blockquote>
<p>modern_browser_value “modern.”; modern_browser msie 5.5; modern_browser gecko 1.0.0; modern_browser opera 9.0; modern_browser safari 413; modern_browser konqueror 3.0; index index.${modern_browser}html index.html;  旧浏览器的重定向： </p>
<p>modern_browser msie 5.0; modern_browser gecko 0.9.1; modern_browser opera 8.0; modern_browser safari 413; modern_browser konqueror 3.0; modern_browser unlisted; ancient_browser Links Lynx netscape4; if ($ancient_browser) { rewrite ^ /ancient.html; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>ancient_browser</strong> <em>string</em> …;<br>  Default:  —  Context:  http , server , location<br>  如果在“User-Agent”请求标头字段中找到任何指定的子字符串，则浏览器将被视为古代。 特殊字符串“ netscape4 ”对应于正则表达式“ ^Mozilla/[1-4] ”。 </p>
<p> Syntax:  <strong>ancient_browser_value</strong> <em>string</em> ;<br>  Default:  ancient_browser_value 1;  Context:  http , server , location<br>  设置$ancient_browser变量的值。 </p>
<p> Syntax:  <strong>modern_browser</strong> <em>browser</em> <em>version</em> ;<br> <strong>modern_browser</strong> unlisted ;<br>  Default:  —  Context:  http , server , location<br>  指定从中将浏览器视为现代的版本。 浏览器可以是以下任何一种： msie ， gecko （基于Mozilla的浏览器）， opera ， safari或konqueror 。 </p>
<p> 可以使用以下格式指定版本：X，XX，XXX或XXXX每种格式的最大值分别为4000,4000.99,4000.99.99和4000.99.99.99。 </p>
<p> unlisted的特殊值指定将浏览器视为现代浏览器，如果它未被modern_browser和ancient_browser指令列出。 否则这样的浏览器被认为是古老的。 如果请求未在标头中提供“User-Agent”字段，则将浏览器视为未列出。 </p>
<p> Syntax:  <strong>modern_browser_value</strong> <em>string</em> ;<br>  Default:  modern_browser_value 1;  Context:  http , server , location<br>  设置$modern_browser变量的值。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_autoindex_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_autoindex_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_autoindex_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-autoindex-module"><a href="#Module-ngx-http-autoindex-module" class="headerlink" title="Module ngx_http_autoindex_module"></a>Module ngx_http_autoindex_module</h2><p> Example Configuration<br> Directives<br> autoindex<br> autoindex_exact_size<br> autoindex_format<br> autoindex_localtime<br> ngx_http_autoindex_module模块处理以斜杠字符（’ / ‘）结尾的请求，并生成目录列表。 当ngx_http_index_module模块找不到索引文件时，通常ngx_http_autoindex_module请求传递给ngx_http_autoindex_module模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { autoindex on; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>autoindex</strong> on | off ;<br>  Default:  autoindex off;  Context:  http , server , location<br>  启用或禁用目录列表输出。 </p>
<p> Syntax:  <strong>autoindex_exact_size</strong> on | off ;<br>  Default:  autoindex_exact_size on;  Context:  http , server , location<br>  对于HTML 格式 ，指定是否应在目录列表中输出确切的文件大小，或者更确切地舍入为千字节，兆字节和千兆字节。 </p>
<p> Syntax:  <strong>autoindex_format</strong> html | xml | json | jsonp ;<br>  Default:  autoindex_format html;  Context:  http , server , location<br>  该指令出现在1.7.9版本中。 </p>
<p> 设置目录列表的格式。 </p>
<p> 使用JSONP格式时，使用callback请求参数设置回调函数的名称。 如果参数缺失或具有空值，则使用JSON格式。 </p>
<p> 可以使用ngx_http_xslt_module模块转换XML输出。 </p>
<p> Syntax:  <strong>autoindex_localtime</strong> on | off ;<br>  Default:  autoindex_localtime off;  Context:  http , server , location<br>  对于HTML 格式 ，指定目录列表中的时间是应以本地时区还是UTC输出。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_request_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_request_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_request_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-request-module"><a href="#Module-ngx-http-auth-request-module" class="headerlink" title="Module ngx_http_auth_request_module"></a>Module ngx_http_auth_request_module</h2><p> Example Configuration<br> Directives<br> auth_request<br> auth_request_set<br> ngx_http_auth_request_module模块（1.5.4+）基于子请求的结果实现客户端授权。 如果子请求返回2xx响应代码，则允许访问。 如果它返回401或403，则拒绝访问，并显示相应的错误代码。 子请求返回的任何其他响应代码都被视为错误。 </p>
<p> 对于401错误，客户端还从子请求响应中接收“WWW-Authenticate”头。 </p>
<p> 默认情况下不构建此模块，应使用–with-http_auth_request_module配置参数启用它。 </p>
<p> 该模块可以通过满足指令与其他访问模块组合，例如ngx_http_access_module ， ngx_http_auth_basic_module和ngx_http_auth_jwt_module 。 </p>
<blockquote>
<p> 在1.7.3版之前，无法缓存对授权子请求的响应（使用proxy_cache ， proxy_store等）。 ####  示例配置</p>
<p>location /private/ { auth_request /auth; … } location = /auth { proxy_pass … proxy_pass_request_body off; proxy_set_header Content-Length “”; proxy_set_header X-Original-URI $request_uri; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>auth_request</strong> <em>uri</em> | off ;<br>  Default:  auth_request off;  Context:  http , server , location<br>  根据子请求的结果启用授权，并设置子请求将发送到的URI。 </p>
<p> Syntax:  <strong>auth_request_set</strong> <em>$variable</em> <em>value</em> ;<br>  Default:  —  Context:  http , server , location<br>  授权请求完成后，将请求<em>variable</em>设置为给定<em>value</em> 。 该值可能包含授权请求中的变量，例如$upstream_http_* 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_jwt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_jwt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_jwt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-jwt-module"><a href="#Module-ngx-http-auth-jwt-module" class="headerlink" title="Module ngx_http_auth_jwt_module"></a>Module ngx_http_auth_jwt_module</h2><p> Example Configuration<br> Directives<br> auth_jwt<br> auth_jwt_claim_set<br> auth_jwt_header_set<br> auth_jwt_key_file<br> auth_jwt_key_request<br> auth_jwt_leeway<br> Embedded Variables<br> ngx_http_auth_jwt_module模块（1.11.3）通过使用指定的密钥验证提供的JSON Web令牌 （JWT）来实现客户端授权。 JWT声明必须以JSON Web签名 （JWS）结构进行编码。 该模块可用于OpenID Connect身份验证。 </p>
<p> 该模块可以通过满足指令与其他访问模块组合，例如ngx_http_access_module ， ngx_http_auth_basic_module和ngx_http_auth_request_module 。 </p>
<p> 该模块支持以下加密算法 ： </p>
<ul>
<li>HS256，HS384，HS512 </li>
<li>RS256，RS384，RS512 </li>
<li>ES256，ES384，ES512 </li>
<li>EdDSA（Ed25519和Ed448签名）（1.15.7）<br>在1.13.7版之前，仅支持HS256，RS256，ES256算法。 </li>
</ul>
<blockquote>
<p> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>location / { auth_jwt “closed site”; auth_jwt_key_file conf/keys.json; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>auth_jwt</strong> <em>string</em> [ token= <em>$variable</em> ] | off ;<br>  Default:  auth_jwt off;  Context:  http , server , location , limit_except<br>  启用JSON Web Token的验证。 指定的<em>string</em>用作域。 参数值可以包含变量。 </p>
<p> 可选的token参数指定包含JSON Web Token的变量。 默认情况下，JWT作为承载令牌在“授权”标头中传递。 JWT也可以作为cookie或查询字符串的一部分传递： </p>
<blockquote>
<p>auth_jwt “closed site” token=$cookie_auth_token;  特殊值off取消了从先前配置级别继承的auth_jwt伪指令的效果。 </p>
</blockquote>
<p> Syntax:  <strong>auth_jwt_claim_set</strong> <em>$variable</em> <em>name</em> …;<br>  Default:  —  Context:  http<br>  该指令出现在1.11.10版中。 </p>
<p> 将<em>variable</em>设置为由键名标识的JWT声明参数。 名称匹配从JSON树的顶级开始。 对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<blockquote>
<p>location / { auth_jwt “closed site”; auth_jwt_key_file conf/keys.json; auth_jwt_claim_set $email info e-mail; auth_jwt_claim_set $job info “job title”; }<br> 在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。  Syntax:  <strong>auth_jwt_header_set</strong> <em>$variable</em> <em>name</em> …;<br>  Default:  —  Context:  http<br>  该指令出现在1.11.10版中。 </p>
</blockquote>
<p> 将<em>variable</em>设置为由键名标识的JOSE标头参数。 名称匹配从JSON树的顶级开始。 对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<blockquote>
<p> 在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。  Syntax:  <strong>auth_jwt_key_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location , limit_except<br>  指定JSON Web Key Set格式的<em>file</em> ，用于验证JWT签名。 参数值可以包含变量。 </p>
</blockquote>
<p> Syntax:  <strong>auth_jwt_key_request</strong> <em>uri</em> ;<br>  Default:  —  Context:  http , server , location , limit_except<br>  该指令出现在1.15.6版中。 </p>
<p> 允许从子请求中检索JSON Web Key Set文件以验证JWT签名，并设置子请求将发送到的URI。 为避免验证开销，建议缓存密钥文件： </p>
<blockquote>
<p>proxy_cache_path /data/nginx/cache levels=1 keys_zone=foo:10m; server { … location / { auth_jwt “closed site”; auth_jwt_key_request /jwks_uri; } location = /jwks_uri { internal; proxy_cache foo; proxy_pass <a href="http://idp.example.com/keys" target="_blank" rel="noopener">http://idp.example.com/keys</a>; } }  Syntax:  <strong>auth_jwt_leeway</strong> <em>time</em> ;<br>  Default:  auth_jwt_leeway 0s;  Context:  http , server , location<br>  该指令出现在1.13.10版本中。 </p>
</blockquote>
<p> 设置最大允许余地，以在验证exp和nbf JWT声明时补偿时钟偏差。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> ngx_http_auth_jwt_module模块支持嵌入变量： </p>
<p> $jwt_header_ <em>name</em>  返回指定JOSE标头的值  $jwt_claim_ <em>name</em>  返回指定JWT声明的值  </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_basic_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_basic_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_basic_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-basic-module"><a href="#Module-ngx-http-auth-basic-module" class="headerlink" title="Module ngx_http_auth_basic_module"></a>Module ngx_http_auth_basic_module</h2><p> Example Configuration<br> Directives<br> auth_basic<br> auth_basic_user_file<br> ngx_http_auth_basic_module模块允许通过使用“HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。 </p>
<p> 访问也可以通过地址 ， 子请求的结果或JWT来限制 。 通过地址和密码同时限制访问由satisf指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { auth_basic “closed site”; auth_basic_user_file conf/htpasswd; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>auth_basic</strong> <em>string</em> | off ;<br>  Default:  auth_basic off;  Context:  http , server , location , limit_except<br>  使用“HTTP基本身份验证”协议启用用户名和密码验证。 指定的参数用作域。 参数值可以包含变量（1.3.10,1.2.7）。 特殊值off允许取消从先前配置级别继承的auth_basic伪指令的效果。 </p>
<p> Syntax:  <strong>auth_basic_user_file</strong> <em>file</em> ;<br>  Default:  —  Context:  http , server , location , limit_except<br>  指定保存用户名和密码的文件，格式如下： </p>
<blockquote>
<h1 id="comment-name1-password1-name2-password2-comment-name3-password3-file名可以包含变量。"><a href="#comment-name1-password1-name2-password2-comment-name3-password3-file名可以包含变量。" class="headerlink" title="comment name1:password1 name2:password2:comment name3:password3  file名可以包含变量。"></a>comment name1:password1 name2:password2:comment name3:password3  <em>file</em>名可以包含变量。</h1></blockquote>
<p> 支持以下密码类型： </p>
<ul>
<li>用crypt()函数加密; 可以使用Apache HTTP Server分发中的“ htpasswd ”实用程序或“ openssl passwd ”命令生成; </li>
<li>使用基于MD5的密码算法（apr1）的Apache变体进行散列; 可以使用相同的工具生成; </li>
<li>由RFC 2307中描述的“ { <em>scheme</em> } <em>data</em> ”语法（1.0.3+）指定; 目前实现的方案包括PLAIN （不应使用示例一）， SHA （1.3.13）（不应使用普通SHA-1哈希）和SSHA （盐渍SHA-1哈希，一些软件包使用，特别是OpenLDAP和Dovecot）。 <blockquote>
<p> 仅添加了对SHA方案的支持，以帮助从其他Web服务器迁移。 它不应该用于新密码，因为它使用的无盐SHA-1散列很容易受到彩虹表攻击。 </p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_api_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_api_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_api_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-api-module"><a href="#Module-ngx-http-api-module" class="headerlink" title="Module ngx_http_api_module"></a>Module ngx_http_api_module</h2><p> Example Configuration<br> Directives<br> api<br> status_zone<br> Compatibility<br> Endpoints<br> /<br> /nginx<br> /processes<br> /connections<br> /ssl<br> /slabs/<br> /slabs/{slabZoneName}<br> /http/<br> /http/requests<br> /http/server_zones/<br> /http/server_zones/{httpServerZoneName}<br> /http/caches/<br> /http/caches/{httpCacheZoneName}<br> /http/upstreams/<br> /http/upstreams/{httpUpstreamName}/<br> /http/upstreams/{httpUpstreamName}/servers/<br> /http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}<br> /http/keyvals/<br> /http/keyvals/{httpKeyvalZoneName}<br> /stream/<br> /stream/server_zones/<br> /stream/server_zones/{streamServerZoneName}<br> /stream/upstreams/<br> /stream/upstreams/{streamUpstreamName}/<br> /stream/upstreams/{streamUpstreamName}/servers/<br> /stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}<br> /stream/keyvals/<br> /stream/keyvals/{streamKeyvalZoneName}<br> /stream/zone_sync/<br> Response Objects<br> ngx_http_api_module模块（1.13.3）提供REST API，用于访问各种状态信息，即时配置上游服务器组以及管理键值对，而无需重新配置nginx。 </p>
<blockquote>
<p> 该模块取代了ngx_http_status_module和ngx_http_upstream_conf_module模块。<br> 该模块作为我们商业订阅的一部分提供。 ####  示例配置</p>
<p>http { upstream backend { zone http_backend 64k; server backend1.example.com weight=5; server backend2.example.com; } proxy_cache_path /data/nginx/cache_backend keys_zone=cache_backend:10m; server { server_name backend.example.com; location / { proxy_pass <a href="http://backend" target="_blank" rel="noopener">http://backend</a>; proxy_cache cache_backend; health_check; } status_zone server_backend; } keyval_zone zone=one:32k state=one.keyval; keyval $arg_text $text zone=one; server { listen 127.0.0.1; location /api { <strong>api</strong> write=on; allow 127.0.0.1; deny all; } } } stream { upstream backend { zone stream_backend 64k; server backend1.example.com:12345 weight=5; server backend2.example.com:12345; } server { listen 127.0.0.1:12345; proxy_pass backend; status_zone server_backend; health_check; } }  所有API请求都包含URI中支持的API 版本 。 使用此配置的API请求示例： </p>
<p><a href="http://127.0.0.1/api/3/" target="_blank" rel="noopener">http://127.0.0.1/api/3/</a> <a href="http://127.0.0.1/api/3/nginx" target="_blank" rel="noopener">http://127.0.0.1/api/3/nginx</a> <a href="http://127.0.0.1/api/3/connections" target="_blank" rel="noopener">http://127.0.0.1/api/3/connections</a> <a href="http://127.0.0.1/api/3/http/requests" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/requests</a> <a href="http://127.0.0.1/api/3/http/server\_zones/server\_backend" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/server\_zones/server\_backend</a> <a href="http://127.0.0.1/api/3/http/caches/cache\_backend" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/caches/cache\_backend</a> <a href="http://127.0.0.1/api/3/http/upstreams/backend" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/upstreams/backend</a> <a href="http://127.0.0.1/api/3/http/upstreams/backend/servers/" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/upstreams/backend/servers/</a> <a href="http://127.0.0.1/api/3/http/upstreams/backend/servers/1" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/upstreams/backend/servers/1</a> <a href="http://127.0.0.1/api/3/http/keyvals/one?key=arg1" target="_blank" rel="noopener">http://127.0.0.1/api/3/http/keyvals/one?key=arg1</a> <a href="http://127.0.0.1/api/3/stream/" target="_blank" rel="noopener">http://127.0.0.1/api/3/stream/</a> <a href="http://127.0.0.1/api/3/stream/server\_zones/server\_backend" target="_blank" rel="noopener">http://127.0.0.1/api/3/stream/server\_zones/server\_backend</a> <a href="http://127.0.0.1/api/3/stream/upstreams/" target="_blank" rel="noopener">http://127.0.0.1/api/3/stream/upstreams/</a> <a href="http://127.0.0.1/api/3/stream/upstreams/backend" target="_blank" rel="noopener">http://127.0.0.1/api/3/stream/upstreams/backend</a> <a href="http://127.0.0.1/api/3/stream/upstreams/backend/servers/1" target="_blank" rel="noopener">http://127.0.0.1/api/3/stream/upstreams/backend/servers/1</a> ####  指令</p>
</blockquote>
<p> Syntax:  <strong>api</strong> [ write = on | off ];<br>  Default:  —  Context:  location<br>  打开周围位置的REST API接口。 应限制访问此位置。 </p>
<p> write参数确定API是只读还是读写。 默认情况下，API是只读的。 </p>
<p> 所有API请求都应在URI中包含受支持的API版本。 如果请求URI等于位置前缀，则返回支持的API版本列表。 当前的API版本为“ 3 ”。 </p>
<p> 请求行中的可选“ fields ”参数指定将输出所请求对象的哪些字段： </p>
<blockquote>
<p><a href="http://127.0.0.1/api/3/nginx?fields=version,build" target="_blank" rel="noopener">http://127.0.0.1/api/3/nginx?fields=version,build</a>  Syntax:  <strong>status_zone</strong> <em>zone</em> ;<br>  Default:  —  Context:  server<br>  该指令出现在1.13.12版中。 </p>
</blockquote>
<p> 允许在指定<em>zone</em>收集虚拟http或流服务器状态信息。 多个服务器可能共享同一个区域。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>/ stream / zone_sync / data在版本 3中添加。 </li>
<li>版本 2中添加了drain参数。 </li>
<li><p>/ stream / keyvals / data在版本 2中添加。 </p>
<h4 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h4><p>/   支持的方法： </p>
</li>
<li><p>GET - 返回根端点列表  返回根端点列表。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回一个字符串数组 
</code></pre><p> /nginx   支持的方法： </p>
<ul>
<li><p>GET - 返回nginx运行实例的状态  返回nginx版本，构建名称，地址，配置重新加载次数，主进程和工作进程的ID。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出运行实例的nginx字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回nginx 
</code></pre><p> /processes   支持的方法： </p>
<ul>
<li><p>GET - 返回nginx进程状态  返回异常终止和重生的子进程的数量。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，退货流程 
</code></pre><ul>
<li><p>DELETE - 重置nginx处理统计信息  重置异常终止和重生的子进程的计数器。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
</code></pre><p> /connections   支持的方法： </p>
<ul>
<li><p>GET - 返回客户端连接统计信息  返回客户端连接的统计信息 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出连接统计信息的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回连接 
</code></pre><ul>
<li><p>DELETE - 重置客户端连接统计信息  重置已接受和已删除客户端连接的统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
</code></pre><p> /ssl   支持的方法： </p>
<ul>
<li><p>GET - 返回SSL统计信息  返回SSL统计信息。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出SSL统计信息的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回SSL 
</code></pre><ul>
<li><p>DELETE - 重置SSL统计信息  重置SSL握手和会话重用的计数器。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
</code></pre><p> /slabs/   支持的方法： </p>
<ul>
<li><p>GET - 所有楼板的返回状态  使用slab分配器返回每个共享内存区域的slab状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出板区域的哪些区域。 如果“ fields ”值为空，则仅输出区域名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有楼板的“ 带有slab分配器的共享内存区域 ”对象的集合 
</code></pre><p> /slabs/{slabZoneName}   所有方法通用的参数：  slabZoneName （ string ，必填）  带有slab分配器的共享内存区域的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回板的状态  使用slab分配器返回特定共享内存区域的slab状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出板区域的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回带有slab分配器的共享内存区域 
+  404 - 未找到平板（ SlabNotFound ），返回错误 
</code></pre><ul>
<li><p>DELETE - 重置slab统计信息  重置每个内存插槽的“ reqs ”和“ reqs ”指标。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 未找到平板（ SlabNotFound ），返回错误 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/   支持的方法： </p>
<ul>
<li><p>GET - 返回与HTTP相关的端点列表  返回第一级HTTP端点的列表。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回一个字符串数组 
</code></pre><p> /http/requests   支持的方法： </p>
<ul>
<li><p>GET - 返回HTTP请求统计信息  返回客户端HTTP请求的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出客户端HTTP请求统计信息的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP请求 
</code></pre><ul>
<li><p>DELETE - 重置HTTP请求统计信息  重置客户端HTTP请求总数。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/server_zones/   支持的方法： </p>
<ul>
<li><p>GET - 返回所有HTTP服务器区域的状态  返回每个HTTP 服务器区域的状态信息。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出服务器区域的哪些字段。 如果“ fields ”值为空，则仅输出服务器区域名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有http服务器区域的“ HTTP服务器区域 ”对象的集合 
</code></pre><p> /http/server_zones/{httpServerZoneName}   所有方法通用的参数：  httpServerZoneName （ string ，必填）  HTTP服务器区域的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回HTTP服务器区域的状态  返回特定HTTP服务器区域的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出服务器区域的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP服务器区域 
+  404 - 找不到服务器区域（ ServerZoneNotFound ），返回错误 
</code></pre><ul>
<li><p>DELETE - 重置HTTP服务器区域的统计信息  重置特定HTTP服务器区域中接受和丢弃的请求，响应，接收和发送字节的统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 找不到服务器区域（ ServerZoneNotFound ），返回错误 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/caches/   支持的方法： </p>
<ul>
<li><p>GET - 返回所有缓存的状态  返回由proxy_cache_path和其他“ *_cache_path ”指令配置的每个缓存的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出缓存区域的哪些字段。 如果“ fields ”值为空，则仅输出缓存区的名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有http缓存的“ HTTP缓存 ”对象集合 
</code></pre><p> /http/caches/{httpCacheZoneName}   所有方法通用的参数：  httpCacheZoneName （ string ，必填）  缓存区的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回缓存的状态  返回特定缓存的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出缓存区的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP缓存 
+  404 - 未找到缓存（ CacheNotFound ），返回Error 
</code></pre><ul>
<li><p>DELETE - 重置缓存统计信息  重置特定缓存区域中缓存命中/未命中的统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 未找到缓存（ CacheNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/upstreams/   支持的方法： </p>
<ul>
<li><p>GET - 返回所有HTTP上游服务器组的状态  返回每个HTTP上游服务器组及其服务器的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出上游服务器组的哪些字段。 如果“ fields ”值为空，则仅输出上游的名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - Success，返回所有http上游的“ HTTP Upstream ”对象集合 
</code></pre><p> /http/upstreams/{httpUpstreamName}/   所有方法通用的参数：  httpUpstreamName （ string ，必填）  HTTP上游服务器组的名称。  支持的方法： </p>
<ul>
<li><p>GET - HTTP上游服务器组的返回状态  返回特定HTTP上游服务器组及其服务器的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出上游服务器组的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP上游 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 找不到UpstreamNotFound （ UpstreamNotFound ），返回Error 
</code></pre><ul>
<li><p>DELETE - 重置HTTP上游服务器组的统计信息  重置上游服务器组中每个上游服务器的统计信息和队列统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 找不到UpstreamNotFound （ UpstreamNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/upstreams/{httpUpstreamName}/servers/   所有方法通用的参数：  httpUpstreamName （ string ，必填）  上游服务器组的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回HTTP上游服务器组中所有服务器的配置  返回特定HTTP上游服务器组中每个服务器的配置。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP上游服务器阵列 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 找不到UpstreamNotFound （ UpstreamNotFound ），返回Error 
</code></pre><ul>
<li><p>POST - 将服务器添加到HTTP上游服务器组  将新服务器添加到HTTP上游服务器组。 服务器参数以JSON格式指定。 </p>
<p>请求参数： </p>
<p>postHttpUpstreamServer （ HTTP上游服务器 ，必需）  JSON格式的新服务器和其他可选参数的地址。 无法更改“ ID ”，“ backup ”和“ service ”参数。  可能的回应： </p>
</li>
</ul>
<pre><code>+  201 - 创建，返回HTTP上游服务器 
+  400 - 上游是静态的（ UpstreamStatic ），无效的“ *parameter* ”值（ UpstreamConfFormatError ），缺少“ server ”参数（ UpstreamConfFormatError ），未知参数“ *name* ”（ UpstreamConfFormatError ），嵌套对象或列表（ UpstreamConfFormatError ），解析时error “ error ”（ UpstreamBadAddress ），服务上游“ host ”可能没有端口（ UpstreamBadAddress ），服务上游“ host ”需要域名（ UpstreamBadAddress ），无效“ weight ”（ UpstreamBadWeight ），无效“ max\_conns ”（ UpstreamBadMaxConns ），无效“ max\_fails ”（ UpstreamBadMaxFails ），无效“ fail\_timeout ”（ UpstreamBadFailTimeout ），无效“ slow\_start ”（ UpstreamBadSlowStart ），路径太长（ UpstreamBadRoute ），“ service ”为空（ UpstreamBadService ），没有解析定义解析（ UpstreamConfNoResolver ），上游“ *name* ”没有备份（ UpstreamNoBackup ），上游“ *name* ”内存耗尽（ UpstreamOutOfMemory UpstreamOutOfMemory ），返回错误 
+  404 - 找不到UpstreamNotFound （ UpstreamNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><p> /http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}   所有方法通用的参数：  httpUpstreamName （ string ，必填）  上游服务器组的名称。  httpUpstreamServerId （ string ，必填）  服务器的ID。  支持的方法： </p>
<ul>
<li><p>GET - 返回HTTP上游服务器组中服务器的配置  返回HTTP上游服务器组中特定服务器的配置。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP上游服务器 
+  400 - Upstream是静态的（ UpstreamStatic ），无效的服务器ID（ UpstreamBadServerId ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ），返回Error 
</code></pre><ul>
<li><p>PATCH - 修改HTTP上游服务器组中的服务器  修改HTTP上游服务器组中特定服务器的设置。 服务器参数以JSON格式指定。 </p>
<p>请求参数： </p>
<p>patchHttpUpstreamServer （ HTTP上游服务器 ，必需）  服务器参数，以JSON格式指定。 无法更改“ ID ”，“ backup ”和“ service ”参数。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP上游服务器 
+  400 - 上游是静态的（ UpstreamStatic ），无效的“ *parameter* ”值（ UpstreamConfFormatError ），未知参数“ *name* ”（ UpstreamConfFormatError ），嵌套对象或列表（ UpstreamConfFormatError ），解析时的“ error ”（ UpstreamBadAddress ），无效的“ server ”参数（ UpstreamBadAddress ），无效的服务器ID（ UpstreamBadServerId ），无效的“ weight ”（ UpstreamBadWeight ），无效的“ max\_conns ”（ UpstreamBadMaxConns ），无效的“ max\_fails ”（ UpstreamBadMaxFails ），无效的“ fail\_timeout ”（ UpstreamBadFailTimeout ），无效的“ slow\_start ”（ UpstreamBadSlowStart ），路由太长（ UpstreamBadRoute ），“ service ”为空（ UpstreamBadService ），服务器“ *ID* ”地址是不可变的（ UpstreamServerImmutable ），服务器“ ID ”权重是不可变的（ UpstreamServerWeightImmutable ），上游“ name ”内存耗尽（ UpstreamOutOfMemory ），返回错误 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>DELETE - 从HTTP上游服务器组中删除服务器  从HTTP上游服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP上游服务器阵列 
+  400 - Upstream是静态的（ UpstreamStatic ），无效的服务器ID（ UpstreamBadServerId ），服务器“ *id* ”不可移动（ UpstreamServerImmutable ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /http/keyvals/   支持的方法： </p>
<ul>
<li><p>GET - 从所有HTTP keyval区域返回键值对  返回每个HTTP keyval共享内存区域的键值对。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  如果“ fields ”值为空，则仅输出HTTP keyval区域名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有http密钥的“ HTTP Keyval共享内存区域 ”对象的集合 
</code></pre><p> /http/keyvals/{httpKeyvalZoneName}   所有方法通用的参数：  httpKeyvalZoneName （ string ，必填）  HTTP keyval共享内存区域的名称。  支持的方法： </p>
<ul>
<li><p>GET - 从HTTP键区域返回键值对  返回存储在特定HTTP keyval共享内存区域中的键值对。 </p>
<p>请求参数： </p>
<p>key （ string ，可选）  从HTTP keyval区域获取特定的键值对。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回HTTP Keyval共享内存区域 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未找到keyval键（ KeyvalKeyNotFound ），返回Error 
</code></pre><ul>
<li><p>POST - 将键值对添加到HTTP键值区域  向HTTP keyval共享内存区域添加新的键值对。 如果HTTP keyval共享内存区域为空，则可以输入多个键值对。 </p>
<p>请求参数： </p>
<p>Key-value （ HTTP Keyval共享内存区域 ，必需）  键值对以JSON格式指定。 如果HTTP keyval共享内存区域为空，则可以输入多个键值对。  可能的回应： </p>
</li>
</ul>
<pre><code>+  201 - 创建 
+  400 - 需要密钥（ KeyvalFormatError ），只能添加一个密钥（ KeyvalFormatError ），嵌套对象或列表（ KeyvalFormatError ），返回Error 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  409 - 密钥已存在（ KeyvalKeyExists ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>PATCH - 修改键值或删除键  更改键值对中所选键的值，或通过将键值设置为null来删除键。 </p>
<p>请求参数： </p>
<p>httpKeyvalZoneKeyValue （ HTTP Keyval共享内存区域 ，必需）  密钥的新值以JSON格式指定。  可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  400 - 需要密钥（ KeyvalFormatError ），只能更新一个密钥（ KeyvalFormatError ），嵌套对象或列表（ KeyvalFormatError ），返回Error 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未找到keyval键（ KeyvalKeyNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>DELETE - 清空HTTP keyval区域  从HTTP keyval共享内存区域中删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /stream/   支持的方法： </p>
<ul>
<li><p>GET - 返回与流相关的端点列表  返回第一级流端点的列表。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回一个字符串数组 
</code></pre><p> /stream/server_zones/   支持的方法： </p>
<ul>
<li><p>GET - 返回所有流服务器区域的状态  返回每个流服务器区域的状态信息。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出服务器区域的哪些字段。 如果“ fields ”值为空，则仅输出服务器区域名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有流服务器区域的“ Stream Server Zone ”对象集合 
+  404 - 未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><p> /stream/server_zones/{streamServerZoneName}   所有方法通用的参数：  streamServerZoneName （ string ，必填）  流服务器区域的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回流服务器区域的状态  返回特定流服务器区域的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出服务器区域的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Server Zone 
+  404 - 未找到服务器区域（ ServerZoneNotFound ），未配置流 （ StreamNotConfigured ），返回错误 
</code></pre><ul>
<li><p>DELETE - 重置流服务器区域的统计信息  重置特定流服务器区域中接受和丢弃的连接，会话，接收和发送字节的统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 未找到服务器区域（ ServerZoneNotFound ），未配置流 （ StreamNotConfigured ），返回错误 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /stream/upstreams/   支持的方法： </p>
<ul>
<li><p>GET - 返回所有流上游服务器组的状态  返回每个流上游服务器组及其服务器的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出上游服务器组的哪些字段。 如果“ fields ”值为空，则仅输出上游的名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，为所有流上游返回“ Stream Upstream ”对象的集合 
+  404 - 未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><p> /stream/upstreams/{streamUpstreamName}/   所有方法通用的参数：  streamUpstreamName （ string ，必填）  流上游服务器组的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回流上游服务器组的状态  返回特定流上游服务器组及其服务器的状态。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  限制将输出上游服务器组的哪些字段。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Upstream 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><ul>
<li><p>DELETE - 重置流上游服务器组的统计信息  重置上游服务器组中每个上游服务器的统计信息。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /stream/upstreams/{streamUpstreamName}/servers/   所有方法通用的参数：  streamUpstreamName （ string ，必填）  上游服务器组的名称。  支持的方法： </p>
<ul>
<li><p>GET - 返回流上游服务器组中所有服务器的配置  返回特定流上游服务器组中每个服务器的配置。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回一组Stream Upstream Servers 
+  400 - Upstream是静态的（ UpstreamStatic ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><ul>
<li><p>POST - 将服务器添加到流上游服务器组  将新服务器添加到流上游服务器组。 服务器参数以JSON格式指定。 </p>
<p>请求参数： </p>
<p>postStreamUpstreamServer （ Stream Upstream Server ，必需）  JSON格式的新服务器和其他可选参数的地址。 无法更改“ ID ”，“ backup ”和“ service ”参数。  可能的回应： </p>
</li>
</ul>
<pre><code>+  201 - 创建，返回Stream Upstream Server 
+  400 - 上游是静态的（ UpstreamStatic ），无效的“ *parameter* ”值（ UpstreamConfFormatError ），缺少“ server ”参数（ UpstreamConfFormatError ），未知参数“ *name* ”（ UpstreamConfFormatError ），嵌套对象或列表（ UpstreamConfFormatError ），解析时error “ error ”（ UpstreamBadAddress ），服务器“ host ”（ UpstreamBadAddress ）中没有端口，服务上游“ host ”可能没有端口（ UpstreamBadAddress ），服务上游“ host ”需要域名（ UpstreamBadAddress ），无效“ weight ”（ UpstreamBadWeight ），无效“ max\_conns “（ UpstreamBadMaxConns ），无效” max\_fails “（ UpstreamBadMaxFails ），无效” fail\_timeout “（ UpstreamBadFailTimeout ），无效” slow\_start “（ UpstreamBadSlowStart ），” service “为空（ UpstreamBadService ），无法解析解析器（ UpstreamConfNoResolver ），上游” *name* “没有备份（ UpstreamNoBackup ），上游” *name* “内存耗尽（ UpstreamOutOfMemory UpstreamOutOfMemory ），返回Error 
+  404 - 未找到UpstreamNotFound （ UpstreamNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><p> /stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}   所有方法通用的参数：  streamUpstreamName （ string ，必填）  上游服务器组的名称。  streamUpstreamServerId （ string ，required）  服务器的ID。  支持的方法： </p>
<ul>
<li><p>GET - 返回流上游服务器组中服务器的配置  返回流上游服务器组中特定服务器的配置。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Upstream Server 
+  400 - Upstream是静态的（ UpstreamStatic ），无效的服务器ID（ UpstreamBadServerId ），返回Error 
+  404 - Upstream not found（ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ）， 流未配置（ StreamNotConfigured ），返回Error 
</code></pre><ul>
<li><p>PATCH - 修改流上游服务器组中的服务器  修改流上游服务器组中特定服务器的设置。 服务器参数以JSON格式指定。 </p>
<p>请求参数： </p>
<p>patchStreamUpstreamServer （ Stream Upstream Server ，必需）  服务器参数，以JSON格式指定。 无法更改“ ID ”，“ backup ”和“ service ”参数。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Upstream Server 
+  400 - 上游是静态的（ UpstreamStatic ），无效的“ *parameter* ”值（ UpstreamConfFormatError ），未知参数“ *name* ”（ UpstreamConfFormatError ），嵌套对象或列表（ UpstreamConfFormatError ），解析时的“ error ”（ UpstreamBadAddress ），无效的“ server ”参数（ UpstreamBadAddress ），服务器“ host ”（ UpstreamBadAddress ）中没有端口，服务器ID无效（ UpstreamBadServerId ），无效“ weight ”（ UpstreamBadWeight ），无效“ max\_conns ”（ UpstreamBadMaxConns ），无效“ max\_fails ”（ UpstreamBadMaxFails ），无效“ fail\_timeout ”（ UpstreamBadFailTimeout ），无效“ slow\_start ”（ UpstreamBadSlowStart ），“ service ”为空（ UpstreamBadService ），服务器“ *ID* ”地址为不可变（ UpstreamServerImmutable ），服务器“ *ID* ”权重为不可变（ UpstreamServerWeightImmutable ），上游“ name ”内存耗尽（ UpstreamOutOfMemory ），返回错误 
+  404 - Upstream not found（ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ）， 流未配置（ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>DELETE - 从流上游服务器组中删除服务器  从流服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回一组Stream Upstream Servers 
+  400 - Upstream是静态的（ UpstreamStatic ），无效的服务器ID（ UpstreamBadServerId ），服务器“ *id* ”不可移动（ UpstreamServerImmutable ），返回Error 
+  404 - Upstream not found（ UpstreamNotFound ），ID为“ *id* ”的服务器不存在（ UpstreamServerNotFound ）， 流未配置（ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /stream/keyvals/   支持的方法： </p>
<ul>
<li><p>GET - 从所有流键区域返回键值对  返回每个流keyval共享内存区域的键值对。 </p>
<p>请求参数： </p>
<p>fields （ string ，可选）  如果“ fields ”值为空，则仅输出流密钥区域名称。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回所有流关键字的“ Stream Keyval Shared Memory Zone ”对象的集合 
+  404 - 未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><p> /stream/keyvals/{streamKeyvalZoneName}   所有方法通用的参数：  streamKeyvalZoneName （ string ，必填）  流keyval共享内存区域的名称。  支持的方法： </p>
<ul>
<li><p>GET - 从流键区域返回键 - 值对  返回存储在特定流keyval共享内存区域中的键值对。 </p>
<p>请求参数： </p>
<p>key （ string ，可选）  从流密钥区域获取特定键值对。  可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Keyval共享内存区域 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未找到keyval键（ KeyvalKeyNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
</code></pre><ul>
<li><p>POST - 将键值对添加到流键值区域  将新键值对添加到流键值共享内存区域 。 如果流键值共享内存区域为空，则可以输入多个键值对。 </p>
<p>请求参数： </p>
<p>Key-value （ Stream Keyval共享内存区域 ，必需）  键值对以JSON格式指定。 如果流键值共享内存区域为空，则可以输入多个键值对。  可能的回应： </p>
</li>
</ul>
<pre><code>+  201 - 创建 
+  400 - 需要密钥（ KeyvalFormatError ），只能添加一个密钥（ KeyvalFormatError ），嵌套对象或列表（ KeyvalFormatError ），返回Error 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  409 - 密钥已存在（ KeyvalKeyExists ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>PATCH - 修改键值或删除键  更改键值对中所选键的值，或通过将键值设置为null来删除键。 </p>
<p>请求参数： </p>
<p>streamKeyvalZoneKeyValue （ Stream Keyval共享内存区域 ，必需）  密钥的新值以JSON格式指定。  可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  400 - 需要密钥（ KeyvalFormatError ），只能更新一个密钥（ KeyvalFormatError ），嵌套对象或列表（ KeyvalFormatError ），返回Error 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未找到keyval键（ KeyvalKeyNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
+  415 - JSON错误（ JsonError ），返回Error 
</code></pre><ul>
<li><p>DELETE - 清空流键值区域  从流keyval共享内存区域中删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  204 - 成功 
+  404 - 未找到KeyvalNotFound （ KeyvalNotFound ），未配置流 （ StreamNotConfigured ），返回Error 
+  405 - 禁用方法（ MethodDisabled ），返回Error 
</code></pre><p> /stream/zone_sync/   支持的方法： </p>
<ul>
<li><p>GET - 返回节点的同步状态  返回群集节点的同步状态。 </p>
<p>可能的回应： </p>
</li>
</ul>
<pre><code>+  200 - 成功，返回Stream Zone Sync节点 
+  404 - 未配置区域同步（ ZoneSyncNotConfigured ），未配置流 （ StreamNotConfigured ），返回错误 
</code></pre><h4 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h4><ul>
<li><p>nginx的： </p>
<p>有关nginx的一般信息：  version （ string ）  nginx的版本。  build （ string ）  nginx构建的名称。  address （ string ）  接受状态请求的服务器的地址。  generation （ integer ）  配置重新加载的总数。  load_timestamp （ string ）  上次重新加载配置的时间，采用ISO 8601格式，分辨率为毫秒。  timestamp （ string ）  ISO 8601格式的当前时间，分辨率为毫秒。  pid （ integer ）  处理状态请求的工作进程的ID。  ppid （ integer ）  启动工作进程的主进程的ID。  例： </p>
</li>
</ul>
<blockquote>
<p>{ “nginx” : { “version” : “1.15.2”, “build” : “nginx-plus-r16”, “address” : “206.251.255.64”, “generation” : 6, “load_timestamp” : “2018-10-08T09:05:48.776Z”, “timestamp” : “2018-10-08T15:23:17.056Z”, “pid” : 32212, “ppid” : 32210 } }</p>
<ul>
<li>流程： </li>
</ul>
</blockquote>
<p> respawned （ integer ）  异常终止和重生的子进程的总数。  例： </p>
<blockquote>
<p>{ “respawned” : 0 }</p>
<ul>
<li>连接： </li>
</ul>
</blockquote>
<p> 已接受，已删除，活动和空闲连接的数量。  accepted （ integer ）  已接受的客户端连接总数。  dropped （ integer ）  已删除的客户端连接总数。  active （ integer ）  当前活动客户端连接数。  idle （ integer ）  当前空闲客户端连接数。  例： </p>
<blockquote>
<p>{ “accepted” : 4968119, “dropped” : 0, “active” : 5, “idle” : 117 }</p>
<ul>
<li>SSL： </li>
</ul>
</blockquote>
<p> handshakes （ integer ）  成功的SSL握手总数。  handshakes_failed （ integer ）  失败的SSL握手总数。  session_reuses （ integer ）  SSL握手期间会话​​重用的总次数。  例： </p>
<blockquote>
<p>{ “handshakes” : 79572, “handshakes_failed” : 21025, “session_reuses” : 15762 }</p>
<ul>
<li>带有slab分配器的共享内存区域： </li>
</ul>
</blockquote>
<p> pages   空闲和已用内存页面的数量。  used （ integer ）  当前使用的内存页数。  free （ integer ）  当前可用内存页数。  slots   内存插槽的状态数据（8,16,32,64,128等） </p>
<p> “ Memory Slot ”对象的集合 </p>
<p> 例： </p>
<blockquote>
<p>{ “pages” : { “used” : 1143, “free” : 2928 }, “slots” : { “8” : { “used” : 0, “free” : 0, “reqs” : 0, “fails” : 0 }, “16” : { “used” : 0, “free” : 0, “reqs” : 0, “fails” : 0 }, “32” : { “used” : 0, “free” : 0, “reqs” : 0, “fails” : 0 }, “64” : { “used” : 1, “free” : 63, “reqs” : 1, “fails” : 0 }, “128” : { “used” : 0, “free” : 0, “reqs” : 0, “fails” : 0 }, “256” : { “used” : 18078, “free” : 178, “reqs” : 1635736, “fails” : 0 } } }</p>
<ul>
<li>内存插槽： </li>
</ul>
</blockquote>
<p> used （ integer ）  当前使用的内存插槽数。  free （ integer ）  当前可用内存插槽的数量。  reqs （ integer ）  分配指定大小内存的总尝试次数。  fails （ integer ）  分配指定大小内存的尝试失败次数。 </p>
<ul>
<li><p>HTTP请求： </p>
<p>total （ integer ）  客户端请求的总数。  current （ integer ）  当前的客户端请求数。  例： </p>
</li>
</ul>
<blockquote>
<p>{ “total” : 10624511, “current” : 4 }</p>
<ul>
<li>HTTP服务器区域： </li>
</ul>
</blockquote>
<p> processing （ integer ）  当前正在处理的客户端请求数。  requests （ integer ）  从客户端收到的客户端请求总数。  responses   发送给客户端的响应总数和状态代码为“ 1xx ”，“ 2xx ”，“ 3xx ”，“ 4xx ”和“ 5xx ”的响应数。  1xx （ integer ）  带有“ 1xx ”状态代码的响应数。  2xx （ integer ）  带有“ 2xx ”状态代码的响应数。  3xx （ integer ）  带有“ 3xx ”状态代码的响应数。  4xx （ integer ）  带有“ 4xx ”状态代码的响应数。  5xx （ integer ）  带有“ 5xx ”状态代码的响应数。  total （ integer ）  发送给客户端的响应总数。  discarded （ integer ）  未发送响应而完成的请求总数。  received （ integer ）  从客户端收到的总字节数。  sent （ integer ）  发送给客户端的总字节数。  例： </p>
<blockquote>
<p>{ “processing” : 1, “requests” : 706690, “responses” : { “1xx” : 0, “2xx” : 699482, “3xx” : 4522, “4xx” : 907, “5xx” : 266, “total” : 705177 }, “discarded” : 1513, “received” : 172711587, “sent” : 19415530115 }</p>
<ul>
<li>HTTP缓存： </li>
</ul>
</blockquote>
<p> size （ integer ）  缓存的当前大小。  max_size （ integer ）  配置中指定的高速缓存的最大大小限制。  cold （ boolean ）  一个布尔值，指示“缓存加载器”进程是否仍在将数据从磁盘加载到缓存中。  hit   responses （ integer ）  从缓存中读取的有效响应总数。  bytes （ integer ）  从缓存中读取的总字节数。  stale   responses （ integer ）  从缓存中读取的过期响应总数（请参阅proxy_cache_use_stale和其他“ <em>_cache_use_stale ”指令）。  bytes （ integer ）  从缓存中读取的总字节数。  updating   responses （ integer ）  在响应更新时从缓存读取的过期响应总数（请参阅proxy_cache_use_stale和其他“ </em>_cache_use_stale ”指令）。  bytes （ integer ）  从缓存中读取的总字节数。  revalidated   responses （ integer ）  从缓存中读取的过期和重新验证响应的总数（请参阅proxy_cache_revalidate和其他“ <em>_cache_revalidate _cache_revalidate ”指令。  bytes （ integer ）  从缓存中读取的总字节数。  miss   responses （ integer ）  在缓存中找不到的响应总数。  bytes （ integer ）  从代理服务器读取的总字节数。  responses_written （ integer ）  写入缓存的响应总数。  bytes_written （ integer ）  写入缓存的总字节数。  expired   responses （ integer ）  未从缓存中获取的过期响应总数。  bytes （ integer ）  从代理服务器读取的总字节数。  responses_written （ integer ）  写入缓存的响应总数。  bytes_written （ integer ）  写入缓存的总字节数。  bypass   responses （ integer ）  由于proxy_cache_bypass和其他“ </em>_cache_bypass ”指令，缓存中未查找的响应总数。  bytes （ integer ）  从代理服务器读取的总字节数。  responses_written （ integer ）  写入缓存的响应总数。  bytes_written （ integer ）  写入缓存的总字节数。  例： </p>
<blockquote>
<p>{ “size” : 530915328, “max_size” : 536870912, “cold” : false, “hit” : { “responses” : 254032, “bytes” : 6685627875 }, “stale” : { “responses” : 0, “bytes” : 0 }, “updating” : { “responses” : 0, “bytes” : 0 }, “revalidated” : { “responses” : 0, “bytes” : 0 }, “miss” : { “responses” : 1619201, “bytes” : 53841943822 }, “expired” : { “responses” : 45859, “bytes” : 1656847080, “responses_written” : 44992, “bytes_written” : 1641825173 }, “bypass” : { “responses” : 200187, “bytes” : 5510647548, “responses_written” : 200173, “bytes_written” : 44992 } }</p>
<ul>
<li>HTTP上游： </li>
</ul>
</blockquote>
<p> peers   一系列的：  id （ integer ）  服务器的ID。  server （ string ）  服务器的地址 。  service （ string ）  server指令的服务参数值。  name （ string ）  server指令中指定的服务器名称。  backup （ boolean ）  一个布尔值，指示服务器是否为备份服务器。  weight （ integer ）  服务器的重量 。  state （ string ）  当前状态，可以是“ up ”，“ draining ”，“ down ”，“ unavail ”，“ checking ”和“ unhealthy ”之一。  active （ integer ）  当前活动连接数。  max_conns （ integer ）  服务器的max_conns限制。  requests （ integer ）  转发到此服务器的客户端请求总数。  responses   1xx （ integer ）  带有“ 1xx ”状态代码的响应数。  2xx （ integer ）  带有“ 2xx ”状态代码的响应数。  3xx （ integer ）  带有“ 3xx ”状态代码的响应数。  4xx （ integer ）  带有“ 4xx ”状态代码的响应数。  5xx （ integer ）  带有“ 5xx ”状态代码的响应数。  total （ integer ）  从此服务器获取的响应总数。  sent （ integer ）  发送到此服务器的总字节数。  received （ integer ）  从此服务器接收的总字节数。  fails （ integer ）  与服务器通信失败的总次数。  unavail （ integer ）  由于尝试达到max_fails阈值的次数不成功，服务器因客户端请求（状态为“ unavail ”）而变为不可用的次数。  health_checks   checks （ integer ）  进行的健康检查请求总数。  fails （ integer ）  健康检查失败的次数。  unhealthy （ integer ）  服务器变得不健康的次数（状态“ unhealthy ”）。  last_passed （ boolean ）  布尔值，指示上次运行状况检查请求是否成功并通过了测试 。  downtime （ integer ）  服务器处于“ unavail ”，“ checking ”和“ unhealthy ”状态的总时间。  downstart （ string ）  服务器变为“ unavail ”，“ checking ”或“ unhealthy ”的时间，采用ISO 8601格式，分辨率为毫秒。  selected ( string )  The time when the server was last selected to process a request, in the ISO 8601 format with millisecond resolution.  header_time ( integer )  The average time to get the response header from the server.  response_time ( integer )  The average time to get the full response from the server.  keepalive ( integer )  当前空闲keepalive连接数。  zombies ( integer )  从组中删除但仍处理活动客户端请求的当前服务器数。  zone ( string )  保持组配置和运行时状态的共享内存区域的名称。  queue   对于请求队列 ，提供以下数据：  size ( integer )  队列中当前的请求数。  max_size ( integer )  可以同时在队列中的最大请求数。  overflows ( integer )  由于队列溢出而拒绝的请求总数。  例： </p>
<blockquote>
<p>{ “upstream_backend” : { “peers” : [ { “id” : 0, “server” : “10.0.0.1:8088”, “name” : “10.0.0.1:8088”, “backup” : false, “weight” : 5, “state” : “up”, “active” : 0, “max_conns” : 20, “requests” : 667231, “header_time” : 20, “response_time” : 36, “responses” : { “1xx” : 0, “2xx” : 666310, “3xx” : 0, “4xx” : 915, “5xx” : 6, “total” : 667231 }, “sent” : 251946292, “received” : 19222475454, “fails” : 0, “unavail” : 0, “health_checks” : { “checks” : 26214, “fails” : 0, “unhealthy” : 0, “last_passed” : true }, “downtime” : 0, “downstart” : “2017-07-07T11:09:21.602Z”, “selected” : “2017-07-17T15:01:25.000Z” }, { “id” : 1, “server” : “10.0.0.1:8089”, “name” : “10.0.0.1:8089”, “backup” : true, “weight” : 1, “state” : “unhealthy”, “active” : 0, “max_conns” : 20, “requests” : 0, “responses” : { “1xx” : 0, “2xx” : 0, “3xx” : 0, “4xx” : 0, “5xx” : 0, “total” : 0 }, “sent” : 0, “received” : 0, “fails” : 0, “unavail” : 0, “health_checks” : { “checks” : 26284, “fails” : 26284, “unhealthy” : 1, “last_passed” : false }, “downtime” : 262925617, “downstart” : “2017-07-07T11:09:21.602Z”, “selected” : “2017-07-17T15:01:25.000Z” } ], “keepalive” : 0, “zombies” : 0, “zone” : “upstream_backend” } }</p>
<ul>
<li>HTTP Upstream Server: </li>
</ul>
</blockquote>
<p> Dynamically configurable parameters of an HTTP upstream server :  id ( integer )  The ID of the HTTP upstream server. The ID is assigned automatically and cannot be changed.  server ( string )  Same as the address parameter of the HTTP upstream server. 添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the resolver directive in the “ http ” block. See also the resolve parameter of the HTTP upstream server.  service ( string )  Same as the service parameter of the HTTP upstream server. This parameter cannot be changed.  weight ( integer )  Same as the weight parameter of the HTTP upstream server.  max_conns ( integer )  Same as the max_conns parameter of the HTTP upstream server.  max_fails ( integer )  Same as the max_fails parameter of the HTTP upstream server.  fail_timeout ( string )  Same as the fail_timeout parameter of the HTTP upstream server.  slow_start ( string )  Same as the slow_start parameter of the HTTP upstream server.  route ( string )  Same as the route parameter of the HTTP upstream server.  backup ( boolean )  When true , adds a backup server. This parameter cannot be changed.  down ( boolean )  Same as the down parameter of the HTTP upstream server.  drain ( boolean )  Same as the drain parameter of the HTTP upstream server.  parent ( string )  Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed.  host ( string )  Hostname of the resolved server. The hostname is assigned automatically and cannot be changed.  例： </p>
<blockquote>
<p>{ “id” : 1, “server” : “10.0.0.1:8089”, “weight” : 4, “max_conns” : 0, “max_fails” : 0, “fail_timeout” : “10s”, “slow_start” : “10s”, “route” : “”, “backup” : true, “down” : true }</p>
<ul>
<li>HTTP Keyval Shared Memory Zone: </li>
</ul>
</blockquote>
<p> Contents of an HTTP keyval shared memory zone.  例： </p>
<blockquote>
<p>{ “key1” : “value1”, “key2” : “value2”, “key3” : “value3” }</p>
<ul>
<li>Stream Server Zone: </li>
</ul>
</blockquote>
<p> processing ( integer )  当前正在处理的客户端连接数。  connections ( integer )  从客户端接受的连接总数。  sessions   The total number of completed sessions, and the number of sessions completed with status codes “ 2xx ”, “ 4xx ”, or “ 5xx ”.  2xx ( integer )  The total number of sessions completed with status codes “ 2xx ”.  4xx ( integer )  The total number of sessions completed with status codes “ 4xx ”.  5xx ( integer )  The total number of sessions completed with status codes “ 5xx ”.  total ( integer )  已完成的客户会话总数。  discarded ( integer )  在不创建会话的情况下完成的连接总数。  received ( integer )  从客户端收到的总字节数。  sent ( integer )  发送给客户端的总字节数。  例： </p>
<blockquote>
<p>{ “dns” : { “processing” : 1, “connections” : 155569, “sessions” : { “2xx” : 155564, “4xx” : 0, “5xx” : 0, “total” : 155569 }, “discarded” : 0, “received” : 4200363, “sent” : 20489184 } }</p>
<ul>
<li>Stream Upstream: </li>
</ul>
</blockquote>
<p> peers   An array of:  id ( integer )  服务器的ID。  server ( string )  服务器的地址 。  service ( string )  server指令的服务参数值。  name ( string )  server指令中指定的服务器名称。  backup ( boolean )  一个布尔值，指示服务器是否为备份服务器。  weight ( integer )  服务器的重量 。  state ( string )  当前状态，可以是“ up ”，“ down ”，“ unavail ”，“ checking ”或“ unhealthy ”之一。  active ( integer )  当前的连接数。  max_conns ( integer )  服务器的max_conns限制。  connections ( integer )  转发到此服务器的客户端连接总数。  connect_time ( integer )  连接上游服务器的平均时间。  first_byte_time ( integer )  接收第一个数据字节的平均时间。  response_time ( integer )  接收最后一个数据字节的平均时间。  sent ( integer )  发送到此服务器的总字节数。  received ( integer )  从此服务器接收的总字节数。  fails ( integer )  与服务器通信失败的总次数。  unavail ( integer )  由于尝试达到max_fails阈值的次数不成功，服务器无法进行客户端连接（状态为“ unavail ”）的次数。  health_checks   checks ( integer )  进行的健康检查请求总数。  fails ( integer )  健康检查失败的次数。  unhealthy ( integer )  服务器变得不健康的次数（状态“ unhealthy ”）。  last_passed ( boolean )  Boolean indicating whether the last health check request was successful and passed tests .  downtime ( integer )  服务器处于“ unavail ”，“ checking ”和“ unhealthy ”状态的总时间。  downstart ( string )  The time when the server became “ unavail ”, “ checking ”, or “ unhealthy ”, in the ISO 8601 format with millisecond resolution.  selected ( string )  The time when the server was last selected to process a connection, in the ISO 8601 format with millisecond resolution.  zombies ( integer )  当前从组中删除但仍处理活动客户端连接的服务器数。  zone ( string )  保持组配置和运行时状态的共享内存区域的名称。  例： </p>
<blockquote>
<p>{ “dns” : { “peers” : [ { “id” : 0, “server” : “10.0.0.1:12347”, “name” : “10.0.0.1:12347”, “backup” : false, “weight” : 5, “state” : “up”, “active” : 0, “max_conns” : 50, “connections” : 667231, “sent” : 251946292, “received” : 19222475454, “fails” : 0, “unavail” : 0, “health_checks” : { “checks” : 26214, “fails” : 0, “unhealthy” : 0, “last_passed” : true }, “downtime” : 0, “downstart” : “2017-07-07T11:09:21.602Z”, “selected” : “2017-07-17T15:01:25.000Z” }, { “id” : 1, “server” : “10.0.0.1:12348”, “name” : “10.0.0.1:12348”, “backup” : true, “weight” : 1, “state” : “unhealthy”, “active” : 0, “max_conns” : 50, “connections” : 0, “sent” : 0, “received” : 0, “fails” : 0, “unavail” : 0, “health_checks” : { “checks” : 26284, “fails” : 26284, “unhealthy” : 1, “last_passed” : false }, “downtime” : 262925617, “downstart” : “2017-07-07T11:09:21.602Z”, “selected” : “2017-07-17T15:01:25.000Z” } ], “zombies” : 0, “zone” : “dns” } }</p>
<ul>
<li>Stream Upstream Server: </li>
</ul>
</blockquote>
<p> Dynamically configurable parameters of a stream upstream server :  id ( integer )  The ID of the stream upstream server. The ID is assigned automatically and cannot be changed.  server ( string )  Same as the address parameter of the stream upstream server. 添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the resolver directive in the “ stream ” block. See also the resolve parameter of the stream upstream server.  service ( string )  Same as the service parameter of the stream upstream server. This parameter cannot be changed.  weight ( integer )  Same as the weight parameter of the stream upstream server.  max_conns ( integer )  Same as the max_conns parameter of the stream upstream server.  max_fails ( integer )  Same as the max_fails parameter of the stream upstream server.  fail_timeout ( string )  Same as the fail_timeout parameter of the stream upstream server.  slow_start ( string )  Same as the slow_start parameter of the stream upstream server.  backup ( boolean )  When true , adds a backup server. This parameter cannot be changed.  down ( boolean )  Same as the down parameter of the stream upstream server.  parent ( string )  Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed.  host ( string )  Hostname of the resolved server. The hostname is assigned automatically and cannot be changed.  例： </p>
<blockquote>
<p>{ “id” : 0, “server” : “10.0.0.1:12348”, “weight” : 1, “max_conns” : 0, “max_fails” : 1, “fail_timeout” : “10s”, “slow_start” : 0, “backup” : false, “down” : false }</p>
<ul>
<li>Stream Keyval Shared Memory Zone: </li>
</ul>
</blockquote>
<p> Contents of a stream keyval shared memory zone.  例： </p>
<blockquote>
<p>{ “key1” : “value1”, “key2” : “value2”, “key3” : “value3” }</p>
<ul>
<li>Stream Zone Sync Node: </li>
</ul>
</blockquote>
<p> zones   Synchronization information per each shared memory zone. </p>
<p> A collection of “ Sync Zone “ objects </p>
<p> status   Synchronization information per node in a cluster.  bytes_in ( integer )  The number of bytes received by this node.  msgs_in ( integer )  The number of messages received by this node.  msgs_out ( integer )  The number of messages sent by this node.  bytes_out ( integer )  The number of bytes sent by this node.  nodes_online ( integer )  The number of peers this node is connected to.  例： </p>
<blockquote>
<p>{ “zones” : { “zone1” : { “records_pending” : 2061, “records_total” : 260575 }, “zone2” : { “records_pending” : 0, “records_total” : 14749 } }, “status” : { “bytes_in” : 1364923761, “msgs_in” : 337236, “msgs_out” : 346717, “bytes_out” : 1402765472, “nodes_online” : 15 } }</p>
<ul>
<li>Sync Zone: </li>
</ul>
</blockquote>
<p> Synchronization status of a shared memory zone.  records_pending ( integer )  The number of records that need to be sent to the cluster.  records_total ( integer )  The total number of records stored in the shared memory zone. </p>
<ul>
<li><p>错误： </p>
<p>nginx error object.  path ( string )  API path.  method ( string )  HTTP method.  error   status ( integer )  HTTP error code.  text ( string )  Error description.  code ( string )  Internal nginx error code.  request_id ( string )  The ID of the request, equals the value of the $request_id variable.  href ( string )  Link to reference documentation. </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_addition_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_addition_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_addition_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-addition-module"><a href="#Module-ngx-http-addition-module" class="headerlink" title="Module ngx_http_addition_module"></a>Module ngx_http_addition_module</h2><p> Example Configuration<br> Directives<br> add_before_body<br> add_after_body<br> addition_types<br> ngx_http_addition_module模块是一个过滤器，用于在响应之前和之后添加文本。 默认情况下不构建此模块，应使用–with-http_addition_module配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { add_before_body /before_action; add_after_body /after_action; } ####  指令</p>
</blockquote>
<p> Syntax:  <strong>add_before_body</strong> <em>uri</em> ;<br>  Default:  —  Context:  http , server , location<br>  添加由于在响应主体之前处理给定子请求而返回的文本。 作为参数的空字符串（ “” ）取消从先前配置级别继承的添加。 </p>
<p> Syntax:  <strong>add_after_body</strong> <em>uri</em> ;<br>  Default:  —  Context:  http , server , location<br>  添加由于在响应主体之后处理给定子请求而返回的文本。 作为参数的空字符串（ “” ）取消从先前配置级别继承的添加。 </p>
<p> Syntax:  <strong>addition_types</strong> <em>mime-type</em> …;<br>  Default:  addition_types text/html;  Context:  http , server , location<br>  该指令出现在0.7.9版本中。 </p>
<p> 除了“ text/html ”之外，还允许在具有指定MIME类型的响应中添加文本。 特殊值“ * ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_access_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_access_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-access-module"><a href="#Module-ngx-http-access-module" class="headerlink" title="Module ngx_http_access_module"></a>Module ngx_http_access_module</h2><p> Example Configuration<br> Directives<br> allow<br> deny<br> ngx_http_access_module模块允许限制对某些客户端地址的访问。 </p>
<p> 访问也可以通过密码 ， 子请求的结果或JWT来限制 。 通过地址和密码同时限制访问由satisf指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; }  按顺序检查规则，直到找到第一个匹配项。 在此示例中，仅允许IPv4网络10.1.1.0/16和192.168.1.0/24不包括地址192.168.1.1 ）和IPv6网络2001:0db8::/32 。 如果有很多规则，最好使用ngx_http_geo_module模块变量。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>allow</strong> <em>address</em> | <em>CIDR</em> | unix: | all ;<br>  Default:  —  Context:  http , server , location , limit_except<br>  允许访问指定的网络或地址。 如果指定了特殊值unix: （1.5.1），则允许访问所有UNIX域套接字。 </p>
<p> Syntax:  <strong>deny</strong> <em>address</em> | <em>CIDR</em> | unix: | all ;<br>  Default:  —  Context:  http , server , location , limit_except<br>  拒绝访问指定的网络或地址。 如果指定了特殊值unix: （1.5.1），则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/load_balancing-nginx中文手册]]></title>
      <url>/ngx/http/load_balancing.html</url>
      <content type="html"><![CDATA[<p>http,load_balancing<br><a id="more"></a></p>
<h2 id="使用nginx作为HTTP负载均衡器"><a href="#使用nginx作为HTTP负载均衡器" class="headerlink" title=" 使用nginx作为HTTP负载均衡器"></a> 使用nginx作为HTTP负载均衡器</h2><p> Load balancing methods<br> Default load balancing configuration<br> Least connected load balancing<br> Session persistence<br> Weighted load balancing<br> Health checks<br> Further reading   </p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> 跨多个应用程序实例的负载平衡是一种常用技术，用于优化资源利用率，最大化吞吐量，减少延迟并确保容错配置。 </p>
<p> 可以使用nginx作为非常有效的HTTP负载平衡器，将流量分配到多个应用程序服务器，并使用nginx提高Web应用程序的性能，可伸缩性和可靠性。 </p>
<h4 id="负载均衡方法"><a href="#负载均衡方法" class="headerlink" title="负载均衡方法"></a>负载均衡方法</h4><p> nginx支持以下负载平衡机制（或​​方法）： </p>
<ul>
<li>循环 - 对应用程序服务器的请求以循环方式分发， </li>
<li>最少连接 - 下一个请求被分配给活动连接数最少的服务器， </li>
<li><p>ip-hash - 哈希函数用于确定应为下一个请求选择哪个服务器（基于客户端的IP地址）。 </p>
<h4 id="默认负载均衡配置"><a href="#默认负载均衡配置" class="headerlink" title="默认负载均衡配置"></a>默认负载均衡配置</h4><p>使用nginx进行负载平衡的最简单配置可能如下所示： </p>
</li>
</ul>
<blockquote>
<p>http { upstream myapp1 { server srv1.example.com; server srv2.example.com; server srv3.example.com; } server { listen 80; location / { proxy_pass <a href="http://myapp1" target="_blank" rel="noopener">http://myapp1</a>; } } }  在上面的示例中，在srv1-srv3上运行了3个相同应用程序的实例。 如果未特别配置负载平衡方法，则默认为循环。 所有请求都代理到服务器组myapp1，nginx应用HTTP负载平衡来分发请求。 </p>
</blockquote>
<p> nginx中的反向代理实现包括HTTP，HTTPS，FastCGI，uwsgi，SCGI，memcached和gRPC的负载平衡。 </p>
<p> 要为HTTPS而不是HTTP配置负载平衡，只需使用“https”作为协议。 </p>
<p> 为FastCGI，uwsgi，SCGI，memcached或gRPC设置负载平衡时，分别使用fastcgi_pass ， uwsgi_pass ， scgi_pass ， memcached_pa​​ss和grpc_pass指令。 </p>
<h4 id="最小连接负载平衡"><a href="#最小连接负载平衡" class="headerlink" title="最小连接负载平衡"></a>最小连接负载平衡</h4><p> 另一个负载平衡规则是最少连接的。 在某些请求需要更长时间才能完成的情况下，最小连接允许更公平地控制应用程序实例上的负载。 </p>
<p> 使用最少连接的负载平衡，nginx将尽量不会使繁忙的应用程序服务器过载请求，而是将新请求分发给不太繁忙的服务器。 </p>
<p> 当least_conn指令用作服务器组配置的一部分时，将激活nginx中的最小连接负载平衡： </p>
<blockquote>
<p> upstream myapp1 { least_conn; server srv1.example.com; server srv2.example.com; server srv3.example.com; } ####  会话持久性</p>
</blockquote>
<p> 请注意，通过循环或最少连接的负载平衡，每个后续客户端的请求可能会分发到不同的服务器。 无法保证同一客户端始终指向同一服务器。 </p>
<p> 如果需要将客户端绑定到特定的应用程序服务器 - 换句话说，就始终尝试选择特定服务器而言，使客户端的会话“粘滞”或“持久” - ip-hash负载平衡机制可以是用过的。 </p>
<p> 使用ip-hash，客户端的IP地址将用作散列密钥，以确定应为客户端的请求选择服务器组中的哪个服务器。 此方法可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。 </p>
<p> 要配置ip-hash负载平衡，只需将ip_hash指令添加到服务器（上游）组配置： </p>
<blockquote>
<p>upstream myapp1 { ip_hash; server srv1.example.com; server srv2.example.com; server srv3.example.com; } ####  加权负载平衡</p>
</blockquote>
<p> 通过使用服务器权重，甚至可以进一步影响nginx负载平衡算法。 </p>
<p> 在上面的示例中，未配置服务器权重，这意味着所有指定的服务器都被视为对特定负载平衡方法具有同等资格。 </p>
<p> 特别是对于循环，它还意味着在服务器上或多或少地平等分配请求 - 只要有足够的请求，并且以统一的方式处理请求并且足够快地完成。 </p>
<p> 当为服务器指定权重参数时， 权重被计入负载平衡决策的一部分。 </p>
<blockquote>
<p> upstream myapp1 { server srv1.example.com weight=3; server srv2.example.com; server srv3.example.com; }  使用此配置，每5个新请求将分布在应用程序实例中，如下所示：3个请求将定向到srv1，一个请求将转到srv2，另一个请求转到srv3。 </p>
</blockquote>
<p> 同样可以在最近的nginx版本中使用具有最少连接和ip-hash负载平衡的权重。 </p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p> nginx中的反向代理实现包括带内（或被动）服务器运行状况检查。 如果来自特定服务器的响应失败并显示错误，则nginx会将此服务器标记为失败，并将尝试避免为后续入站请求选择此服务器一段时间。 </p>
<p> max_fails指令设置在fail_timeout期间应该发生的与服务器通信的连续不成功尝试次数。 默认情况下， max_fails设置为1.当设置为0时，将禁用此服务器的运行状况检查。 fail_timeout参数还定义服务器将标记为失败的时间。 在服务器发生故障后的fail_timeout时间间隔后，nginx将开始使用实时客户端的请求正常探测服务器。 如果探测成功，则将服务器标记为实时。 </p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p> 此外，还有更多指令和参数可以控制nginx中的服务器负载平衡，例如proxy_next_upstream ， backup ， down和keepalive 。 有关更多信息，请查看我们的参考文档 。 </p>
<p> 最后但同样重要的是， 应用程序负载平衡 ， 应用程序运行状况检查 ， 活动监视和服务器组的动态重新配置是我们付费NGINX Plus订阅的一部分。 </p>
<p> 以下文章更详细地描述了与NGINX Plus的负载平衡： </p>
<ul>
<li>使用NGINX和NGINX Plus进行负载均衡 </li>
<li>使用NGINX和NGINX Plus第2部分进行负载平衡 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/converting_rewrite_rules-nginx中文手册]]></title>
      <url>/ngx/http/converting_rewrite_rules.html</url>
      <content type="html"><![CDATA[<p>http,converting_rewrite_rules<br><a id="more"></a></p>
<h2 id="转换重写规则"><a href="#转换重写规则" class="headerlink" title=" 转换重写规则"></a> 转换重写规则</h2><p> Converting Mongrel rules   </p>
<h4 id="重定向到主站点"><a href="#重定向到主站点" class="headerlink" title="重定向到主站点"></a>重定向到主站点</h4><p> 在共享托管生活期间用于<em>仅</em>使用Apache的.htaccess文件配置<em>所有内容</em>的人通常会翻译以下规则： </p>
<blockquote>
<p>RewriteCond %{HTTP_HOST} example.org RewriteRule (.*) <a href="http://www.example.org$1" target="_blank" rel="noopener">http://www.example.org$1</a>  这样的事情： </p>
<p>server { listen 80; server_name www.example.org example.org; if ($http_host = example.org) { rewrite (.*) <a href="http://www.example.org$1" target="_blank" rel="noopener">http://www.example.org$1</a>; } … }  这是一种错误，繁琐且无效的方式。 正确的方法是为example.org定义一个单独的服务器： </p>
<p>server { listen 80; server_name example.org; return 301 <a href="http://www.example.org$request\_uri" target="_blank" rel="noopener">http://www.example.org$request\_uri</a>; } server { listen 80; server_name www.example.org; … }<br> 在0.9.1之前的版本上，重定向可以使用： </p>
<blockquote>
<p> rewrite ^ <a href="http://www.example.org$request\_uri?" target="_blank" rel="noopener">http://www.example.org$request\_uri?</a>;  另一个例子。 而不是“倒置”逻辑“所有不是example.com而不是www.example.com ”： </p>
</blockquote>
<p>RewriteCond %{HTTP_HOST} !example.com RewriteCond %{HTTP_HOST} !www.example.com RewriteRule (.*) <a href="http://www.example.com$1" target="_blank" rel="noopener">http://www.example.com$1</a>  一个人应该简单地定义example.com ， www.example.com和“其他一切”： </p>
<p>server { listen 80; server_name example.com www.example.com; … } server { listen 80 default_server; server_name _; return 301 <a href="http://example.com$request\_uri" target="_blank" rel="noopener">http://example.com$request\_uri</a>; }<br> 在0.9.1之前的版本上，重定向可以使用： </p>
<blockquote>
<p> rewrite ^ <a href="http://example.com$request\_uri?" target="_blank" rel="noopener">http://example.com$request\_uri?</a>; ####  转换Mongrel规则</p>
</blockquote>
</blockquote>
<p> 典型的Mongrel规则： </p>
<blockquote>
<p>DocumentRoot /var/www/myapp.com/current/public RewriteCond %{DOCUMENT_ROOT}/system/maintenance.html -f RewriteCond %{SCRIPT_FILENAME} !maintenance.html RewriteRule ^.<em>$ %{DOCUMENT_ROOT}/system/maintenance.html [L] RewriteCond %{REQUEST_FILENAME} -f RewriteRule ^(.</em>)$ $1 [QSA,L] RewriteCond %{REQUEST_FILENAME}/index.html -f RewriteRule ^(.<em>)$ $1/index.html [QSA,L] RewriteCond %{REQUEST_FILENAME}.html -f RewriteRule ^(.</em>)$ $1.html [QSA,L] RewriteRule ^/(.*)$ balancer://mongrel_cluster%{REQUEST_URI} [P,QSA,L]  应转换为 </p>
<p>location / { root /var/www/myapp.com/current/public; try_files /system/maintenance.html $uri $uri/index.html $uri.html @mongrel; } location @mongrel { proxy_pass <a href="http://mongrel" target="_blank" rel="noopener">http://mongrel</a>; }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/configuring_https_servers-nginx中文手册]]></title>
      <url>/ngx/http/configuring_https_servers.html</url>
      <content type="html"><![CDATA[<p>http,configuring_https_servers<br><a id="more"></a></p>
<h2 id="配置HTTPS服务器"><a href="#配置HTTPS服务器" class="headerlink" title=" 配置HTTPS服务器"></a> 配置HTTPS服务器</h2><p> HTTPS server optimization<br> SSL certificate chains<br> A single HTTP/HTTPS server<br> Name-based HTTPS servers<br> An SSL certificate with several names<br> Server Name Indication<br> Compatibility<br> 要配置HTTPS服务器，必须在服务器块中的侦听套接字上启用ssl参数，并且应指定服务器证书和私钥文件的位置： </p>
<blockquote>
<p>server { listen 443 <strong>ssl</strong> ; server_name www.example.com; ssl_certificate <strong>www.example.com.crt</strong> ; ssl_certificate_key <strong>www.example.com.key</strong> ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; … }  服务器证书是公共实体。 它被发送到连接到服务器的每个客户端。 私钥是一个安全的实体，应该存储在具有受限访问权限的文件中，但是，它必须是nginx的主进程可读的。 私钥可以替代地存储在与证书相同的文件中： </p>
<p> ssl_certificate www.example.com.cert; ssl_certificate_key www.example.com.cert;  在这种情况下，还应限制文件访问权限。 虽然证书和密钥存储在一个文件中，但只有证书才会发送到客户端。 </p>
</blockquote>
<p> 指令ssl_protocols和ssl_ciphers可用于限制连接以仅包括SSL / TLS的强版本和密码。 默认情况下，nginx使用“ ssl_protocols TLSv1 TLSv1.1 TLSv1.2 ”和“ ssl_ciphers HIGH:!aNULL:!MD5 ”，因此通常不需要明确配置它们。 请注意，这些指令的默认值已多次更改 。 </p>
<h4 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h4><p> SSL操作会消耗额外的CPU资源。 在多处理器系统上，应运行多个工作进程 ，不少于可用CPU核心数。 CPU占用最多的操作是SSL握手。 有两种方法可以最大限度地减少每个客户端的这些操作数量：第一种方法是通过启用keepalive连接来通过一个连接发送多个请求，第二种方法是重用SSL会话参数以避免SSL并行连接和后续连接。 会话存储在工作线程之间共享的SSL会话高速缓存中，并由ssl_session_cache指令配置。 一兆字节的缓存包含大约4000个会话。 默认缓存超时为5分钟。 可以使用ssl_session_timeout指令增加它。 以下是针对具有10兆字节共享会话缓存的多核系统优化的示例配置： </p>
<blockquote>
<p> <strong>worker_processes auto</strong> ; http { <strong>ssl_session_cache shared:SSL:10m</strong> ; <strong>ssl_session_timeout 10m</strong> ; server { listen 443 ssl; server_name www.example.com; <strong>keepalive_timeout 70</strong> ; ssl_certificate www.example.com.crt; ssl_certificate_key www.example.com.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; … ####  SSL证书链</p>
</blockquote>
<p> 某些浏览器可能会抱怨由知名证书颁发机构签名的证书，而其他浏览器可能会毫无问题地接受证书。 发生这种情况是因为颁发机构使用中间证书对服务器证书进行了签名，该中间证书不存在于与特定浏览器一起分发的知名可信证书颁发机构的证书库中。 在这种情况下，授权机构提供一组链式证书，这些证书应连接到签名的服务器证书。 服务器证书必须出现在组合文件中的链接证书之前： </p>
<blockquote>
<p>$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt  生成的文件应该在ssl_certificate指令中使用： </p>
<p>server { listen 443 ssl; server_name www.example.com; ssl_certificate www.example.com.chained.crt; ssl_certificate_key www.example.com.key; … }  如果服务器证书和软件包已按错误的顺序连接，则nginx将无法启动并显示错误消息： </p>
<p>SSL_CTX_use_PrivateKey_file(“ … /www.example.com.key”) failed (SSL: error:0B080074:x509 certificate routines: X509_check_private_key:key values mismatch)  因为nginx试图将私钥与bundle的第一个证书而不是服务器证书一起使用。 </p>
</blockquote>
<p> 浏览器通常存储他们收到的中间证书，并由受信任的权威机构签名，因此主动使用的浏览器可能已经拥有所需的中间证书，并且可能不会抱怨没有链接束发送的证书。 要确保服务器发送完整的证书链，可以使用openssl命令行实用程序，例如： </p>
<blockquote>
<p>$ openssl s_client -connect www.godaddy.com:443 … Certificate chain 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc /OU=MIS Department/ <strong>CN=www.GoDaddy.com</strong> /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b) i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc. /OU=<a href="http://certificates.godaddy.com/repository" target="_blank" rel="noopener">http://certificates.godaddy.com/repository</a> /CN=Go Daddy Secure Certification Authority /serialNumber=07969287 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc. /OU=<a href="http://certificates.godaddy.com/repository" target="_blank" rel="noopener">http://certificates.godaddy.com/repository</a> /CN=Go Daddy Secure Certification Authority /serialNumber=07969287 i:/C=US/O=The Go Daddy Group, Inc. /OU=Go Daddy Class 2 Certification Authority 2 s:/C=US/O=The Go Daddy Group, Inc. /OU=Go Daddy Class 2 Certification Authority i:/L=ValiCert Validation Network/O= <strong>ValiCert, Inc.</strong> /OU=ValiCert Class 2 Policy Validation Authority /CN=<a href="http://www.valicert.com//emailAddress=info@valicert.com" target="_blank" rel="noopener">http://www.valicert.com//emailAddress=info@valicert.com</a> …<br> 在使用SNI测试配置时，指定-servername选项很重要，因为默认情况下openssl不使用SNI。  在该示例中， www.GoDaddy.com服务器证书＃0的主题（“ <em>s</em> ”）由发行者（“ <em>i</em> ”）签名，发行者本身是证书＃1的主题，其由发行者本身签署。是证书＃2的主题，由知名发行人<em>ValiCert，Inc。签署，</em>其证书存储在浏览器的内置证书库（位于Jack建造的房屋中）中。 </p>
</blockquote>
<p> 如果尚未添加证书包，则仅显示服务器证书＃0。 </p>
<h4 id="单个HTTP-HTTPS服务器"><a href="#单个HTTP-HTTPS服务器" class="headerlink" title="单个HTTP / HTTPS服务器"></a>单个HTTP / HTTPS服务器</h4><p> 可以配置处理HTTP和HTTPS请求的单个服务器： </p>
<blockquote>
<p>server { listen 80; listen 443 ssl; server_name www.example.com; ssl_certificate www.example.com.crt; ssl_certificate_key www.example.com.key; … }<br> 在0.7.14之前，无法为个别侦听套接字选择性地启用SSL，如上所示。 只能使用ssl指令为整个服务器启用SSL ，从而无法设置单个HTTP / HTTPS服务器。 添加了listen指令的ssl参数来解决此问题。 因此不鼓励在现代版本中使用ssl指令。 ####  基于名称的HTTPS服务器</p>
</blockquote>
<p> 配置两个或多个侦听单个IP地址的HTTPS服务器时会出现一个常见问题： </p>
<blockquote>
<p>server { listen 443 ssl; server_name www.example.com; ssl_certificate www.example.com.crt; … } server { listen 443 ssl; server_name www.example.org; ssl_certificate www.example.org.crt; … }  使用此配置，浏览器接收默认服务器的证书，即www.example.com无论请求的服务器名称如何。 这是由SSL协议行为引起的。 在浏览器发送HTTP请求之前建立SSL连接，并且nginx不知道所请求服务器的名称。 因此，它可能只提供默认服务器的证书。 </p>
</blockquote>
<p> 解决此问题的最古老，最强大的方法是为每个HTTPS服务器分配一个单独的IP地址： </p>
<blockquote>
<p>server { listen 192.168.1.1:443 ssl; server_name www.example.com; ssl_certificate www.example.com.crt; … } server { listen 192.168.1.2:443 ssl; server_name www.example.org; ssl_certificate www.example.org.crt; … } ####  具有多个名称的SSL证书</p>
</blockquote>
<p> 还有其他方法允许在多个HTTPS服务器之间共享单个IP地址。 但是，所有这些都有它们的缺点。 一种方法是在SubjectAltName证书字段中使用具有多个名称的证书，例如www.example.com和www.example.org 。 但是，SubjectAltName字段长度是有限的。 </p>
<p> 另一种方法是使用带有通配符名称的证书，例如<em>.example.org 。 通配符证书可保护指定域的所有子域，但仅限于一个级别。 此证书与www.example.org匹配，但与example.org和www.sub.example.org不匹配。 这两种方法也可以组合使用。 证书可以在SubjectAltName字段中包含完全和通配符名称，例如example.org和</em>.example.org 。 </p>
<p> 最好将具有多个名称的证书文件及其私钥文件放在配置的<em>http</em>级别，以在所有服务器中继承其单个内存副本： </p>
<blockquote>
<p>ssl_certificate common.crt; ssl_certificate_key common.key; server { listen 443 ssl; server_name www.example.com; … } server { listen 443 ssl; server_name www.example.org; … } ####  服务器名称指示</p>
</blockquote>
<p> 在单个IP地址上运行多个HTTPS服务器的更通用的解决方案是TLS服务器名称指示扩展 （SNI，RFC 6066），它允许浏览器在SSL握手期间传递请求的服务器名称，因此服务器将知道哪个它应该用于连接的证书。 目前大多数现代浏览器都支持 SNI，但某些老客户或特殊客户可能无法使用。 </p>
<blockquote>
<p> 只有域名可以在SNI中传递，但是如果请求包含文字IP地址，某些浏览器可能会错误地传递服务器的IP地址作为其名称。 人们不应该依赖于此。  为了在nginx中使用SNI，必须在构建nginx二进制文件的OpenSSL库以及在运行时动态链接到的库中支持它。 如果使用配置选项“–enable-tlsext”构建，OpenSSL支持自0.9.8f版本以来的SNI 。 自OpenSSL 0.9.8j以来，默认情况下启用此选项。 如果nginx是使用SNI支持构建的，那么nginx将在使用“-V”开关运行时显示： </p>
<p>$ nginx -V … TLS SNI support enabled …  但是，如果启用SNI的nginx动态链接到没有SNI支持的OpenSSL库，nginx会显示警告： </p>
<p>nginx was built with SNI support, however, now it is linked dynamically to an OpenSSL library which has no tlsext support, therefore SNI is not available ####  兼容性</p>
</blockquote>
<ul>
<li>自0.8.21和0.7.62以来，“-V”开关显示SNI支持状态。 </li>
<li>自0.7.14起，支持listen指令的ssl参数。 在0.8.21之前，它只能与default参数一起指定。 </li>
<li>自0.5.23以来，SNI一直受到支持。 </li>
<li>自0.5.6以来一直支持共享SSL会话缓存。 </li>
<li>版本1.9.1及更高版本：默认的SSL协议是TLSv1，TLSv1.1和TLSv1.2（如果OpenSSL库支持）。 </li>
<li>版本0.7.65,0.8.19及更高版本：默认的SSL协议是SSLv3，TLSv1，TLSv1.1和TLSv1.2（如果受OpenSSL库支持）。 </li>
<li>版本0.7.64,0.8.18及更早版本：默认的SSL协议是SSLv2，SSLv3和TLSv1。 </li>
<li>版本1.0.5及更高版本：默认的SSL密码为“ HIGH:!aNULL:!MD5 ”。 </li>
<li>版本0.7.65,0.8.20及更高版本：默认SSL密码为“ HIGH:!ADH:!MD5 ”。 </li>
<li>版本0.8.19：默认SSL密码为“ ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM ”。 </li>
<li>版本0.7.64,0.8.18及更早版本：默认的SSL密码是<br>“ ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP ”。<br>written by Igor Sysoev<br>edited by Brian Mercer  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dev/development_guide-nginx中文手册]]></title>
      <url>/ngx/dev/development_guide.html</url>
      <content type="html"><![CDATA[<p>dev,development_guide<br><a id="more"></a></p>
<h2 id="开发指南"><a href="#开发指南" class="headerlink" title=" 开发指南"></a> 开发指南</h2><p> Introduction<br> Code layout<br> Include files<br> Integers<br> Common return codes<br> Error handling<br> Strings<br> Overview<br> Formatting<br> Numeric conversion<br> Regular expressions<br> Time<br> Containers<br> Array<br> List<br> Queue<br> Red-Black tree<br> Hash<br> Memory management<br> Heap<br> Pool<br> Shared memory<br> Logging<br> Cycle<br> Buffer<br> Networking<br> Connection<br> Events<br> Event<br> I/O events<br> Timer events<br> Posted events<br> Event loop<br> Processes<br> Threads<br> Modules<br> Adding new modules<br> Core Modules<br> Configuration Directives<br> HTTP<br> Connection<br> Request<br> Configuration<br> Phases<br> Variables<br> Complex values<br> Request redirection<br> Subrequests<br> Request finalization<br> Request body<br> Response<br> Response body<br> Body filters<br> Building filter modules<br> Buffer reuse<br> Load balancing<br> Examples<br> Code style<br> General rules<br> Files<br> Comments<br> Preprocessor<br> Types<br> Variables<br> Functions<br> Expressions<br> Conditionals and Loops<br> Labels   </p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h4 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h4><ul>
<li>auto - 构建脚本 </li>
<li><p>src </p>
<ul>
<li><p>core - 基本类型和函数 - 字符串，数组，日志，池等。 </p>
<ul>
<li>event - 事件核心 </li>
</ul>
<ul>
<li>modules - 事件通知模块： epoll ， kqueue ， select等。 </li>
</ul>
<ul>
<li>http - 核心HTTP模块和通用代码 </li>
</ul>
<ul>
<li>modules - 其他HTTP模块 </li>
<li>v2 - HTTP / 2 </li>
</ul>
<ul>
<li>mail - 邮件模块 </li>
<li>os - 特定于平台的代码 </li>
</ul>
<ul>
<li>unix <ul>
<li>win32 </li>
</ul>
</li>
</ul>
<ul>
<li>stream - 流模块 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h4><p> 以下两个#include语句必须出现在每个nginx文件的开头： </p>
<blockquote>
<p>#include <ngx\_config.h> #include <ngx\_core.h>  除此之外，HTTP代码应包括 </ngx\_core.h></ngx\_config.h></p>
<p>#include <ngx\_http.h>  邮件代码应包括 </ngx\_http.h></p>
<p>#include <ngx\_mail.h>  流代码应包括 </ngx\_mail.h></p>
<p>#include <ngx\_stream.h> ####  整型</ngx\_stream.h></p>
</blockquote>
<p> 出于一般目的，nginx代码使用两种整数类型， ngx_int_t和ngx_uint_t ，它们分别是intptr_t和uintptr_t typedef。 </p>
<h4 id="常见的返回码"><a href="#常见的返回码" class="headerlink" title="常见的返回码"></a>常见的返回码</h4><p> nginx中的大多数函数返回以下代码： </p>
<ul>
<li>NGX_OK - 操作成功。 </li>
<li>NGX_ERROR - 操作失败。 </li>
<li>NGX_AGAIN - 操作不完整; 再次调用该函数。 </li>
<li>NGX_DECLINED - 例如，操作被拒绝，因为它在配置中被禁用。 这绝不是一个错误。 </li>
<li>NGX_BUSY - 资源不可用。 </li>
<li>NGX_DONE - 操作完成或在其他地方继续。 也用作替代成功代码。 </li>
<li><p>NGX_ABORT - 功能已中止。 也用作替代错误代码。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>ngx_errno宏返回上一个系统错误代码。 它映射到POSIX平台上的errno和Windows中的GetLastError()调用。 ngx_socket_errno宏返回最后一个套接字错误号。 与ngx_errno宏一样，它映射到POSIX平台上的errno 。 它映射到Windows上的WSAGetLastError()调用。 ngx_socket_errno多次访问ngx_errno或ngx_socket_errno的值可能会导致性能问题。 如果可能多次使用错误值，请将其存储在ngx_err_t类型的本地变量中。 要设置错误，请使用ngx_set_errno(errno)和ngx_set_socket_errno(errno)宏。 </p>
<p>ngx_errno和ngx_socket_errno的值可以传递给日志函数ngx_log_error()和ngx_log_debugX() ，在这种情况下，系统错误文本将添加到日志消息中。 </p>
<p>使用ngx_errno示例： </p>
</li>
</ul>
<blockquote>
<p>void ngx_my_kill(ngx_pid_t pid, ngx_log_t *log, int signo) { ngx_err_t err; if (kill(pid, signo) == -1) { err = ngx_errno; ngx_log_error(NGX_LOG_ALERT, log, err, “kill(%P, %d) failed”, pid, signo); if (err == NGX_ESRCH) { return 2; } return 1; } return 0; } ####  字符串</p>
</blockquote>
<h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p> 对于C字符串，nginx使用无符号字符类型指针u_char * 。 </p>
<p> nginx字符串类型ngx_str_t定义如下： </p>
<blockquote>
<p>typedef struct { size_t len; u_char *data; } ngx_str_t;  len字段保存字符串长度， data保存字符串数据。 保存在ngx_str_t中的ngx_str_t在len字节之后可能会或可能不会以空值终止。 在大多数情况下，事实并非如此。 但是，在代码的某些部分（例如，在解析配置时），已知ngx_str_t对象以空值终止，这简化了字符串比较并使字符串更容易传递给系统调用。 </p>
</blockquote>
<p> nginx中的字符串操作在src/core/ngx_string.h中声明。其中一些是围绕标准C函数的包装器： </p>
<ul>
<li><p>ngx_strcmp() </p>
<ul>
<li>ngx_strncmp() </li>
<li>ngx_strstr() </li>
<li>ngx_strlen() </li>
<li>ngx_strchr() </li>
<li>ngx_memcmp() </li>
<li>ngx_memset() </li>
<li>ngx_memcpy() </li>
<li>ngx_memmove()<br>其他字符串函数是特定于nginx的 </li>
</ul>
</li>
<li><p>ngx_memzero() - 用零填充内存。 </p>
</li>
<li>ngx_explicit_memzero() - 与ngx_memzero()相同，但编译器的死存储消除优化永远不会删除此调用。 此功能可用于清除密码和密钥等敏感数据。 </li>
<li>ngx_cpymem() - 与ngx_memcpy()相同，但返回最终目标地址这个可以方便地连续添加多个字符串。 </li>
<li>ngx_movemem() - 与ngx_memmove()相同，但返回最终目标地址。 </li>
<li><p>ngx_strlchr() - 搜索字符串中的字符，由两个指针分隔。<br>以下函数执行大小写转换和比较： </p>
</li>
<li><p>ngx_tolower() </p>
<ul>
<li>ngx_toupper() </li>
<li>ngx_strlow() </li>
<li>ngx_strcasecmp() </li>
<li>ngx_strncasecmp()<br>以下宏简化了字符串初始化： </li>
</ul>
</li>
<li><p>ngx_string(text) - 来自C字符串文字text的ngx_str_t类型的静态初始值设定项 </p>
</li>
<li>ngx_null_string - ngx_str_t类型的静态空字符串初始值设定项 </li>
<li>ngx_str_set(str, text) - 使用C字符串文字text初始化ngx_str_t * type的字符串str </li>
<li><p>ngx_str_null(str) - 使用空字符串初始化ngx_str_t * type的字符串str </p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>以下格式化函数支持特定于nginx的类型： </p>
</li>
<li><p>ngx_sprintf(buf, fmt, …) </p>
<ul>
<li>ngx_snprintf(buf, max, fmt, …) </li>
<li>ngx_slprintf(buf, last, fmt, …) </li>
<li>ngx_vslprintf(buf, last, fmt, args) </li>
<li>ngx_vsnprintf(buf, max, fmt, args)<br>这些函数支持的格式化选项的完整列表位于src/core/ngx_string.c 。 他们之中有一些是： </li>
</ul>
</li>
<li><p>%O - off_t </p>
</li>
<li>%T - time_t </li>
<li>%z - ssize_t </li>
<li>%i - ngx_int_t </li>
<li>%p - void * </li>
<li>%V - ngx_str_t * </li>
<li>%s - u_char * （以null结尾） </li>
<li><p>%<em>s - size_t + u_char </em><br>您可以在大多数类型上添加前缀以使其无符号。 要将输出转换为十六进制，请使用X或x 。 </p>
<p>例如： </p>
</li>
</ul>
<blockquote>
<p>u_char buf[NGX_INT_T_LEN]; size_t len; ngx_uint_t n; /<em> set n here </em>/ len = ngx_sprintf(buf, “%ui”, n) — buf; ####  数字转换</p>
</blockquote>
<p> 在nginx中实现了几个用于数值转换的函数。 前四个每个都将给定长度的字符串转换为指定类型的正整数。 它们在出错时返回NGX_ERROR 。 </p>
<ul>
<li>ngx_atoi(line, n) - ngx_int_t </li>
<li>ngx_atosz(line, n) - ssize_t </li>
<li>ngx_atoof(line, n) - off_t </li>
<li><p>ngx_atotm(line, n) - time_t<br>还有两个额外的数字转换函数。 与前四个一样，他们在出错时返回NGX_ERROR 。 </p>
</li>
<li><p>ngx_atofp(line, n, point) - 将给定长度的固定点浮点数转换为ngx_int_t类型的正整数。 结果左移小数点位置。 数字的字符串表示形式预计不会超过小数位数。 例如， ngx_atofp(“10.5”, 4, 2)返回1050 。 </p>
</li>
<li><p>ngx_hextoi(line, n) - 将正整数的十六进制表示形式转换为ngx_int_t 。 </p>
<h4 id="常用表达"><a href="#常用表达" class="headerlink" title="常用表达"></a>常用表达</h4><p>nginx中的正则表达式接口是PCRE库的包装器。 相应的头文件是src/core/ngx_regex.h 。 </p>
<p>要使用正则表达式进行字符串匹配，首先需要编译它，这通常在配置阶段完成。 请注意，由于PCRE支持是可选的，因此使用该接口的所有代码都必须受到周围NGX_PCRE宏的保护： </p>
</li>
</ul>
<blockquote>
<p>#if (NGX_PCRE) ngx_regex_t <em>re; ngx_regex_compile_t rc; u_char errstr[NGX_MAX_CONF_ERRSTR]; ngx_str_t value = ngx_string(“message (\d\d\d).</em>Codeword is ‘(?<cw>\w+)’”); ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); rc.pattern = value; rc.pool = cf-&gt;pool; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; /<em> rc.options are passed as is to pcre_compile() </em>/ if (ngx_regex_compile(&amp;rc) != NGX_OK) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, “%V”, &amp;rc.err); return NGX_CONF_ERROR; } re = rc.regex; #endif  编译成功后， ngx_regex_compile_t结构中的ngx_regex_compile_t和named_captures字段ngx_regex_compile_t包含正则表达式中的所有捕获和命名捕获的计数。 </cw></p>
</blockquote>
<p> 然后可以使用编译的正则表达式来匹配字符串： </p>
<blockquote>
<p>ngx_int_t n; int captures[(1 + rc.captures) <em> 3]; ngx_str_t input = ngx_string(“This is message 123. Codeword is ‘foobar’.”); n = ngx_regex_exec(re, &amp;input, captures, (1 + rc.captures) </em> 3); if (n &gt;= 0) { /<em> string matches expression </em>/ } else if (n == NGX_REGEX_NO_MATCHED) { /<em> no match was found </em>/ } else { /<em> some error </em>/ ngx_log_error(NGX_LOG_ALERT, log, 0, ngx_regex_exec_n “ failed: %i”, n); }  ngx_regex_exec()的参数是编译的正则表达式re ，匹配s的字符串，用于保存找到的任何captures的可选整数数组以及数组的size 。 根据PCRE API的要求， captures数组的大小必须是三的倍数。 在该示例中，大小是根据匹配的字符串本身的总捕获数加1 。 </p>
</blockquote>
<p> 如果有匹配，则可以按如下方式访问捕获： </p>
<blockquote>
<p>u_char <em>p; size_t size; ngx_str_t name, value; /</em> all captures <em>/ for (i = 0; i &lt; n </em> 2; i += 2) { value.data = input.data + captures[i]; value.len = captures[i + 1] — captures[i]; } /<em> accessing named captures </em>/ size = rc.name_size; p = rc.names; for (i = 0; i &lt; rc.named_captures; i++, p += size) { /<em> capture name </em>/ name.data = &amp;p[2]; name.len = ngx_strlen(name.data); n = 2 <em> ((p[0] &lt;&lt; 8) + p[1]); /</em> captured value */ value.data = &amp;input.data[captures[n]]; value.len = captures[n + 1] — captures[n]; }  ngx_regex_exec_array()函数接受ngx_regex_elt_t元素的数组（它们只是具有关联名称的已编译正则表达式），要匹配的字符串和日志。 该函数将表达式从数组应用到字符串，直到找到匹配或不再有表达式为止。 当匹配时返回值为NGX_OK ，否则NGX_ERROR ，如果出错则返回值为NGX_OK 。 </p>
</blockquote>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p> ngx_time_t结构表示具有三种不同类型的时间，包括秒，毫秒和GMT偏移量： </p>
<blockquote>
<p>typedef struct { time_t sec; ngx_uint_t msec; ngx_int_t gmtoff; } ngx_time_t;  ngx_tm_t结构是UNIX平台上的struct tm和Windows上的SYSTEMTIME的别名。 </p>
</blockquote>
<p> 要获得当前时间，通常可以访问其中一个可用的全局变量，表示所需格式的缓存时间值。 </p>
<p> 可用的字符串表示形式为： </p>
<ul>
<li>ngx_cached_err_log_time - 用于错误日志条目： “1970/09/28 12:00:00” </li>
<li>ngx_cached_http_log_time - 用于HTTP访问日志条目： “28/Sep/1970:12:00:00 +0600” </li>
<li>ngx_cached_syslog_time - 用于syslog条目： “Sep 28 12:00:00” </li>
<li>ngx_cached_http_time - 用于HTTP标头： “Mon, 28 Sep 1970 06:00:00 GMT” </li>
<li><p>ngx_cached_http_log_iso8601 - ISO 8601标准格式： “1970-09-28T12:00:00+06:00”<br>ngx_time()和ngx_timeofday()宏以秒为单位返回当前时间值，是访问缓存时间值的首选方法。 </p>
<p>要显式获取时间，请使用ngx_gettimeofday() ，它更新其参数（指向struct timeval指针）。 当nginx从系统调用返回到事件循环时，时间总是更新。 要立即更新时间，请在信号处理程序上下文中更新时间时调用ngx_time_update()或ngx_time_sigsafe_update() 。 </p>
<p>以下函数将time_t转换为指示的细分时间表示。 每对中的第一个函数将time_t转换为ngx_tm_t ，将第二个函数（使用_libc_ infix）转换为struct tm ： </p>
</li>
<li><p>ngx_gmtime(), ngx_libc_gmtime() - 以UTC表示的时间 </p>
</li>
<li>ngx_localtime(), ngx_libc_localtime() - 相对于本地时区表示的时间<br>ngx_http_time(buf, time)函数返回适合在HTTP头中使用的字符串表示（例如， “Mon, 28 Sep 1970 06:00:00 GMT” ）。 ngx_http_cookie_time(buf, time)返回一个字符串表示函数，返回一个适合HTTP cookie的字符串表示（ “Thu, 31-Dec-37 23:55:55 GMT” ）。 </li>
</ul>
<h4 id="集装箱"><a href="#集装箱" class="headerlink" title="集装箱"></a>集装箱</h4><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p> nginx数组类型ngx_array_t定义如下 </p>
<blockquote>
<p>typedef struct { void <em>elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t </em>pool; } ngx_array_t;  elts字段中提供了数组的元素。 nelts字段包含元素的数量。 size字段保存单个元素的大小，并在初始化数组时设置。 </p>
</blockquote>
<p> 使用ngx_array_create(pool, n, size)调用在池中创建数组，并使用ngx_array_init(array, pool, n, size)调用来初始化已分配的数组对象。 </p>
<blockquote>
<p>ngx_array_t <em>a, b; /</em> create an array of strings with preallocated memory for 10 elements <em>/ a = ngx_array_create(pool, 10, sizeof(ngx_str_t)); /</em> initialize string array for 10 elements */ ngx_array_init(&amp;b, pool, 10, sizeof(ngx_str_t));  使用以下函数将元素添加到数组： </p>
</blockquote>
<ul>
<li>ngx_array_push(a)添加一个尾部元素并返回指向它的指针 </li>
<li>ngx_array_push_n(a, n)添加n尾部元素并返回指向第一个元素的指针<br>如果当前分配的内存量不足以容纳新元素，则分配新的内存块并将现有元素复制到其中。 新内存块通常是现有内存块的两倍。 </li>
</ul>
<blockquote>
<p>s = ngx_array_push(a); ss = ngx_array_push_n(&amp;b, 3); ####  名单</p>
</blockquote>
<p> 在nginx中，列表是一系列数组，针对插入可能大量的项进行了优化。 ngx_list_t列表类型定义如下： </p>
<blockquote>
<p>typedef struct { ngx_list_part_t <em>last; ngx_list_part_t part; size_t size; ngx_uint_t nalloc; ngx_pool_t </em>pool; } ngx_list_t;  实际项目存储在列表部分中，其定义如下： </p>
<p>typedef struct ngx_list_part_s ngx_list_part_t; struct ngx_list_part_s { void <em>elts; ngx_uint_t nelts; ngx_list_part_t </em>next; };  在使用之前，必须通过调用ngx_list_init(list, pool, n, size)或通过调用ngx_list_create(pool, n, size)创建列表来初始化ngx_list_init(list, pool, n, size) 。 这两个函数都将单个项的大小和每个列表部分的项数作为参数。 要将项添加到列表，请使用ngx_list_push(list)函数。 要迭代这些项，请直接访问列表字段，如示例所示： </p>
<p>ngx_str_t <em>v; ngx_uint_t i; ngx_list_t </em>list; ngx_list_part_t <em>part; list = ngx_list_create(pool, 100, sizeof(ngx_str_t)); if (list == NULL) { /</em> error <em>/ } /</em> add items to the list <em>/ v = ngx_list_push(list); if (v == NULL) { /</em> error <em>/ } ngx_str_set(v, “foo”); v = ngx_list_push(list); if (v == NULL) { /</em> error <em>/ } ngx_str_set(v, “bar”); /</em> iterate over the list <em>/ part = &amp;list-&gt;part; v = part-&gt;elts; for (i = 0; /</em> void */; i++) { if (i &gt;= part-&gt;nelts) { if (part-&gt;next == NULL) { break; } part = part-&gt;next; v = part-&gt;elts; i = 0; } ngx_do_smth(&amp;v[i]); }  列表主要用于HTTP输入和输出标头。 </p>
</blockquote>
<p> 列表不支持删除项目。 但是，在需要时，项目可以在内部被标记为缺失，而不会实际从列表中删除。 例如，要将HTTP输出标头（存储为ngx_table_elt_t对象）标记为缺失，请将ngx_table_elt_t的hash字段设置为零。 迭代标题时，显式跳过以这种方式标记的项目。 </p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p> 在nginx中，队列是一个侵入式双向链表，每个节点定义如下： </p>
<blockquote>
<p>typedef struct ngx_queue_s ngx_queue_t; struct ngx_queue_s { ngx_queue_t <em>prev; ngx_queue_t </em>next; };  头队列节点未与任何数据链接。 使用前，请使用ngx_queue_init(q)调用初始化列表头。 队列支持以下操作： </p>
</blockquote>
<ul>
<li>ngx_queue_insert_head(h, x) ， ngx_queue_insert_tail(h, x) - 插入新节点 </li>
<li>ngx_queue_remove(x) - 删除队列节点 </li>
<li>ngx_queue_split(h, q, n) - 在一个节点上拆分队列，将队列尾部返回到一个单独的队列中 </li>
<li>ngx_queue_add(h, n) - 将第二个队列添加到第一个队列 </li>
<li>ngx_queue_head(h) ， ngx_queue_last(h) - 获取第一个或最后一个队列节点 </li>
<li>ngx_queue_sentinel(h) - 获取队列sentinel对象以结束迭代 </li>
<li>ngx_queue_data(q, type, link) - 获取对队列节点数据结构开头的引用，考虑其中的队列字段偏移量<br>一个例子： </li>
</ul>
<blockquote>
<p>typedef struct { ngx_str_t value; ngx_queue_t queue; } ngx_foo_t; ngx_foo_t <em>f; ngx_queue_t values, </em>q; ngx_queue_init(&amp;values); f = ngx_palloc(pool, sizeof(ngx_foo_t)); if (f == NULL) { /<em> error </em>/ } ngx_str_set(&amp;f-&gt;value, “foo”); ngx_queue_insert_tail(&amp;values, &amp;f-&gt;queue); /<em> insert more nodes here </em>/ for (q = ngx_queue_head(&amp;values); q != ngx_queue_sentinel(&amp;values); q = ngx_queue_next(q)) { f = ngx_queue_data(q, ngx_foo_t, queue); ngx_do_smth(&amp;f-&gt;value); } ####  红黑树</p>
</blockquote>
<p> src/core/ngx_rbtree.h头文件提供了对红黑树的有效实现的访问。 </p>
<blockquote>
<p>typedef struct { ngx_rbtree_t rbtree; ngx_rbtree_node_t sentinel; /<em> custom per-tree data here </em>/ } my_tree_t; typedef struct { ngx_rbtree_node_t rbnode; /<em> custom per-node data </em>/ foo_t val; } my_node_t;  要处理整个树，需要两个节点：root和sentinel。 通常，它们会添加到自定义结构中，允许您将数据组织到树中，其中树叶包含指向或嵌入数据的链接。 </p>
</blockquote>
<p> 要初始化树： </p>
<blockquote>
<p>my_tree_t root; ngx_rbtree_init(&amp;root.rbtree, &amp;root.sentinel, insert_value_function);  要遍历树并插入新值，请使用“ insert_value ”函数。 例如， ngx_str_rbtree_insert_value函数处理ngx_str_t类型。 它的参数是指向插入的根节点，要添加的新创建的节点以及树的标记的指针。 </p>
<p>void ngx_str_rbtree_insert_value(ngx_rbtree_node_t <em>temp, ngx_rbtree_node_t </em>node, ngx_rbtree_node_t *sentinel)  遍历非常简单，可以使用以下查找函数模式进行演示： </p>
<p>my_node_t <em> my_rbtree_lookup(ngx_rbtree_t </em>rbtree, foo_t <em>val, uint32_t hash) { ngx_int_t rc; my_node_t </em>n; ngx_rbtree_node_t <em>node, </em>sentinel; node = rbtree-&gt;root; sentinel = rbtree-&gt;sentinel; while (node != sentinel) { n = (my_node_t *) node; if (hash != node-&gt;key) { node = (hash &lt; node-&gt;key) ? node-&gt;left : node-&gt;right; continue; } rc = compare(val, node-&gt;val); if (rc &lt; 0) { node = node-&gt;left; continue; } if (rc &gt; 0) { node = node-&gt;right; continue; } return n; } return NULL; }  compare()函数是一个经典的比较器函数，它返回一个小于，等于或大于零的值。 为了加速查找并避免比较可能很大的用户对象，使用整数哈希字段。 </p>
</blockquote>
<p> 要将节点添加到树，请分配新节点，对其进行初始化并调用ngx_rbtree_insert() ： </p>
<blockquote>
<p> my_node_t <em>my_node; ngx_rbtree_node_t </em>node; my_node = ngx_palloc(…); init_custom_data(&amp;my_node-&gt;val); node = &amp;my_node-&gt;rbnode; node-&gt;key = create_key(my_node-&gt;val); ngx_rbtree_insert(&amp;root-&gt;rbtree, node);  要删除节点，请调用ngx_rbtree_delete()函数： </p>
<p>ngx_rbtree_delete(&amp;root-&gt;rbtree, node); ####  哈希</p>
</blockquote>
<p> 散列表函数在src/core/ngx_hash.h 。 支持精确匹配和通配符匹配。 后者需要额外的设置，并在下面的单独部分中描述。 </p>
<p> 在初始化哈希之前，您需要知道它将保留的元素数量，以便nginx可以最佳地构建它。 需要配置的两个参数是max_size和bucket_size ，详见单独的文档 。 它们通常可由用户配置。 散列初始化设置与ngx_hash_init_t类型一起存储，散列本身为ngx_hash_t ： </p>
<blockquote>
<p>ngx_hash_t foo_hash; ngx_hash_init_t hash; hash.hash = &amp;foo_hash; hash.key = ngx_hash_key; hash.max_size = 512; hash.bucket_size = ngx_align(64, ngx_cacheline_size); hash.name = “foo_hash”; hash.pool = cf-&gt;pool; hash.temp_pool = cf-&gt;temp_pool;  key是指向函数的指针，该函数从字符串创建哈希整数键。 有两个通用的密钥创建函数： ngx_hash_key(data, len)和ngx_hash_key_lc(data, len) 。 后者将字符串转换为全部小写字符，因此传递的字符串必须是可写的。 如果不是这样，将NGX_HASH_READONLY_KEY标志传递给函数，初始化密钥数组（见下文）。 </p>
</blockquote>
<p> 散列键存储在ngx_hash_keys_arrays_t ，并使用ngx_hash_keys_array_init(arr, type)初始化：第二个参数（ type ）控制为散列预分配的资源量，可以是NGX_HASH_SMALL或NGX_HASH_LARGE 。 如果您希望散列包含数千个元素，则后者是合适的。 </p>
<blockquote>
<p>ngx_hash_keys_arrays_t foo_keys; foo_keys.pool = cf-&gt;pool; foo_keys.temp_pool = cf-&gt;temp_pool; ngx_hash_keys_array_init(&amp;foo_keys, NGX_HASH_SMALL);  要将键插入哈希键数组，请使用ngx_hash_add_key(keys_array, key, value, flags)函数： </p>
<p>ngx_str_t k1 = ngx_string(“key1”); ngx_str_t k2 = ngx_string(“key2”); ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;my_data_ptr_1, NGX_HASH_READONLY_KEY); ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;my_data_ptr_2, NGX_HASH_READONLY_KEY);  要构建哈希表，请调用ngx_hash_init(hinit, key_names, nelts)函数： </p>
<p>ngx_hash_init(&amp;hash, foo_keys.keys.elts, foo_keys.keys.nelts);  如果max_size或bucket_size参数不够大，则该函数失败。 </p>
</blockquote>
<p> 构建哈希时，使用ngx_hash_find(hash, key, name, len)函数查找元素： </p>
<blockquote>
<p>my_data_t <em>data; ngx_uint_t key; key = ngx_hash_key(k1.data, k1.len); data = ngx_hash_find(&amp;foo_hash, key, k1.data, k1.len); if (data == NULL) { /</em> key not found */ } ####  通配符匹配</p>
</blockquote>
<p> 要创建使用通配符的哈希，请使用ngx_hash_combined_t类型。 它包括上面描述的散列类型，并有两个额外的键数组： dns_wc_head和dns_wc_tail 。 基本属性的初始化类似于常规哈希： </p>
<blockquote>
<p>ngx_hash_init_t hash ngx_hash_combined_t foo_hash; hash.hash = &amp;foo_hash.hash; hash.key = …;  可以使用NGX_HASH_WILDCARD_KEY标志添加通配符键： </p>
<p>/<em> k1 = “.example.org”; </em>/ /<em> k2 = “foo.</em>“; */ ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;data1, NGX_HASH_WILDCARD_KEY); ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;data2, NGX_HASH_WILDCARD_KEY);  该函数识别通配符并将键添加到相应的数组中。 有关通配符语法和匹配算法的说明，请参阅映射模块文档。 </p>
</blockquote>
<p> 根据添加的键的内容，您可能需要初始化最多三个键阵列：一个用于精确匹配（如上所述），另外两个用于从字符串的头部或尾部开始匹配： </p>
<blockquote>
<p>if (foo_keys.dns_wc_head.nelts) { ngx_qsort(foo_keys.dns_wc_head.elts, (size_t) foo_keys.dns_wc_head.nelts, sizeof(ngx_hash_key_t), cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = pool; if (ngx_hash_wildcard_init(&amp;hash, foo_keys.dns_wc_head.elts, foo_keys.dns_wc_head.nelts) != NGX_OK) { return NGX_ERROR; } foo_hash.wc_head = (ngx_hash_wildcard_t *) hash.hash; }  需要对keys数组进行排序，并且必须将初始化结果添加到组合哈希中。 dns_wc_tail数组的初始化类似地完成。 </p>
</blockquote>
<p> 组合哈希中的查找由ngx_hash_find_combined(chash, key, name, len) ： </p>
<blockquote>
<p>/<em> key = “bar.example.org”; — will match “.example.org” </em>/ /<em> key = “foo.example.com”; — will match “foo.</em>“ */ hkey = ngx_hash_key(key.data, key.len); res = ngx_hash_find_combined(&amp;foo_hash, hkey, key.data, key.len); ####  内存管理</p>
</blockquote>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p> 要从系统堆分配内存，请使用以下函数： </p>
<ul>
<li>ngx_alloc(size, log) - 从系统堆分配内存。 这是malloc()的包装，具有日志记录支持。 分配错误和调试信息将记录到log 。 </li>
<li>ngx_calloc(size, log) - 从系统堆分配内存，如ngx_alloc() ，但在分配后用零填充内存。 </li>
<li>ngx_memalign(alignment, size, log) - 从系统堆中分配对齐的内存。 这是提供该功能的那些平台上posix_memalign()的包装器。 否则，实现将回ngx_alloc() ，它提供了最大的对齐。 </li>
<li><p>ngx_free(p) - 免费分配的内存。 这是free()的包装器 </p>
<h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>大多数nginx分配都是在池中完成的。 当池被销毁时，nginx池中分配的内存将自动释放。 这提供了良好的分配性能并使内存控制变得容易。 </p>
<p>池内部在连续的内存块中分配对象。 块已满后，将分配一个新块并将其添加到池内存块列表中。 当请求的分配太大而无法容纳到块中时，请求将被转发到系统分配器，并且返回的指针将存储在池中以进一步解除分配。 </p>
<p>nginx池的类型是ngx_pool_t 。 支持以下操作： </p>
</li>
<li><p>ngx_create_pool(size, log) - 创建具有指定块大小的池。 返回的池对象也在池中分配。 size至少应为NGX_MIN_POOL_SIZE和NGX_MIN_POOL_SIZE的倍数。 </p>
</li>
<li>ngx_destroy_pool(pool) - 释放所有池内存，包括池对象本身。 </li>
<li>ngx_palloc(pool, size) - 从指定的池中分配对齐的内存。 </li>
<li>ngx_pcalloc(pool, size) - 从指定的池中分配对齐的内存并用零填充它。 </li>
<li>ngx_pnalloc(pool, size) - 从指定的池中分配未对齐的内存。 主要用于分配字符串。 </li>
<li>ngx_pfree(pool, p) - 以前在指定池中分配的ngx_pfree(pool, p)内存。 只能释放由转发到系统分配器的请求产生的分配。 </li>
</ul>
<blockquote>
<p>u_char <em>p; ngx_str_t </em>s; ngx_pool_t <em>pool; pool = ngx_create_pool(1024, log); if (pool == NULL) { /</em> error <em>/ } s = ngx_palloc(pool, sizeof(ngx_str_t)); if (s == NULL) { /</em> error <em>/ } ngx_str_set(s, “foo”); p = ngx_pnalloc(pool, 3); if (p == NULL) { /</em> error */ } ngx_memcpy(p, “foo”, 3);  链接（ ngx_chain_t ）在nginx中被主动使用，因此nginx池实现提供了重用它们的方法。 ngx_pool_t的chain字段保留了先前分配的链接列表，可以重用。 要在池中有效分配链路链接，请使用ngx_alloc_chain_link(pool)功能。 此函数在池列表中查找自由链链接，并在池列表为空时分配新的链链接。 要释放链接，请调用ngx_free_chain(pool, cl)函数。 </p>
</blockquote>
<p> 清理处理程序可以在池中注册。 清理处理程序是一个带有参数的回调函数，该函数在销毁池时调用。 池通常绑定到特定的nginx对象（如HTTP请求），并在对象到达其生命周期结束时被销毁。 注册池清理是释放资源，关闭文件描述符或对与主对象关联的共享数据进行最终调整的便捷方式。 </p>
<p> 要注册池清理，请调用ngx_pool_cleanup_add(pool, size) ，它返回一个要由调用者填写的ngx_pool_cleanup_t指针。 使用size参数为清理处理程序分配上下文。 </p>
<blockquote>
<p>ngx_pool_cleanup_t <em>cln; cln = ngx_pool_cleanup_add(pool, 0); if (cln == NULL) { /</em> error <em>/ } cln-&gt;handler = ngx_my_cleanup; cln-&gt;data = “foo”; … static void ngx_my_cleanup(void </em>data) { u_char *msg = data; ngx_do_smth(msg); } ####  共享内存</p>
</blockquote>
<p> nginx使用共享内存在进程之间共享公共数据。 ngx_shared_memory_add(cf, name, size, tag)函数将新的共享内存条目ngx_shm_zone_t到循环中。 该函数接收区域的name和size 。 每个共享区域必须具有唯一名称。 如果已存在具有提供的name和tag的共享区域条目，则重用现有区域条目。 如果具有相同名称的现有条目具有不同的标记，则该函数将失败并显示错误。 通常，模块结构的地址作为tag传递，从而可以在一个nginx模块中按名称重用共享区域。 </p>
<p> 共享内存条目结构ngx_shm_zone_t具有以下字段： </p>
<ul>
<li>init - 初始化回调，在共享区域映射到实际内存后调用 </li>
<li>data - 数据上下文，用于将任意数据传递给init回调 </li>
<li>noreuse - 禁用旧循环重用共享区域的标志 </li>
<li>tag - 共享区域标记 </li>
<li><p>shm - 类型为ngx_shm_t的特定于平台的对象，至少包含以下字段： </p>
<ul>
<li>addr - 映射共享内存地址，最初为NULL </li>
<li>size - 共享内存大小 </li>
<li>name - 共享内存名称 </li>
<li>log - 共享内存日志 </li>
<li>exists - 表示共享内存的标志是从主进程继承的（特定于Windows） </li>
</ul>
<p>解析配置后，共享区域条目将映射到ngx_init_cycle()实际内存。 在POSIX系统上， mmap() syscall用于创建共享匿名映射。 在Windows上，使用CreateFileMapping() / MapViewOfFileEx()对。 </p>
<p>对于在共享内存中分配，nginx提供slab池ngx_slab_pool_t类型。 在每个nginx共享区域中自动创建用于分配内存的slab池。 该池位于共享区域的开头，可以通过表达式(ngx_slab_pool_t *) shm_zone-&gt;shm.addr 。 要在共享区域中分配内存，请调用ngx_slab_alloc(pool, size)或ngx_slab_calloc(pool, size) 。 要释放内存，请调用ngx_slab_free(pool, p) 。 </p>
<p>Slab池将所有共享区域划分为页面。 每个页面用于分配相同大小的对象。 指定的大小必须是2的幂，并且大于8字节的最小大小。 不合格的值被四舍五入。 每个页面的位掩码跟踪正在使用哪些块以及哪些块可以自由分配。 对于大于半页（通常为2048字节）的大小，一次分配整个页面 </p>
<p>要保护共享内存中的数据不受并发访问影响，请使用ngx_slab_pool_t的mutex字段中提供的mutex 。 在分配和释放内存时，板块池最常使用互斥锁，但它可用于保护共享区域中分配的任何其他用户数据结构。 要锁定或解锁互斥锁，请分别调用ngx_shmtx_lock(&amp;shpool-&gt;mutex)或ngx_shmtx_unlock(&amp;shpool-&gt;mutex) 。 </p>
</li>
</ul>
<blockquote>
<p>ngx_str_t name; ngx_foo_ctx_t <em>ctx; ngx_shm_zone_t </em>shm_zone; ngx_str_set(&amp;name, “foo”); /<em> allocate shared zone context </em>/ ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_foo_ctx_t)); if (ctx == NULL) { /<em> error </em>/ } /<em> add an entry for 64k shared zone </em>/ shm_zone = ngx_shared_memory_add(cf, &amp;name, 65536, &amp;ngx_foo_module); if (shm_zone == NULL) { /<em> error </em>/ } /<em> register init callback and context </em>/ shm_zone-&gt;init = ngx_foo_init_zone; shm_zone-&gt;data = ctx; … static ngx_int_t ngx_foo_init_zone(ngx_shm_zone_t <em>shm_zone, void </em>data) { ngx_foo_ctx_t <em>octx = data; size_t len; ngx_foo_ctx_t </em>ctx; ngx_slab_pool_t <em>shpool; value = shm_zone-&gt;data; if (octx) { /</em> reusing a shared zone from old cycle <em>/ ctx-&gt;value = octx-&gt;value; return NGX_OK; } shpool = (ngx_slab_pool_t </em>) shm_zone-&gt;shm.addr; if (shm_zone-&gt;shm.exists) { /<em> initialize shared zone context in Windows nginx worker </em>/ ctx-&gt;value = shpool-&gt;data; return NGX_OK; } /<em> initialize shared zone </em>/ ctx-&gt;value = ngx_slab_alloc(shpool, sizeof(ngx_uint_t)); if (ctx-&gt;value == NULL) { return NGX_ERROR; } shpool-&gt;data = ctx-&gt;value; return NGX_OK; } ####  记录</p>
</blockquote>
<p> 对于日志记录，nginx使用ngx_log_t对象。 nginx记录器支持几种类型的输出： </p>
<ul>
<li>stderr - 记录到标准错误（stderr） </li>
<li>file - 记录到文件 </li>
<li>syslog - 记录到syslog </li>
<li><p>memory - 记录到内部存储器以用于开发目的; 稍后可以使用调试器访问内存<br>记录器实例可以是记录器链，使用next字段相互链接。 在这种情况下，每条消息都写入链中的所有记录器。 </p>
<p>对于每个记录器，严重性级别控制将哪些消息写入日志（仅记录分配了该级别或更高级别的事件）。 支持以下严重性级别： </p>
</li>
<li><p>NGX_LOG_EMERG </p>
<ul>
<li>NGX_LOG_ALERT </li>
<li>NGX_LOG_CRIT </li>
<li>NGX_LOG_ERR </li>
<li>NGX_LOG_WARN </li>
<li>NGX_LOG_NOTICE </li>
<li>NGX_LOG_INFO </li>
<li>NGX_LOG_DEBUG<br>对于调试日志记录，还会检查调试掩码。 调试掩码是： </li>
</ul>
</li>
<li><p>NGX_LOG_DEBUG_CORE </p>
<ul>
<li>NGX_LOG_DEBUG_ALLOC </li>
<li>NGX_LOG_DEBUG_MUTEX </li>
<li>NGX_LOG_DEBUG_EVENT </li>
<li>NGX_LOG_DEBUG_HTTP </li>
<li>NGX_LOG_DEBUG_MAIL </li>
<li>NGX_LOG_DEBUG_STREAM<br>通常，记录器是由error_log指令中的现有nginx代码创建的，几乎在循环，配置，客户端连接和其他对象的每个处理阶段都可用。 </li>
</ul>
<p>Nginx提供以下日志记录宏： </p>
</li>
<li><p>ngx_log_error(level, log, err, fmt, …) - 错误记录 </p>
</li>
<li>ngx_log_debug0(level, log, err, fmt) ， ngx_log_debug1(level, log, err, fmt, arg1)等 - 使用最多八个支持的格式化参数调试日志记录<br>日志消息在堆栈中的大小为NGX_MAX_ERROR_STR （当前为2048字节）的缓冲区中格式化。 该消息前面附有严重性级别，进程ID（PID），连接ID（存储在log-&gt;connection ）和系统错误文本。 对于非调试消息，还调用log-&gt;handler以将更多特定信息添加到日志消息中。 HTTP模块将ngx_http_log_error()函数设置为日志处理程序，以记录客户端和服务器地址，当前操作（存储在log-&gt;action ），客户端请求行，服务器名称等。 </li>
</ul>
<blockquote>
<p>/<em> specify what is currently done </em>/ log-&gt;action = “sending mp4 to client”; /<em> error and debug log </em>/ ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0, “client prematurely closed connection”); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4-&gt;file.log, 0, “mp4 start:%ui, length:%ui”, mp4-&gt;start, mp4-&gt;length);  上面的示例导致日志条目如下： </p>
<p>2016/09/16 22:08:52 [info] 17445#0: <em>1 client prematurely closed connection while sending mp4 to client, client: 127.0.0.1, server: , request: “GET /file.mp4 HTTP/1.1” 2016/09/16 23:28:33 [debug] 22140#0: </em>1 mp4 start:0, length:10000 ####  周期</p>
</blockquote>
<p> 循环对象存储从特定配置创建的nginx运行时上下文。 它的类型是ngx_cycle_t 。 当前循环由ngx_cycle全局变量引用，并在nginx worker启动时继承。 每次重新加载nginx配置时，都会从新的nginx配置创建一个新的循环; 成功创建新循环后，通常会删除旧循环。 </p>
<p> 循环由ngx_init_cycle()函数创建，该函数将前一个循环作为其参数。 该函数定位上一个循环的配置文件，并从前一个循环继承尽可能多的资源。 称为“初始循环”的占位符循环创建为nginx启动，然后由从配置构建的实际循环替换。 </p>
<p> 该周期的成员包括： </p>
<ul>
<li>pool - 自行车游泳池 为每个新周期创建。 </li>
<li>log - 循环日志。 最初从旧循环继承，在读取配置后将其设置为指向new_log 。 </li>
<li>new_log - 由配置创建的循环日志。 它受根范围error_log指令的影响。 </li>
<li>connections ， connection_n - 类型为ngx_connection_t的连接数组，由事件模块在初始化每个nginx worker时创建。 nginx配置中的worker_connections指令设置连接数connection_n 。 </li>
<li>free_connections ， free_connection_n - 当前可用连接的列表和数量。 如果没有可用的连接，则nginx工作程序拒绝接受新客户端或连接到上游服务器。 </li>
<li>files ， files_n - 用于将文件描述符映射到nginx连接的数组。 该映射由具有NGX_USE_FD_EVENT标志的事件模块使用（当前，它是poll和devpoll ）。 </li>
<li>conf_ctx - 核心模块配置数组。 在读取nginx配置文件期间创建并填充配置。 </li>
<li>modules ， modules_n - 由当前配置加载的ngx_module_t类型的模块数组，包括静态和动态模块。 </li>
<li>listening - ngx_listening_t类型的侦听对象数组。 通常通过调用ngx_create_listening()函数的不同模块的listen指令添加侦听对象。 侦听套接字是基于侦听对象创建的。 </li>
<li><p>paths - ngx_path_t类型的路径数组。 通过从将在某些目录上运行的模块调用函数ngx_add_path()来添加路径。 这些目录是在读取配置后由nginx创建的，如果缺少的话。 此外，可以为每个路径添加两个处理程序： </p>
<ul>
<li>path loader - 在启动或重新加载nginx后，仅在60秒内执行一次。 通常，加载程序读取目录并将数据存储在nginx共享内存中。 从专用的nginx进程“nginx缓存加载器”调用该处理程序。 </li>
<li>路径管理器 - 定期执行。 通常，管理器从目录中删除旧文件并更新nginx内存以反映更改。 处理程序从专用的“nginx缓存管理器”进程调用。 </li>
</ul>
</li>
<li><p>open_files - 类型为ngx_open_file_t的打开文件对象列表，通过调用函数ngx_conf_open_file() 。 目前，nginx使用这种打开的文件进行日志记录。 读取配置后，nginx将打开open_files列表中的所有文件，并将每个文件描述符存储在对象的fd字段中。 文件以附加模式打开，如果缺少则创建。 列表中的文件在收到重新打开信号（最常见的是USR1 ）后由nginx worker重新打开。 在这种情况下， fd字段中的描述符将更改为新值。 </p>
</li>
<li><p>shared_memory - 共享内存区域列表，每个区域都通过调用ngx_shared_memory_add()函数添加。 共享区域映射到所有nginx进程中的相同地址范围，并用于共享公共数据，例如HTTP缓存内存树。 </p>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>对于输入/输出操作，nginx提供缓冲区类型ngx_buf_t 。 通常，它用于保存要写入目标或从源读取的数据。 缓冲区可以引用内存或文件中的数据，从技术上讲，缓冲区可以同时引用这两个数据。 缓冲区的内存是单独分配的，与缓冲区结构ngx_buf_t 。 </p>
<p>ngx_buf_t结构包含以下字段： </p>
</li>
<li><p>start ， end - 为缓冲区分配的内存块的边界。 </p>
</li>
<li>pos ， last - 内存缓冲区的边界; 通常是一个start的子范围.. end 。 </li>
<li>file_pos ， file_last - 文件缓冲区的边界，表示为从文件开头的偏移量。 </li>
<li>tag - 用于区分缓冲区的唯一值; 由不同的nginx模块创建，通常用于缓冲区重用。 </li>
<li>file - 文件对象。 </li>
<li>temporary - 指示缓冲区引用可写内存的标志。 </li>
<li>memory - 指示缓冲区引用只读memory标志。 </li>
<li>in_file - 指示缓冲区引用文件中数据的标志。 </li>
<li>flush - 表示需要刷新缓冲区之前的所有数据的标志。 </li>
<li>recycled - 表示缓冲区可以重用并需要尽快使用的标志。 </li>
<li>sync - 表示缓冲区不携带数据或flush或last_buf等特殊信号的last_buf 。 默认情况下，nginx认为这样的缓冲区是一个错误条件，但是这个标志告诉nginx跳过错误检查。 </li>
<li>last_buf - 表示缓冲区是输出中的最后一个的标志。 </li>
<li>last_in_chain - 表示请求或子请求中不再有数据缓冲区的标志。 </li>
<li>shadow - 引用与当前缓冲区相关的另一个（“shadow”）缓冲区，通常是缓冲区使用阴影中的数据。 消耗缓冲区时，通常还将阴影缓冲区标记为已消耗。 </li>
<li>last_shadow - 指示缓冲区是引用特定影子缓冲区的最后一个缓冲区的标志。 </li>
<li>temp_file - 指示缓冲区位于临时文件中的标志。<br>对于输入和输出操作，缓冲区链接在一起。 链是ngx_chain_t类型的链序列，定义如下： </li>
</ul>
<blockquote>
<p>typedef struct ngx_chain_s ngx_chain_t; struct ngx_chain_s { ngx_buf_t <em>buf; ngx_chain_t </em>next; };  每个链节都保持对其缓冲区的引用和对下一个链节的引用。 </p>
</blockquote>
<p> 使用缓冲区和链的示例： </p>
<blockquote>
<p>ngx_chain_t <em> ngx_get_my_chain(ngx_pool_t </em>pool) { ngx_buf_t <em>b; ngx_chain_t </em>out, <em>cl, **ll; /</em> first buf <em>/ cl = ngx_alloc_chain_link(pool); if (cl == NULL) { /</em> error <em>/ } b = ngx_calloc_buf(pool); if (b == NULL) { /</em> error <em>/ } b-&gt;start = (u_char </em>) “foo”; b-&gt;pos = b-&gt;start; b-&gt;end = b-&gt;start + 3; b-&gt;last = b-&gt;end; b-&gt;memory = 1; /<em> read-only memory </em>/ cl-&gt;buf = b; out = cl; ll = &amp;cl-&gt;next; /<em> second buf </em>/ cl = ngx_alloc_chain_link(pool); if (cl == NULL) { /<em> error </em>/ } b = ngx_create_temp_buf(pool, 3); if (b == NULL) { /<em> error </em>/ } b-&gt;last = ngx_cpymem(b-&gt;last, “foo”, 3); cl-&gt;buf = b; cl-&gt;next = NULL; *ll = cl; return out; } ####  联网</p>
</blockquote>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p> 连接类型ngx_connection_t是套接字描述符的包装器。 它包括以下字段： </p>
<ul>
<li>fd - 套接字描述符 </li>
<li>data - 任意连接上下文。 通常，它是指向在连接之上构建的更高级别对象的指针，例如HTTP请求或Stream会话。 </li>
<li>read ， write - 读取和写入连接事件。 </li>
<li>recv ， send ， recv_chain ， send_chain - 连接的I / O操作。 </li>
<li>pool - 连接池。 </li>
<li>log - 连接日志。 </li>
<li>sockaddr ， socklen ， addr_text - 二进制和文本形式的远程套接字地址。 </li>
<li>local_sockaddr ， local_socklen - 二进制形式的本地套接字地址。 最初，这些字段为空。 使用ngx_connection_local_sockaddr()函数获取本地套接字地址。 </li>
<li>proxy_protocol_addr ， proxy_protocol_port - PROXY协议客户端地址和端口，如果为连接启用了PROXY协议。 </li>
<li>ssl - 连接的SSL上下文。 </li>
<li>reusable - 指示连接处于允许重用的状态的标志。 </li>
<li><p>close - 表示正在重用连接并需要close标志。<br>nginx连接可以透明地封装SSL层。 在这种情况下，连接的ssl字段包含指向ngx_ssl_connection_t结构的指针，保留连接的所有SSL相关数据，包括SSL_CTX和SSL 。 recv ， send ， recv_chain和send_chain处理程序也设置为启用SSL的函数。 </p>
<p>nginx配置中的worker_connections指令限制了每个nginx worker的连接数。 当工人启动并存储在循环对象的connections字段中时，所有连接结构都是预先创建的。 要检索连接结构，请使用ngx_get_connection(s, log)函数。 它需要一个套接字描述符作为其参数，它需要包装在一个连接结构中。 </p>
<p>Because the number of connections per worker is limited, nginx provides a way to grab connections that are currently in use. To enable or disable reuse of a connection, call the ngx_reusable_connection(c, reusable) function. Calling ngx_reusable_connection(c, 1) sets the reuse flag in the connection structure and inserts the connection into the reusable_connections_queue of the cycle. Whenever ngx_get_connection() finds out there are no available connections in the cycle’s free_connections list, it calls ngx_drain_connections() to release a specific number of reusable connections. For each such connection, the close flag is set and its read handler is called which is supposed to free the connection by calling ngx_close_connection(c) and make it available for reuse. To exit the state when a connection can be reused ngx_reusable_connection(c, 0) is called. HTTP client connections are an example of reusable connections in nginx; they are marked as reusable until the first request byte is received from the client. </p>
</li>
</ul>
<h4 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p> Event object ngx_event_t in nginx provides a mechanism for notification that a specific event has occurred. </p>
<p> Fields in ngx_event_t include: </p>
<ul>
<li>data — Arbitrary event context used in event handlers, usually as pointer to a connection related to the event. </li>
<li>handler — Callback function to be invoked when the event happens. </li>
<li>write — Flag indicating a write event. Absence of the flag indicates a read event. </li>
<li>active — Flag indicating that the event is registered for receiving I/O notifications, normally from notification mechanisms like epoll , kqueue , poll . </li>
<li>ready — Flag indicating that the event has received an I/O notification. </li>
<li>delayed — Flag indicating that I/O is delayed due to rate limiting. </li>
<li>timer — Red-black tree node for inserting the event into the timer tree. </li>
<li>timer_set — Flag indicating that the event timer is set and not yet expired. </li>
<li>timedout — Flag indicating that the event timer has expired. </li>
<li>eof — Flag indicating that EOF occurred while reading data. </li>
<li>pending_eof — Flag indicating that EOF is pending on the socket, even though there may be some data available before it. The flag is delivered via the EPOLLRDHUP epoll event or EV_EOF kqueue flag. </li>
<li>error — Flag indicating that an error occurred during reading (for a read event) or writing (for a write event). </li>
<li>cancelable — Timer event flag indicating that the event should be ignored while shutting down the worker. Graceful worker shutdown is delayed until there are no non-cancelable timer events scheduled. </li>
<li>posted — Flag indicating that the event is posted to a queue. </li>
<li><p>queue — Queue node for posting the event to a queue. </p>
<h4 id="I-O-events"><a href="#I-O-events" class="headerlink" title="I/O events"></a>I/O events</h4><p>Each connection obtained by calling the ngx_get_connection() function has two attached events, c-&gt;read and c-&gt;write , which are used for receiving notification that the socket is ready for reading or writing. All such events operate in Edge-Triggered mode, meaning that they only trigger notifications when the state of the socket changes. For example, doing a partial read on a socket does not make nginx deliver a repeated read notification until more data arrives on the socket. Even when the underlying I/O notification mechanism is essentially Level-Triggered ( poll , select etc), nginx converts the notifications to Edge-Triggered. To make nginx event notifications consistent across all notifications systems on different platforms, the functions ngx_handle_read_event(rev, flags) and ngx_handle_write_event(wev, lowat) must be called after handling an I/O socket notification or calling any I/O functions on that socket. Normally, the functions are called once at the end of each read or write event handler. </p>
</li>
</ul>
<h4 id="Timer-events"><a href="#Timer-events" class="headerlink" title="Timer events"></a>Timer events</h4><p> An event can be set to send a notification when a timeout expires. The timer used by events counts milliseconds since some unspecified point in the past truncated to ngx_msec_t type. Its current value can be obtained from the ngx_current_msec variable. </p>
<p> The function ngx_add_timer(ev, timer) sets a timeout for an event, ngx_del_timer(ev) deletes a previously set timeout. The global timeout red-black tree ngx_event_timer_rbtree stores all timeouts currently set. The key in the tree is of type ngx_msec_t and is the time when the event occurs. The tree structure enables fast insertion and deletion operations, as well as access to the nearest timeouts, which nginx uses to find out how long to wait for I/O events and for expiring timeout events. </p>
<h4 id="Posted-events"><a href="#Posted-events" class="headerlink" title="Posted events"></a>Posted events</h4><p> An event can be posted which means that its handler will be called at some point later within the current event loop iteration. Posting events is a good practice for simplifying code and escaping stack overflows. Posted events are held in a post queue. The ngx_post_event(ev, q) mscro posts the event ev to the post queue q . The ngx_delete_posted_event(ev) macro deletes the event ev from the queue it’s currently posted in. Normally, events are posted to the ngx_posted_events queue, which is processed late in the event loop — after all I/O and timer events are already handled. The function ngx_event_process_posted() is called to process an event queue. It calls event handlers until the queue is not empty. This means that a posted event handler can post more events to be processed within the current event loop iteration. </p>
<p> 一个例子： </p>
<blockquote>
<p>void ngx_my_connection_read(ngx_connection_t <em>c) { ngx_event_t </em>rev; rev = c-&gt;read; ngx_add_timer(rev, 1000); rev-&gt;handler = ngx_my_read_handler; ngx_my_read(rev); } void ngx_my_read_handler(ngx_event_t <em>rev) { ssize_t n; ngx_connection_t </em>c; u_char buf[256]; if (rev-&gt;timedout) { /<em> timeout expired </em>/ } c = rev-&gt;data; while (rev-&gt;ready) { n = c-&gt;recv(c, buf, sizeof(buf)); if (n == NGX_AGAIN) { break; } if (n == NGX_ERROR) { /<em> error </em>/ } /<em> process buf </em>/ } if (ngx_handle_read_event(rev, 0) != NGX_OK) { /<em> error </em>/ } } ####  Event loop</p>
</blockquote>
<p> Except for the nginx master process, all nginx processes do I/O and so have an event loop. (The nginx master process instead spends most of its time in the sigsuspend() call waiting for signals to arrive.) The nginx event loop is implemented in the ngx_process_events_and_timers() function, which is called repeatedly until the process exits. </p>
<p> The event loop has the following stages: </p>
<ul>
<li>Find the timeout that is closest to expiring, by calling ngx_event_find_timer() . This function finds the leftmost node in the timer tree and returns the number of milliseconds until the node expires. </li>
<li>Process I/O events by calling a handler, specific to the event notification mechanism, chosen by nginx configuration. This handler waits for at least one I/O event to happen, but only until the next timeout expires. When a read or write event occurs, the ready flag is set and the event’s handler is called. For Linux, the ngx_epoll_process_events() handler is normally used, which calls epoll_wait() to wait for I/O events. </li>
<li>Expire timers by calling ngx_event_expire_timers() . The timer tree is iterated from the leftmost element to the right until an unexpired timeout is found. For each expired node the timedout event flag is set, the timer_set flag is reset, and the event handler is called </li>
<li>Process posted events by calling ngx_event_process_posted() . The function repeatedly removes the first element from the posted events queue and calls the element’s handler, until the queue is empty.<br>All nginx processes handle signals as well. Signal handlers only set global variables which are checked after the ngx_process_events_and_timers() call. </li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p> There are several types of processes in nginx. The type of a process is kept in the ngx_process global variable, and is one of the following: </p>
<ul>
<li>NGX_PROCESS_MASTER — The master process, which reads the NGINX configuration, creates cycles, and starts and controls child processes. It does not perform any I/O and responds only to signals. Its cycle function is ngx_master_process_cycle() . </li>
</ul>
<ul>
<li>NGX_PROCESS_WORKER — The worker process, which handles client connections. It is started by the master process and responds to its signals and channel commands as well. Its cycle function is ngx_worker_process_cycle() . There can be multiple worker processes, as configured by the worker_processes directive. </li>
</ul>
<ul>
<li>NGX_PROCESS_SINGLE — The single process, which exists only in master_process off mode, and is the only process running in that mode. It creates cycles (like the master process does) and handles client connections (like the worker process does). Its cycle function is ngx_single_process_cycle() . </li>
</ul>
<ul>
<li>NGX_PROCESS_HELPER — The helper process, of which currently there are two types: cache manager and cache loader. The cycle function for both is ngx_cache_manager_process_cycle() . </li>
</ul>
<p> The nginx processes handle the following signals: </p>
<ul>
<li>NGX_SHUTDOWN_SIGNAL ( SIGQUIT on most systems) — Gracefully shutdown. Upon receiving this signal, the master process sends a shutdown signal to all child processes. When no child processes are left, the master destroys the cycle pool and exits. When a worker process receives this signal, it closes all listening sockets and waits until there are no non-cancelable events scheduled, then destroys the cycle pool and exits. When the cache manager or the cache loader process receives this signal, it exits immediately. The ngx_quit variable is set to 1 when a process receives this signal, and is immediately reset after being processed. The ngx_exiting variable is set to 1 while a worker process is in the shutdown state. </li>
</ul>
<ul>
<li>NGX_TERMINATE_SIGNAL ( SIGTERM on most systems) — Terminate. Upon receiving this signal, the master process sends a terminate signal to all child processes. If a child process does not exit within 1 second, the master process sends the SIGKILL signal to kill it. When no child processes are left, the master process destroys the cycle pool and exits. When a worker process, the cache manager process or the cache loader process receives this signal, it destroys the cycle pool and exits. The variable ngx_terminate is set to 1 when this signal is received. </li>
</ul>
<ul>
<li>NGX_NOACCEPT_SIGNAL ( SIGWINCH on most systems) - Shut down all worker and helper processes. Upon receiving this signal, the master process shuts down its child processes. If a previously started new nginx binary exits, the child processes of the old master are started again. When a worker process receives this signal, it shuts down in debug mode set by the debug_points directive. </li>
</ul>
<ul>
<li>NGX_RECONFIGURE_SIGNAL ( SIGHUP on most systems) - Reconfigure. Upon receiving this signal, the master process re-reads the configuration and creates a new cycle based on it. If the new cycle is created successfully, the old cycle is deleted and new child processes are started. Meanwhile, the old child processes receive the NGX_SHUTDOWN_SIGNAL signal. In single-process mode, nginx creates a new cycle, but keeps the old one until there are no longer clients with active connections tied to it. The worker and helper processes ignore this signal. </li>
</ul>
<ul>
<li>NGX_REOPEN_SIGNAL ( SIGUSR1 on most systems) — Reopen files. The master process sends this signal to workers, which reopen all open_files related to the cycle. </li>
</ul>
<ul>
<li>NGX_CHANGEBIN_SIGNAL ( SIGUSR2 on most systems) — Change the nginx binary. The master process starts a new nginx binary and passes in a list of all listen sockets. The text-format list, passed in the “NGINX” environment variable, consists of descriptor numbers separated with semicolons. The new nginx binary reads the “NGINX” variable and adds the sockets to its init cycle. Other processes ignore this signal. </li>
</ul>
<p> While all nginx worker processes are able to receive and properly handle POSIX signals, the master process does not use the standard kill() syscall to pass signals to workers and helpers. Instead, nginx uses inter-process socket pairs which allow sending messages between all nginx processes. Currently, however, messages are only sent from the master to its children. The messages carry the standard signals. </p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p> It is possible to offload into a separate thread tasks that would otherwise block the nginx worker process. For example, nginx can be configured to use threads to perform file I/O . Another use case is a library that doesn’t have asynchronous interface and thus cannot be normally used with nginx. Keep in mind that the threads interface is a helper for the existing asynchronous approach to processing client connections, and by no means intended as a replacement. </p>
<p> To deal with synchronization, the following wrappers over pthreads primitives are available: </p>
<ul>
<li><p>typedef pthread_mutex_t ngx_thread_mutex_t; </p>
<ul>
<li>ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t <em>mtx, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t <em>mtx, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t <em>mtx, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t <em>mtx, ngx_log_t </em>log); </li>
</ul>
</li>
<li><p>typedef pthread_cond_t ngx_thread_cond_t; </p>
<ul>
<li>ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t <em>cond, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t <em>cond, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t <em>cond, ngx_log_t </em>log); </li>
<li>ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t <em>cond, ngx_thread_mutex_t </em>mtx, ngx_log_t *log); </li>
</ul>
<p>Instead of creating a new thread for each task, nginx implements a thread_pool strategy. Multiple thread pools may be configured for different purposes (for example, performing I/O on different sets of disks). Each thread pool is created at startup and contains a limited number of threads that process a queue of tasks. When a task is completed, a predefined completion handler is called. </p>
<p>The src/core/ngx_thread_pool.h header file contains relevant definitions: </p>
</li>
</ul>
<blockquote>
<p>struct ngx_thread_task_s { ngx_thread_task_t <em>next; ngx_uint_t id; void </em>ctx; void (<em>handler)(void </em>data, ngx_log_t <em>log); ngx_event_t event; }; typedef struct ngx_thread_pool_s ngx_thread_pool_t; ngx_thread_pool_t </em>ngx_thread_pool_add(ngx_conf_t <em>cf, ngx_str_t </em>name); ngx_thread_pool_t <em>ngx_thread_pool_get(ngx_cycle_t </em>cycle, ngx_str_t <em>name); ngx_thread_task_t </em>ngx_thread_task_alloc(ngx_pool_t <em>pool, size_t size); ngx_int_t ngx_thread_task_post(ngx_thread_pool_t </em>tp, ngx_thread_task_t *task);  At configuration time, a module willing to use threads has to obtain a reference to a thread pool by calling ngx_thread_pool_add(cf, name) , which either creates a new thread pool with the given name or returns a reference to the pool with that name if it already exists. </p>
</blockquote>
<p> To add a task into a queue of a specified thread pool tp at runtime, use the ngx_thread_task_post(tp, task) function. To execute a function in a thread, pass parameters and setup a completion handler using the ngx_thread_task_t structure: </p>
<blockquote>
<p>typedef struct { int foo; } my_thread_ctx_t; static void my_thread_func(void <em>data, ngx_log_t </em>log) { my_thread_ctx_t <em>ctx = data; /</em> this function is executed in a separate thread <em>/ } static void my_thread_completion(ngx_event_t </em>ev) { my_thread_ctx_t <em>ctx = ev-&gt;data; /</em> executed in nginx event loop <em>/ } ngx_int_t my_task_offload(my_conf_t </em>conf) { my_thread_ctx_t <em>ctx; ngx_thread_task_t </em>task; task = ngx_thread_task_alloc(conf-&gt;pool, sizeof(my_thread_ctx_t)); if (task == NULL) { return NGX_ERROR; } ctx = task-&gt;ctx; ctx-&gt;foo = 42; task-&gt;handler = my_thread_func; task-&gt;event.handler = my_thread_completion; task-&gt;event.data = ctx; if (ngx_thread_task_post(conf-&gt;thread_pool, task) != NGX_OK) { return NGX_ERROR; } return NGX_OK; } ####  Modules</p>
</blockquote>
<h4 id="Adding-new-modules"><a href="#Adding-new-modules" class="headerlink" title="Adding new modules"></a>Adding new modules</h4><p> Each standalone nginx module resides in a separate directory that contains at least two files: config and a file with the module source code. The config file contains all information needed for nginx to integrate the module, for example: </p>
<blockquote>
<p>ngx_module_type=CORE ngx_module_name=ngx_foo_module ngx_module_srcs=”$ngx_addon_dir/ngx_foo_module.c” . auto/module ngx_addon_name=$ngx_module_name  The config file is a POSIX shell script that can set and access the following variables: </p>
</blockquote>
<ul>
<li>ngx_module_type — Type of module to build. Possible values are CORE , HTTP , HTTP_FILTER , HTTP_INIT_FILTER , HTTP_AUX_FILTER , MAIL , STREAM , or MISC . </li>
<li>ngx_module_name — Module names. To build multiple modules from a set of source files, specify a whitespace-separated list of names. The first name indicates the name of the output binary for the dynamic module. The names in the list must match the names used in the source code. </li>
<li>ngx_addon_name — Name of the module as it appears in output on the console from the configure script. </li>
<li>ngx_module_srcs — Whitespace-separated list of source files used to compile the module. The $ngx_addon_dir variable can be used to represent the path to the module directory. </li>
<li>ngx_module_incs — Include paths required to build the module </li>
<li>ngx_module_deps — Whitespace-separated list of the module’s dependencies. Usually, it is the list of header files. </li>
<li>ngx_module_libs — Whitespace-separated list of libraries to link with the module. For example, use ngx_module_libs=-lpthread to link libpthread library. The following macros can be used to link against the same libraries as nginx: LIBXSLT , LIBGD , GEOIP , PCRE , OPENSSL , MD5 , SHA1 , ZLIB , and PERL . </li>
<li>ngx_module_link — Variable set by the build system to DYNAMIC for a dynamic module or ADDON for a static module and used to determine different actions to perform depending on linking type. </li>
<li><p>ngx_module_order — Load order for the module; useful for the HTTP_FILTER and HTTP_AUX_FILTER module types. The format for this option is a whitespace-separated list of modules. All modules in the list following the current module’s name end up after it in the global list of modules, which sets up the order for modules initialization. For filter modules later initialization means earlier execution.  The following modules are typically used as references. The ngx_http_copy_filter_module reads the data for other filter modules and is placed near the bottom of the list so that it is one of the first to be executed. The ngx_http_write_filter_module writes the data to the client socket and is placed near the top of the list, and is the last to be executed. </p>
<p>By default, filter modules are placed before the ngx_http_copy_filter in the module list so that the filter handler is executed after the copy filter handler. For other module types the default is the empty string. </p>
</li>
</ul>
<p> To compile a module into nginx statically, use the –add-module=/path/to/module argument to the configure script. To compile a module for later dynamic loading into nginx, use the –add-dynamic-module=/path/to/module argument. </p>
<h4 id="Core-Modules"><a href="#Core-Modules" class="headerlink" title="Core Modules"></a>Core Modules</h4><p> Modules are the building blocks of nginx, and most of its functionality is implemented as modules. The module source file must contain a global variable of type ngx_module_t , which is defined as follows: </p>
<blockquote>
<p>struct ngx_module_s { /<em> private part is omitted </em>/ void <em>ctx; ngx_command_t </em>commands; ngx_uint_t type; ngx_int_t (<em>init_master)(ngx_log_t </em>log); ngx_int_t (<em>init_module)(ngx_cycle_t </em>cycle); ngx_int_t (<em>init_process)(ngx_cycle_t </em>cycle); ngx_int_t (<em>init_thread)(ngx_cycle_t </em>cycle); void (<em>exit_thread)(ngx_cycle_t </em>cycle); void (<em>exit_process)(ngx_cycle_t </em>cycle); void (<em>exit_master)(ngx_cycle_t </em>cycle); /<em> stubs for future extensions are omitted </em>/ };  The omitted private part includes the module version and a signature and is filled using the predefined macro NGX_MODULE_V1 . </p>
</blockquote>
<p> Each module keeps its private data in the ctx field, recognizes the configuration directives, specified in the commands array, and can be invoked at certain stages of nginx lifecycle. The module lifecycle consists of the following events: </p>
<ul>
<li>Configuration directive handlers are called as they appear in configuration files in the context of the master process. </li>
<li>After the configuration is parsed successfully, init_module handler is called in the context of the master process. The init_module handler is called in the master process each time a configuration is loaded. </li>
<li>The master process creates one or more worker processes and the init_process handler is called in each of them. </li>
<li>When a worker process receives the shutdown or terminate command from the master, it invokes the exit_process handler. </li>
<li><p>The master process calls the exit_master handler before exiting.<br>Because threads are used in nginx only as a supplementary I/O facility with its own API, init_thread and exit_thread handlers are not currently called. There is also no init_master handler, because it would be unnecessary overhead. </p>
<p>The module type defines exactly what is stored in the ctx field. Its value is one of the following types: </p>
</li>
<li><p>NGX_CORE_MODULE </p>
<ul>
<li>NGX_EVENT_MODULE </li>
<li>NGX_HTTP_MODULE </li>
<li>NGX_MAIL_MODULE </li>
<li>NGX_STREAM_MODULE<br>The NGX_CORE_MODULE is the most basic and thus the most generic and most low-level type of module. The other module types are implemented on top of it and provide a more convenient way to deal with corresponding domains, like handling events or HTTP requests. </li>
</ul>
<p>The set of core modules includes ngx_core_module , ngx_errlog_module , ngx_regex_module , ngx_thread_pool_module and ngx_openssl_module modules. The HTTP module, the stream module, the mail module and event modules are core modules too. The context of a core module is defined as: </p>
</li>
</ul>
<blockquote>
<p>typedef struct { ngx_str_t name; void <em>(</em>create_conf)(ngx_cycle_t <em>cycle); char </em>(<em>init_conf)(ngx_cycle_t </em>cycle, void *conf); } ngx_core_module_t;  where the name is a module name string, create_conf and init_conf are pointers to functions that create and initialize module configuration respectively. For core modules, nginx calls create_conf before parsing a new configuration and init_conf after all configuration is parsed successfully. The typical create_conf function allocates memory for the configuration and sets default values. </p>
</blockquote>
<p> For example, a simplistic module called ngx_foo_module might look like this: </p>
<blockquote>
<p>/<em> </em> Copyright (C) Author. <em>/ #include <ngx\_config.h> #include <ngx\_core.h> typedef struct { ngx_flag_t enable; } ngx_foo_conf_t; static void </ngx\_core.h></ngx\_config.h></em>ngx_foo_create_conf(ngx_cycle_t <em>cycle); static char </em>ngx_foo_init_conf(ngx_cycle_t <em>cycle, void </em>conf); static char <em>ngx_foo_enable(ngx_conf_t </em>cf, void <em>post, void </em>data); static ngx_conf_post_t ngx_foo_enable_post = { ngx_foo_enable }; static ngx_command_t ngx_foo_commands[] = { { ngx_string(“foo_enabled”), NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG, ngx_conf_set_flag_slot, 0, offsetof(ngx_foo_conf_t, enable), &amp;ngx_foo_enable_post }, ngx_null_command }; static ngx_core_module_t ngx_foo_module_ctx = { ngx_string(“foo”), ngx_foo_create_conf, ngx_foo_init_conf }; ngx_module_t ngx_foo_module = { NGX_MODULE_V1, &amp;ngx_foo_module_ctx, /<em> module context </em>/ ngx_foo_commands, /<em> module directives </em>/ NGX_CORE_MODULE, /<em> module type </em>/ NULL, /<em> init master </em>/ NULL, /<em> init module </em>/ NULL, /<em> init process </em>/ NULL, /<em> init thread </em>/ NULL, /<em> exit thread </em>/ NULL, /<em> exit process </em>/ NULL, /<em> exit master </em>/ NGX_MODULE_V1_PADDING }; static void <em> ngx_foo_create_conf(ngx_cycle_t </em>cycle) { ngx_foo_conf_t <em>fcf; fcf = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_foo_conf_t)); if (fcf == NULL) { return NULL; } fcf-&gt;enable = NGX_CONF_UNSET; return fcf; } static char </em> ngx_foo_init_conf(ngx_cycle_t <em>cycle, void </em>conf) { ngx_foo_conf_t <em>fcf = conf; ngx_conf_init_value(fcf-&gt;enable, 0); return NGX_CONF_OK; } static char </em> ngx_foo_enable(ngx_conf_t <em>cf, void </em>post, void <em>data) { ngx_flag_t </em>fp = data; if (*fp == 0) { return NGX_CONF_OK; } ngx_log_error(NGX_LOG_NOTICE, cf-&gt;log, 0, “Foo Module is enabled”); return NGX_CONF_OK; } ####  Configuration Directives</p>
</blockquote>
<p> The ngx_command_t type defines a single configuration directive. Each module that supports configuration provides an array of such structures that describe how to process arguments and what handlers to call: </p>
<blockquote>
<p>typedef struct ngx_command_s ngx_command_t; struct ngx_command_s { ngx_str_t name; ngx_uint_t type; char <em>(</em>set)(ngx_conf_t <em>cf, ngx_command_t </em>cmd, void <em>conf); ngx_uint_t conf; ngx_uint_t offset; void </em>post; };  Terminate the array with the special value ngx_null_command . The name is the name of a directive as it appears in the configuration file, for example “worker_processes” or “listen”. The type is a bit-field of flags that specify the number of arguments the directive takes, its type, and the context in which it appears. The flags are: </p>
</blockquote>
<ul>
<li>NGX_CONF_NOARGS — Directive takes no arguments. </li>
<li>NGX_CONF_1MORE — Directive takes one or more arguments. </li>
<li>NGX_CONF_2MORE — Directive takes two or more arguments. </li>
<li>NGX_CONF_TAKE1 .. NGX_CONF_TAKE7 — Directive takes exactly the indicated number of arguments. </li>
<li><p>NGX_CONF_TAKE12 , NGX_CONF_TAKE13 , NGX_CONF_TAKE23 , NGX_CONF_TAKE123 , NGX_CONF_TAKE1234 — Directive may take different number of arguments. Options are limited to the given numbers. For example, NGX_CONF_TAKE12 means it takes one or two arguments.<br>The flags for directive types are: </p>
</li>
<li><p>NGX_CONF_BLOCK — Directive is a block, that is, it can contain other directives within its opening and closing braces, or even implement its own parser to handle contents inside. </p>
</li>
<li><p>NGX_CONF_FLAG — Directive takes a boolean value, either on or off .<br>A directive’s context defines where it may appear in the configuration: </p>
</li>
<li><p>NGX_MAIN_CONF — In the top level context. </p>
</li>
<li>NGX_HTTP_MAIN_CONF — In the http block. </li>
<li>NGX_HTTP_SRV_CONF — In a server block within the http block. </li>
<li>NGX_HTTP_LOC_CONF — In a location block within the http block. </li>
<li>NGX_HTTP_UPS_CONF — In an upstream block within the http block. </li>
<li>NGX_HTTP_SIF_CONF — In an if block within a server block in the http block. </li>
<li>NGX_HTTP_LIF_CONF — In an if block within a location block in the http block. </li>
<li>NGX_HTTP_LMT_CONF — In a limit_except block within the http block. </li>
<li>NGX_STREAM_MAIN_CONF — In the stream block. </li>
<li>NGX_STREAM_SRV_CONF — In a server block within the stream block. </li>
<li>NGX_STREAM_UPS_CONF — In an upstream block within the stream block. </li>
<li>NGX_MAIL_MAIN_CONF — In the mail block. </li>
<li>NGX_MAIL_SRV_CONF — In a server block within the mail block. </li>
<li>NGX_EVENT_CONF — In the event block. </li>
<li><p>NGX_DIRECT_CONF — Used by modules that don’t create a hierarchy of contexts and only have one global configuration. This configuration is passed to the handler as the conf argument.<br>The configuration parser uses these flags to throw an error in case of a misplaced directive and calls directive handlers supplied with a proper configuration pointer, so that the same directives in different locations can store their values in distinct places. </p>
<p>The set field defines a handler that processes a directive and stores parsed values into the corresponding configuration. There’s a number of functions that perform common conversions: </p>
</li>
<li><p>ngx_conf_set_flag_slot — Converts the literal strings on and off into an ngx_flag_t value with values 1 or 0, respectively. </p>
</li>
<li>ngx_conf_set_str_slot — Stores a string as a value of the ngx_str_t type. </li>
<li>ngx_conf_set_str_array_slot — Appends a value to an array ngx_array_t of strings ngx_str_t . The array is created if does not already exist. </li>
<li>ngx_conf_set_keyval_slot — Appends a key-value pair to an array ngx_array_t of key-value pairs ngx_keyval_t . The first string becomes the key and the second the value. The array is created if it does not already exist. </li>
<li>ngx_conf_set_num_slot — Converts a directive’s argument to an ngx_int_t value. </li>
<li>ngx_conf_set_size_slot — Converts a size to a size_t value expressed in bytes. </li>
<li>ngx_conf_set_off_slot — Converts an offset to an off_t value expressed in bytes. </li>
<li>ngx_conf_set_msec_slot — Converts a time to an ngx_msec_t value expressed in milliseconds. </li>
<li>ngx_conf_set_sec_slot — Converts a time to a time_t value expressed in in seconds. </li>
<li>ngx_conf_set_bufs_slot — Converts the two supplied arguments into an ngx_bufs_t object that holds the number and size of buffers. </li>
<li>ngx_conf_set_enum_slot — Converts the supplied argument into an ngx_uint_t value. The null-terminated array of ngx_conf_enum_t passed in the post field defines the acceptable strings and corresponding integer values. </li>
<li>ngx_conf_set_bitmask_slot — Converts the supplied arguments into an ngx_uint_t value. The mask values for each argument are ORed producing the result. The null-terminated array of ngx_conf_bitmask_t passed in the post field defines the acceptable strings and corresponding mask values. </li>
<li>set_path_slot — Converts the supplied arguments to an ngx_path_t value and performs all required initializations. For details, see the documentation for the proxy_temp_path directive. </li>
<li><p>set_access_slot — Converts the supplied arguments to a file permissions mask. For details, see the documentation for the proxy_store_access directive.<br>The conf field defines which configuration structure is passed to the directory handler. Core modules only have the global configuration and set NGX_DIRECT_CONF flag to access it. Modules like HTTP, Stream or Mail create hierarchies of configurations. For example, a module’s configuration is created for server , location and if scopes. </p>
</li>
<li><p>NGX_HTTP_MAIN_CONF_OFFSET — Configuration for the http block. </p>
</li>
<li>NGX_HTTP_SRV_CONF_OFFSET — Configuration for a server block within the http block. </li>
<li>NGX_HTTP_LOC_CONF_OFFSET — Configuration for a location block within the http . </li>
<li>NGX_STREAM_MAIN_CONF_OFFSET — Configuration for the stream block. </li>
<li>NGX_STREAM_SRV_CONF_OFFSET — Configuration for a server block within the stream block. </li>
<li>NGX_MAIL_MAIN_CONF_OFFSET — Configuration for the mail block. </li>
<li><p>NGX_MAIL_SRV_CONF_OFFSET — Configuration for a server block within the mail block.<br>The offset defines the offset of a field in a module configuration structure that holds values for this particular directive. The typical use is to employ the offsetof() macro. </p>
<p>The post field has two purposes: it may be used to define a handler to be called after the main handler has completed, or to pass additional data to the main handler. In the first case, the ngx_conf_post_t structure needs to be initialized with a pointer to the handler, for example: </p>
</li>
</ul>
<blockquote>
<p>static char <em>ngx_do_foo(ngx_conf_t </em>cf, void <em>post, void </em>data); static ngx_conf_post_t ngx_foo_post = { ngx_do_foo };  The post argument is the ngx_conf_post_t object itself, and the data is a pointer to the value, converted from arguments by the main handler with the appropriate type. </p>
</blockquote>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h4 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h4><p> Each HTTP client connection runs through the following stages: </p>
<ul>
<li>ngx_event_accept() accepts a client TCP connection. This handler is called in response to a read notification on a listen socket. A new ngx_connecton_t object is created at this stage to wrap the newly accepted client socket. Each nginx listener provides a handler to pass the new connection object to. For HTTP connections it’s ngx_http_init_connection(c) . </li>
<li>ngx_http_init_connection() performs early initialization of the HTTP connection. At this stage an ngx_http_connection_t object is created for the connection and its reference is stored in the connection’s data field. Later it will be replaced by an HTTP request object. A PROXY protocol parser and the SSL handshake are started at this stage as well. </li>
<li>ngx_http_wait_request_handler() read event handler is called when data is available on the client socket. At this stage an HTTP request object ngx_http_request_t is created and set to the connection’s data field. </li>
<li>ngx_http_process_request_line() read event handler reads client request line. The handler is set by ngx_http_wait_request_handler() . The data is read into connection’s buffer . The size of the buffer is initially set by the directive client_header_buffer_size . The entire client header is supposed to fit in the buffer. If the initial size is not sufficient, a bigger buffer is allocated, with the capacity set by the large_client_header_buffers directive. </li>
<li>ngx_http_process_request_headers() read event handler, is set after ngx_http_process_request_line() to read the client request header. </li>
<li>ngx_http_core_run_phases() is called when the request header is completely read and parsed. This function runs request phases from NGX_HTTP_POST_READ_PHASE to NGX_HTTP_CONTENT_PHASE . The last phase is intended to generate a response and pass it along the filter chain. The response is not necessarily sent to the client at this phase. It might remain buffered and be sent at the finalization stage. </li>
<li>ngx_http_finalize_request() is usually called when the request has generated all the output or produced an error. In the latter case an appropriate error page is looked up and used as the response. If the response is not completely sent to the client by this point, an HTTP writer ngx_http_writer() is activated to finish sending outstanding data. </li>
<li><p>ngx_http_finalize_connection() is called when the complete response has been sent to the client and the request can be destroyed. If the client connection keepalive feature is enabled, ngx_http_set_keepalive() is called, which destroys the current request and waits for the next request on the connection. Otherwise, ngx_http_close_request() destroys both the request and the connection. </p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>For each client HTTP request the ngx_http_request_t object is created. Some of the fields of this object are: </p>
</li>
<li><p>connection — Pointer to a ngx_connection_t client connection object. Several requests can reference the same connection object at the same time - one main request and its subrequests. After a request is deleted, a new request can be created on the same connection. </p>
<p>Note that for HTTP connections ngx_connection_t ‘s data field points back to the request. Such requests are called active, as opposed to the other requests tied to the connection. An active request is used to handle client connection events and is allowed to output its response to the client. Normally, each request becomes active at some point so that it can send its output. </p>
</li>
</ul>
<ul>
<li>ctx — Array of HTTP module contexts. Each module of type NGX_HTTP_MODULE can store any value (normally, a pointer to a structure) in the request. The value is stored in the ctx array at the module’s ctx_index position. The following macros provide a convenient way to get and set request contexts: </li>
</ul>
<pre><code>+  ngx\_http\_get\_module\_ctx(r, module) — Returns the module &apos;s context 
+  ngx\_http\_set\_ctx(r, c, module) — Sets c as the module &apos;s context 
</code></pre><ul>
<li>main_conf , srv_conf , loc_conf — Arrays of current request configurations. Configurations are stored at the module’s ctx_index positions. </li>
<li>read_event_handler , write_event_handler - Read and write event handlers for the request. Normally, both the read and write event handlers for an HTTP connection are set to ngx_http_request_handler() . This function calls the read_event_handler and write_event_handler handlers for the currently active request. </li>
<li>cache — Request cache object for caching the upstream response. </li>
<li>upstream — Request upstream object for proxying. </li>
<li>pool — Request pool. The request object itself is allocated in this pool, which is destroyed when the request is deleted. For allocations that need to be available throughout the client connection’s lifetime, use ngx_connection_t ‘s pool instead. </li>
<li>header_in — Buffer into which the client HTTP request header is read. </li>
<li>headers_in , headers_out — Input and output HTTP headers objects. Both objects contain the headers field of type ngx_list_t for keeping the raw list of headers. In addition to that, specific headers are available for getting and setting as separate fields, for example content_length_n , status etc. </li>
<li>request_body — Client request body object. </li>
<li>start_sec , start_msec — Time point when the request was created, used for tracking request duration. </li>
<li>method , method_name — Numeric and text representation of the client HTTP request method. Numeric values for methods are defined in src/http/ngx_http_request.h with the macros NGX_HTTP_GET , NGX_HTTP_HEAD , NGX_HTTP_POST , etc. </li>
<li>http_protocol — Client HTTP protocol version in its original text form (“HTTP/1.0”, “HTTP/1.1” etc). </li>
<li>http_version — Client HTTP protocol version in numeric form ( NGX_HTTP_VERSION_10 , NGX_HTTP_VERSION_11 , etc.). </li>
<li>http_major , http_minor — Client HTTP protocol version in numeric form split into major and minor parts. </li>
<li>request_line , unparsed_uri — Request line and URI in the original client request. </li>
<li>uri , args , exten — URI, arguments and file extension for the current request. The URI value here might differ from the original URI sent by the client due to normalization. Throughout request processing, these values can change as internal redirects are performed. </li>
<li>main — Pointer to a main request object. This object is created to process a client HTTP request, as opposed to subrequests, which are created to perform a specific subtask within the main request. </li>
<li>parent — Pointer to the parent request of a subrequest. </li>
<li>postponed — List of output buffers and subrequests, in the order in which they are sent and created. The list is used by the postpone filter to provide consistent request output when parts of it are created by subrequests. </li>
<li>post_subrequest — Pointer to a handler with the context to be called when a subrequest gets finalized. Unused for main requests. </li>
<li><p>posted_requests — List of requests to be started or resumed, which is done by calling the request’s write_event_handler . Normally, this handler holds the request main function, which at first runs request phases and then produces the output. </p>
<p>A request is usually posted by the ngx_http_post_request(r, NULL) call. It is always posted to the main request posted_requests list. The function ngx_http_run_posted_requests(c) runs all requests that are posted in the main request of the passed connection’s active request. All event handlers call ngx_http_run_posted_requests , which can lead to new posted requests. Normally, it is called after invoking a request’s read or write handler. </p>
</li>
</ul>
<ul>
<li>phase_handler — Index of current request phase. </li>
<li>ncaptures , captures , captures_data — Regex captures produced by the last regex match of the request. A regex match can occur at a number of places during request processing: map lookup, server lookup by SNI or HTTP Host, rewrite, proxy_redirect, etc. Captures produced by a lookup are stored in the above mentioned fields. The field ncaptures holds the number of captures, captures holds captures boundaries and captures_data holds the string against which the regex was matched and which is used to extract captures. After each new regex match, request captures are reset to hold new values. </li>
<li>count — Request reference counter. The field only makes sense for the main request. Increasing the counter is done by simple r-&gt;main-&gt;count++ . To decrease the counter, call ngx_http_finalize_request(r, rc) . Creating of a subrequest and running the request body read process both increment the counter. </li>
<li>subrequests — Current subrequest nesting level. Each subrequest inherits its parent’s nesting level, decreased by one. An error is generated if the value reaches zero. The value for the main request is defined by the NGX_HTTP_MAX_SUBREQUESTS constant. </li>
<li>uri_changes — Number of URI changes remaining for the request. The total number of times a request can change its URI is limited by the NGX_HTTP_MAX_URI_CHANGES constant. With each change the value is decremented until it reaches zero, at which time an error is generated. Rewrites and internal redirects to normal or named locations are considered URI changes. </li>
<li>blocked — Counter of blocks held on the request. While this value is non-zero, the request cannot be terminated. Currently, this value is increased by pending AIO operations (POSIX AIO and thread operations) and active cache lock. </li>
<li>buffered — Bitmask showing which modules have buffered the output produced by the request. A number of filters can buffer output; for example, sub_filter can buffer data because of a partial string match, copy filter can buffer data because of the lack of free output buffers etc. As long as this value is non-zero, the request is not finalized pending the flush. </li>
<li>header_only — Flag indicating that the output does not require a body. For example, this flag is used by HTTP HEAD requests. </li>
<li>keepalive — Flag indicating whether client connection keepalive is supported. The value is inferred from the HTTP version and the value of the “Connection” header. </li>
</ul>
<ul>
<li>header_sent — Flag indicating that the output header has already been sent by the request. </li>
<li>internal — Flag indicating that the current request is internal. To enter the internal state, a request must pass through an internal redirect or be a subrequest. Internal requests are allowed to enter internal locations. </li>
<li>allow_ranges — Flag indicating that a partial response can be sent to the client, as requested by the HTTP Range header. </li>
<li>subrequest_ranges — Flag indicating that a partial response can be sent while a subrequest is being processed. </li>
<li>single_range — Flag indicating that only a single continuous range of output data can be sent to the client. This flag is usually set when sending a stream of data, for example from a proxied server, and the entire response is not available in one buffer. </li>
<li>main_filter_need_in_memory , filter_need_in_memory — Flags requesting that the output produced in memory buffers rather than files. This is a signal to the copy filter to read data from file buffers even if sendfile is enabled. The difference between the two flags is the location of the filter modules that set them. Filters called before the postpone filter in the filter chain set filter_need_in_memory , requesting that only the current request output come in memory buffers. Filters called later in the filter chain set main_filter_need_in_memory , requesting that both the main request and all subrequests read files in memory while sending output. </li>
<li><p>filter_need_temporary — Flag requesting that the request output be produced in temporary buffers, but not in readonly memory buffers or file buffers. This is used by filters which may change output directly in the buffers where it’s sent. </p>
<h4 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h4><p>Each HTTP module can have three types of configuration: </p>
</li>
<li><p>Main configuration — Applies to the entire http block. Functions as global settings for a module. </p>
</li>
<li>Server configuration — Applies to a single server block. Functions as server-specific settings for a module. </li>
<li>Location configuration — Applies to a single location , if or limit_except block. Functions as location-specific settings for a module.<br>Configuration structures are created at the nginx configuration stage by calling functions, which allocate the structures, initialize them and merge them. The following example shows how to create a simple location configuration for a module. The configuration has one setting, foo , of type unsigned integer. </li>
</ul>
<blockquote>
<p>typedef struct { ngx_uint_t foo; } ngx_http_foo_loc_conf_t; static ngx_http_module_t ngx_http_foo_module_ctx = { NULL, /<em> preconfiguration </em>/ NULL, /<em> postconfiguration </em>/ NULL, /<em> create main configuration </em>/ NULL, /<em> init main configuration </em>/ NULL, /<em> create server configuration </em>/ NULL, /<em> merge server configuration </em>/ ngx_http_foo_create_loc_conf, /<em> create location configuration </em>/ ngx_http_foo_merge_loc_conf /<em> merge location configuration </em>/ }; static void <em> ngx_http_foo_create_loc_conf(ngx_conf_t </em>cf) { ngx_http_foo_loc_conf_t <em>conf; conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_foo_loc_conf_t)); if (conf == NULL) { return NULL; } conf-&gt;foo = NGX_CONF_UNSET_UINT; return conf; } static char </em> ngx_http_foo_merge_loc_conf(ngx_conf_t <em>cf, void </em>parent, void <em>child) { ngx_http_foo_loc_conf_t </em>prev = parent; ngx_http_foo_loc_conf_t *conf = child; ngx_conf_merge_uint_value(conf-&gt;foo, prev-&gt;foo, 1); }  As seen in the example, the ngx_http_foo_create_loc_conf() function creates a new configuration structure, and ngx_http_foo_merge_loc_conf() merges a configuration with configuration from a higher level. In fact, server and location configuration do not exist only at the server and location levels, but are also created for all levels above them. Specifically, a server configuration is also created at the main level and location configurations are created at the main, server, and location levels. These configurations make it possible to specify server- and location-specific settings at any level of an nginx configuration file. Eventually configurations are merged down. A number of macros like NGX_CONF_UNSET and NGX_CONF_UNSET_UINT are provided for indicating a missing setting and ignoring it while merging. Standard nginx merge macros like ngx_conf_merge_value() and ngx_conf_merge_uint_value() provide a convenient way to merge a setting and set the default value if none of the configurations provided an explicit value. For complete list of macros for different types, see src/core/ngx_conf_file.h . </p>
</blockquote>
<p> The following macros are available. for accessing configuration for HTTP modules at configuration time. They all take ngx_conf_t reference as the first argument. </p>
<ul>
<li>ngx_http_conf_get_module_main_conf(cf, module) <ul>
<li>ngx_http_conf_get_module_srv_conf(cf, module) </li>
<li>ngx_http_conf_get_module_loc_conf(cf, module)<br>The following example gets a pointer to a location configuration of standard nginx core module ngx_http_core_module and replaces the location content handler kept in the handler field of the structure. </li>
</ul>
</li>
</ul>
<blockquote>
<p>static ngx_int_t ngx_http_foo_handler(ngx_http_request_t <em>r); static ngx_command_t ngx_http_foo_commands[] = { { ngx_string(“foo”), NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS, ngx_http_foo, 0, 0, NULL }, ngx_null_command }; static char </em> ngx_http_foo(ngx_conf_t <em>cf, ngx_command_t </em>cmd, void <em>conf) { ngx_http_core_loc_conf_t </em>clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_bar_handler; return NGX_CONF_OK; }  The following macros are available for accessing configuration for HTTP modules at runtime. </p>
</blockquote>
<ul>
<li>ngx_http_get_module_main_conf(r, module) <ul>
<li>ngx_http_get_module_srv_conf(r, module) </li>
<li>ngx_http_get_module_loc_conf(r, module)<br>These macros receive a reference to an HTTP request ngx_http_request_t . The main configuration of a request never changes. Server configuration can change from the default after the virtual server for the request is chosen. Location configuration selected for processing a request can change multiple times as a result of a rewrite operation or internal redirect. The following example shows how to access a module’s HTTP configuration at runtime. </li>
</ul>
</li>
</ul>
<blockquote>
<p>static ngx_int_t ngx_http_foo_handler(ngx_http_request_t <em>r) { ngx_http_foo_loc_conf_t </em>flcf; flcf = ngx_http_get_module_loc_conf(r, ngx_http_foo_module); … } ####  相</p>
</blockquote>
<p> Each HTTP request passes through a sequence of phases. In each phase a distinct type of processing is performed on the request. Module-specific handlers can be registered in most phases, and many standard nginx modules register their phase handlers as a way to get called at a specific stage of request processing. Phases are processed successively and the phase handlers are called once the request reaches the phase. Following is the list of nginx HTTP phases. </p>
<ul>
<li>NGX_HTTP_POST_READ_PHASE — First phase. The ngx_http_realip_module registers its handler at this phase to enable substitution of client addresses before any other module is invoked. </li>
<li>NGX_HTTP_SERVER_REWRITE_PHASE — Phase where rewrite directives defined in a server block (but outside a location block) are processed. The ngx_http_rewrite_module installs its handler at this phase. </li>
<li>NGX_HTTP_FIND_CONFIG_PHASE — Special phase where a location is chosen based on the request URI. Before this phase, the default location for the relevant virtual server is assigned to the request, and any module requesting a location configuration receives the configuration for the default server location. This phase a assigns a new location to the request. No additional handlers can be registered at this phase. </li>
<li>NGX_HTTP_REWRITE_PHASE — Same as NGX_HTTP_SERVER_REWRITE_PHASE , but for rewrite rules defined in the location, chosen in the previous phase. </li>
<li>NGX_HTTP_POST_REWRITE_PHASE — Special phase where the request is redirected to a new location if its URI changed during a rewrite. This is implemented by the request going through the NGX_HTTP_FIND_CONFIG_PHASE again. No additional handlers can be registered at this phase. </li>
<li>NGX_HTTP_PREACCESS_PHASE — A common phase for different types of handlers, not associated with access control. The standard nginx modules ngx_http_limit_conn_module and ngx_http_limit_req_module register their handlers at this phase. </li>
<li>NGX_HTTP_ACCESS_PHASE — Phase where it is verified that the client is authorized to make the request. Standard nginx modules such as ngx_http_access_module and ngx_http_auth_basic_module register their handlers at this phase. By default the client must pass the authorization check of all handlers registered at this phase for the request to continue to the next phase. The satisfy directive, can be used to permit processing to continue if any of the phase handlers authorizes the client. </li>
<li>NGX_HTTP_POST_ACCESS_PHASE — Special phase where the satisfy any directive is processed. If some access phase handlers denied access and none explicitly allowed it, the request is finalized. No additional handlers can be registered at this phase. </li>
<li>NGX_HTTP_PRECONTENT_PHASE — Phase for handlers to be called prior to generating content. Standard modules such as ngx_http_try_files_module and ngx_http_mirror_module register their handlers at this phase. </li>
<li>NGX_HTTP_CONTENT_PHASE — Phase where the response is normally generated. Multiple nginx standard modules register their handlers at this phase, including ngx_http_index_module or ngx_http_static_module . They are called sequentially until one of them produces the output. It’s also possible to set content handlers on a per-location basis. If the ngx_http_core_module ‘s location configuration has handler set, it is called as the content handler and the handlers installed at this phase are ignored. </li>
<li>NGX_HTTP_LOG_PHASE — Phase where request logging is performed. Currently, only the ngx_http_log_module registers its handler at this stage for access logging. Log phase handlers are called at the very end of request processing, right before freeing the request.<br>Following is the example of a preaccess phase handler. </li>
</ul>
<blockquote>
<p>static ngx_http_module_t ngx_http_foo_module_ctx = { NULL, /<em> preconfiguration </em>/ ngx_http_foo_init, /<em> postconfiguration </em>/ NULL, /<em> create main configuration </em>/ NULL, /<em> init main configuration </em>/ NULL, /<em> create server configuration </em>/ NULL, /<em> merge server configuration </em>/ NULL, /<em> create location configuration </em>/ NULL /<em> merge location configuration </em>/ }; static ngx_int_t ngx_http_foo_handler(ngx_http_request_t <em>r) { ngx_str_t </em>ua; ua = r-&gt;headers_in-&gt;user_agent; if (ua == NULL) { return NGX_DECLINED; } /<em> reject requests with “User-Agent: foo” </em>/ if (ua-&gt;value.len == 3 &amp;&amp; ngx_strncmp(ua-&gt;value.data, “foo”, 3) == 0) { return NGX_HTTP_FORBIDDEN; } return NGX_DECLINED; } static ngx_int_t ngx_http_foo_init(ngx_conf_t <em>cf) { ngx_http_handler_pt </em>h; ngx_http_core_main_conf_t <em>cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers); if (h == NULL) { return NGX_ERROR; } </em>h = ngx_http_foo_handler; return NGX_OK; }  Phase handlers are expected to return specific codes: </p>
</blockquote>
<ul>
<li>NGX_OK — Proceed to the next phase. </li>
<li>NGX_DECLINED — Proceed to the next handler of the current phase. If the current handler is the last in the current phase, move to the next phase. </li>
<li>NGX_AGAIN , NGX_DONE — Suspend phase handling until some future event which can be an asynchronous I/O operation or just a delay, for example. It is assumed, that phase handling will be resumed later by calling ngx_http_core_run_phases() . </li>
<li>Any other value returned by the phase handler is treated as a request finalization code, in particular, an HTTP response code. The request is finalized with the code provided.<br>For some phases, return codes are treated in a slightly different way. At the content phase, any return code other that NGX_DECLINED is considered a finalization code. Any return code from the location content handlers is considered a finalization code. At the access phase, in satisfy any mode, any return code other than NGX_OK , NGX_DECLINED , NGX_AGAIN , NGX_DONE is considered a denial. If no subsequent access handlers allow or deny access with a different code, the denial code will become the finalization code. </li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h4 id="Accessing-existing-variables"><a href="#Accessing-existing-variables" class="headerlink" title="Accessing existing variables"></a>Accessing existing variables</h4><p> Variables can be referenced by index (this is the most common method) or name (see below ). The index is created at configuration stage, when a variable is added to the configuration. To obtain the variable index, use ngx_http_get_variable_index() : </p>
<blockquote>
<p>ngx_str_t name; /<em> ngx_string(“foo”) </em>/ ngx_int_t index; index = ngx_http_get_variable_index(cf, &amp;name);  Here, cf is a pointer to nginx configuration and name points to a string containing the variable name. The function returns NGX_ERROR on error or a valid index otherwise, which is typically stored somewhere in the module’s configuration for future use. </p>
</blockquote>
<p> All HTTP variables are evaluated in the context of a given HTTP request, and results are specific to and cached in that HTTP request. All functions that evaluate variables return the ngx_http_variable_value_t type, representing the variable value: </p>
<blockquote>
<p>typedef ngx_variable_value_t ngx_http_variable_value_t; typedef struct { unsigned len:28; unsigned valid:1; unsigned no_cacheable:1; unsigned not_found:1; unsigned escape:1; u_char *data; } ngx_variable_value_t;  哪里： </p>
</blockquote>
<ul>
<li>len — The length of the value </li>
<li>data — The value itself </li>
<li>valid — The value is valid </li>
<li>not_found — The variable was not found and thus the data and len fields are irrelevant; this can happen, for example, with variables like $arg_foo when a corresponding argument was not passed in a request </li>
<li>no_cacheable — Do not cache result </li>
<li>escape — Used internally by the logging module to mark values that require escaping on output.<br>The ngx_http_get_flushed_variable() and ngx_http_get_indexed_variable() functions are used to obtain the value of a variable. They have the same interface - accepting an HTTP request r as a context for evaluating the variable and an index that identifies it. An example of typical usage: </li>
</ul>
<blockquote>
<p>ngx_http_variable_value_t <em>v; v = ngx_http_get_flushed_variable(r, index); if (v == NULL || v-&gt;not_found) { /</em> we failed to get value or there is no such variable, handle it <em>/ return NGX_ERROR; } /</em> some meaningful value is found */  The difference between functions is that the ngx_http_get_indexed_variable() returns a cached value and ngx_http_get_flushed_variable() flushes the cache for non-cacheable variables. </p>
</blockquote>
<p> Some modules, such as SSI and Perl, need to deal with variables for which the name is not known at configuration time. An index therefore cannot be used to access them, but the ngx_http_get_variable(r, name, key) function is available. It searches for a variable with a given name and its hash key derived from the name. </p>
<h4 id="Creating-variables"><a href="#Creating-variables" class="headerlink" title="Creating variables"></a>Creating variables</h4><p> To create a variable, use the ngx_http_add_variable() function. It takes as arguments a configuration (where the variable is registered), the variable name and flags that control the function’s behaviour: </p>
<ul>
<li>NGX_HTTP_VAR_CHANGEABLE — Enables redefinition of the variable: there is no conflict if another module defines a variable with the same name. This allows the set directive to override variables. </li>
<li>NGX_HTTP_VAR_NOCACHEABLE — Disables caching, which is useful for variables such as $time_local . </li>
<li>NGX_HTTP_VAR_NOHASH — Indicates that this variable is only accessible by index, not by name. This is a small optimization for use when it is known that the variable is not needed in modules like SSI or Perl. </li>
<li>NGX_HTTP_VAR_PREFIX — The name of the variable is a prefix. In this case, a handler must implement additional logic to obtain the value of a specific variable. For example, all “ arg_ ” variables are processed by the same handler, which performs lookup in request arguments and returns the value of a specific argument.<br>The function returns NULL in case of error or a pointer to ngx_http_variable_t otherwise: </li>
</ul>
<blockquote>
<p>struct ngx_http_variable_s { ngx_str_t name; ngx_http_set_variable_pt set_handler; ngx_http_get_variable_pt get_handler; uintptr_t data; ngx_uint_t flags; ngx_uint_t index; };  The get and set handlers are called to obtain or set the variable value, data is passed to variable handlers, and index holds assigned variable index used to reference the variable. </p>
</blockquote>
<p> Usually, a null-terminated static array of ngx_http_variable_t structures is created by a module and processed at the preconfiguration stage to add variables into the configuration, for example: </p>
<blockquote>
<p>static ngx_http_variable_t ngx_http_foo_vars[] = { { ngx_string(“foo_v1”), NULL, ngx_http_foo_v1_variable, 0, 0, 0 }, ngx_http_null_variable }; static ngx_int_t ngx_http_foo_add_variables(ngx_conf_t <em>cf) { ngx_http_variable_t </em>var, *v; for (v = ngx_http_foo_vars; v-&gt;name.len; v++) { var = ngx_http_add_variable(cf, &amp;v-&gt;name, v-&gt;flags); if (var == NULL) { return NGX_ERROR; } var-&gt;get_handler = v-&gt;get_handler; var-&gt;data = v-&gt;data; } return NGX_OK; }  This function in the example is used to initialize the preconfiguration field of the HTTP module context and is called before the parsing of HTTP configuration, so that the parser can refer to these variables. </p>
</blockquote>
<p> The get handler is responsible for evaluating a variable in the context of a specific request, for example: </p>
<blockquote>
<p>static ngx_int_t ngx_http_variable_connection(ngx_http_request_t <em>r, ngx_http_variable_value_t </em>v, uintptr_t data) { u_char *p; p = ngx_pnalloc(r-&gt;pool, NGX_ATOMIC_T_LEN); if (p == NULL) { return NGX_ERROR; } v-&gt;len = ngx_sprintf(p, “%uA”, r-&gt;connection-&gt;number) - p; v-&gt;valid = 1; v-&gt;no_cacheable = 0; v-&gt;not_found = 0; v-&gt;data = p; return NGX_OK; }  It returns NGX_ERROR in case of internal error (for example, failed memory allocation) or NGX_OK otherwise. To learn the status of variable evaluation, inspect the flags in ngx_http_variable_value_t (see the description above ). </p>
</blockquote>
<p> The set handler allows setting the property referenced by the variable. For example, the set handler of the $limit_rate variable modifies the request’s limit_rate field: </p>
<blockquote>
<p>… { ngx_string(“limit_rate”), ngx_http_variable_request_set_size, ngx_http_variable_request_get_size, offsetof(ngx_http_request_t, limit_rate), NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE, 0 }, … static void ngx_http_variable_request_set_size(ngx_http_request_t <em>r, ngx_http_variable_value_t </em>v, uintptr_t data) { ssize_t s, <em>sp; ngx_str_t val; val.len = v-&gt;len; val.data = v-&gt;data; s = ngx_parse_size(&amp;val); if (s == NGX_ERROR) { ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, “invalid size \”%V\””, &amp;val); return; } sp = (ssize_t </em>) ((char <em>) r + data); </em>sp = s; return; } ####  Complex values</p>
</blockquote>
<p> A complex value, despite its name, provides an easy way to evaluate expressions which can contain text, variables, and their combination. </p>
<p> The complex value description in ngx_http_compile_complex_value is compiled at the configuration stage into ngx_http_complex_value_t which is used at runtime to obtain results of expression evaluation. </p>
<blockquote>
<p>ngx_str_t <em>value; ngx_http_complex_value_t cv; ngx_http_compile_complex_value_t ccv; value = cf-&gt;args-&gt;elts; /</em> directive arguments */ ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &cv; ccv.zero = 1; ccv.conf_prefix = 1; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) { return NGX_CONF_ERROR; }  Here, ccv holds all parameters that are required to initialize the complex value cv : </p>
</blockquote>
<ul>
<li>cf — Configuration pointer </li>
<li>value — String to be parsed (input) </li>
<li>complex_value — Compiled value (output) </li>
<li>zero — Flag that enables zero-terminating value </li>
<li>conf_prefix — Prefixes the result with the configuration prefix (the directory where nginx is currently looking for configuration) </li>
<li><p>root_prefix — Prefixes the result with the root prefix (the normal nginx installation prefix)<br>The zero flag is useful when results are to be passed to libraries that require zero-terminated strings, and prefixes are handy when dealing with filenames. </p>
<p>Upon successful compilation, cv.lengths contains information about the presence of variables in the expression. The NULL value means that the expression contained static text only, and so can be stored in a simple string rather than as a complex value. </p>
<p>The ngx_http_set_complex_value_slot() is a convenient function used to initialize a complex value completely in the directive declaration itself. </p>
<p>At runtime, a complex value can be calculated using the ngx_http_complex_value() function: </p>
</li>
</ul>
<blockquote>
<p>ngx_str_t res; if (ngx_http_complex_value(r, &amp;cv, &amp;res) != NGX_OK) { return NGX_ERROR; }  Given the request r and previously compiled value cv , the function evaluates the expression and writes the result to res . </p>
</blockquote>
<h4 id="Request-redirection"><a href="#Request-redirection" class="headerlink" title="Request redirection"></a>Request redirection</h4><p> An HTTP request is always connected to a location via the loc_conf field of the ngx_http_request_t structure. This means that at any point the location configuration of any module can be retrieved from the request by calling ngx_http_get_module_loc_conf(r, module) . Request location can change several times during the request’s lifetime. Initially, a default server location of the default server is assigned to a request. If the request switches to a different server (chosen by the HTTP “Host” header or SSL SNI extension), the request switches to the default location of that server as well. The next change of the location takes place at the NGX_HTTP_FIND_CONFIG_PHASE request phase. At this phase a location is chosen by request URI among all non-named locations configured for the server. The ngx_http_rewrite_module can change the request URI at the NGX_HTTP_REWRITE_PHASE request phase as a result of the rewrite directive and send the request back to the NGX_HTTP_FIND_CONFIG_PHASE phase for selection of a new location based on the new URI. </p>
<p> It is also possible to redirect a request to a new location at any point by calling one of ngx_http_internal_redirect(r, uri, args) or ngx_http_named_location(r, name) . </p>
<p> The ngx_http_internal_redirect(r, uri, args) function changes the request URI and returns the request to the NGX_HTTP_SERVER_REWRITE_PHASE phase. The request proceeds with a server default location. Later at NGX_HTTP_FIND_CONFIG_PHASE a new location is chosen based on the new request URI. </p>
<p> The following example performs an internal redirect with the new request arguments. </p>
<blockquote>
<p>ngx_int_t ngx_http_foo_redirect(ngx_http_request_t *r) { ngx_str_t uri, args; ngx_str_set(&amp;uri, “/foo”); ngx_str_set(&amp;args, “bar=1”); return ngx_http_internal_redirect(r, &amp;uri, &amp;args); }  The function ngx_http_named_location(r, name) redirects a request to a named location. The name of the location is passed as the argument. The location is looked up among all named locations of the current server, after which the requests switches to the NGX_HTTP_REWRITE_PHASE phase. </p>
</blockquote>
<p> The following example performs a redirect to a named location @foo. </p>
<blockquote>
<p>ngx_int_t ngx_http_foo_named_redirect(ngx_http_request_t *r) { ngx_str_t name; ngx_str_set(&amp;name, “foo”); return ngx_http_named_location(r, &amp;name); }  Both functions - ngx_http_internal_redirect(r, uri, args) and ngx_http_named_location(r, name) can be called when nginx modules have already stored some contexts in a request’s ctx field. It’s possible for these contexts to become inconsistent with the new location configuration. To prevent inconsistency, all request contexts are erased by both redirect functions. </p>
</blockquote>
<p> Calling ngx_http_internal_redirect(r, uri, args) or ngx_http_named_location(r, name) increases the request count . For consistent request reference counting, call ngx_http_finalize_request(r, NGX_DONE) after redirecting the request. This will finalize current request code path and decrease the counter. </p>
<p> Redirected and rewritten requests become internal and can access the internal locations. Internal requests have the internal flag set. </p>
<h4 id="Subrequests"><a href="#Subrequests" class="headerlink" title="Subrequests"></a>Subrequests</h4><p> Subrequests are primarily used to insert output of one request into another, possibly mixed with other data. A subrequest looks like a normal request, but shares some data with its parent. In particular, all fields related to client input are shared because a subrequest does not receive any other input from the client. The request field parent for a subrequest contains a link to its parent request and is NULL for the main request. The field main contains a link to the main request in a group of requests. </p>
<p> A subrequest starts in the NGX_HTTP_SERVER_REWRITE_PHASE phase. It passes through the same subsequent phases as a normal request and is assigned a location based on its own URI. </p>
<p> The output header in a subrequest is always ignored. The ngx_http_postpone_filter places the subrequest’s output body in the right position relative to other data produced by the parent request. </p>
<p> Subrequests are related to the concept of active requests. A request r is considered active if c-&gt;data == r , where c is the client connection object. At any given point, only the active request in a request group is allowed to output its buffers to the client. An inactive request can still send its output to the filter chain, but it does not pass beyond the ngx_http_postpone_filter and remains buffered by that filter until the request becomes active. Here are some rules of request activation: </p>
<ul>
<li>Initially, the main request is active. </li>
<li>The first subrequest of an active request becomes active right after creation. </li>
<li>The ngx_http_postpone_filter activates the next request in the active request’s subrequest list, once all data prior to that request are sent. </li>
<li><p>When a request is finalized, its parent is activated.<br>Create a subrequest by calling the function ngx_http_subrequest(r, uri, args, psr, ps, flags) , where r is the parent request, uri and args are the URI and arguments of the subrequest, psr is the output parameter, which receives the newly created subrequest reference, ps is a callback object for notifying the parent request that the subrequest is being finalized, and flags is bitmask of flags. The following flags are available: </p>
</li>
<li><p>NGX_HTTP_SUBREQUEST_IN_MEMORY - Output is not sent to the client, but rather stored in memory. The flag only affects subrequests which are processed by one of the proxying modules. After a subrequest is finalized its output is available in a r-&gt;upstream-&gt;buffer of type ngx_buf_t . </p>
</li>
<li>NGX_HTTP_SUBREQUEST_WAITED - The subrequest’s done flag is set even if the subrequest is not active when it is finalized. This subrequest flag is used by the SSI filter. </li>
<li>NGX_HTTP_SUBREQUEST_CLONE - The subrequest is created as a clone of its parent. It is started at the same location and proceeds from the same phase as the parent request.<br>The following example creates a subrequest with the URI of /foo . </li>
</ul>
<blockquote>
<p>ngx_int_t rc; ngx_str_t uri; ngx_http_request_t <em>sr; … ngx_str_set(&amp;uri, “/foo”); rc = ngx_http_subrequest(r, &amp;uri, NULL, &amp;sr, NULL, 0); if (rc == NGX_ERROR) { /</em> error */ }  This example clones the current request and sets a finalization callback for the subrequest. </p>
<p>ngx_int_t ngx_http_foo_clone(ngx_http_request_t <em>r) { ngx_http_request_t </em>sr; ngx_http_post_subrequest_t <em>ps; ps = ngx_palloc(r-&gt;pool, sizeof(ngx_http_post_subrequest_t)); if (ps == NULL) { return NGX_ERROR; } ps-&gt;handler = ngx_http_foo_subrequest_done; ps-&gt;data = “foo”; return ngx_http_subrequest(r, &amp;r-&gt;uri, &amp;r-&gt;args, &amp;sr, ps, NGX_HTTP_SUBREQUEST_CLONE); } ngx_int_t ngx_http_foo_subrequest_done(ngx_http_request_t </em>r, void <em>data, ngx_int_t rc) { char </em>msg = (char *) data; ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0, “done subrequest r:%p msg:%s rc:%i”, r, msg, rc); return rc; }  Subrequests are normally created in a body filter, in which case their output can be treated like the output from any explicit request. This means that eventually the output of a subrequest is sent to the client, after all explicit buffers that are passed before subrequest creation and before any buffers that are passed after creation. This ordering is preserved even for large hierarchies of subrequests. The following example inserts output from a subrequest after all request data buffers, but before the final buffer with the last_buf flag. </p>
<p>ngx_int_t ngx_http_foo_body_filter(ngx_http_request_t <em>r, ngx_chain_t </em>in) { ngx_int_t rc; ngx_buf_t <em>b; ngx_uint_t last; ngx_chain_t </em>cl, out; ngx_http_request_t <em>sr; ngx_http_foo_filter_ctx_t </em>ctx; ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module); if (ctx == NULL) { return ngx_http_next_body_filter(r, in); } last = 0; for (cl = in; cl; cl = cl-&gt;next) { if (cl-&gt;buf-&gt;last_buf) { cl-&gt;buf-&gt;last_buf = 0; cl-&gt;buf-&gt;last_in_chain = 1; cl-&gt;buf-&gt;sync = 1; last = 1; } } /<em> Output explicit output buffers </em>/ rc = ngx_http_next_body_filter(r, in); if (rc == NGX_ERROR || !last) { return rc; } /<em> </em> Create the subrequest. The output of the subrequest <em> will automatically be sent after all preceding buffers, </em> but before the last_buf buffer passed later in this function. <em>/ if (ngx_http_subrequest(r, ctx-&gt;uri, NULL, &amp;sr, NULL, 0) != NGX_OK) { return NGX_ERROR; } ngx_http_set_ctx(r, NULL, ngx_http_foo_filter_module); /</em> Output the final buffer with the last_buf flag */ b = ngx_calloc_buf(r-&gt;pool); if (b == NULL) { return NGX_ERROR; } b-&gt;last_buf = 1; out.buf = b; out.next = NULL; return ngx_http_output_filter(r, &amp;out); }  A subrequest can also be created for other purposes than data output. For example, the ngx_http_auth_request_module module creates a subrequest at the NGX_HTTP_ACCESS_PHASE phase. To disable output at this point, the header_only flag is set on the subrequest. This prevents the subrequest body from being sent to the client. Note that the subrequest’s header is never sent to the client. The result of the subrequest can be analyzed in the callback handler. </p>
</blockquote>
<h4 id="Request-finalization"><a href="#Request-finalization" class="headerlink" title="Request finalization"></a>Request finalization</h4><p> An HTTP request is finalized by calling the function ngx_http_finalize_request(r, rc) . It is usually finalized by the content handler after all output buffers are sent to the filter chain. At this point all of the output might not be sent to the client, with some of it remaining buffered somewhere along the filter chain. If it is, the ngx_http_finalize_request(r, rc) function automatically installs a special handler ngx_http_writer(r) to finish sending the output. A request is also finalized in case of an error or if a standard HTTP response code needs to be returned to the client. </p>
<p> The function ngx_http_finalize_request(r, rc) expects the following rc values: </p>
<ul>
<li>NGX_DONE - Fast finalization. Decrement the request count and destroy the request if it reaches zero. The client connection can be used for more requests after the current request is destroyed. </li>
<li>NGX_ERROR , NGX_HTTP_REQUEST_TIME_OUT ( 408 ), NGX_HTTP_CLIENT_CLOSED_REQUEST ( 499 ) - Error finalization. Terminate the request as soon as possible and close the client connection. </li>
<li>NGX_HTTP_CREATED ( 201 ), NGX_HTTP_NO_CONTENT ( 204 ), codes greater than or equal to NGX_HTTP_SPECIAL_RESPONSE ( 300 ) - Special response finalization. For these values nginx either sends to the client a default response page for the code or performs the internal redirect to an error_page location if that is configured for the code. </li>
<li><p>Other codes are considered successful finalization codes and might activate the request writer to finish sending the response body. Once the body is completely sent, the request count is decremented. If it reaches zero, the request is destroyed, but the client connection can still be used for other requests. If count is positive, there are unfinished activities within the request, which will be finalized at a later point. </p>
<h4 id="Request-body"><a href="#Request-body" class="headerlink" title="Request body"></a>Request body</h4><p>For dealing with the body of a client request, nginx provides the ngx_http_read_client_request_body(r, post_handler) and ngx_http_discard_request_body(r) functions. The first function reads the request body and makes it available via the request_body request field. The second function instructs nginx to discard (read and ignore) the request body. One of these functions must be called for every request. Normally, the content handler makes the call. </p>
<p>Reading or discarding the client request body from a subrequest is not allowed. It must always be done in the main request. When a subrequest is created, it inherits the parent’s request_body object which can be used by the subrequest if the main request has previously read the request body. </p>
<p>The function ngx_http_read_client_request_body(r, post_handler) starts the process of reading the request body. When the body is completely read, the post_handler callback is called to continue processing the request. If the request body is missing or has already been read, the callback is called immediately. The function ngx_http_read_client_request_body(r, post_handler) allocates the request_body request field of type ngx_http_request_body_t . The field bufs of this object keeps the result as a buffer chain. The body can be saved in memory buffers or file buffers, if the capacity specified by the client_body_buffer_size directive is not enough to fit the entire body in memory. </p>
<p>The following example reads a client request body and returns its size. </p>
</li>
</ul>
<blockquote>
<p>ngx_int_t ngx_http_foo_content_handler(ngx_http_request_t <em>r) { ngx_int_t rc; rc = ngx_http_read_client_request_body(r, ngx_http_foo_init); if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) { /</em> error <em>/ return rc; } return NGX_DONE; } void ngx_http_foo_init(ngx_http_request_t </em>r) { off_t len; ngx_buf_t <em>b; ngx_int_t rc; ngx_chain_t </em>in, out; if (r-&gt;request_body == NULL) { ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; } len = 0; for (in = r-&gt;request_body-&gt;bufs; in; in = in-&gt;next) { len += ngx_buf_size(in-&gt;buf); } b = ngx_create_temp_buf(r-&gt;pool, NGX_OFF_T_LEN); if (b == NULL) { ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; } b-&gt;last = ngx_sprintf(b-&gt;pos, “%O”, len); b-&gt;last_buf = (r == r-&gt;main) ? 1: 0; b-&gt;last_in_chain = 1; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = b-&gt;last - b-&gt;pos; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) { ngx_http_finalize_request(r, rc); return; } out.buf = b; out.next = NULL; rc = ngx_http_output_filter(r, &amp;out); ngx_http_finalize_request(r, rc); }  The following fields of the request determine how the request body is read: </p>
</blockquote>
<ul>
<li>request_body_in_single_buf - Read the body to a single memory buffer. </li>
<li>request_body_in_file_only - Always read the body to a file, even if fits in the memory buffer. </li>
<li>request_body_in_persistent_file - Do not unlink the file immediately after creation. A file with this flag can be moved to another directory. </li>
<li>request_body_in_clean_file - Unlink the file when the request is finalized. This can be useful when a file was supposed to be moved to another directory but was not moved for some reason. </li>
<li>request_body_file_group_access - Enable group access to the file by replacing the default 0600 access mask with 0660. </li>
<li>request_body_file_log_level - Severity level at which to log file errors. </li>
<li>request_body_no_buffering - Read the request body without buffering.<br>The request_body_no_buffering flag enables the unbuffered mode of reading a request body. In this mode, after calling ngx_http_read_client_request_body() , the bufs chain might keep only a part of the body. To read the next part, call the ngx_http_read_unbuffered_request_body(r) function. The return value NGX_AGAIN and the request flag reading_body indicate that more data is available. If bufs is NULL after calling this function, there is nothing to read at the moment. The request callback read_event_handler will be called when the next part of request body is available. </li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p> In nginx an HTTP response is produced by sending the response header followed by the optional response body. Both header and body are passed through a chain of filters and eventually get written to the client socket. An nginx module can install its handler into the header or body filter chain and process the output coming from the previous handler. </p>
<h4 id="Response-header"><a href="#Response-header" class="headerlink" title="Response header"></a>Response header</h4><p> The ngx_http_send_header(r) function sends the output header. Do not call this function until r-&gt;headers_out contains all of the data required to produce the HTTP response header. The status field in r-&gt;headers_out must always be set. If the response status indicates that a response body follows the header, content_length_n can be set as well. The default value for this field is -1 , which means that the body size is unknown. In this case, chunked transfer encoding is used. To output an arbitrary header, append the headers list. </p>
<blockquote>
<p>static ngx_int_t ngx_http_foo_content_handler(ngx_http_request_t <em>r) { ngx_int_t rc; ngx_table_elt_t </em>h; /<em> send header </em>/ r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = 3; /<em> X-Foo: foo </em>/ h = ngx_list_push(&amp;r-&gt;headers_out.headers); if (h == NULL) { return NGX_ERROR; } h-&gt;hash = 1; ngx_str_set(&amp;h-&gt;key, “X-Foo”); ngx_str_set(&amp;h-&gt;value, “foo”); rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) { return rc; } /<em> send body </em>/ … } ####  Header filters</p>
</blockquote>
<p> The ngx_http_send_header(r) function invokes the header filter chain by calling the first header filter handler stored in the ngx_http_top_header_filter variable. It’s assumed that every header handler calls the next handler in the chain until the final handler ngx_http_header_filter(r) is called. The final header handler constructs the HTTP response based on r-&gt;headers_out and passes it to the ngx_http_writer_filter for output. </p>
<p> To add a handler to the header filter chain, store its address in the global variable ngx_http_top_header_filter at configuration time. The previous handler address is normally stored in a static variable in a module and is called by the newly added handler before exiting. </p>
<p> The following example of a header filter module adds the HTTP header “ X-Foo: foo “ to every response with status 200 . </p>
<blockquote>
<p>#include <ngx\_config.h> #include <ngx\_core.h> #include <ngx\_http.h> static ngx_int_t ngx_http_foo_header_filter(ngx_http_request_t <em>r); static ngx_int_t ngx_http_foo_header_filter_init(ngx_conf_t </em>cf); static ngx_http_module_t ngx_http_foo_header_filter_module_ctx = { NULL, /<em> preconfiguration </em>/ ngx_http_foo_header_filter_init, /<em> postconfiguration </em>/ NULL, /<em> create main configuration </em>/ NULL, /<em> init main configuration </em>/ NULL, /<em> create server configuration </em>/ NULL, /<em> merge server configuration </em>/ NULL, /<em> create location configuration </em>/ NULL /<em> merge location configuration </em>/ }; ngx_module_t ngx_http_foo_header_filter_module = { NGX_MODULE_V1, &amp;ngx_http_foo_header_filter_module_ctx, /<em> module context </em>/ NULL, /<em> module directives </em>/ NGX_HTTP_MODULE, /<em> module type </em>/ NULL, /<em> init master </em>/ NULL, /<em> init module </em>/ NULL, /<em> init process </em>/ NULL, /<em> init thread </em>/ NULL, /<em> exit thread </em>/ NULL, /<em> exit process </em>/ NULL, /<em> exit master </em>/ NGX_MODULE_V1_PADDING }; static ngx_http_output_header_filter_pt ngx_http_next_header_filter; static ngx_int_t ngx_http_foo_header_filter(ngx_http_request_t <em>r) { ngx_table_elt_t </em>h; /<em> </em> The filter handler adds “X-Foo: foo” header <em> to every HTTP 200 response </em>/ if (r-&gt;headers_out.status != NGX_HTTP_OK) { return ngx_http_next_header_filter(r); } h = ngx_list_push(&amp;r-&gt;headers_out.headers); if (h == NULL) { return NGX_ERROR; } h-&gt;hash = 1; ngx_str_set(&amp;h-&gt;key, “X-Foo”); ngx_str_set(&amp;h-&gt;value, “foo”); return ngx_http_next_header_filter(r); } static ngx_int_t ngx_http_foo_header_filter_init(ngx_conf_t *cf) { ngx_http_next_header_filter = ngx_http_top_header_filter; ngx_http_top_header_filter = ngx_http_foo_header_filter; return NGX_OK; } ####  Response body</ngx\_http.h></ngx\_core.h></ngx\_config.h></p>
</blockquote>
<p> To send the response body, call the ngx_http_output_filter(r, cl) function. The function can be called multiple times. Each time, it sends a part of the response body in the form of a buffer chain. Set the last_buf flag in the last body buffer. </p>
<p> The following example produces a complete HTTP response with “foo” as its body. For the example to work as subrequest as well as a main request, the last_in_chain flag is set in the last buffer of the output. The last_buf flag is set only for the main request because the last buffer for a subrequest does not end the entire output. </p>
<blockquote>
<p>static ngx_int_t ngx_http_bar_content_handler(ngx_http_request_t <em>r) { ngx_int_t rc; ngx_buf_t </em>b; ngx_chain_t out; /<em> send header </em>/ r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = 3; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) { return rc; } /<em> send body </em>/ b = ngx_calloc_buf(r-&gt;pool); if (b == NULL) { return NGX_ERROR; } b-&gt;last_buf = (r == r-&gt;main) ? 1: 0; b-&gt;last_in_chain = 1; b-&gt;memory = 1; b-&gt;pos = (u_char *) “foo”; b-&gt;last = b-&gt;pos + 3; out.buf = b; out.next = NULL; return ngx_http_output_filter(r, &amp;out); } ####  Body filters</p>
</blockquote>
<p> The function ngx_http_output_filter(r, cl) invokes the body filter chain by calling the first body filter handler stored in the ngx_http_top_body_filter variable. It’s assumed that every body handler calls the next handler in the chain until the final handler ngx_http_write_filter(r, cl) is called. </p>
<p> A body filter handler receives a chain of buffers. The handler is supposed to process the buffers and pass a possibly new chain to the next handler. It’s worth noting that the chain links ngx_chain_t of the incoming chain belong to the caller, and must not be reused or changed. Right after the handler completes, the caller can use its output chain links to keep track of the buffers it has sent. To save the buffer chain or to substitute some buffers before passing to the next filter, a handler needs to allocate its own chain links. </p>
<p> Following is an example of a simple body filter that counts the number of bytes in the body. The result is available as the $counter variable which can be used in the access log. </p>
<blockquote>
<p>#include <ngx\_config.h> #include <ngx\_core.h> #include <ngx\_http.h> typedef struct { off_t count; } ngx_http_counter_filter_ctx_t; static ngx_int_t ngx_http_counter_body_filter(ngx_http_request_t <em>r, ngx_chain_t </em>in); static ngx_int_t ngx_http_counter_variable(ngx_http_request_t <em>r, ngx_http_variable_value_t </em>v, uintptr_t data); static ngx_int_t ngx_http_counter_add_variables(ngx_conf_t <em>cf); static ngx_int_t ngx_http_counter_filter_init(ngx_conf_t </em>cf); static ngx_http_module_t ngx_http_counter_filter_module_ctx = { ngx_http_counter_add_variables, /<em> preconfiguration </em>/ ngx_http_counter_filter_init, /<em> postconfiguration </em>/ NULL, /<em> create main configuration </em>/ NULL, /<em> init main configuration </em>/ NULL, /<em> create server configuration </em>/ NULL, /<em> merge server configuration </em>/ NULL, /<em> create location configuration </em>/ NULL /<em> merge location configuration </em>/ }; ngx_module_t ngx_http_counter_filter_module = { NGX_MODULE_V1, &amp;ngx_http_counter_filter_module_ctx, /<em> module context </em>/ NULL, /<em> module directives </em>/ NGX_HTTP_MODULE, /<em> module type </em>/ NULL, /<em> init master </em>/ NULL, /<em> init module </em>/ NULL, /<em> init process </em>/ NULL, /<em> init thread </em>/ NULL, /<em> exit thread </em>/ NULL, /<em> exit process </em>/ NULL, /<em> exit master </em>/ NGX_MODULE_V1_PADDING }; static ngx_http_output_body_filter_pt ngx_http_next_body_filter; static ngx_str_t ngx_http_counter_name = ngx_string(“counter”); static ngx_int_t ngx_http_counter_body_filter(ngx_http_request_t <em>r, ngx_chain_t </em>in) { ngx_chain_t <em>cl; ngx_http_counter_filter_ctx_t </em>ctx; ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module); if (ctx == NULL) { ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_counter_filter_ctx_t)); if (ctx == NULL) { return NGX_ERROR; } ngx_http_set_ctx(r, ctx, ngx_http_counter_filter_module); } for (cl = in; cl; cl = cl-&gt;next) { ctx-&gt;count += ngx_buf_size(cl-&gt;buf); } return ngx_http_next_body_filter(r, in); } static ngx_int_t ngx_http_counter_variable(ngx_http_request_t <em>r, ngx_http_variable_value_t </em>v, uintptr_t data) { u_char <em>p; ngx_http_counter_filter_ctx_t </em>ctx; ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module); if (ctx == NULL) { v-&gt;not_found = 1; return NGX_OK; } p = ngx_pnalloc(r-&gt;pool, NGX_OFF_T_LEN); if (p == NULL) { return NGX_ERROR; } v-&gt;data = p; v-&gt;len = ngx_sprintf(p, “%O”, ctx-&gt;count) - p; v-&gt;valid = 1; v-&gt;no_cacheable = 0; v-&gt;not_found = 0; return NGX_OK; } static ngx_int_t ngx_http_counter_add_variables(ngx_conf_t <em>cf) { ngx_http_variable_t </em>var; var = ngx_http_add_variable(cf, &amp;ngx_http_counter_name, 0); if (var == NULL) { return NGX_ERROR; } var-&gt;get_handler = ngx_http_counter_variable; return NGX_OK; } static ngx_int_t ngx_http_counter_filter_init(ngx_conf_t *cf) { ngx_http_next_body_filter = ngx_http_top_body_filter; ngx_http_top_body_filter = ngx_http_counter_body_filter; return NGX_OK; } ####  Building filter modules</ngx\_http.h></ngx\_core.h></ngx\_config.h></p>
</blockquote>
<p> When writing a body or header filter, pay special attention to the filter’s position in the filter order. There’s a number of header and body filters registered by nginx standard modules. The nginx standard modules register a number of head and body filters and it’s important to register a new filter module in the right place with respect to them. Normally, modules register filters in their postconfiguration handlers. The order in which filters are called during processing is obviously the reverse of the order in which they are registered. </p>
<p> For third-party filter modules nginx provides a special slot HTTP_AUX_FILTER_MODULES . To register a filter module in this slot, set the ngx_module_type variable to HTTP_AUX_FILTER in the module’s configuration. </p>
<p> The following example shows a filter module config file assuming for a module with just one source file, ngx_http_foo_filter_module.c . </p>
<blockquote>
<p>ngx_module_type=HTTP_AUX_FILTER ngx_module_name=ngx_http_foo_filter_module ngx_module_srcs=”$ngx_addon_dir/ngx_http_foo_filter_module.c” . auto/module ####  Buffer reuse</p>
</blockquote>
<p> When issuing or altering a stream of buffers, it’s often desirable to reuse the allocated buffers. A standard and widely adopted approach in nginx code is to keep two buffer chains for this purpose: free and busy . The free chain keeps all free buffers, which can be reused. The busy chain keeps all buffers sent by the current module that are still in use by some other filter handler. A buffer is considered in use if its size is greater than zero. Normally, when a buffer is consumed by a filter, its pos (or file_pos for a file buffer) is moved towards last ( file_last for a file buffer). Once a buffer is completely consumed, it’s ready to be reused. To add newly freed buffers to the free chain it’s enough to iterate over the busy chain and move the zero size buffers at the head of it to free . This operation is so common that there is a special function for it, ngx_chain_update_chains(free, busy, out, tag) . The function appends the output chain out to busy and moves free buffers from the top of busy to free . Only the buffers with the specified tag are reused. This lets a module reuse only the buffers that it allocated itself. </p>
<p> The following example is a body filter that inserts the string “foo” before each incoming buffer. The new buffers allocated by the module are reused if possible. Note that for this example to work properly, setting up a header filter and resetting content_length_n to -1 is also required, but the relevant code is not provided here. </p>
<blockquote>
<p>typedef struct { ngx_chain_t <em>free; ngx_chain_t </em>busy; } ngx_http_foo_filter_ctx_t; ngx_int_t ngx_http_foo_body_filter(ngx_http_request_t <em>r, ngx_chain_t </em>in) { ngx_int_t rc; ngx_buf_t <em>b; ngx_chain_t </em>cl, <em>tl, </em>out, <em>*ll; ngx_http_foo_filter_ctx_t </em>ctx; ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module); if (ctx == NULL) { ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_foo_filter_ctx_t)); if (ctx == NULL) { return NGX_ERROR; } ngx_http_set_ctx(r, ctx, ngx_http_foo_filter_module); } /<em> create a new chain “out” from “in” with all the changes </em>/ ll = &out; for (cl = in; cl; cl = cl-&gt;next) { /<em> append “foo” in a reused buffer if possible </em>/ tl = ngx_chain_get_free_buf(r-&gt;pool, &amp;ctx-&gt;free); if (tl == NULL) { return NGX_ERROR; } b = tl-&gt;buf; b-&gt;tag = (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module; b-&gt;memory = 1; b-&gt;pos = (u_char <em>) “foo”; b-&gt;last = b-&gt;pos + 3; </em>ll = tl; ll = &amp;tl-&gt;next; /<em> append the next incoming buffer </em>/ tl = ngx_alloc_chain_link(r-&gt;pool); if (tl == NULL) { return NGX_ERROR; } tl-&gt;buf = cl-&gt;buf; <em>ll = tl; ll = &amp;tl-&gt;next; } </em>ll = NULL; /<em> send the new chain </em>/ rc = ngx_http_next_body_filter(r, out); /<em> update “busy” and “free” chains for reuse </em>/ ngx_chain_update_chains(r-&gt;pool, &amp;ctx-&gt;free, &amp;ctx-&gt;busy, &amp;out, (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module); return rc; } ####  负载均衡</p>
</blockquote>
<p> The ngx_http_upstream_module provides the basic functionality needed to pass requests to remote servers. Modules that implement specific protocols, such as HTTP or FastCGI, use this functionality. The module also provides an interface for creating custom load-balancing modules and implements a default round-robin method. </p>
<p> The least_conn and hash modules implement alternative load-balancing methods, but are actually implemented as extensions of the upstream round-robin module and share a lot of code with it, such as the representation of a server group. The keepalive module is an independent module that extends upstream functionality. </p>
<p> The ngx_http_upstream_module can be configured explicitly by placing the corresponding upstream block into the configuration file, or implicitly by using directives such as proxy_pass that accept a URL that gets evaluated at some point into a list of servers. The alternative load-balancing methods are available only with an explicit upstream configuration. The upstream module configuration has its own directive context NGX_HTTP_UPS_CONF . The structure is defined as follows: </p>
<blockquote>
<p>struct ngx_http_upstream_srv_conf_s { ngx_http_upstream_peer_t peer; void <em>*srv_conf; ngx_array_t </em>servers; /<em> ngx_http_upstream_server_t </em>/ ngx_uint_t flags; ngx_str_t host; u_char <em>file_name; ngx_uint_t line; in_port_t port; ngx_uint_t no_port; /</em> unsigned no_port:1 <em>/ #if (NGX_HTTP_UPSTREAM_ZONE) ngx_shm_zone_t </em>shm_zone; #endif }; *  srv_conf — Configuration context of upstream modules. </p>
<ul>
<li>servers — Array of ngx_http_upstream_server_t , the result of parsing a set of server directives in the upstream block. </li>
<li>flags — Flags that mostly mark which features are supported by the load-balancing method. The features are configured as parameters of the server directive: <ul>
<li>NGX_HTTP_UPSTREAM_CREATE — Distinguishes explicitly defined upstreams from those that are automatically created by the proxy_pass directive and “friends” (FastCGI, SCGI, etc.) </li>
<li>NGX_HTTP_UPSTREAM_WEIGHT — The “ weight ” parameter is supported </li>
<li>NGX_HTTP_UPSTREAM_MAX_FAILS — The “ max_fails ” parameter is supported </li>
<li>NGX_HTTP_UPSTREAM_FAIL_TIMEOUT — The “ fail_timeout ” parameter is supported </li>
<li>NGX_HTTP_UPSTREAM_DOWN — The “ down ” parameter is supported </li>
<li>NGX_HTTP_UPSTREAM_BACKUP — The “ backup ” parameter is supported </li>
<li>NGX_HTTP_UPSTREAM_MAX_CONNS — The “ max_conns ” parameter is supported </li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>host — Name of the upstream. </li>
<li>file_name, line — Name of the configuration file and the line where the upstream block is located. </li>
<li>port and no_port — Not used for explicitly defined upstream groups. </li>
<li>shm_zone — Shared memory zone used by this upstream group, if any. </li>
<li><p>peer — object that holds generic methods for initializing upstream configuration: </p>
<blockquote>
<p>typedef struct { ngx_http_upstream_init_pt init_upstream; ngx_http_upstream_init_peer_pt init; void *data; } ngx_http_upstream_peer_t;  A module that implements a load-balancing algorithm must set these methods and initialize private data . If init_upstream was not initialized during configuration parsing, ngx_http_upstream_module sets it to the default ngx_http_upstream_init_round_robin algorithm. </p>
<ul>
<li>init_upstream(cf, us) — Configuration-time method responsible for initializing a group of servers and initializing the init() method in case of success. A typical load-balancing module uses a list of servers in the upstream block to create an efficient data structure that it uses and saves its own configuration to the data field. </li>
<li>init(r, us) — Initializes a per-request ngx_http_upstream_peer_t.peer structure that is used for load balancing (not to be confused with the ngx_http_upstream_srv_conf_t.peer described above which is per-upstream). It is passed as the data argument to all callbacks that deal with server selection. </li>
</ul>
</blockquote>
<p>When nginx has to pass a request to another host for processing, it uses the configured load-balancing method to obtain an address to connect to. The method is obtained from the ngx_http_upstream_t.peer object of type ngx_peer_connection_t : </p>
</li>
</ul>
<blockquote>
<p>struct ngx_peer_connection_s { … struct sockaddr <em>sockaddr; socklen_t socklen; ngx_str_t </em>name; ngx_uint_t tries; ngx_event_get_peer_pt get; ngx_event_free_peer_pt free; ngx_event_notify_peer_pt notify; void *data; #if (NGX_SSL || NGX_COMPAT) ngx_event_set_peer_session_pt set_session; ngx_event_save_peer_session_pt save_session; #endif … };  The structure has the following fields: </p>
</blockquote>
<ul>
<li>sockaddr , socklen , name — Address of the upstream server to connect to; this is the output parameter of a load-balancing method. </li>
<li>data — The per-request data of a load-balancing method; keeps the state of the selection algorithm and usually includes the link to the upstream configuration. It is passed as an argument to all methods that deal with server selection (see below ). </li>
<li>tries — Allowed number of attempts to connect to an upstream server. </li>
<li><p>get , free , notify , set_session , and save_session - Methods of the load-balancing module, described below.<br>All methods accept at least two arguments: a peer connection object pc and the data created by ngx_http_upstream_srv_conf_t.peer.init() . Note that it might differ from pc.data due to “chaining” of load-balancing modules. </p>
</li>
<li><p>get(pc, data) — The method called when the upstream module is ready to pass a request to an upstream server and needs to know its address. The method has to fill the sockaddr , socklen , and name fields of ngx_peer_connection_t structure. The return is one of: </p>
<ul>
<li>NGX_OK — Server was selected. </li>
<li>NGX_ERROR — Internal error occurred. </li>
<li>NGX_BUSY — no servers are currently available. This can happen due to many reasons, including: the dynamic server group is empty, all servers in the group are in the failed state, or all servers in the group are already handling the maximum number of connections. </li>
<li>NGX_DONE — the underlying connection was reused and there is no need to create a new connection to the upstream server. This value is set by the keepalive module. </li>
</ul>
</li>
<li><p>free(pc, data, state) — The method called when an upstream module has finished work with a particular server. The state argument is the completion status of the upstream connection, a bitmask with the following possible values: </p>
<ul>
<li>NGX_PEER_FAILED — Attempt was unsuccessful </li>
<li>NGX_PEER_NEXT — A special case when upstream server returns codes 403 or 404 , which are not considered a failure . </li>
<li>NGX_PEER_KEEPALIVE — Currently unused<br>This method also decrements the tries counter. </li>
</ul>
</li>
<li>notify(pc, data, type) — Currently unused in the OSS version. </li>
<li><p>set_session(pc, data) and save_session(pc, data) — SSL-specific methods that enable caching sessions to upstream servers. The implementation is provided by the round-robin balancing method. </p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>The nginx-dev-examples repository provides nginx module examples. </p>
</li>
</ul>
<h4 id="Code-style"><a href="#Code-style" class="headerlink" title="Code style"></a>Code style</h4><h4 id="General-rules"><a href="#General-rules" class="headerlink" title="General rules"></a>General rules</h4><ul>
<li>maximum text width is 80 characters </li>
<li>indentation is 4 spaces </li>
<li>no tabs, no trailing spaces </li>
<li>list elements on the same line are separated with spaces </li>
<li>hexadecimal literals are lowercase </li>
<li>file names, function and type names, and global variables have the ngx_ or more specific prefix such as ngx_http_ and ngx_mail_ </li>
</ul>
<blockquote>
<p>size_t ngx_utf8_length(u_char <em>p, size_t n) { u_char c, </em>last; size_t len; last = p + n; for (len = 0; p &lt; last; len++) { c = <em>p; if (c &lt; 0x80) { p++; continue; } if (ngx_utf8_decode(&amp;p, n) &gt; 0x10ffff) { /</em> invalid UTF-8 */ return n; } } return len; } ####  档</p>
</blockquote>
<p> A typical source file may contain the following sections separated by two empty lines: </p>
<ul>
<li>copyright statements </li>
<li>包括 </li>
<li>preprocessor definitions </li>
<li>type definitions </li>
<li>function prototypes </li>
<li>variable definitions </li>
<li>function definitions<br>Copyright statements look like this: </li>
</ul>
<blockquote>
<p>/<em> </em> Copyright (C) Author Name <em> Copyright (C) Organization, Inc. </em>/  If the file is modified significantly, the list of authors should be updated, the new author is added to the top. </p>
</blockquote>
<p> The ngx_config.h and ngx_core.h files are always included first, followed by one of ngx_http.h , ngx_stream.h , or ngx_mail.h . Then follow optional external header files: </p>
<blockquote>
<p>#include <ngx\_config.h> #include <ngx\_core.h> #include <ngx\_http.h> #include <libxml parser.h=""> #include <libxml tree.h=""> #include <libxslt xslt.h=""> #if (NGX_HAVE_EXSLT) #include <libexslt exslt.h=""> #endif  Header files should include the so called “header protection”: </libexslt></libxslt></libxml></libxml></ngx\_http.h></ngx\_core.h></ngx\_config.h></p>
<p>#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_ #define _NGX_PROCESS_CYCLE_H_INCLUDED_ … #endif /<em> _NGX_PROCESS_CYCLE_H_INCLUDED_ </em>/ ####  评论</p>
</blockquote>
<ul>
<li>“ // ” comments are not used </li>
<li>text is written in English, American spelling is preferred </li>
<li><p>multi-line comments are formatted like this: </p>
<blockquote>
<p>/<em> </em> The red-black tree code is based on the algorithm described in <em> the “Introduction to Algorithms” by Cormen, Leiserson and Rivest. </em>/<br>/<em> find the server configuration for the address:port </em>/ </p>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4></blockquote>
<p>Macro names start from ngx_ or NGX_ (or more specific) prefix. Macro names for constants are uppercase. Parameterized macros and macros for initializers are lowercase. The macro name and value are separated by at least two spaces: </p>
</li>
</ul>
<blockquote>
<p>#define NGX_CONF_BUFFER 4096 #define ngx_buf_in_memory(b) (b-&gt;temporary || b-&gt;memory || b-&gt;mmap) #define ngx_buf_size(b) \ (ngx_buf_in_memory(b) ? (off_t) (b-&gt;last - b-&gt;pos): \ (b-&gt;file_last - b-&gt;file_pos)) #define ngx_null_string { 0, NULL }  Conditions are inside parentheses, negation is outside: </p>
<p>#if (NGX_HAVE_KQUEUE) … #elif ((NGX_HAVE_DEVPOLL &amp;&amp; !(NGX_TEST_BUILD_DEVPOLL)) \ || (NGX_HAVE_EVENTPORT &amp;&amp; !(NGX_TEST_BUILD_EVENTPORT))) … #elif (NGX_HAVE_EPOLL &amp;&amp; !(NGX_TEST_BUILD_EPOLL)) … #elif (NGX_HAVE_POLL) … #else /<em> select </em>/ … #endif /<em> NGX_HAVE_KQUEUE </em>/ ####  类型</p>
</blockquote>
<p> Type names end with the “ _t ” suffix. A defined type name is separated by at least two spaces: </p>
<blockquote>
<p>typedef ngx_uint_t ngx_rbtree_key_t;  Structure types are defined using typedef . Inside structures, member types and names are aligned: </p>
<p>typedef struct { size_t len; u_char *data; } ngx_str_t;  Keep alignment identical among different structures in the file. A structure that points to itself has the name, ending with “ _s ”. Adjacent structure definitions are separated with two empty lines: </p>
<p>typedef struct ngx_list_part_s ngx_list_part_t; struct ngx_list_part_s { void <em>elts; ngx_uint_t nelts; ngx_list_part_t </em>next; }; typedef struct { ngx_list_part_t <em>last; ngx_list_part_t part; size_t size; ngx_uint_t nalloc; ngx_pool_t </em>pool; } ngx_list_t;  Each structure member is declared on its own line: </p>
<p>typedef struct { ngx_uint_t hash; ngx_str_t key; ngx_str_t value; u_char *lowcase_key; } ngx_table_elt_t;  Function pointers inside structures have defined types ending with “ _pt ”: </p>
<p>typedef ssize_t (<em>ngx_recv_pt)(ngx_connection_t </em>c, u_char <em>buf, size_t size); typedef ssize_t (</em>ngx_recv_chain_pt)(ngx_connection_t <em>c, ngx_chain_t </em>in, off_t limit); typedef ssize_t (<em>ngx_send_pt)(ngx_connection_t </em>c, u_char <em>buf, size_t size); typedef ngx_chain_t </em>(<em>ngx_send_chain_pt)(ngx_connection_t </em>c, ngx_chain_t *in, off_t limit); typedef struct { ngx_recv_pt recv; ngx_recv_chain_pt recv_chain; ngx_recv_pt udp_recv; ngx_send_pt send; ngx_send_pt udp_send; ngx_send_chain_pt udp_send_chain; ngx_send_chain_pt send_chain; ngx_uint_t flags; } ngx_os_io_t;  Enumerations have types ending with “ _e ”: </p>
<p>typedef enum { ngx_http_fastcgi_st_version = 0, ngx_http_fastcgi_st_type, … ngx_http_fastcgi_st_padding } ngx_http_fastcgi_state_e; ####  变量</p>
</blockquote>
<p> Variables are declared sorted by length of a base type, then alphabetically. Type names and variable names are aligned. The type and name “columns” are separated with two spaces. Large arrays are put at the end of a declaration block: </p>
<blockquote>
<p>u_char | | <em>rv, </em>p; ngx_conf_t | | <em>cf; ngx_uint_t | | i, j, k; unsigned int | | len; struct sockaddr | | </em>sa; const unsigned char | | <em>data; ngx_peer_connection_t | | </em>pc; ngx_http_core_srv_conf_t | |<em>*cscfp; ngx_http_upstream_srv_conf_t| | </em>us, *uscf; u_char | | text[NGX_SOCKADDR_STRLEN];  Static and global variables may be initialized on declaration: </p>
<p>static ngx_str_t ngx_http_memcached_key = ngx_string(“memcached_key”);<br>static ngx_uint_t mday[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };<br>static uint32_t ngx_crc32_table16[] = { 0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, … 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };  There is a bunch of commonly used type/name combinations: </p>
<p>u_char <em>rv; ngx_int_t rc; ngx_conf_t </em>cf; ngx_connection_t <em>c; ngx_http_request_t </em>r; ngx_peer_connection_t <em>pc; ngx_http_upstream_srv_conf_t </em>us, *uscf; ####  功能</p>
</blockquote>
<p> All functions (even static ones) should have prototypes. Prototypes include argument names. Long prototypes are wrapped with a single indentation on continuation lines: </p>
<blockquote>
<p>static char <em>ngx_http_block(ngx_conf_t </em>cf, ngx_command_t <em>cmd, void </em>conf); static ngx_int_t ngx_http_init_phases(ngx_conf_t <em>cf, ngx_http_core_main_conf_t </em>cmcf); static char <em>ngx_http_merge_servers(ngx_conf_t </em>cf, ngx_http_core_main_conf_t <em>cmcf, ngx_http_module_t </em>module, ngx_uint_t ctx_index);  The function name in a definition starts with a new line. The function body opening and closing braces are on separate lines. The body of a function is indented. There are two empty lines between functions: </p>
<p>static ngx_int_t ngx_http_find_virtual_server(ngx_http_request_t <em>r, u_char </em>host, size_t len) { … } static ngx_int_t ngx_http_add_addresses(ngx_conf_t <em>cf, ngx_http_core_srv_conf_t </em>cscf, ngx_http_conf_port_t <em>port, ngx_http_listen_opt_t </em>lsopt) { … }  There is no space after the function name and opening parenthesis. Long function calls are wrapped such that continuation lines start from the position of the first function argument. If this is impossible, format the first continuation line such that it ends at position 79: </p>
<p>ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, “http header: \”%V: %V\””, &amp;h-&gt;key, &amp;h-&gt;value); hc-&gt;busy = ngx_palloc(r-&gt;connection-&gt;pool, cscf-&gt;large_client_header_buffers.num <em> sizeof(ngx_buf_t </em>));  The ngx_inline macro should be used instead of inline : </p>
<p>static ngx_inline void ngx_cpuid(uint32_t i, uint32_t *buf); ####  表达式</p>
</blockquote>
<p> Binary operators except “ . ” and “ −&gt; ” should be separated from their operands by one space. Unary operators and subscripts are not separated from their operands by spaces: </p>
<blockquote>
<p>width = width <em> 10 + (</em>fmt++ - ‘0’);<br>ch = (u_char) ((decoded &lt;&lt; 4) + (ch - ‘0’));<br>r-&gt;exten.data = &amp;r-&gt;uri.data[i + 1];  Type casts are separated by one space from casted expressions. An asterisk inside type cast is separated with space from type name: </p>
<p>len = ngx_sock_ntop((struct sockaddr *) sin6, p, len, 1);  If an expression does not fit into single line, it is wrapped. The preferred point to break a line is a binary operator. The continuation line is lined up with the start of expression: </p>
<p>if (status == NGX_HTTP_MOVED_PERMANENTLY || status == NGX_HTTP_MOVED_TEMPORARILY || status == NGX_HTTP_SEE_OTHER || status == NGX_HTTP_TEMPORARY_REDIRECT || status == NGX_HTTP_PERMANENT_REDIRECT) { … }<br>p-&gt;temp_file-&gt;warn = “an upstream response is buffered “ “to a temporary file”;  As a last resort, it is possible to wrap an expression so that the continuation line ends at position 79: </p>
<p>hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, sizeof(ngx_hash_wildcard_t) + size <em> sizeof(ngx_hash_elt_t </em>));  The above rules also apply to sub-expressions, where each sub-expression has its own indentation level: </p>
<p>if (((u-&gt;conf-&gt;cache_use_stale &amp; NGX_HTTP_UPSTREAM_FT_UPDATING) || c-&gt;stale_updating) &amp;&amp; !r-&gt;background &amp;&amp; u-&gt;conf-&gt;cache_background_update) { … }  Sometimes, it is convenient to wrap an expression after a cast. In this case, the continuation line is indented: </p>
<p>node = (ngx_rbtree_node_t <em>) ((u_char </em>) lr - offsetof(ngx_rbtree_node_t, color));  Pointers are explicitly compared to NULL (not 0 ): </p>
<p>if (ptr != NULL) { … } ####  Conditionals and Loops</p>
</blockquote>
<p> The “ if ” keyword is separated from the condition by one space. Opening brace is located on the same line, or on a dedicated line if the condition takes several lines. Closing brace is located on a dedicated line, optionally followed by “ else if / else ”. Usually, there is an empty line before the “ else if / else ” part: </p>
<blockquote>
<p>if (node-&gt;left == sentinel) { temp = node-&gt;right; subst = node; } else if (node-&gt;right == sentinel) { temp = node-&gt;left; subst = node; } else { subst = ngx_rbtree_min(node-&gt;right, sentinel); if (subst-&gt;left != sentinel) { temp = subst-&gt;left; } else { temp = subst-&gt;right; } }  Similar formatting rules are applied to “ do ” and “ while ” loops: </p>
<p>while (p &lt; last &amp;&amp; *p == ‘ ‘) { p++; }<br>do { ctx-&gt;node = rn; ctx = ctx-&gt;next; } while (ctx);  The “ switch ” keyword is separated from the condition by one space. Opening brace is located on the same line. Closing brace is located on a dedicated line. The “ case ” keywords are lined up with “ switch ”: </p>
<p>switch (ch) { case ‘!’: looked = 2; state = ssi_comment0_state; break; case ‘&lt;’: copy_end = p; break; default: copy_end = p; looked = 0; state = ssi_start_state; break; }  Most “ for ” loops are formatted like this: </p>
<p>for (i = 0; i &lt; ccf-&gt;env.nelts; i++) { … }<br>for (q = ngx_queue_head(locations); q != ngx_queue_sentinel(locations); q = ngx_queue_next(q)) { … }  If some part of the “ for ” statement is omitted, this is indicated by the “ /<em> void </em>/ ” comment: </p>
<p>for (i = 0; /<em> void </em>/ ; i++) { … }  A loop with an empty body is also indicated by the “ /<em> void </em>/ ” comment which may be put on the same line: </p>
<p>for (cl = <em>busy; cl-&gt;next; cl = cl-&gt;next) { /</em> void */ }  An endless loop looks like this: </p>
<p>for ( ;; ) { … } ####  标签</p>
</blockquote>
<p> Labels are surrounded with empty lines and are indented at the previous level: </p>
<blockquote>
<p> if (i == 0) { u-&gt;err = “host not found”; goto failed; } u-&gt;addrs = ngx_pcalloc(pool, i * sizeof(ngx_addr_t)); if (u-&gt;addrs == NULL) { goto failed; } u-&gt;naddrs = i; … return NGX_OK; failed: freeaddrinfo(res); return NGX_ERROR;  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows-nginx中文手册]]></title>
      <url>/ngx/windows.html</url>
      <content type="html"><![CDATA[<p>windows<br><a id="more"></a></p>
<h2 id="适用于Windows的nginx"><a href="#适用于Windows的nginx" class="headerlink" title=" 适用于Windows的nginx"></a> 适用于Windows的nginx</h2><p> Known issues<br> Possible future enhancements<br> 适用于Windows的nginx版本使用本机Win32 API（而不是Cygwin仿真层）。 目前仅使用select()连接处理方法，因此不应期望高性能和可伸缩性。 由于这个以及一些其他已知问题，nginx for Windows的版本被认为是<em>测试</em>版。 目前，除了XSLT过滤器，图像过滤器，GeoIP模块和嵌入式Perl语言之外，它提供的功能几乎与UNIX版本的nginx相同。 </p>
<p> 要安装nginx / Windows，请下载最新的主线版本发行版（1.15.7），因为nginx的主线分支包含所有已知的修复程序。 然后解压缩发行版，转到nginx-1.15.7目录，然后运行nginx 。 以下是驱动器C：根目录的示例： </p>
<blockquote>
<p>cd c:\ unzip nginx-1.15.7.zip cd nginx-1.15.7 start nginx  运行tasklist命令行实用程序以查看nginx进程： </p>
<p>C:\nginx-1.15.7&gt;tasklist /fi “imagename eq nginx.exe” Image Name PID Session Name Session# Mem Usage =============== ======== ============== ========== ============ nginx.exe 652 Console 0 2 780 K nginx.exe 1332 Console 0 3 112 K  其中一个进程是主进程，另一个进程是工作进程。 如果nginx未启动，请在错误日志文件logs\error.log查找原因。 如果尚未创建日志文件，则应在Windows事件日志中报告其原因。 如果显示错误页面而不是预期页面，还要在logs\error.log文件中查找原因。 </p>
</blockquote>
<p> nginx / Windows使用运行它的目录作为配置中相对路径的前缀。 在上面的示例中，前缀为C:\nginx-1.15.7\ 。 必须使用正斜杠以UNIX样式指定配置文件中的路径： </p>
<blockquote>
<p>access_log logs/site.log; root C:/web/html;  nginx / Windows作为标准控制台应用程序（而非服务）运行，可以使用以下命令进行管理： </p>
<p>nginx -s stopfast shutdownnginx -s quitgraceful shutdownnginx -s reload changing configuration, starting new worker processes with a new configuration, graceful shutdown of old worker processes nginx -s reopenre-opening log files####  已知的问题</p>
</blockquote>
<ul>
<li>虽然可以启动几个工作人员，但实际上只有一个工作。 </li>
<li>一个worker可以处理不超过1024个并发连接。 </li>
<li><p>不支持UDP代理功能。 </p>
<h4 id="可能的未来增强功能"><a href="#可能的未来增强功能" class="headerlink" title="可能的未来增强功能"></a>可能的未来增强功能</h4></li>
<li><p>作为服务运行。 </p>
</li>
<li>使用I / O完成端口作为连接处理方法。 </li>
<li>在单个工作进程中使用多个工作线程。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[varindex-nginx中文手册]]></title>
      <url>/ngx/varindex.html</url>
      <content type="html"><![CDATA[<p>varindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的变量索引"><a href="#按字母顺序排列的变量索引" class="headerlink" title=" 按字母顺序排列的变量索引"></a> 按字母顺序排列的变量索引</h2><p> $ ancient_browser<br> $ arg_<br> 的$ args<br> $ binary_remote_addr （ngx_http_core_module）<br> $ binary_remote_addr （ngx_stream_core_module）<br> $ body_bytes_sent<br> $ bytes_received<br> $ bytes_sent （ngx_http_core_module）<br> $ bytes_sent （ngx_http_log_module）<br> $ bytes_sent （ngx_stream_core_module）<br> $ connection （ngx_http_core_module）<br> $ connection （ngx_http_log_module）<br> $ connection （ngx_stream_core_module）<br> $ connection_requests （ngx_http_core_module）<br> $ connection_requests （ngx_http_log_module）<br> $ connections_active<br> $ connections_reading<br> $ connections_waiting<br> $ connections_writing<br> $ CONTENT_LENGTH<br> $ CONTENT_TYPE<br> $ cookie_<br> $ date_gmt<br> $ DATE_LOCAL<br> $ DOCUMENT_ROOT<br> $ DOCUMENT_URI<br> $ fastcgi_path_info<br> $ fastcgi_script_name<br> $ geoip_area_code （ngx_http_geoip_module）<br> $ geoip_area_code （ngx_stream_geoip_module）<br> $ geoip_city （ngx_http_geoip_module）<br> $ geoip_city （ngx_stream_geoip_module）<br> $ geoip_city_continent_code （ngx_http_geoip_module）<br> $ geoip_city_continent_code （ngx_stream_geoip_module）<br> $ geoip_city_country_code （ngx_http_geoip_module）<br> $ geoip_city_country_code （ngx_stream_geoip_module）<br> $ geoip_city_country_code3 （ngx_http_geoip_module）<br> $ geoip_city_country_code3 （ngx_stream_geoip_module）<br> $ geoip_city_country_name （ngx_http_geoip_module）<br> $ geoip_city_country_name （ngx_stream_geoip_module）<br> $ geoip_country_code （ngx_http_geoip_module）<br> $ geoip_country_code （ngx_stream_geoip_module）<br> $ geoip_country_code3 （ngx_http_geoip_module）<br> $ geoip_country_code3 （ngx_stream_geoip_module）<br> $ geoip_country_name （ngx_http_geoip_module）<br> $ geoip_country_name （ngx_stream_geoip_module）<br> $ geoip_dma_code （ngx_http_geoip_module）<br> $ geoip_dma_code （ngx_stream_geoip_module）<br> $ geoip_latitude （ngx_http_geoip_module）<br> $ geoip_latitude （ngx_stream_geoip_module）<br> $ geoip_longitude （ngx_http_geoip_module）<br> $ geoip_longitude （ngx_stream_geoip_module）<br> $ geoip_org （ngx_http_geoip_module）<br> $ geoip_org （ngx_stream_geoip_module）<br> $ geoip_postal_code （ngx_http_geoip_module）<br> $ geoip_postal_code （ngx_stream_geoip_module）<br> $ geoip_region （ngx_http_geoip_module）<br> $ geoip_region （ngx_stream_geoip_module）<br> $ geoip_region_name （ngx_http_geoip_module）<br> $ geoip_region_name （ngx_stream_geoip_module）<br> $ gzip_ratio<br> $主机<br> $ hostname （ngx_http_core_module）<br> $ hostname （ngx_stream_core_module）<br> $ http2<br> $ HTTP<br> $ HTTPS<br> $ invalid_referer<br> $ is_args<br> $ jwt_claim_<br> $ jwt_header_<br> $ limit_rate<br> $ memcached_key<br> $ modern_browser<br> $ msec （ngx_http_core_module）<br> $ msec （ngx_http_log_module）<br> $ msec （ngx_stream_core_module）<br> $ MSIE<br> $ nginx_version （ngx_http_core_module）<br> $ nginx_version （ngx_stream_core_module）<br> $ pid （ngx_http_core_module）<br> $ pid （ngx_stream_core_module）<br> $ pipe （ngx_http_core_module）<br> $ pipe （ngx_http_log_module）<br> $协议<br> $ proxy_add_x_forwarded_for<br> $ proxy_host使用<br> 话$ proxy_port<br> $ proxy_protocol_addr （ngx_http_core_module）<br> $ proxy_protocol_addr （ngx_stream_core_module）<br> $ proxy_protocol_port （ngx_http_core_module）<br> $ proxy_protocol_port （ngx_stream_core_module）<br> $ QUERY_STRING<br> $ realip_remote_addr （ngx_http_realip_module）<br> $ realip_remote_addr （ngx_stream_realip_module）<br> $ realip_remote_port （ngx_http_realip_module）<br> $ realip_remote_port （ngx_stream_realip_module）<br> $ realpath_root<br> $ remote_addr （ngx_http_core_module）<br> $ remote_addr （ngx_stream_core_module）<br> $ remote_port （ngx_http_core_module）<br> $ remote_port （ngx_stream_core_module）<br> $ REMOTE_USER<br> $请求<br> $ request_body<br> $ REQUEST_BODY_FILE<br> $ request_completion<br> $ REQUEST_FILENAME<br> $ REQUEST_ID<br> $ request_length （ngx_http_core_module）<br> $ request_length （ngx_http_log_module）<br> $ REQUEST_METHOD<br> $ request_time （ngx_http_core_module）<br> $ request_time （ngx_http_log_module）<br> $ REQUEST_URI<br> $方案<br> $ secure_link<br> $ secure_link_expires<br> $ sent_http_<br> $ sent_trailer_<br> $ server_addr （ngx_http_core_module）<br> $ server_addr （ngx_stream_core_module）<br> $ SERVER_NAME<br> $ server_port （ngx_http_core_module）<br> $ server_port （ngx_stream_core_module）<br> $ SERVER_PROTOCOL<br> $ session_log_binary_id<br> $ session_log_id<br> $ session_time<br> $ slice_range<br> $ SPDY<br> $ spdy_request_priority<br> $ ssl_cipher （ngx_http_ssl_module）<br> $ ssl_cipher （ngx_stream_ssl_module）<br> $ ssl_ciphers （ngx_http_ssl_module）<br> $ ssl_ciphers （ngx_stream_ssl_module）<br> $ ssl_client_cert （ngx_http_ssl_module）<br> $ ssl_client_cert （ngx_stream_ssl_module）<br> $ ssl_client_escaped_cert<br> $ ssl_client_fingerprint （ngx_http_ssl_module）<br> $ ssl_client_fingerprint （ngx_stream_ssl_module）<br> $ ssl_client_i_dn （ngx_http_ssl_module）<br> $ ssl_client_i_dn （ngx_stream_ssl_module）<br> $ ssl_client_i_dn_legacy<br> $ ssl_client_raw_cert （ngx_http_ssl_module）<br> $ ssl_client_raw_cert （ngx_stream_ssl_module）<br> $ ssl_client_s_dn （ngx_http_ssl_module）<br> $ ssl_client_s_dn （ngx_stream_ssl_module）<br> $ ssl_client_s_dn_legacy<br> $ ssl_client_serial （ngx_http_ssl_module）<br> $ ssl_client_serial （ngx_stream_ssl_module）<br> $ ssl_client_v_end （ngx_http_ssl_module）<br> $ ssl_client_v_end （ngx_stream_ssl_module）<br> $ ssl_client_v_remain （ngx_http_ssl_module）<br> $ ssl_client_v_remain （ngx_stream_ssl_module）<br> $ ssl_client_v_start （ngx_http_ssl_module）<br> $ ssl_client_v_start （ngx_stream_ssl_module）<br> $ ssl_client_verify （ngx_http_ssl_module）<br> $ ssl_client_verify （ngx_stream_ssl_module）<br> $ ssl_curves （ngx_http_ssl_module）<br> $ ssl_curves （ngx_stream_ssl_module）<br> $ ssl_early_data<br> $ ssl_preread_alpn_protocols<br> $ ssl_preread_protocol<br> $ ssl_preread_server_name<br> $ ssl_protocol （ngx_http_ssl_module）<br> $ ssl_protocol （ngx_stream_ssl_module）<br> $ ssl_server_name （ngx_http_ssl_module）<br> $ ssl_server_name （ngx_stream_ssl_module）<br> $ ssl_session_id （ngx_http_ssl_module）<br> $ ssl_session_id （ngx_stream_ssl_module）<br> $ ssl_session_reused （ngx_http_ssl_module）<br> $ ssl_session_reused （ngx_stream_ssl_module）<br> $ status （ngx_http_core_module）<br> $ status （ngx_http_log_module）<br> $ status （ngx_stream_core_module）<br> $ tcpinfo_rtt<br> $ tcpinfo_rttvar<br> $ tcpinfo_snd_cwnd<br> $ tcpinfo_rcv_space<br> $ time_iso8601 （ngx_http_core_module）<br> $ time_iso8601 （ngx_http_log_module）<br> $ time_iso8601 （ngx_stream_core_module）<br> $ time_local （ngx_http_core_module）<br> $ time_local （ngx_http_log_module）<br> $ time_local （ngx_stream_core_module）<br> $ uid_got<br> $ uid_reset<br> $ uid_set<br> $ upstream_addr （ngx_http_upstream_module）<br> $ upstream_addr （ngx_stream_upstream_module）<br> $ upstream_bytes_received （ngx_http_upstream_module）<br> $ upstream_bytes_received （ngx_stream_upstream_module）<br> $ upstream_bytes_sent （ngx_http_upstream_module）<br> $ upstream_bytes_sent （ngx_stream_upstream_module）<br> $ upstream_cache_status<br> $ upstream_connect_time （ngx_http_upstream_module）<br> $ upstream_connect_time （ngx_stream_upstream_module）<br> $ upstream_cookie_<br> $ upstream_first_byte_time<br> $ upstream_header_time<br> $ upstream_http_<br> $ upstream_queue_time<br> $ upstream_response_length<br> $ upstream_response_time<br> $ upstream_session_time<br> $ upstream_status<br> $ upstream_trailer_<br> $ URI   </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syslog-nginx中文手册]]></title>
      <url>/ngx/syslog.html</url>
      <content type="html"><![CDATA[<p>syslog<br><a id="more"></a></p>
<h2 id="记录到syslog"><a href="#记录到syslog" class="headerlink" title=" 记录到syslog"></a> 记录到syslog</h2><p> error_log和access_log指令支持记录到syslog。 以下参数配置到syslog的日志记录： </p>
<p> server= <em>address</em>  定义syslog服务器的地址。 可以将地址指定为域名或IP地址，带有可选端口，或者指定为“ unix: ”前缀后指定的UNIX域套接字路径。 如果未指定端口，则使用UDP端口514。 如果域名解析为多个IP地址，则使用第一个解析的地址。  facility= <em>string</em>  设置syslog消息的工具，如RFC 3164中所定义。 设施可以是“ kern ”，“ user ”，“ mail ”，“ daemon ”，“ auth ”，“ intern ”，“ lpr ”，“ news ”，“ uucp ”，“ clock ”，“ authpriv ”，“ ftp “，” ntp “，” audit “，” alert “，” cron “，” local0 “..” local7 “。 默认为“ local7 ”。  severity= <em>string</em>  设置access_log的syslog消息的严重性，如RFC 3164中所定义。 可能的值与error_log指令的第二个参数（级别）相同。 默认为“ info ”。 </p>
<blockquote>
<p> 错误消息的严重性由nginx确定，因此在error_log指令中忽略该参数。  tag= <em>string</em>  设置syslog消息的标记。 默认为“ nginx ”。  nohostname   禁用将“hostname”字段添加到syslog消息头（1.9.7）中。  syslog配置示例： </p>
<p>error_log syslog:server=192.168.1.1 debug; access_log syslog:server=unix:/var/log/nginx.sock,nohostname; access_log syslog:server=[2001:db8::1]:12345,facility=local7,tag=nginx,severity=info combined;<br> 从版本1.7.1开始，可以登录到syslog。 作为我们商业订阅的一部分，从1.5.3版开始，可以使用日志记录到syslog。  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syntax-nginx中文手册]]></title>
      <url>/ngx/syntax.html</url>
      <content type="html"><![CDATA[<p>syntax<br><a id="more"></a></p>
<h2 id="配置文件测量单位"><a href="#配置文件测量单位" class="headerlink" title=" 配置文件测量单位"></a> 配置文件测量单位</h2><p> 大小可以以字节，千字节（后缀k和K ）或兆字节（后缀m和M ）来指定，例如，“ 1024 ”，“ 8k ”，“ 1m ”。 </p>
<p> 也可以使用g或G后缀以千兆字节为g指定偏移量。 </p>
<p> 可以使用以下后缀以毫秒，秒，分钟，小时，天等指定时间间隔： </p>
<p>msmillisecondsssecondsmminuteshhoursddayswweeksMmonths, 30 daysyyears, 365 days 通过按从最高有效到最低有序的顺序指定多个单元，可以将多个单元组合成单个值，并且可选地由空格分隔。 例如，“ 1h 30m ”指定与“ 90m ”或“ 5400s ”相同的时间。 没有后缀的值表示秒。 建议始终指定后缀。 </p>
<p> 某些时间间隔只能以秒分辨率指定。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[switches-nginx中文手册]]></title>
      <url>/ngx/switches.html</url>
      <content type="html"><![CDATA[<p>switches<br><a id="more"></a></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title=" 命令行参数"></a> 命令行参数</h2><p> nginx支持以下命令行参数： </p>
<ul>
<li>-? | -h - 打印命令行参数的帮助。 </li>
<li>-c <em>file</em> - 使用备用配置<em>file</em>而不是默认文件。 </li>
<li>-g <em>directives</em> - 设置全局配置指令 ，例如， <blockquote>
<p>nginx -g “pid /var/run/nginx.pid; worker_processes <code>sysctl -n hw.ncpu</code>;” </p>
</blockquote>
</li>
<li>-p <em>prefix</em> - 设置nginx路径前缀，即保留服务器文件的目录（默认值为<em>/usr/local/nginx</em> ）。 </li>
<li>-q - 在配置测试期间禁止出现非错误消息。 </li>
<li><p>-s <em>signal</em> - 向主进程发送<em>信号</em> 。 参数<em>信号</em>可以是以下之一： </p>
<ul>
<li>stop - 快速关闭 </li>
<li>quit - 优雅地关闭 </li>
<li>reload - 重新加载配置，使用新配置启动新的工作进程，正常关闭旧的工作进程。 </li>
<li>reopen - 重新打开日志文件 </li>
</ul>
</li>
<li><p>-t - 测试配置文件：nginx检查配置是否有正确的语法，然后尝试打开配置中引用的文件。 </p>
</li>
<li>-T - 与-t相同，但另外将配置文件转储到标准输出（1.9.2）。 </li>
<li>-v - 打印nginx版本。 </li>
<li>-V - 打印nginx版本，编译器版本和配置参数。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reference-nginx中文手册]]></title>
      <url>/ngx/reference.html</url>
      <content type="html"><![CDATA[<p>reference<br><a id="more"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title=" 参考"></a> 参考</h2><p> nginx objects<br> HTTP Request<br> Stream Session<br> Core<br> String<br> JSON<br> Crypto<br> Timers<br> File System<br> njs提供了扩展nginx功能的对象，方法和属性。 </p>
<h4 id="nginx对象"><a href="#nginx对象" class="headerlink" title="nginx对象"></a>nginx对象</h4><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p> HTTP请求对象仅在ngx_http_js_module模块中可用。 对象的所有字符串属性都是字节字符串 。 </p>
<p> r.args{}   请求参数对象，只读  r.error( <em>string</em> )   在记录的error级别上将string写入错误日志  r.finish()   完成向客户发送回复  r.headersIn{}   传入头对象，只读。  例如，可以使用语法headersIn.foo或headersIn[‘Foo’]访问Foo标头 </p>
<p> r.headersOut{}   传出头对象，可写。  例如，可以使用语法headersOut.foo或headersOut[‘Foo’]访问Foo标头 </p>
<p> r.httpVersion   HTTP版本，只读  r.log( <em>string</em> )   将string写入日志info级别的错误日志  r.internalRedirect( <em>uri</em> )   执行内部重定向到指定的uri 。 如果uri以“ @ ”前缀开头，则将其视为命名位置。  r.method   HTTP方法，只读  r.parent   引用父请求对象  r.remoteAddress   客户端地址，只读  r.requestBody   如果客户端请求正文尚未写入临时文件，则返回该请求正文。 要确保客户端请求正文在内存中，其大小应受client_max_body_size限制，并且应使用client_body_buffer_size设置足够的缓冲区大小。  r.responseBody   拥有子请求响应主体，只读。 r.responseBody的大小受r.responseBody指令的限制。  r.return(status[, string])   将具有指定status的整个响应发送到客户端  可以指定重定向URL（对于代码301,302,303,307和308）或响应正文文本（对于其他代码）作为第二个参数 </p>
<p> r.send( <em>string</em> )   将响应主体的一部分发送给客户端  r.sendHeader()   将HTTP标头发送到客户端  r.status   地位，可写  r.variables{}   nginx变量对象，只读  r.warn( <em>string</em> )   在记录的warning级别上将string写入错误日志  r.uri   当前URI，只读  r.subrequest( <em>uri</em> [, <em>options</em> [, <em>callback</em> ]])   使用给定的uri和options创建子请求，并安装可选的完成callback 。  如果options是一个字符串，那么它包含子请求参数字符串。 否则， options应该是具有以下键的对象： </p>
<p> args   参数字符串  body   请求机构  method   HTTP方法  完成callback接收子请求响应对象，其方法和属性与父请求对象相同。 </p>
<h4 id="流会话"><a href="#流会话" class="headerlink" title="流会话"></a>流会话</h4><p> 流会话对象仅在ngx_stream_js_module模块中可用。 对象的所有字符串属性都是字节字符串 。 </p>
<blockquote>
<p> 在njs 0.2.4之前，流会话对象具有一些当前被删除的属性。  s.allow()   成功完成阶段处理程序（ 0.2.4 ）  s.decline()   完成阶段处理程序并将控制权传递给下一个处理程序（ 0.2.4 ）  s.deny()   使用访问错误代码（ 0.2.4 ）完成阶段处理程序  s.done （ <em>[code]</em> ）  成功完成当前阶段处理程序或使用指定的数字代码（ 0.2.4 ）完成它。  s.error( <em>string</em> )   在发送的error级别上将发送的string写入错误日志  s.log( <em>string</em> )   将发送的<em>string</em>写入日志记录info级别的错误日志  s.off( <em>eventName</em> )   取消注册s.on（）方法设置的回调（ 0.2.4 ）  s.on( <em>event</em> , <em>callback</em> )   为指定event注册callback （ 0.2.4 ）。  event可以是以下字符串之一： </p>
</blockquote>
<p> upload   来自客户的新数据  download   给客户的新数据  完成回调具有以下原型： callback(data, flags) ，其中data是字符串， flags是具有以下属性的对象： </p>
<p> last   布尔值，如果数据是最后一个缓冲区，则为true。  s.remoteAddress   客户端地址，只读  s.send( <em>data</em> [, <em>options</em> ])   将数据发送到客户端（ 0.2.4 ）。 options是一个对象，用于覆盖从传入数据块缓冲区派生的nginx缓冲区标志。 可以使用以下标志覆盖标志：  last   boolean，如果缓冲区是最后一个缓冲区，则为true  flush   boolean，如果缓冲区应该具有flush标志，则为true  每次回调调用可以多次调用该方法。  s.variables{}   nginx变量对象，只读  s.warn( <em>string</em> )   在日志记录的warning级别将发送的string写入错误日志 ####  过时的属性</p>
<p> 这些属性已在njs 0.2.4中删除，并且与现有的njs代码不向后兼容。 </p>
<p> s.ABORT   ABORT返回码 </p>
<blockquote>
<p> 从njs 0.2.4开始，应该使用s.deny（）方法。  s.AGAIN   AGAIN返回代码<br> 从njs 0.2.4开始，如果没有调用s.allow（） ， s.deny（） ， s.decline（） ， s.done（）并且注册了回调， 则会实现相应的行为。  s.buffer   当前缓冲区，可写<br> 从0.2.4开始，应该使用s.send（）方法进行编写。 对于读取，当前缓冲区可用作event回调的第一个参数。  s.DECLINED   DECLINED返回码<br> 从njs 0.2.4开始，应该使用s.decline（）方法。  s.eof   布尔值只读属性，如果当前缓冲区是最后一个缓冲区，则为true<br> 从0.2.4开始，应该使用flags.last属性。  s.ERROR   ERROR返回码<br> 从njs 0.2.4开始，可以抛出适当的异常来报告错误。  s.fromUpstream   布尔值只读属性，如果当前缓冲区是从上游服务器到客户端，则为true<br> 从0.2.4开始，应使用相应的事件 （ upload或download ）来处理来自客户端的数据。  s.OK   OK返回码<br> 从njs 0.2.4开始，应该使用s.allow（）方法。 ####  核心</p>
</blockquote>
<h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p> 有两种类型的字符串： Unicode string （默认）和byte string 。 </p>
<p> Unicode string对应于包含Unicode字符的ECMAScript字符串。 </p>
<p> Byte strings包含一系列字节。 它们用于将Unicode字符串序列化为外部数据，并从外部源反序列化。 例如， toUTF8（）方法使用UTF8编码将Unicode字符串序列化为字节字符串： </p>
<blockquote>
<blockquote>
<blockquote>
<p>‘£’.toUTF8().toString(‘hex’) ‘c2a3’ /<em> C2 A3 is the UTF8 representation of 00A3 (‘£’) code point </em>/  toBytes（）方法将代码点最多为255的Unicode字符串序列化为字节字符串，否则返回null ： </p>
<p>‘£’.toBytes().toString(‘hex’) ‘a3’ /<em> a3 is a byte equal to 00A3 (‘£’) code point </em>/  只有字节字符串可以转换为不同的编码。 例如，字符串不能直接编码为hex ： </p>
<p>‘αβγδ’.toString(‘base64’) TypeError: argument must be a byte string at String.prototype.toString (native) at main (native)  要将Unicode字符串转换为十六进制，首先应将其转换为字节字符串，然后转换为十六进制： </p>
<p>‘αβγδ’.toUTF8().toString(‘base64’) ‘zrHOss6zzrQ=’  String.bytesFrom( <em>array</em> | <em>string</em> , <em>encoding</em> )   （njs specific）从包含八位字节的数组或从编码字符串（0.2.3）创建字节字符串。 编码可以是hex ， base64和base64url 。<br>String.bytesFrom([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]) ‘buffer’ &gt;&gt; String.bytesFrom(‘YnVmZmVy’, ‘base64’) ‘buffer’  String.fromCharCode( <em>CharCode1</em> [, …[, <em>CharCodeN</em> ]])   从一个或多个Unicode代码点返回一个字符串。<br>String.fromCharCode(97, 98, 99, 100) ‘abcd’  String.fromCodePoint( <em>codePoint1</em> [, …[, <em>codePoint2</em> ]])   从一个或多个Unicode代码点返回一个字符串。<br>String.fromCodePoint(97, 98, 99, 100) ‘abcd’  String.prototype.charAt( <em>index</em> )   返回表示指定index处的一个Unicode代码单元的字符串; 如果索引超出范围，则为空字符串。 index可以是0到1之间的整数 - 小于字符串的长度。 如果未提供索引，则默认值为0 ，因此将返回字符串中的第一个字符。  String.prototype.CodePointAt( <em>position</em> )   返回一个数字，表示给定索引处字符的代码点值; 如果位置没有元素，则为undefined 。<br>‘ABCD’.codePointAt(3); 68  String.prototype.concat( <em>string1</em> [, …, <em>stringN</em> ])   返回包含指定strings串联的strings 。<br>“a”.concat(“b”, “c”) ‘abc’  String.prototype.endsWith( <em>searchString</em> [, <em>length</em> ])   如果字符串以指定字符串的字符结尾，则返回true ，否则返回false 。 可选的length参数是字符串的长度。 如果省略，则默认值为字符串的长度。<br>‘abc’.endsWith(‘abc’) true &gt;&gt; ‘abca’.endsWith(‘abc’) false  String.prototype.fromBytes( <em>start</em> [, <em>end</em> ])   （njs specific）从字节字符串返回一个新的Unicode字符串，其中每个字节都替换为相应的Unicode代码点。  String.prototype.fromUTF8( <em>start</em> [, <em>end</em> ])   （特定于njs）将包含有效UTF8字符串的字节字符串转换为Unicode字符串，否则返回null 。  String.prototype.includes( <em>searchString</em> [, <em>position</em> ]))   如果在另一个字符串中找到字符串，则返回true ，否则返回false 。 可选的position参数是字符串中开始搜索searchString 。 默认值为0。<br>‘abc’.includes(‘bc’) true  String.prototype.indexOf( <em>searchString</em> [, <em>fromIndex</em> ])   返回searchString第一次出现的位置搜索从fromIndex开始。 如果未找到该值，则返回<em>-1</em> 。 fromIndex是一个整数，默认值为0.如果fromIndex小于0或大于String.prototype.length  ，搜索从索引<em>0</em>和<em>String.prototype.length</em> 。<br>‘abcdef’.indexOf(‘de’, 2) 3  String.prototype.lastIndexOf( <em>searchString</em> [, <em>fromIndex</em> ])   返回searchString最后一次出现的位置，从fromIndex向后搜索。 如果未找到该值，则返回<em>-1</em> 。 如果searchString为空，则返回fromIndex 。<br>“nginx”.lastIndexOf(“gi”) 1  String.prototype.length   返回字符串的长度。<br>‘αβγδ’.length 4  String.prototype.match([ <em>regexp</em> ])   匹配正则regexp的字符串。<br>‘nginx’.match( /ng/i ) ‘ng’  String.prototype.padEnd( <em>length</em> [, <em>string</em> ])   返回指定length的string ，其中pad string应用于指定字符串的末尾（0.2.3）。<br>‘1234’.padEnd(8, ‘abcd’) ‘1234abcd’  String.prototype.padStart( <em>length</em> [, <em>string</em> ])   返回指定length的string ，其中pad string应用于指定字符串的开头（0.2.3）。<br>‘1234’.padStart(8, ‘abcd’) ‘abcd1234’  String.prototype.repeat( <em>number</em> )   返回具有指定字符串副本数的字符串。<br>‘abc’.repeat(3) ‘abcabcabc’  String.prototype.replace([ <em>regexp</em> | <em>string</em> [, <em>string</em> | <em>function</em> ]])   返回一个新字符串，其中包含由string或function替换的模式（ string或正则regexp ）的string 。<br>‘abcdefgh’.replace(‘d’, 1) ‘abc1efgh’  String.prototype.search([ <em>regexp</em> ])   使用正则regexp搜索字符串<br>‘abcdefgh’.search(‘def’) 3  String.prototype.slice( <em>start</em> [, <em>end</em> ])   返回一个新字符串，其中包含start和end之间或从字符串start到end之间的原始字符串的一部分。<br>‘abcdefghijklmno’.slice(NaN, 5) ‘abcde’  String.prototype.split(([ <em>string</em> | <em>regexp</em> [, <em>limit</em> ]]))   返回字符串与正则regexp匹配。 可选的limit参数是一个整数，指定要查找的拆分数限制。<br>‘abc’.split(‘’) [ ‘a’, ‘b’, ‘c’ ]  String.prototype.startsWith( <em>searchString</em> [, <em>position</em> ])   如果字符串以指定字符串的字符开头，则返回true ，否则返回false 。 可选的position参数是此字符串中开始搜索searchString 。 默认值为0。<br>‘abc’.startsWith(‘abc’) true &gt; ‘aabc’.startsWith(‘abc’) false  String.prototype.substr( <em>start</em> [, <em>length</em> ])   返回从字符串的start或start到结尾的指定length的字符串部分。<br>‘abcdefghijklmno’.substr(3, 5) ‘defgh’  String.prototype.substring( <em>start</em> [, <em>end</em> ])   返回字符串中字符串的start和end之间或从start到结尾的部分。<br>‘abcdefghijklmno’.substring(3, 5) ‘de’  String.prototype.toBytes(start[, end])   （特定于njs）将Unicode字符串序列化为字节字符串。 如果在字符串中找到大于255的字符，则返回null 。  String.prototype.toLowerCase()   将字符串转换为小写。 该方法仅支持简单的Unicode折叠。<br>‘ΑΒΓΔ’.toLowerCase() ‘αβγδ’  String.prototype.toString([ <em>encoding</em> ])   如果未指定encoding ，则返回ECMAScript中指定的Unicode字符串或字节字符串。 </p>
</blockquote>
</blockquote>
</blockquote>
<p> （特定于njs）如果指定了encoding ，则将字节字符串编码为hex ， base64或base64url 。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>‘αβγδ’.toUTF8().toString(‘base64url’) ‘zrHOss6zzrQ’  String.prototype.toUpperCase()   将字符串转换为大写。 该方法仅支持简单的Unicode折叠。<br>‘αβγδ’.toUpperCase() ‘ΑΒΓΔ’  String.prototype.toUTF8( <em>start</em> [, <em>end</em> ])   （特定于njs）使用UTF8编码将Unicode字符串序列化为字节字符串。<br>‘αβγδ’.toUTF8().length 8 &gt;&gt; ‘αβγδ’.length 4  String.prototype.trim()   从字符串的两端删除空格。<br>‘ abc ‘.trim() ‘abc’  encodeURI( <em>URI</em> )   通过将某些字符的每个实例替换为表示字符的UTF-8编码的一个，两个，三个或四个转义序列来对URI进行编码<br>encodeURI(‘012αβγδ’) ‘012%CE%B1%CE%B2%CE%B3%CE%B4’  encodeURIComponent( <em>encodedURIString</em> )   通过将某些字符的每个实例替换为表示字符的UTF-8编码的一个，两个，三个或四个转义序列来对URI进行编码。<br>encodeURIComponent(‘[@?=’) ‘%5B%40%3F%3D’  decodeURI( <em>encodedURI</em> )   解码先前编码的 URI。<br>decodeURI(‘012%CE%B1%CE%B2%CE%B3%CE%B4’) ‘012αβγδ’  decodeURIComponent( <em>decodedURIString</em> )   解码先前编码的URI的编码组件。<br>decodeURIComponent(‘%5B%40%3F%3D’) ‘[@?=’ ####  JSON</p>
</blockquote>
</blockquote>
</blockquote>
<p> JSON对象（ES 5.1）提供了将njs值转换为JSON格式和从JSON格式转换的函数。 </p>
<p> JSON.parse( <em>string</em> [, <em>reviver</em> ])   将表示JSON数据的string转换为njs对象（ {…} ）或数组（ […] ）。 可选的reviver参数是一个函数（键，值），它将为每个（键，值）对调用，并可以转换该值。  JSON.stringify( <em>value</em> [, <em>replacer</em> ] [, <em>space</em> ])   将njs对象转换回JSON。 必需value参数通常是要转换的JSON object或array 。 如果值具有toJSON()方法，则它定义对象的序列化方式。 可选的replacer参数是转换结果的function或array 。 可选的space参数是string或number 。 如果是number ，则表示结果前的空白数（不超过10）。 如果是string ，则将其用作空格（或前10个字符）。 如果省略或为null ，则不使用空格。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>var json = JSON.parse(‘{“a”:1, “b”:true}’) &gt;&gt; json.a 1 &gt;&gt; JSON.stringify(json) ‘{“a”:1,”b”:true}’ &gt;&gt; JSON.stringify(json, undefined, 1) ‘{\n “a”: 1,\n “b”: true\n}’ &gt;&gt; JSON.stringify({ x: [10, undefined, function(){}] }) ‘{“x”:[10,null,null]}’ &gt;&gt; JSON.stringify({“a”:1, “toJSON”: function() {return “xxx”}}) ‘“xxx”‘ # Example with function replacer &gt;&gt; function replacer(key, value) {return (typeof value === ‘string’) ? undefined : value} &gt;&gt;JSON.stringify({a:1, b:”b”, c:true}, replacer) ‘{“a”:1,”c”:true}’ ####  加密</p>
</blockquote>
</blockquote>
</blockquote>
<p> Crypto模块提供加密功能支持。 require(‘crypto’)返回Crypto模块对象。 </p>
<p> crypto.createHash( <em>algorithm</em> )   创建并返回一个Hash对象，该对象可用于使用给定<em>algorithm</em>生成散列摘要。 算法可以是md5 ， sha1和sha256 。  crypto.createHmac( <em>algorithm</em> , <em>secret key</em> )   创建并返回使用给定<em>algorithm</em>和<em>secret key</em>的HMAC对象。 算法可以是md5 ， sha1和sha256 。 ####  哈希</p>
<p> hash.update( <em>data</em> )   使用给定<em>data</em>更新哈希内容。  hash.digest([ <em>encoding</em> ])   计算使用hash.update()传递的所有数据的摘要。 编码可以是hex ， base64和base64url 。 如果未提供编码，则返回字节字符串。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>var cr = require(‘crypto’) undefined &gt;&gt; cr.createHash(‘sha1’).update(‘A’).update(‘B’).digest(‘base64url’) ‘BtlFlCqiamG-GMPiK_GbvKjdK10’ ####  HMAC</p>
</blockquote>
</blockquote>
</blockquote>
<p> hmac.update( <em>data</em> )   使用给定<em>data</em>更新HMAC内容。  hmac.digest([ <em>encoding</em> ])   计算使用hmac.update()传递的所有数据的HMAC摘要。 编码可以是hex ， base64和base64url 。 如果未提供编码，则返回字节字符串。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>var cr = require(‘crypto’) undefined &gt;&gt; cr.createHmac(‘sha1’, ‘secret.key’).update(‘AB’).digest(‘base64url’) ‘Oglm93xn23_MkiaEq_e9u8zk374’ ####  计时器</p>
</blockquote>
</blockquote>
</blockquote>
<p> clearTimeout( <em>timeout</em> )   取消由setTimeout（）创建的timeout对象。  setTimeout( <em>function</em> , <em>ms</em> [, <em>arg1</em> , <em>argN</em> ])   在指定的milliseconds数后调用function 。 可以将一个或多个可选arguments传递给指定的函数。 返回timeout对象。 </p>
<blockquote>
<p>function handler(v) { // … } t = setTimeout(handler, 12); // … clearTimeout(t); ####  文件系统</p>
</blockquote>
<p> 文件系统模块提供文件操作。 require(‘fs’)返回模块对象。 </p>
<p> appendFileSync( <em>filename</em> , <em>data</em> [, <em>options</em> ])   同步将指定data附加到具有提供的filename 。 如果该文件不存在，则将创建该文件。 options参数应该是具有以下键的对象：  mode   mode选项，默认为0o666  flag   文件系统标志 ，默认为  readFileSync( <em>filename</em> [, <em>options</em> ])   使用提供的filename同步返回文件的内容。 options参数包含指定编码的string 。 如果未指定，则返回字节字符串 。 如果指定了utf8编码，则返回Unicode字符串。 否则， options应该是具有以下键的对象：  encoding   默认情况下，未指定编码。 编码可以是utf8  flag   文件系统标志 ，默认为r </p>
<blockquote>
<blockquote>
<blockquote>
<p>var fs = require(‘fs’) undefined &gt;&gt; var file = fs.readFileSync(‘/file/path.tar.gz’) undefined &gt;&gt; var gzipped = /^\x1f\x8b/.test(file); gzipped true  writeFileSync( <em>filename</em> , <em>data</em> [, <em>options</em> ])   同步将data写入具有提供的filename 。 如果该文件不存在，则将创建该文件，如果该文件存在，则将替换该文件。 options参数应该是具有以下键的对象：  mode   mode选项，默认为0o666  flag   文件系统标志 ，默认为w<br>var fs = require(‘fs’) undefined &gt;&gt; var file = fs.writeFileSync(‘hello.txt’, ‘Hello world’) undefined ####  文件系统标志</p>
</blockquote>
</blockquote>
</blockquote>
<p> flag选项可以接受以下值： </p>
<ul>
<li>a - 打开要追加的文件。 如果文件不存在，则创建该文件 </li>
<li>ax - 与a相同但如果文件已存在则失败 </li>
<li>a+ - 打开一个文件进行阅读和追加。 如果该文件不存在，则将创建该文件 </li>
<li>ax+ - 与a+相同但如果文件已经存在则失败 </li>
<li>as - 打开一个文件以便以同步模式追加。 如果该文件不存在，则将创建该文件 </li>
<li>as+ - 打开一个文件以便以同步模式读取和追加。 如果该文件不存在，则将创建该文件 </li>
<li>r - 打开文件进行阅读。 如果文件不存在，则会发生异常 </li>
<li>r+ - 打开一个文件进行读写。 如果文件不存在，则会发生异常 </li>
<li>rs+ - 打开一个文件，以同步模式读写。 指示操作系统绕过本地文件系统缓存 </li>
<li>w - 打开文件进行写作。 如果该文件不存在，则将创建该文件。 如果文件存在，则将替换它 </li>
<li>wx - 与w相同但如果文件已存在则失败 </li>
<li>w+ - 打开一个文件进行读写。 如果该文件不存在，则将创建该文件。 如果文件存在，则将替换它 </li>
<li>wx+ - 与w+相同但如果文件已存在则失败 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_google_perftools_module-nginx中文手册]]></title>
      <url>/ngx/ngx_google_perftools_module.html</url>
      <content type="html"><![CDATA[<p>ngx_google_perftools_module<br><a id="more"></a></p>
<h2 id="Module-ngx-google-perftools-module"><a href="#Module-ngx-google-perftools-module" class="headerlink" title="Module ngx_google_perftools_module"></a>Module ngx_google_perftools_module</h2><p> Example Configuration<br> Directives<br> google_perftools_profiles<br> ngx_google_perftoos_module模块（0.6.29）支持使用Google Performance Tools分析nginx工作进程。 该模块适用于nginx开发人员。 </p>
<p> 默认情况下不会构建此模块，应使用–with-google_perftools_module配置参数启用它。 </p>
<blockquote>
<p> 该模块需要gperftools库。 ####  示例配置</p>
<p>google_perftools_profiles /path/to/profile;  配置文件将存储为/path/to/profile.<worker\_pid> 。 </worker\_pid></p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p> Syntax:  <strong>google_perftools_profiles</strong> <em>file</em> ;<br>  Default:  —  Context:  main<br>  设置一个文件名，用于保存nginx工作进程的分析信息。 工作进程的ID始终是文件名的一部分，并在点后面附加到文件名的末尾。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_core_module-nginx中文手册]]></title>
      <url>/ngx/ngx_core_module.html</url>
      <content type="html"><![CDATA[<p>ngx_core_module<br><a id="more"></a></p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title=" 核心功能"></a> 核心功能</h2><p> Example Configuration<br> Directives<br> accept_mutex<br> accept_mutex_delay<br> daemon<br> debug_connection<br> debug_points<br> env<br> error_log<br> events<br> include<br> load_module<br> lock_file<br> master_process<br> multi_accept<br> pcre_jit<br> pid<br> ssl_engine<br> thread_pool<br> timer_resolution<br> use<br> user<br> worker_aio_requests<br> worker_connections<br> worker_cpu_affinity<br> worker_priority<br> worker_processes<br> worker_rlimit_core<br> worker_rlimit_nofile<br> worker_shutdown_timeout<br> working_directory   </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>user www www; worker_processes 2; error_log /var/log/nginx-error.log info; events { use kqueue; worker_connections 2048; } … ####  指令</p>
</blockquote>
<p> Syntax:  <strong>accept_mutex</strong> on | off ;<br>  Default:  accept_mutex off;  Context:  events<br>  如果启用了accept_mutex ，则工作进程将依次接受新连接。 否则，将通知所有工作进程有关新连接的信息，如果新连接的数量很少，则某些工作进程可能只是浪费系统资源。 </p>
<blockquote>
<p> 无需在支持EPOLLEXCLUSIVE标志（1.11.3）的系统上或使用reuseport时启用accept_mutex 。<br> 在1.11.3版之前，默认值为on 。  Syntax:  <strong>accept_mutex_delay</strong> <em>time</em> ;<br>  Default:  accept_mutex_delay 500ms;  Context:  events<br>  如果启用了accept_mutex ，则指定当另一个工作进程当前正在接受新连接时，工作进程将尝试重新启动接受新连接的最长时间。 </p>
</blockquote>
<p> Syntax:  <strong>daemon</strong> on | off ;<br>  Default:  daemon on;  Context:  main<br>  确定nginx是否应该成为守护进程。 主要用于开发过程中。 </p>
<p> Syntax:  <strong>debug_connection</strong> <em>address</em> | <em>CIDR</em> | unix: ;<br>  Default:  —  Context:  events<br>  为选定的客户端连接启用调试日志。 其他连接将使用error_log指令设置的日志记录级别。 调试连接由IPv4或IPv6（1.3.0,1.2.1）地址或网络指定。 也可以使用主机名指定连接。 对于使用UNIX域套接字（1.3.0,1.2.1）的连接，调试日志由“ unix: ”参数启用。 </p>
<blockquote>
<p>events { debug_connection 127.0.0.1; debug_connection localhost; debug_connection 192.0.2.0/24; debug_connection ::1; debug_connection 2001:0db8::/32; debug_connection unix:; … }<br> 要使此指令起作用，需要使用–with-debug构建nginx，请参阅“ 调试日志 ”。  Syntax:  <strong>debug_points</strong> abort | stop ;<br>  Default:  —  Context:  main<br>  该指令用于调试。 </p>
</blockquote>
<p> 当检测到内部错误时，例如在重新启动工作进程时套接字泄漏，启用debug_points会导致核心文件创建（ abort ）或停止进程（ stop ）以使用系统调试器进行进一步分析。 </p>
<p> Syntax:  <strong>env</strong> <em>variable</em> [= <em>value</em> ];<br>  Default:  env TZ;  Context:  main<br>  默认情况下，nginx会删除从其父进程继承的所有环境变量，但TZ变量除外。 该指令允许保留一些继承的变量，更改其值或创建新的环境变量。 那么这些变量是： </p>
<ul>
<li>在可执行文件的实时升级期间继承; </li>
<li>由ngx_http_perl_module模块使用; </li>
<li><p>由工作进程使用。 应该记住，以这种方式控制系统库并不总是可行的，因为库只在初始化期间检查变量是常见的，远在它们可以使用该指令设置之前。 一个例外是上面提到的可执行文件的实时升级 。<br>除非明确配置，否则TZ变量始终继承并可供ngx_http_perl_module模块使用。 </p>
<p>用法示例： </p>
</li>
</ul>
<blockquote>
<p>env MALLOC_OPTIONS; env PERL5LIB=/data/site/modules; env OPENSSL_ALLOW_PROXY_CERTS=1;<br> NGINX环境变量由nginx在内部使用，不应由用户直接设置。  Syntax:  <strong>error_log</strong> <em>file</em> [ <em>level</em> ];<br>  Default:  error_log logs/error.log error;  Context:  main , http , mail , stream , server , location<br>  配置日志记录。 可以在同一级别指定多个日志（1.5.2）。 如果在main配置级别上未明确定义将日志写入文件，则将使用默认文件。 </p>
</blockquote>
<p> 第一个参数定义将存储日志的<em>file</em> 。 特殊值stderr选择标准错误文件。 可以通过指定“ syslog: ”前缀来配置记录到syslog 。 可以通过指定“ memory: ”前缀和缓冲区<em>size</em>来配置记录到循环内存缓冲区 ，通常用于调试（1.7.11）。 </p>
<p> 第二个参数确定日志记录<em>level</em> ，可以是以下之一： debug ， info ， notice ， warn ， error ， crit ， alert或emerg 。 上面的日志级别按严重性增加的顺序列出。 设置某个日志级别将导致记录指定和更严重日志级别的所有消息。 例如，默认级别error将导致记录error ， crit ， alert和emerg消息。 如果省略此参数，则使用error 。 </p>
<blockquote>
<p> 要使debug日志记录正常工作，需要使用–with-debug构建nginx，请参阅“ 调试日志 ”。<br> 该指令可以在从1.7.11版本开始的stream级别上指定，也可以在从1.9.0版本开始的mail级别上指定。  Syntax:  <strong>events</strong> { … }<br>  Default:  —  Context:  main<br>  提供配置文件上下文，其中指定了影响连接处理的指令。 </p>
</blockquote>
<p> Syntax:  <strong>include</strong> <em>file</em> | <em>mask</em> ;<br>  Default:  —  Context:  any<br>  包含另一个<em>file</em>或与指定<em>mask</em>匹配的文件到配置中。 包含的文件应包含语法正确的指令和块。 </p>
<p> 用法示例： </p>
<blockquote>
<p>include mime.types; include vhosts/<em>.conf;  Syntax:  <strong>load_module</strong> </em>file* ;<br>  Default:  —  Context:  main<br>  该指令出现在1.9.11版中。 </p>
</blockquote>
<p> 加载动态模块。 </p>
<p> 例： </p>
<blockquote>
<p>load_module modules/ngx_mail_module.so;  Syntax:  <strong>lock_file</strong> <em>file</em> ;<br>  Default:  lock_file logs/nginx.lock;  Context:  main<br>  nginx使用锁定机制来实现accept_mutex并序列化对共享内存的访问。 在大多数系统上，锁是使用原子操作实现的，并且忽略该指令。 在其他系统上，使用“锁定文件”机制。 该指令指定锁文件名称的前缀。 </p>
</blockquote>
<p> Syntax:  <strong>master_process</strong> on | off ;<br>  Default:  master_process on;  Context:  main<br>  确定是否已启动工作进程。 该指令适用于nginx开发人员。 </p>
<p> Syntax:  <strong>multi_accept</strong> on | off ;<br>  Default:  multi_accept off;  Context:  events<br>  如果禁用multi_accept则工作进程将一次接受一个新连接。 否则，工作进程将一次接受所有新连接。 </p>
<blockquote>
<p> 如果使用kqueue连接处理方法，则忽略该指令，因为它报告了等待接受的新连接的数量。  Syntax:  <strong>pcre_jit</strong> on | off ;<br>  Default:  pcre_jit off;  Context:  main<br>  该指令出现在1.1.12版本中。 </p>
</blockquote>
<p> 启用或禁用对配置解析时已知的正则表达式使用“即时编译”（PCRE JIT）。 </p>
<p> PCRE JIT可以显着加快正则表达式的处理速度。 </p>
<blockquote>
<p> 从使用–enable-jit配置参数构建的8.20版开始，JIT在PCRE库中可用。 当使用nginx（– –with-pcre= ）构建PCRE库时，通过–with-pcre-jit配置参数启用JIT支持。  Syntax:  <strong>pid</strong> <em>file</em> ;<br>  Default:  pid logs/nginx.pid;  Context:  main<br>  定义将存储主进程的进程ID的<em>file</em> 。 </p>
</blockquote>
<p> Syntax:  <strong>ssl_engine</strong> <em>device</em> ;<br>  Default:  —  Context:  main<br>  定义硬件SSL加速器的名称。 </p>
<p> Syntax:  <strong>thread_pool</strong> <em>name</em> threads = <em>number</em> [ max_queue = <em>number</em> ];<br>  Default:  thread_pool default threads=32 max_queue=65536;  Context:  main<br>  该指令出现在1.7.11版本中。 </p>
<p> 定义用于多线程读取和发送文件而不阻塞工作进程的命名线程池。 </p>
<p> threads参数定义池中的线程数。 </p>
<p> 如果池中的所有线程都忙，则新任务将在队列中等待。 max_queue参数限制允许在队列中等待的任务数。 默认情况下，队列中最多可以等待65536个任务。 当队列溢出时，任务完成并出现错误。 </p>
<p> Syntax:  <strong>timer_resolution</strong> <em>interval</em> ;<br>  Default:  —  Context:  main<br>  减少工作进程中的计时器分辨率，从而减少gettimeofday()系统调用的次数。 默认情况下，每次收到内核事件时都会调用gettimeofday() 。 在降低分辨率的情况下， gettimeofday()仅在每个指定的<em>interval</em>调用一次。 </p>
<p> 例： </p>
<blockquote>
<p>timer_resolution 100ms;  间隔的内部实现取决于使用的方法： </p>
</blockquote>
<ul>
<li>如果使用kqueue ， EVFILT_TIMER过滤器; </li>
<li>timer_create()如果使用了eventport ; </li>
<li><p>setitimer()否则。<br>Syntax:  <strong>use</strong> <em>method</em> ;<br>Default:  —  Context:  events<br>指定要使用的连接处理 <em>method</em> 。 通常不需要明确指定它，因为nginx默认使用最有效的方法。 </p>
<p>Syntax:  <strong>user</strong> <em>user</em> [ <em>group</em> ];<br>Default:  user nobody nobody;  Context:  main<br>定义工作进程使用的<em>user</em>和<em>group</em>凭据。 如果省略group，则使用名称等于<em>user</em>的组。 </p>
<p>Syntax:  <strong>worker_aio_requests</strong> <em>number</em> ;<br>Default:  worker_aio_requests 32;  Context:  events<br>该指令出现在1.1.4和1.0.7版本中。 </p>
<p>将aio与epoll连接处理方法一起使用时，设置单个工作进程的未完成异步I / O操作的最大<em>number</em> 。 </p>
<p>Syntax:  <strong>worker_connections</strong> <em>number</em> ;<br>Default:  worker_connections 512;  Context:  events<br>设置工作进程可以打开的最大并发连接数。 </p>
<p>应该记住，这个数字包括所有连接（例如与代理服务器的连接等），而不仅仅是与客户端的连接。 另一个考虑因素是实际的并发连接数不能超过最大打开文件数的当前限制，可以通过worker_rlimit_nofile更改。 </p>
<p>Syntax:  <strong>worker_cpu_affinity</strong> <em>cpumask</em> …;<br><strong>worker_cpu_affinity</strong> auto [ <em>cpumask</em> ];<br>Default:  —  Context:  main<br>将工作进程绑定到CPU组。 每个CPU集由允许的CPU的位掩码表示。 应该为每个工作进程定义一个单独的集合。 默认情况下，工作进程不绑定到任何特定的CPU。 </p>
<p>例如， </p>
</li>
</ul>
<blockquote>
<p>worker_processes 4; worker_cpu_affinity 0001 0010 0100 1000;  将每个工作进程绑定到一个单独的CPU，同时 </p>
<p>worker_processes 2; worker_cpu_affinity 0101 1010;  将第一个工作进程绑定到CPU0 / CPU2，将第二个工作进程绑定到CPU1 / CPU3。 第二个例子适用于超线程。 </p>
</blockquote>
<p> 特殊值auto （1.9.10）允许将工作进程自动绑定到可用的CPU： </p>
<blockquote>
<p>worker_processes auto; worker_cpu_affinity auto;  可选的mask参数可用于限制可用于自动绑定的CPU： </p>
<p>worker_cpu_affinity auto 01010101;<br> 该指令仅适用于FreeBSD和Linux。  Syntax:  <strong>worker_priority</strong> <em>number</em> ;<br>  Default:  worker_priority 0;  Context:  main<br>  定义工作进程的调度优先级，就像使用nice命令一样：负数表示更高的优先级。 允许范围通常在-20到20之间变化。 </p>
</blockquote>
<p> 例： </p>
<blockquote>
<p>worker_priority -10;  Syntax:  <strong>worker_processes</strong> <em>number</em> | auto ;<br>  Default:  worker_processes 1;  Context:  main<br>  定义工作进程的数量。 </p>
</blockquote>
<p> 最佳值取决于许多因素，包括（但不限于）CPU核心数，存储数据的硬盘驱动器数和负载模式。 如果有疑问，将其设置为可用CPU核心数将是一个良好的开端（值“ auto ”将尝试自动检测它）。 </p>
<blockquote>
<p> 从版本1.3.8和1.2.5开始支持auto参数。  Syntax:  <strong>worker_rlimit_core</strong> <em>size</em> ;<br>  Default:  —  Context:  main<br>  更改工作进程的核心文件（ RLIMIT_CORE ）的最大大小限制。 用于在不重新启动主进程的情况下增加限制。 </p>
</blockquote>
<p> Syntax:  <strong>worker_rlimit_nofile</strong> <em>number</em> ;<br>  Default:  —  Context:  main<br>  更改工作进程的最大打开文件数（ RLIMIT_NOFILE ）限制。 用于在不重新启动主进程的情况下增加限制。 </p>
<p> Syntax:  <strong>worker_shutdown_timeout</strong> <em>time</em> ;<br>  Default:  —  Context:  main<br>  该指令出现在1.11.11版中。 </p>
<p> 配置正常关闭工作进程的超时。 当<em>time</em>到期时，nginx将尝试关闭当前打开的所有连接以方便关闭。 </p>
<p> Syntax:  <strong>working_directory</strong> <em>directory</em> ;<br>  Default:  —  Context:  main<br>  定义工作进程的当前工作目录。 它主要在编写核心文件时使用，在这种情况下，工作进程应具有指定目录的写入权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx_dtrace_pid_provider-nginx中文手册]]></title>
      <url>/ngx/nginx_dtrace_pid_provider.html</url>
      <content type="html"><![CDATA[<p>nginx_dtrace_pid_provider<br><a id="more"></a></p>
<h2 id="使用DTrace-pid提供程序调试nginx"><a href="#使用DTrace-pid提供程序调试nginx" class="headerlink" title=" 使用DTrace pid提供程序调试nginx"></a> 使用DTrace pid提供程序调试nginx</h2><p> 本文假设读者具有nginx内部和DTrace的一般知识。 </p>
<p> 尽管使用–with-debug选项构建的nginx已经提供了大量有关请求处理的信息，但有时需要更彻底地跟踪代码路径的特定部分，同时省略其余的调试输出。 DTrace pid提供程序（在Solaris，macOS上提供）是一个用于探索userland程序内部的有用工具，因为它不需要任何代码更改，它可以帮助完成任务。 用于跟踪和打印nginx函数调用的简单DTrace脚本可能如下所示： </p>
<blockquote>
<p>#pragma D option flowindent pid$target:nginx::entry { } pid$target:nginx::return { }  但是，函数调用跟踪的DTrace功能仅提供有限的有用信息。 函数参数的实时检查通常更有趣，但也更复杂一些。 以下示例旨在帮助读者更熟悉DTrace以及使用DTrace分析nginx行为的过程。 </p>
</blockquote>
<p> 将DTrace与nginx一起使用的常见方案之一如下：附加到nginx工作进程以记录请求行和请求开始时间。 要附加的相应函数是ngx_http_process_request() ，所讨论的参数是指向ngx_http_request_t结构的指针。 用于此类请求记录的DTrace脚本可以如下所示： </p>
<blockquote>
<p>pid$target::<em>ngx_http_process_request:entry { this-&gt;request = (ngx_http_request_t </em>)copyin(arg0, sizeof(ngx_http_request_t)); this-&gt;request_line = stringof(copyin((uintptr_t)this-&gt;request-&gt;request_line.data, this-&gt;request-&gt;request_line.len)); printf(“request line = %s\n”, this-&gt;request_line); printf(“request start sec = %d\n”, this-&gt;request-&gt;start_sec); }  应该注意的是，在上面的示例中，DTrace需要一些关于ngx_http_process_request结构的知识。 不幸的是，虽然可以在DTrace脚本中使用特定的#include指令，然后将其传递给C预处理器（带有-C标志），但这并不能真正起作用。 由于存在大量的交叉依赖性，因此几乎所有的nginx头文件都必须包含在内。 反过来，基于configure脚本设置，nginx标头将包括PCRE，OpenSSL和各种系统头文件。 虽然理论上所有与特定nginx构建相关的头文件都可能包含在DTrace脚本预处理和编译中，但实际上DTrace脚本很可能由于某些头文件中的语法未知而无法编译。 </p>
</blockquote>
<p> 上述问题可以通过在DTrace脚本中仅包含相关且必要的结构和类型定义来解决。 DTrace必须知道结构，类型和字段偏移的大小。 因此，可以通过手动优化用于DTrace的结构定义来进一步减少依赖性。 </p>
<p> 让我们使用上面的DTrace脚本示例，看看它需要什么样的结构定义才能正常工作。 </p>
<p> 首先应该包括configure生成的objs/ngx_auto_config.h文件，因为它定义了一些影响各种#ifdef的常量。 之后， ngx_table_elt_t一些基本类型和定义（如ngx_str_t ， ngx_table_elt_t ， ngx_uint_t等）放在DTrace脚本的开头。 这些定义是紧凑的，常用且不太可能经常改变。 </p>
<p> 然后是ngx_http_process_request_t结构，其中包含许多指向其他结构的指针。 因为这些指针实际上与此脚本无关，并且因为它们具有相同的大小，所以可以用void指针替换它们。 不是更改定义，最好添加适当的typedef，但是： </p>
<blockquote>
<p>typedef ngx_http_upstream_t void; typedef ngx_http_request_body_t void;  最后但并非最不重要的是，有必要添加两个成员结构的定义（ ngx_http_headers_in_t ， ngx_http_headers_out_t ），回调函数的声明和常量的定义。 </p>
</blockquote>
<p> 最终的DTrace脚本可以从这里下载。 </p>
<p> 以下示例显示了运行此脚本的输出： </p>
<blockquote>
<h1 id="dtrace-C-I-objs-s-trace-process-request-d-p-4848-dtrace-script-‘trace-process-request-d’-matched-1-probe-CPU-ID-FUNCTION-NAME-1-4-XAbmO-ngx-http-process-request-entry-request-line-GET-HTTP-1-1-request-start-sec-1349162898-0-4-XAbmO-ngx-http-process-request-entry-request-line-GET-en-docs-nginx-dtrace-pid-provider-html-HTTP-1-1-request-start-sec-1349162899-使用类似的技术，读者应该能够跟踪其他nginx函数调用。"><a href="#dtrace-C-I-objs-s-trace-process-request-d-p-4848-dtrace-script-‘trace-process-request-d’-matched-1-probe-CPU-ID-FUNCTION-NAME-1-4-XAbmO-ngx-http-process-request-entry-request-line-GET-HTTP-1-1-request-start-sec-1349162898-0-4-XAbmO-ngx-http-process-request-entry-request-line-GET-en-docs-nginx-dtrace-pid-provider-html-HTTP-1-1-request-start-sec-1349162899-使用类似的技术，读者应该能够跟踪其他nginx函数调用。" class="headerlink" title="dtrace -C -I ./objs -s trace_process_request.d -p 4848 dtrace: script ‘trace_process_request.d’ matched 1 probe CPU ID FUNCTION:NAME 1 4 .XAbmO.ngx_http_process_request:entry request line = GET / HTTP/1.1 request start sec = 1349162898 0 4 .XAbmO.ngx_http_process_request:entry request line = GET /en/docs/nginx_dtrace_pid_provider.html HTTP/1.1 request start sec = 1349162899  使用类似的技术，读者应该能够跟踪其他nginx函数调用。"></a>dtrace -C -I ./objs -s trace_process_request.d -p 4848 dtrace: script ‘trace_process_request.d’ matched 1 probe CPU ID FUNCTION:NAME 1 4 .XAbmO.ngx_http_process_request:entry request line = GET / HTTP/1.1 request start sec = 1349162898 0 4 .XAbmO.ngx_http_process_request:entry request line = GET /en/docs/nginx_dtrace_pid_provider.html HTTP/1.1 request start sec = 1349162899  使用类似的技术，读者应该能够跟踪其他nginx函数调用。</h1></blockquote>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><ul>
<li>Solaris动态跟踪指南 </li>
<li>有关DTrace pid提供程序的简介文章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux_packages-nginx中文手册]]></title>
      <url>/ngx/linux_packages.html</url>
      <content type="html"><![CDATA[<p>linux_packages<br><a id="more"></a></p>
<h2 id="nginx：Linux包"><a href="#nginx：Linux包" class="headerlink" title=" nginx：Linux包"></a> nginx：Linux包</h2><p> 目前，nginx软件包可用于以下发行版和版本： </p>
<p> RHEL / CentOS的： </p>
<blockquote>
<p>VersionSupported Platforms6.xx86_64, i3867.4+x86_64, ppc64le Debian的： </p>
<p>VersionCodenameSupported Platforms8.xjessiex86_64, i3869.xstretchx86_64, i386 Ubuntu的： </p>
<p>VersionCodenameSupported Platforms14.04trustyx86_64, i386, aarch64/arm6416.04xenialx86_64, i386, ppc64el, aarch64/arm6418.04bionicx86_64, aarch64/arm6418.10cosmicx86_64 SLES： </p>
<p>VersionSupported Platforms12x86_6415x86_64 要启用Linux软件包的自动更新，请为RHEL / CentOS发行版设置yum存储库，为Debian / Ubuntu发行版设置apt存储库，或为SLES设置zypper存储库。 </p>
</blockquote>
<h4 id="用于稳定版本的预制包"><a href="#用于稳定版本的预制包" class="headerlink" title="用于稳定版本的预制包"></a>用于稳定版本的预制包</h4><p> 要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为/etc/yum.repos.d/nginx.repo的文件： </p>
<blockquote>
<p>[nginx] name=nginx repo baseurl=<a href="http://nginx.org/packages/OS/OSRELEASE/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/OS/OSRELEASE/$basearch/</a> gpgcheck=0 enabled=1  对于6.x或7.x版本，将“ OS ”替换为“ rhel ”或“ centos ”，取决于所使用的分布，将“ OSRELEASE ”替换为“ 6 ”或“ 7 ”。 </p>
</blockquote>
<p> 对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到apt程序密钥环。 请从我们的网站下载此密钥 ，并使用以下命令将其添加到apt程序密钥环： </p>
<blockquote>
<p>sudo apt-key add nginx_signing.key  对于Debian，用Debian分发代号取代<em>代号</em> ，并将以下内容附加到/etc/apt/sources.list文件的末尾： </p>
<p>deb <a href="http://nginx.org/packages/debian/" target="_blank" rel="noopener">http://nginx.org/packages/debian/</a> <em>codename</em> nginx deb-src <a href="http://nginx.org/packages/debian/" target="_blank" rel="noopener">http://nginx.org/packages/debian/</a> <em>codename</em> nginx  对于Ubuntu，使用Ubuntu分发代号来替换<em>代号</em> ，并将以下内容附加到/etc/apt/sources.list文件的末尾： </p>
<p>deb <a href="http://nginx.org/packages/ubuntu/" target="_blank" rel="noopener">http://nginx.org/packages/ubuntu/</a> <em>codename</em> nginx deb-src <a href="http://nginx.org/packages/ubuntu/" target="_blank" rel="noopener">http://nginx.org/packages/ubuntu/</a> <em>codename</em> nginx  对于Debian / Ubuntu，然后运行以下命令： </p>
<p>apt-get update apt-get install nginx  对于SLES 12，运行以下命令： </p>
<p>zypper addrepo -G -t yum -c ‘<a href="http://nginx.org/packages/sles/12" target="_blank" rel="noopener">http://nginx.org/packages/sles/12</a>‘ nginx  对于SLES 15，运行以下命令： </p>
<p>zypper addrepo -G -t yum -c ‘<a href="http://nginx.org/packages/sles/15" target="_blank" rel="noopener">http://nginx.org/packages/sles/15</a>‘ nginx ####  Mainline版本的预构建包</p>
</blockquote>
<p> 要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为/etc/yum.repos.d/nginx.repo的文件： </p>
<blockquote>
<p>[nginx] name=nginx repo baseurl=<a href="http://nginx.org/packages/mainline/OS/OSRELEASE/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/OS/OSRELEASE/$basearch/</a> gpgcheck=0 enabled=1  对于6.x或7.x版本，将“ OS ”替换为“ rhel ”或“ centos ”，取决于所使用的分布，将“ OSRELEASE ”替换为“ 6 ”或“ 7 ”。 </p>
</blockquote>
<p> 对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到apt程序密钥环。 请从我们的网站下载此密钥 ，并使用以下命令将其添加到apt程序密钥环： </p>
<blockquote>
<p>sudo apt-key add nginx_signing.key  对于Debian，用Debian分发代号取代<em>代号</em> ，并将以下内容附加到/etc/apt/sources.list文件的末尾： </p>
<p>deb <a href="http://nginx.org/packages/mainline/debian/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/debian/</a> <em>codename</em> nginx deb-src <a href="http://nginx.org/packages/mainline/debian/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/debian/</a> <em>codename</em> nginx  对于Ubuntu，使用Ubuntu分发代号来替换<em>代号</em> ，并将以下内容附加到/etc/apt/sources.list文件的末尾： </p>
<p>deb <a href="http://nginx.org/packages/mainline/ubuntu/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/ubuntu/</a> <em>codename</em> nginx deb-src <a href="http://nginx.org/packages/mainline/ubuntu/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/ubuntu/</a> <em>codename</em> nginx  对于Debian / Ubuntu，然后运行以下命令： </p>
<p>apt-get update apt-get install nginx  对于SLES 12，运行以下命令： </p>
<p>zypper addrepo -G -t yum -c ‘<a href="http://nginx.org/packages/mainline/sles/12" target="_blank" rel="noopener">http://nginx.org/packages/mainline/sles/12</a>‘ nginx  对于SLES 15，运行以下命令： </p>
<p>zypper addrepo -G -t yum -c ‘<a href="http://nginx.org/packages/mainline/sles/15" target="_blank" rel="noopener">http://nginx.org/packages/mainline/sles/15</a>‘ nginx ####  源包</p>
</blockquote>
<p> 包装源可以在包装源库中找到 。 </p>
<p> default分支包含当前主线版本的打包源，而stable-*分支包含稳定版本的最新源。 要构建二进制包，请在Debian / Ubuntu上的debian/目录中运行make ，或在RHEL / CentOS / SLES上的rpm/SPECS/运行make 。 </p>
<p> 打包源在nginx使用的相同的2条款BSD类许可证下分发。 </p>
<h4 id="动态模块"><a href="#动态模块" class="headerlink" title="动态模块"></a>动态模块</h4><p> 主nginx包是使用所有模块构建的，这些模块不需要额外的库来避免额外的依赖性。 从版本1.9.11开始，nginx支持动态模块 ，以下模块构建为动态模块并作为单独的软件包提供： </p>
<blockquote>
<p>nginx-module-geoip nginx-module-image-filter nginx-module-njs nginx-module-perl nginx-module-xslt ####  签名</p>
</blockquote>
<p> RPM软件包和Debian / Ubuntu存储库都使用数字签名来验证下载软件包的完整性和来源。 为了检查签名，有必要下载nginx签名密钥并将其导入rpm或apt程序的密钥环： </p>
<ul>
<li>在Debian / Ubuntu上： <blockquote>
<p>sudo apt-key add nginx_signing.key</p>
</blockquote>
</li>
<li>在RHEL / CentOS上： <blockquote>
<p>sudo rpm –import nginx_signing.key</p>
</blockquote>
</li>
<li>在SLES上： <blockquote>
<p>sudo rpm –import nginx_signing.key<br>在Debian / Ubuntu / SLES上，默认情况下会检查签名，但在RHEL / CentOS上需要设置 </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>gpgcheck=1 在/etc/yum.repos.d/nginx.repo文件中。 </p>
</blockquote>
<p> 由于我们的PGP密钥和软件包位于同一台服务器上，因此它们同样受信任。 强烈建议另外验证下载的PGP密钥的真实性。 PGP具有“信任网”概念，当一个密钥由其他人的密钥签名时，该密钥又由另一个密钥签名，依此类推。 通常可以构建从任意密钥到您知道并亲自信任的某个人密钥的链，从而验证链中第一个密钥的真实性。 GPG Mini Howto详细描述了这一概念。 我们的密钥有足够的签名，其真实性相对容易检查。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[install-nginx中文手册]]></title>
      <url>/ngx/install.html</url>
      <content type="html"><![CDATA[<p>install<br><a id="more"></a></p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title=" 安装nginx"></a> 安装nginx</h2><p> nginx的安装方式可能不同，具体取决于操作系统。 </p>
<h4 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h4><p> 对于Linux，可以使用nginx.org中的nginx 包 。 </p>
<h4 id="在FreeBSD上安装"><a href="#在FreeBSD上安装" class="headerlink" title="在FreeBSD上安装"></a>在FreeBSD上安装</h4><p> 在FreeBSD上，可以从软件包或通过ports系统安装nginx。 ports系统提供了更大的灵活性，允许在众多选项中进行选择。 该端口将使用指定的选项编译nginx并安装它。 </p>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p> 如果需要一些特殊功能，包和端口不可用，也可以从源文件编译nginx。 虽然更灵活，但这种方法对初学者来说可能很复杂。 有关更多信息，请参阅从源构建nginx 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[index-nginx中文手册]]></title>
      <url>/ngx/index.html</url>
      <content type="html"><![CDATA[<p>index<br><a id="more"></a></p>
<h2 id="nginx文档"><a href="#nginx文档" class="headerlink" title=" nginx文档"></a> nginx文档</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>安装nginx </li>
<li>从Sources构建nginx </li>
<li>初学者指南 </li>
<li>管理员指南 </li>
<li>控制nginx </li>
<li>连接处理方法 </li>
<li>设置哈希值 </li>
<li>调试日志 </li>
<li>记录到syslog </li>
<li>配置文件测量单位 </li>
<li>命令行参数 </li>
<li>适用于Windows的nginx </li>
<li>nginx如何处理请求 </li>
<li>服务器名称 </li>
<li>使用nginx作为HTTP负载均衡器 </li>
<li>配置HTTPS服务器 </li>
<li>nginx如何处理TCP / UDP会话 </li>
<li>用njs编写脚本 </li>
<li><p>“开源应用程序架构”中的“nginx”一章 </p>
<h4 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h4></li>
<li><p>使用Visual C在Win32平台上构建nginx </p>
</li>
<li>在Amazon EC2上设置NGINX Plus环境 </li>
<li>使用DTrace pid提供程序调试nginx </li>
<li>转换重写规则 </li>
<li><p>WebSocket代理 </p>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4></li>
<li><p>贡献变化 </p>
</li>
<li><p>开发指南 </p>
<h4 id="模块参考"><a href="#模块参考" class="headerlink" title="模块参考"></a>模块参考</h4></li>
<li><p>按字母顺序排列的指令索引 </p>
</li>
<li>按字母顺序排列的变量索引 </li>
<li>核心功能 </li>
<li>ngx_http_core_module </li>
<li>ngx_http_access_module </li>
<li>ngx_http_addition_module </li>
<li>ngx_http_api_module </li>
<li>ngx_http_auth_basic_module </li>
<li>ngx_http_auth_jwt_module </li>
<li>ngx_http_auth_request_module </li>
<li>ngx_http_autoindex_module </li>
<li>ngx_http_browser_module </li>
<li>ngx_http_charset_module </li>
<li>ngx_http_dav_module </li>
<li>ngx_http_empty_gif_module </li>
<li>ngx_http_f4f_module </li>
<li>ngx_http_fastcgi_module </li>
<li>ngx_http_flv_module </li>
<li>ngx_http_geo_module </li>
<li>ngx_http_geoip_module </li>
<li>ngx_http_grpc_module </li>
<li>ngx_http_gunzip_module </li>
<li>ngx_http_gzip_module </li>
<li>ngx_http_gzip_static_module </li>
<li>ngx_http_headers_module </li>
<li>ngx_http_hls_module </li>
<li>ngx_http_image_filter_module </li>
<li>ngx_http_index_module </li>
<li>ngx_http_js_module </li>
<li>ngx_http_keyval_module </li>
<li>ngx_http_limit_conn_module </li>
<li>ngx_http_limit_req_module </li>
<li>ngx_http_log_module </li>
<li>ngx_http_map_module </li>
<li>ngx_http_memcached_module </li>
<li>ngx_http_mirror_module </li>
<li>ngx_http_mp4_module </li>
<li>ngx_http_perl_module </li>
<li>ngx_http_proxy_module </li>
<li>ngx_http_random_index_module </li>
<li>ngx_http_realip_module </li>
<li>ngx_http_referer_module </li>
<li>ngx_http_rewrite_module </li>
<li>ngx_http_scgi_module </li>
<li>ngx_http_secure_link_module </li>
<li>ngx_http_session_log_module </li>
<li>ngx_http_slice_module </li>
<li>ngx_http_spdy_module </li>
<li>ngx_http_split_clients_module </li>
<li>ngx_http_ssi_module </li>
<li>ngx_http_ssl_module </li>
<li>ngx_http_status_module </li>
<li>ngx_http_stub_status_module </li>
<li>ngx_http_sub_module </li>
<li>ngx_http_upstream_module </li>
<li>ngx_http_upstream_conf_module </li>
<li>ngx_http_upstream_hc_module </li>
<li>ngx_http_userid_module </li>
<li>ngx_http_uwsgi_module </li>
<li>ngx_http_v2_module </li>
<li>ngx_http_xslt_module </li>
<li>ngx_mail_core_module </li>
<li>ngx_mail_auth_http_module </li>
<li>ngx_mail_proxy_module </li>
<li>ngx_mail_ssl_module </li>
<li>ngx_mail_imap_module </li>
<li>ngx_mail_pop3_module </li>
<li>ngx_mail_smtp_module </li>
<li>ngx_stream_core_module </li>
<li>ngx_stream_access_module </li>
<li>ngx_stream_geo_module </li>
<li>ngx_stream_geoip_module </li>
<li>ngx_stream_js_module </li>
<li>ngx_stream_keyval_module </li>
<li>ngx_stream_limit_conn_module </li>
<li>ngx_stream_log_module </li>
<li>ngx_stream_map_module </li>
<li>ngx_stream_proxy_module </li>
<li>ngx_stream_realip_module </li>
<li>ngx_stream_return_module </li>
<li>ngx_stream_split_clients_module </li>
<li>ngx_stream_ssl_module </li>
<li>ngx_stream_ssl_preread_module </li>
<li>ngx_stream_upstream_module </li>
<li>ngx_stream_upstream_hc_module </li>
<li>ngx_stream_zone_sync_module </li>
<li>ngx_google_perftools_module </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[howto_build_on_win32-nginx中文手册]]></title>
      <url>/ngx/howto_build_on_win32.html</url>
      <content type="html"><![CDATA[<p>howto_build_on_win32<br><a id="more"></a></p>
<h2 id="使用Visual-C在Win32平台上构建nginx"><a href="#使用Visual-C在Win32平台上构建nginx" class="headerlink" title=" 使用Visual C在Win32平台上构建nginx"></a> 使用Visual C在Win32平台上构建nginx</h2><p> Build steps<br> See also   </p>
<h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p> 要在MicrosoftWin32®平台上构建nginx，您需要： </p>
<ul>
<li>Microsoft Visual C编译器。 已知Microsoft VisualStudio®8和10可以使用。 </li>
<li>MSYS 。 </li>
<li>Perl，如果你想用SSL支持构建OpenSSL®和nginx。 例如ActivePerl或Strawberry Perl 。 </li>
<li>Mercurial客户。 </li>
<li><p>PCRE ， zlib和OpenSSL库源。 </p>
<h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><p>确保在开始构建之前将Perl，Mercurial和MSYS bin目录的路径添加到PATH环境变量中。 要设置Visual C环境，请从Visual C目录运行vcvarsall.bat脚本。 </p>
<p>要构建nginx： </p>
</li>
<li><p>启动MSYS bash。 </p>
</li>
<li>查看hg.nginx.org存储库中的nginx源代码。 例如： <blockquote>
<p>hg clone <a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">http://hg.nginx.org/nginx</a> </p>
</blockquote>
</li>
<li>创建一个build和lib目录，并将zlib，PCRE和OpenSSL库源解压缩到lib目录中： <blockquote>
<p>mkdir objs mkdir objs/lib cd objs/lib tar -xzf ../../pcre-8.42.tar.gz tar -xzf ../../zlib-1.2.11.tar.gz tar -xzf ../../openssl-1.0.2q.tar.gz </p>
</blockquote>
</li>
<li>运行configure脚本： <blockquote>
<p>auto/configure \ –with-cc=cl \ –with-debug \ –prefix= \ –conf-path=conf/nginx.conf \ –pid-path=logs/nginx.pid \ –http-log-path=logs/access.log \ –error-log-path=logs/error.log \ –sbin-path=nginx.exe \ –http-client-body-temp-path=temp/client_body_temp \ –http-proxy-temp-path=temp/proxy_temp \ –http-fastcgi-temp-path=temp/fastcgi_temp \ –http-scgi-temp-path=temp/scgi_temp \ –http-uwsgi-temp-path=temp/uwsgi_temp \ –with-cc-opt=-DFD_SETSIZE=1024 \ –with-pcre=objs/lib/pcre-8.42 \ –with-zlib=objs/lib/zlib-1.2.11 \ –with-openssl=objs/lib/openssl-1.0.2q \ –with-openssl-opt=no-asm \ –with-select_module \ –with-http_ssl_module </p>
</blockquote>
</li>
<li><p>运行make： </p>
<blockquote>
<p>nmake </p>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4></blockquote>
</li>
<li><p>适用于Windows的nginx </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hash-nginx中文手册]]></title>
      <url>/ngx/hash.html</url>
      <content type="html"><![CDATA[<p>hash<br><a id="more"></a></p>
<h2 id="设置哈希值"><a href="#设置哈希值" class="headerlink" title=" 设置哈希值"></a> 设置哈希值</h2><p> 为了快速处理静态数据集，例如服务器名称， 映射指令的值，MIME类型，请求头字符串的名称，nginx使用哈希表。 在启动期间和每次重新配置时，nginx选择最小可能大小的散列表，使得存储具有相同散列值的密钥的桶大小不超过配置的参数（散列桶大小）。 表的大小以桶表示。 继续调整，直到表大小超过散列最大大小参数。 大多数哈希都有相应的指令允许更改这些参数，例如，对于服务器名称哈希，它们是server_names_hash_max_size和server_names_hash_bucket_size 。 </p>
<p> 散列桶大小参数与处理器的高速缓存行大小的倍数对齐。 这通过减少内存访问的数量来加速现代处理器上的散列中的密钥搜索。 如果散列桶大小等于一个处理器的高速缓存行大小，那么在最坏的情况下，密钥搜索期间的内存访问次数将是两次 - 首先计算存储区地址，第二次是在存储桶内的密钥搜索期间。 因此，如果nginx发出请求增加散列最大大小或散列桶大小的消息，则应首先增加第一个参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[examples-nginx中文手册]]></title>
      <url>/ngx/examples.html</url>
      <content type="html"><![CDATA[<p>examples<br><a id="more"></a></p>
<h2 id="示例nginx配置"><a href="#示例nginx配置" class="headerlink" title=" 示例nginx配置"></a> 示例nginx配置</h2><p> 示例站点配置，将所有请求传递给后端，但以“/ download /”开头的图像和请求除外。 </p>
<blockquote>
<p>user www www; worker_processes 2; pid /var/run/nginx.pid; # [ debug | info | notice | warn | error | crit ] error_log /var/log/nginx.error_log info; events { worker_connections 2000; # use [ kqueue | epoll | /dev/poll | select | poll ]; use kqueue; } http { include conf/mime.types; default_type application/octet-stream; log_format main ‘$remote_addr - $remote_user [$time_local] ‘ ‘“$request” $status $bytes_sent ‘ ‘“$http_referer” “$http_user_agent” ‘ ‘“$gzip_ratio”‘; log_format download ‘$remote_addr - $remote_user [$time_local] ‘ ‘“$request” $status $bytes_sent ‘ ‘“$http_referer” “$http_user_agent” ‘ ‘“$http_range” “$sent_http_content_range”‘; client_header_timeout 3m; client_body_timeout 3m; send_timeout 3m; client_header_buffer_size 1k; large_client_header_buffers 4 4k; gzip on; gzip_min_length 1100; gzip_buffers 4 8k; gzip_types text/plain; output_buffers 1 32k; postpone_output 1460; sendfile on; tcp_nopush on; tcp_nodelay on; send_lowat 12000; keepalive_timeout 75 20; #lingering_time 30; #lingering_timeout 10; #reset_timedout_connection on; server { listen one.example.com; server_name one.example.com www.one.example.com; access_log /var/log/nginx.access_log main; location / { proxy_pass <a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a>; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; client_body_temp_path /var/nginx/client_body_temp; proxy_connect_timeout 70; proxy_send_timeout 90; proxy_read_timeout 90; proxy_send_lowat 12000; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path /var/nginx/proxy_temp; charset koi8-r; } error_page 404 /404.html; location = /404.html { root /spool/www; } location /old_stuff/ { rewrite ^/old_stuff/(.<em>)$ /new_stuff/$1 permanent; } location /download/ { valid_referers none blocked server_names </em>.example.com; if ($invalid_referer) { #rewrite ^/ <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a>; return 403; } #rewrite_log on; # rewrite /download/<em>/mp3/</em>.any_ext to /download/<em>/mp3/</em>.mp3 rewrite ^/(download/.<em>)/mp3/(.</em>)..<em>$ /$1/mp3/$2.mp3 break; root /spool/www; #autoindex on; access_log /var/log/nginx-download.access_log download; } location ~</em> .(jpg|jpeg|gif)$ { root /spool/www; access_log off; expires 30d; } } }  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[events-nginx中文手册]]></title>
      <url>/ngx/events.html</url>
      <content type="html"><![CDATA[<p>events<br><a id="more"></a></p>
<h2 id="连接处理方法"><a href="#连接处理方法" class="headerlink" title=" 连接处理方法"></a> 连接处理方法</h2><p> nginx支持各种连接处理方法。 特定方法的可用性取决于所使用的平台。 在支持多种方法的平台上，nginx通常会自动选择最有效的方法。 但是，如果需要，可以使用use指令显式选择连接处理方法。 </p>
<p> 支持以下连接处理方法： </p>
<ul>
<li>select - 标准方法。 支持模块自动构建在缺乏更有效方法的平台上。 –with-select_module和–without-select_module配置参数可用于强制启用或禁用此模块的构建。 </li>
</ul>
<ul>
<li>poll - 标准方法。 支持模块自动构建在缺乏更有效方法的平台上。 –with-poll_module和–without-poll_module配置参数可用于强制启用或禁用此模块的构建。 </li>
</ul>
<ul>
<li>kqueue - 在FreeBSD 4.1 +，OpenBSD 2.9 +，NetBSD 2.0和macOS上使用的有效方法。 </li>
</ul>
<ul>
<li>Linux 2.6+上使用的epoll -efficient方法。 </li>
</ul>
<blockquote>
<p> 自1.11.3起，支持EPOLLRDHUP （Linux 2.6.17，glibc 2.8）和EPOLLEXCLUSIVE （Linux 4.5，glibc 2.24）标志。<br> 一些较旧的发行版（如SuSE 8.2）提供了为2.4内核添加epoll支持的补丁。 </p>
<ul>
<li>/dev/poll - Solaris 7 11/99 +，HP / UX 11.22+（eventport），IRIX 6.5.15+和Tru64 UNIX 5.1A +上使用的有效方法。 </li>
</ul>
</blockquote>
<ul>
<li>eventport - 事件端口，Solaris 10+上使用的方法（由于已知问题，建议使用/dev/poll方法）。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dirindex-nginx中文手册]]></title>
      <url>/ngx/dirindex.html</url>
      <content type="html"><![CDATA[<p>dirindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的指令索引"><a href="#按字母顺序排列的指令索引" class="headerlink" title=" 按字母顺序排列的指令索引"></a> 按字母顺序排列的指令索引</h2><p> absolute_redirect<br> accept_mutex<br> accept_mutex_delay<br> access_log （ngx_http_log_module）<br> access_log （ngx_stream_log_module）<br> add_after_body<br> add_before_body<br> add_header<br> add_trailer<br> addition_types<br> AIO<br> aio_write<br> 别号<br> 允许 （ngx_http_access_module）<br> 允许 （ngx_stream_access_module）<br> ancient_browser<br> ancient_browser_value<br> API<br> auth_basic<br> auth_basic_user_file<br> auth_http<br> auth_http_header<br> auth_http_pass_client_cert<br> auth_http_timeout<br> auth_jwt<br> auth_jwt_claim_set<br> auth_jwt_header_set<br> auth_jwt_key_file<br> auth_jwt_key_request<br> auth_jwt_leeway<br> auth_request<br> auth_request_set<br> 自动索引<br> autoindex_exact_size<br> autoindex_format<br> autoindex_localtime<br> 打破<br> 字符集<br> charset_map<br> charset_types<br> chunked_transfer_encoding<br> client_body_buffer_size<br> client_body_in_file_only<br> client_body_in_single_buffer<br> client_body_temp_path<br> client_body_timeout<br> client_header_buffer_size<br> client_header_timeout<br> client_max_body_size<br> connection_pool_size<br> create_full_put_path<br> 守护进程<br> dav_access<br> dav_methods<br> debug_connection<br> debug_points<br> default_type文件<br> 拒绝 （ngx_http_access_module）<br> 拒绝 （ngx_stream_access_module）<br> 的directio<br> directio_alignment<br> disable_symlinks<br> empty_gif<br> ENV<br> error_log中<br> error_page<br> ETAG<br> 事件<br> 到期<br> F4F<br> f4f_buffer_size<br> fastcgi_bind<br> fastcgi_buffer_size<br> fastcgi_buffering<br> fastcgi_buffers<br> fastcgi_busy_buffers_size<br> fastcgi_cache<br> fastcgi_cache_background_update<br> fastcgi_cache_bypass<br> fastcgi_cache_key<br> fastcgi_cache_lock<br> fastcgi_cache_lock_age<br> fastcgi_cache_lock_timeout<br> fastcgi_cache_max_range_offset<br> fastcgi_cache_methods<br> fastcgi_cache_min_uses<br> fastcgi_cache_path<br> fastcgi_cache_purge<br> fastcgi_cache_revalidate<br> fastcgi_cache_use_stale<br> fastcgi_cache_valid<br> fastcgi_catch_stderr<br> fastcgi_connect_timeout<br> fastcgi_force_ranges<br> fastcgi_hide_header<br> fastcgi_ignore_client_abort<br> fastcgi_ignore_headers<br> fastcgi_index<br> fastcgi_intercept_errors<br> fastcgi_keep_conn<br> fastcgi_limit_rate<br> fastcgi_max_temp_file_size<br> fastcgi_next_upstream<br> fastcgi_next_upstream_timeout<br> fastcgi_next_upstream_tries<br> fastcgi_no_cache<br> fastcgi_param<br> fastcgi_pass<br> fastcgi_pass_header<br> fastcgi_pass_request_body<br> fastcgi_pass_request_headers<br> fastcgi_read_timeout<br> fastcgi_request_buffering<br> fastcgi_send_lowat<br> fastcgi_send_timeout<br> fastcgi_socket_keepalive<br> fastcgi_split_path_info<br> fastcgi_store<br> fastcgi_store_access<br> fastcgi_temp_file_write_size<br> fastcgi_temp_path<br> FLV<br> geo （ngx_http_geo_module）<br> geo （ngx_stream_geo_module）<br> geoip_city （ngx_http_geoip_module）<br> geoip_city （ngx_stream_geoip_module）<br> geoip_country （ngx_http_geoip_module）<br> geoip_country （ngx_stream_geoip_module）<br> geoip_org （ngx_http_geoip_module）<br> geoip_org （ngx_stream_geoip_module）<br> geoip_proxy<br> geoip_proxy_recursive<br> google_perftools_profiles<br> grpc_bind<br> grpc_buffer_size<br> grpc_connect_timeout<br> grpc_hide_header<br> grpc_ignore_headers<br> grpc_intercept_errors<br> grpc_next_upstream<br> grpc_next_upstream_timeout<br> grpc_next_upstream_tries<br> grpc_pass<br> grpc_pass_header<br> grpc_read_timeout<br> grpc_send_timeout<br> grpc_set_header<br> grpc_socket_keepalive<br> grpc_ssl_certificate<br> grpc_ssl_certificate_key<br> grpc_ssl_ciphers<br> grpc_ssl_crl<br> grpc_ssl_name<br> grpc_ssl_password_file<br> grpc_ssl_protocols<br> grpc_ssl_server_name<br> grpc_ssl_session_reuse<br> grpc_ssl_trusted_certificate<br> grpc_ssl_verify<br> grpc_ssl_verify_depth<br> gunzip解<br> gunzip_buffers<br> gzip的<br> gzip_buffers<br> gzip_comp_level<br> gzip_disable<br> gzip_http_version<br> gzip_min_length<br> gzip_proxied<br> gzip_static<br> gzip_types<br> gzip_vary<br> hash （ngx_http_upstream_module）<br> hash （ngx_stream_upstream_module）<br> health_check （ngx_http_upstream_hc_module）<br> health_check（ngx_stream_upstream_hc_module）<br> health_check_timeout<br> HLS<br> hls_buffers<br> hls_forward_args<br> hls_fragment<br> hls_mp4_buffer_size<br> hls_mp4_max_buffer_size<br> HTTP<br> http2_body_preread_size<br> http2_chunk_size<br> http2_idle_timeout<br> http2_max_concurrent_pushes<br> http2_max_concurrent_streams<br> http2_max_field_size<br> http2_max_header_size<br> http2_max_requests<br> http2_push<br> http2_push_preload<br> http2_recv_buffer_size<br> http2_recv_timeout<br> 如果<br> if_modified_since<br> ignore_invalid_headers<br> image_filter<br> image_filter_buffer<br> image_filter_interlace<br> image_filter_jpeg_quality<br> image_filter_sharpen<br> image_filter_transparency<br> image_filter_webp_quality<br> imap_auth<br> imap_capabilities<br> imap_client_buffer<br> 包括<br> 指数<br> 内部<br> ip_hash<br> js_access<br> js_content<br> js_filter<br> js_include （ngx_http_js_module）<br> js_include （ngx_stream_js_module）<br> js_preread<br> js_set （ngx_http_js_module）<br> js_set （ngx_stream_js_module）<br> 活着<br> keepalive_disable<br> keepalive_requests （ngx_http_core_module）<br> keepalive_requests （ngx_http_upstream_module）<br> keepalive_timeout （ngx_http_core_module）<br> keepalive_timeout （ngx_http_upstream_module）<br> keyval （ngx_http_keyval_module）<br> keyval （ngx_stream_keyval_module）<br> keyval_zone （ngx_http_keyval_module）<br> keyval_zone （ngx_stream_keyval_module）<br> large_client_header_buffers<br> least_conn （ngx_http_upstream_module）<br> least_conn （ngx_stream_upstream_module）<br> least_time （ngx_http_upstream_module）<br> least_time （ngx_stream_upstream_module）<br> limit_conn （ngx_http_limit_conn_module）<br> limit_conn （ngx_stream_limit_conn_module）<br> limit_conn_log_level （ngx_http_limit_conn_module）<br> limit_conn_log_level （ngx_stream_limit_conn_module）<br> limit_conn_status<br> limit_conn_zone （ngx_http_limit_conn_module）<br> limit_conn_zone （ngx_stream_limit_conn_module）<br> limit_except<br> limit_rate<br> limit_rate_after<br> limit_req<br> limit_req_log_level<br> limit_req_status<br> limit_req_zone<br> limit_zone<br> lingering_close<br> lingering_time<br> lingering_timeout<br> 听 （ngx_http_core_module）<br> 听 （ngx_mail_core_module）<br> 听 （ngx_stream_core_module）<br> load_module<br> 地点<br> LOCK_FILE<br> log_format （ngx_http_log_module）<br> log_format （ngx_stream_log_module）<br> log_not_found<br> log_subrequest<br> 邮件<br> 地图 （ngx_http_map_module）<br> 地图 （ngx_stream_map_module）<br> map_hash_bucket_size （ngx_http_map_module）<br> map_hash_bucket_size （ngx_stream_map_module）<br> map_hash_max_size （ngx_http_map_module）<br> map_hash_max_size （ngx_stream_map_module）<br> master_process<br> 匹配 （ngx_http_upstream_hc_module）<br> 匹配 （ngx_stream_upstream_hc_module）<br> max_ranges<br> memcached_bind<br> memcached_buffer_size<br> memcached_connect_timeout<br> memcached_force_ranges<br> memcached_gzip_flag<br> memcached_next_upstream<br> memcached_next_upstream_timeout<br> memcached_next_upstream_tries<br> memcached_pa​​ss<br> memcached_read_timeout<br> memcached_send_timeout<br> memcached_socket_keepalive<br> merge_slashes<br> min_delete_depth<br> 镜子<br> mirror_request_body<br> modern_browser<br> modern_browser_value<br> MP4<br> mp4_buffer_size<br> mp4_limit_rate<br> mp4_limit_rate_after<br> mp4_max_buffer_size<br> msie_padding<br> msie_refresh<br> multi_accept<br> NTLM<br> open_file_cache<br> open_file_cache_errors<br> open_file_cache_min_uses<br> open_file_cache_valid<br> open_log_file_cache （ngx_http_log_module）<br> open_log_file_cache （ngx_stream_log_module）<br> output_buffers<br> override_charset<br> pcre_jit<br> perl的<br> perl_modules<br> perl_require<br> perl_set<br> PID<br> pop3_auth<br> pop3_capabilities<br> port_in_redirect<br> postpone_output<br> preread_buffer_size<br> preread_timeout<br> 协议<br> proxy_bind （ngx_http_proxy_module）<br> proxy_bind （ngx_stream_proxy_module）<br> proxy_buffer<br> proxy_buffer_size （ngx_http_proxy_module）<br> proxy_buffer_size （ngx_stream_proxy_module）<br> proxy_buffering<br> proxy_buffers<br> proxy_busy_buffers_size<br> proxy_cache<br> proxy_cache_background_update<br> proxy_cache_bypass<br> proxy_cache_convert_head<br> proxy_cache_key<br> proxy_cache_lock<br> proxy_cache_lock_age<br> proxy_cache_lock_timeout<br> proxy_cache_max_range_offset<br> proxy_cache_methods<br> proxy_cache_min_uses<br> proxy_cache_path<br> proxy_cache_purge<br> proxy_cache_revalidate<br> proxy_cache_use_stale<br> proxy_cache_valid<br> proxy_connect_timeout （ngx_http_proxy_module）<br> proxy_connect_timeout （ngx_stream_proxy_module）<br> proxy_cookie_domain<br> proxy_cookie_path<br> proxy_download_rate<br> proxy_force_ranges<br> proxy_headers_hash_bucket_size<br> proxy_headers_hash_max_size<br> proxy_hide_header<br> proxy_http_version<br> proxy_ignore_client_abort<br> proxy_ignore_headers<br> proxy_intercept_errors<br> proxy_limit_rate<br> proxy_max_temp_file_size<br> proxy_method<br> proxy_next_upstream （ngx_http_proxy_module）<br> proxy_next_upstream （ngx_stream_proxy_module）<br> proxy_next_upstream_timeout （ngx_http_proxy_module）<br> proxy_next_upstream_timeout （ngx_stream_proxy_module）<br> proxy_next_upstream_tries （ngx_http_proxy_module）<br> proxy_next_upstream_tries （ngx_stream_proxy_module）<br> proxy_no_cache<br> proxy_pass （ngx_http_proxy_module）<br> proxy_pass （ngx_stream_proxy_module）<br> proxy_pass_error_message<br> proxy_pass_header<br> proxy_pass_request_body<br> proxy_pass_request_headers<br> proxy_protocol<br> proxy_protocol_timeout<br> proxy_read_timeout<br> proxy_redirect<br> proxy_request_buffering<br> proxy_requests<br> proxy_responses<br> proxy_send_lowat<br> proxy_send_timeout<br> proxy_set_body<br> proxy_set_header<br> proxy_socket_keepalive （ngx_http_proxy_module）<br> proxy_socket_keepalive （ngx_stream_proxy_module）<br> proxy_ssl<br> proxy_ssl_certificate （ngx_http_proxy_module）<br> proxy_ssl_certificate （ngx_stream_proxy_module）<br> proxy_ssl_certificate_key （ngx_http_proxy_module）<br> proxy_ssl_certificate_key （ngx_stream_proxy_module）<br> proxy_ssl_ciphers （ngx_http_proxy_module）<br> proxy_ssl_ciphers （ngx_stream_proxy_module）<br> proxy_ssl_crl （ngx_http_proxy_module）<br> proxy_ssl_crl （ngx_stream_proxy_module）<br> proxy_ssl_name （ngx_http_proxy_module）<br> proxy_ssl_name （ngx_stream_proxy_module）<br> proxy_ssl_password_file （ngx_http_proxy_module）<br> proxy_ssl_password_file （ngx_stream_proxy_module）<br> proxy_ssl_protocols （ngx_http_proxy_module）<br> proxy_ssl_protocols （ngx_stream_proxy_module）<br> proxy_ssl_server_name （ngx_http_proxy_module）<br> proxy_ssl_server_name （ngx_stream_proxy_module）<br> proxy_ssl_session_reuse （ngx_http_proxy_module）<br> proxy_ssl_session_reuse （ngx_stream_proxy_module）<br> proxy_ssl_trusted_certificate （ngx_http_proxy_module）<br> proxy_ssl_trusted_certificate （ngx_stream_proxy_module）<br> proxy_ssl_verify （ngx_http_proxy_module）<br> proxy_ssl_verify （ngx_stream_proxy_module）<br> proxy_ssl_verify_depth （ngx_http_proxy_module）<br> proxy_ssl_verify_depth （ngx_stream_proxy_module）<br> proxy_store<br> proxy_store_access<br> proxy_temp_file_write_size<br> proxy_temp_path<br> proxy_timeout （ngx_mail_proxy_module）<br> proxy_timeout （ngx_stream_proxy_module）<br> proxy_upload_rate<br> 队列<br> 随机的 （ngx_http_upstream_module）<br> 随机的 （ngx_stream_upstream_module）<br> random_index<br> read_ahead<br> real_ip_header<br> real_ip_recursive<br> recursive_error_pages<br> referer_hash_bucket_size<br> referer_hash_max_size<br> request_pool_size<br> reset_timedout_connection<br> 解析器 （ngx_http_core_module）<br> 解析器 （ngx_mail_core_module）<br> 解析器 （ngx_stream_core_module）<br> resolver_timeout （ngx_http_core_module）<br> resolver_timeout （ngx_mail_core_module）<br> resolver_timeout （ngx_stream_core_module）<br> return （ngx_http_rewrite_module）<br> return （ngx_stream_return_module）<br> 改写<br> rewrite_log<br> 根<br> 满足<br> scgi_bind<br> scgi_buffer_size<br> scgi_buffering<br> scgi_buffers<br> scgi_busy_buffers_size<br> scgi_cache<br> scgi_cache_background_update<br> scgi_cache_bypass<br> scgi_cache_key<br> scgi_cache_lock<br> scgi_cache_lock_age<br> scgi_cache_lock_timeout<br> scgi_cache_max_range_offset<br> scgi_cache_methods<br> scgi_cache_min_uses<br> scgi_cache_path<br> scgi_cache_purge<br> scgi_cache_revalidate<br> scgi_cache_use_stale<br> scgi_cache_valid<br> scgi_connect_timeout<br> scgi_force_ranges<br> scgi_hide_header<br> scgi_ignore_client_abort<br> scgi_ignore_headers<br> scgi_intercept_errors<br> scgi_limit_rate<br> scgi_max_temp_file_size<br> scgi_next_upstream<br> scgi_next_upstream_timeout<br> scgi_next_upstream_tries<br> scgi_no_cache<br> scgi_param<br> scgi_pass<br> scgi_pass_header<br> scgi_pass_request_body<br> scgi_pass_request_headers<br> scgi_read_timeout<br> scgi_request_buffering<br> scgi_send_timeout<br> scgi_socket_keepalive<br> scgi_store<br> scgi_store_access<br> scgi_temp_file_write_size<br> scgi_temp_path<br> secure_link<br> secure_link_md5<br> secure_link_secret<br> send_lowat<br> send_timeout<br> 发送文件<br> sendfile_max_chunk<br> 服务器 （ngx_http_core_module）<br> 服务器 （ngx_http_upstream_module）<br> 服务器 （ngx_mail_core_module）<br> 服务器 （ngx_stream_core_module）<br> 服务器 （ngx_stream_upstream_module）<br> server_name （ngx_http_core_module）<br> server_name （ngx_mail_core_module）<br> server_name_in_redirect<br> server_names_hash_bucket_size<br> server_names_hash_max_size<br> server_tokens<br> session_log<br> session_log_format<br> session_log_zone<br> 组<br> set_real_ip_from （ngx_http_realip_module）<br> set_real_ip_from （ngx_stream_realip_module）<br> 切片<br> SMTP_AUTH<br> smtp_capabilities<br> smtp_client_buffer<br> smtp_greeting_delay<br> source_charset<br> spdy_chunk_size<br> spdy_headers_comp<br> split_clients （ngx_http_split_clients_module）<br> split_clients （ngx_stream_split_clients_module）<br> SSI<br> ssi_last_modified<br> ssi_min_file_chunk<br> ssi_silent_errors<br> ssi_types<br> ssi_value_length<br> ssl （ngx_http_ssl_module）<br> ssl （ngx_mail_ssl_module）<br> ssl_buffer_size<br> ssl_certificate （ngx_http_ssl_module）<br> ssl_certificate （ngx_mail_ssl_module）<br> ssl_certificate （ngx_stream_ssl_module）<br> ssl_certificate_key （ngx_http_ssl_module）<br> ssl_certificate_key （ngx_mail_ssl_module）<br> ssl_certificate_key （ngx_stream_ssl_module）<br> ssl_ciphers （ngx_http_ssl_module）<br> ssl_ciphers （ngx_mail_ssl_module）<br> ssl_ciphers （ngx_stream_ssl_module）<br> ssl_client_certificate （ngx_http_ssl_module）<br> ssl_client_certificate （ngx_mail_ssl_module）<br> ssl_client_certificate （ngx_stream_ssl_module）<br> ssl_crl （ngx_http_ssl_module）<br> ssl_crl （ngx_mail_ssl_module）<br> ssl_crl （ngx_stream_ssl_module）<br> ssl_dhparam （ngx_http_ssl_module）<br> ssl_dhparam （ngx_mail_ssl_module）<br> ssl_dhparam （ngx_stream_ssl_module）<br> ssl_early_data<br> ssl_ecdh_curve （ngx_http_ssl_module）<br> ssl_ecdh_curve （ngx_mail_ssl_module）<br> ssl_ecdh_curve （ngx_stream_ssl_module）<br> ssl_engine<br> ssl_handshake_timeout<br> ssl_password_file （ngx_http_ssl_module）<br> ssl_password_file （ngx_mail_ssl_module）<br> ssl_password_file （ngx_stream_ssl_module）<br> ssl_prefer_server_ciphers （ngx_http_ssl_module）<br> ssl_prefer_server_ciphers （ngx_mail_ssl_module）<br> ssl_prefer_server_ciphers （ngx_stream_ssl_module）<br> ssl_preread<br> ssl_protocols （ngx_http_ssl_module）<br> ssl_protocols （ngx_mail_ssl_module）<br> ssl_protocols （ngx_stream_ssl_module）<br> ssl_session_cache （ngx_http_ssl_module）<br> ssl_session_cache （ngx_mail_ssl_module）<br> ssl_session_cache （ngx_stream_ssl_module）<br> ssl_session_ticket_key （ngx_http_ssl_module）<br> ssl_session_ticket_key （ngx_mail_ssl_module）<br> ssl_session_ticket_key （ngx_stream_ssl_module）<br> ssl_session_tickets （ngx_http_ssl_module）<br> ssl_session_tickets （ngx_mail_ssl_module）<br> ssl_session_tickets （ngx_stream_ssl_module）<br> ssl_session_timeout （ngx_http_ssl_module）<br> ssl_session_timeout （ngx_mail_ssl_module）<br> ssl_session_timeout （ngx_stream_ssl_module）<br> ssl_stapling<br> ssl_stapling_file<br> ssl_stapling_responder<br> ssl_stapling_verify<br> ssl_trusted_certificate （ngx_http_ssl_module）<br> ssl_trusted_certificate （ngx_mail_ssl_module）<br> ssl_trusted_certificate （ngx_stream_ssl_module）<br> ssl_verify_client （ngx_http_ssl_module）<br> ssl_verify_client （ngx_mail_ssl_module）<br> ssl_verify_client （ngx_stream_ssl_module）<br> ssl_verify_depth （ngx_http_ssl_module）<br> ssl_verify_depth （ngx_mail_ssl_module）<br> ssl_verify_depth （ngx_stream_ssl_module）<br> STARTTLS<br> state （ngx_http_upstream_module）<br> state （ngx_stream_upstream_module）<br> 状态<br> status_format的<br> status_zone （ngx_http_api_module）<br> status_zone （ngx_http_status_module）<br> 黏<br> sticky_cookie_insert<br> 流<br> stub_status<br> sub_filter<br> sub_filter_last_modified<br> sub_filter_once<br> sub_filter_types<br> subrequest_output_buffer_size<br> tcp_nodelay （ngx_http_core_module）<br> tcp_nodelay （ngx_stream_core_module）<br> tcp_nopush<br> thread_pool<br> 超时<br> timer_resolution<br> try_files<br> 类型<br> types_hash_bucket_size<br> types_hash_max_size<br> underscores_in_headers<br> uninitialized_variable_warn<br> 上游 （ngx_http_upstream_module）<br> 上游 （ngx_stream_upstream_module）<br> upstream_conf<br> 使用<br> 用户<br> 用户身份<br> userid_domain<br> userid_expires<br> userid_mark<br> userid_name<br> userid_p3p<br> userid_path<br> userid_service<br> uwsgi_bind<br> uwsgi_buffer_size<br> uwsgi_buffering<br> uwsgi_buffers<br> uwsgi_busy_buffers_size<br> uwsgi_cache<br> uwsgi_cache_background_update<br> uwsgi_cache_bypass<br> uwsgi_cache_key<br> uwsgi_cache_lock<br> uwsgi_cache_lock_age<br> uwsgi_cache_lock_timeout<br> uwsgi_cache_max_range_offset<br> uwsgi_cache_methods<br> uwsgi_cache_min_uses<br> uwsgi_cache_path<br> uwsgi_cache_purge<br> uwsgi_cache_revalidate<br> uwsgi_cache_use_stale<br> uwsgi_cache_valid<br> uwsgi_connect_timeout<br> uwsgi_force_ranges<br> uwsgi_hide_header<br> uwsgi_ignore_client_abort<br> uwsgi_ignore_headers<br> uwsgi_intercept_errors<br> uwsgi_limit_rate<br> uwsgi_max_temp_file_size<br> uwsgi_modifier1<br> uwsgi_modifier2<br> uwsgi_next_upstream<br> uwsgi_next_upstream_timeout<br> uwsgi_next_upstream_tries<br> uwsgi_no_cache<br> uwsgi_param<br> uwsgi_pass<br> uwsgi_pass_header<br> uwsgi_pass_request_body<br> uwsgi_pass_request_headers<br> uwsgi_read_timeout<br> uwsgi_request_buffering<br> uwsgi_send_timeout<br> uwsgi_socket_keepalive<br> uwsgi_ssl_certificate<br> uwsgi_ssl_certificate_key<br> uwsgi_ssl_ciphers<br> uwsgi_ssl_crl<br> uwsgi_ssl_name<br> uwsgi_ssl_password_file<br> uwsgi_ssl_protocols<br> uwsgi_ssl_server_name<br> uwsgi_ssl_session_reuse<br> uwsgi_ssl_trusted_certificate<br> uwsgi_ssl_verify<br> uwsgi_ssl_verify_depth<br> uwsgi_store<br> uwsgi_store_access<br> uwsgi_temp_file_write_size<br> uwsgi_temp_path<br> valid_referers<br> variables_hash_bucket_size （ngx_http_core_module）<br> variables_hash_bucket_size （ngx_stream_core_module）<br> variables_hash_max_size （ngx_http_core_module）<br> variables_hash_max_size （ngx_stream_core_module）<br> worker_aio_requests<br> worker_connections<br> worker_cpu_affinity<br> worker_priority<br> worker_processes<br> worker_rlimit_core<br> worker_rlimit_nofile<br> worker_shutdown_timeout<br> working_directory的<br> X客户端<br> xml_entities<br> xslt_last_modified<br> xslt_param<br> xslt_string_param<br> xslt_stylesheet<br> xslt_types<br> zone （ngx_http_upstream_module）<br> zone （ngx_stream_upstream_module）<br> zone_sync<br> zone_sync_buffers<br> zone_sync_connect_retry_interval<br> zone_sync_connect_timeout<br> zone_sync_interval<br> zone_sync_recv_buffer_size<br> zone_sync_server<br> zone_sync_ssl<br> zone_sync_ssl_certificate<br> zone_sync_ssl_certificate_key<br> zone_sync_ssl_ciphers<br> zone_sync_ssl_crl<br> zone_sync_ssl_name<br> zone_sync_ssl_password_file<br> zone_sync_ssl_protocols<br> zone_sync_ssl_server_name<br> zone_sync_ssl_trusted_certificate<br> zone_sync_ssl_verify<br> zone_sync_ssl_verify_depth<br> zone_sync_timeout   </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[debugging_log-nginx中文手册]]></title>
      <url>/ngx/debugging_log.html</url>
      <content type="html"><![CDATA[<p>debugging_log<br><a id="more"></a></p>
<h2 id="调试日志"><a href="#调试日志" class="headerlink" title=" 调试日志"></a> 调试日志</h2><p> Debugging log for selected clients<br> Logging to a cyclic memory buffer<br> 要启用调试日志，需要配置nginx以在构建期间支持调试： </p>
<blockquote>
<p>./configure –with-debug …  然后应使用error_log指令设置debug级别： </p>
<p>error_log /path/to/log debug;  要验证nginx是否配置为支持调试，请运行nginx -V命令： </p>
<p>configure arguments: –with-debug …  预构建的Linux软件包为使用nginx-debug二进制文件（1.9.8）调试日志提供了开箱即用的支持，可以使用命令运行 </p>
<p>service nginx stop service nginx-debug start  然后设置debug级别。 用于Windows的nginx二进制版本始终使用调试日志支持构建，因此仅设置debug级别就足够了。 </p>
</blockquote>
<p> 请注意，重新定义日志而不指定debug级别将禁用调试日志。 在下面的示例中，重新定义服务器级别上的日志会禁用此服务器的调试日志： </p>
<blockquote>
<p>error_log /path/to/log debug; http { server { error_log /path/to/log; …  为避免这种情况，应重新定义重新定义日志的行，或者还应添加debug级别规范： </p>
<p>error_log /path/to/log debug; http { server { error_log /path/to/log debug; … ####  调试所选客户端的日志</p>
</blockquote>
<p> 也可以仅为选定的客户端地址启用调试日志： </p>
<blockquote>
<p>error_log /path/to/log; events { debug_connection 192.168.1.1; debug_connection 192.168.10.0/24; } ####  记录到循环内存缓冲区</p>
</blockquote>
<p> 调试日志可以写入循环内存缓冲区： </p>
<blockquote>
<p>error_log memory:32m debug;  即使在高负载下，在debug级别上记录到内存缓冲区也不会对性能产生重大影响。 在这种情况下，可以使用gdb脚本提取日志，如下所示： </p>
<p>set $log = ngx_cycle-&gt;log while $log-&gt;writer != ngx_log_memory_writer set $log = $log-&gt;next end set $buf = (ngx_log_memory_buf_t *) $log-&gt;wdata dump binary memory debug_log.txt $buf-&gt;start $buf-&gt;end  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[control-nginx中文手册]]></title>
      <url>/ngx/control.html</url>
      <content type="html"><![CDATA[<p>control<br><a id="more"></a></p>
<h2 id="控制nginx"><a href="#控制nginx" class="headerlink" title=" 控制nginx"></a> 控制nginx</h2><p> Changing Configuration<br> Rotating Log-files<br> Upgrading Executable on the Fly<br> nginx可以用信号控制。 默认情况下，主进程的进程ID将写入文件/usr/local/nginx/logs/nginx.pid 。 此名称可以在配置时更改，也可以使用pid指令在nginx.conf更改。 主进程支持以下信号： </p>
<blockquote>
<p>TERM, INTfast shutdownQUITgraceful shutdownHUPchanging configuration, keeping up with a changed time zone (only for FreeBSD and Linux), starting new worker processes with a new configuration, graceful shutdown of old worker processesUSR1re-opening log filesUSR2upgrading an executable fileWINCHgraceful shutdown of worker processes 虽然不是必需的，但也可以通过信号控制单个工作进程。 支持的信号是： </p>
<p>TERM, INTfast shutdownQUITgraceful shutdownUSR1re-opening log filesWINCHabnormal termination for debugging (requires debug_points to be enabled) ####  改变配置</p>
</blockquote>
<p> 为了让nginx重新读取配置文件，应该将HUP信号发送到主进程。 主进程首先检查语法有效性，然后尝试应用新配置，即打开日志文件和新的侦听套接字。 如果此操作失败，则会回滚更改并继续使用旧配置。 如果成功，它将启动新的工作进程，并向旧工作进程发送消息，请求它们正常关闭。 旧工作进程关闭侦听套接字并继续为旧客户端提供服务。 在为所有客户端提供服务后，将关闭旧工作进程。 </p>
<p> 让我们通过例子来说明这一点。 想象一下，nginx是在FreeBSD和命令上运行的 </p>
<blockquote>
<p>ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep ‘(nginx|PID)’  产生以下输出： </p>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1148 pause nginx: master process /usr/local/nginx/sbin/nginx 33127 33126 nobody 0.0 1380 kqread nginx: worker process (nginx) 33128 33126 nobody 0.0 1364 kqread nginx: worker process (nginx) 33129 33126 nobody 0.0 1364 kqread nginx: worker process (nginx)  如果将HUP发送到主进程，则输出变为： </p>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1164 pause nginx: master process /usr/local/nginx/sbin/nginx 33129 33126 nobody 0.0 1380 kqread nginx: worker process is shutting down (nginx) 33134 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 33135 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 33136 33126 nobody 0.0 1368 kqread nginx: worker process (nginx)  PID 33129的旧工作进程之一仍然继续工作。 退出一段时间后： </p>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1164 pause nginx: master process /usr/local/nginx/sbin/nginx 33134 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 33135 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 33136 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) ####  旋转日志文件</p>
</blockquote>
<p> 为了旋转日志文件，需要先重命名它们。 之后，应将USR1信号发送到主进程。 然后，主进程将重新打开所有当前打开的日志文件，并为作为所有者的工作进程正在运行的非特权用户分配。 成功重新打开后，主进程将关闭所有打开的文件，并将消息发送到工作进程，要求他们重新打开文件。 工作进程还会立即打开新文件并关闭旧文件。 因此，旧文件几乎可立即用于后期处理，例如压缩。 </p>
<h4 id="即时升级可执行文件"><a href="#即时升级可执行文件" class="headerlink" title="即时升级可执行文件"></a>即时升级可执行文件</h4><p> 为了升级服务器可执行文件，应首先使用新的可执行文件代替旧文件。 之后，应将USR2信号发送到主进程。 主进程首先使用进程ID将其文件重命名为带有.oldbin后缀的新文件，例如/usr/local/nginx/logs/nginx.pid.oldbin ，然后启动一个新的可执行文件，该文件又启动新的工作进程： </p>
<blockquote>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1164 pause nginx: master process /usr/local/nginx/sbin/nginx 33134 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 33135 33126 nobody 0.0 1380 kqread nginx: worker process (nginx) 33136 33126 nobody 0.0 1368 kqread nginx: worker process (nginx) 36264 33126 root 0.0 1148 pause nginx: master process /usr/local/nginx/sbin/nginx 36265 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36266 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36267 36264 nobody 0.0 1364 kqread nginx: worker process (nginx)  之后，所有工作进程（新旧进程）继续接受请求。 如果将WINCH信号发送到第一个主进程，它将向其工作进程发送消息，请求它们正常关闭，然后它们将开始退出： </p>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1164 pause nginx: master process /usr/local/nginx/sbin/nginx 33135 33126 nobody 0.0 1380 kqread nginx: worker process is shutting down (nginx) 36264 33126 root 0.0 1148 pause nginx: master process /usr/local/nginx/sbin/nginx 36265 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36266 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36267 36264 nobody 0.0 1364 kqread nginx: worker process (nginx)  一段时间后，只有新的工作进程才会处理请求： </p>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 33126 1 root 0.0 1164 pause nginx: master process /usr/local/nginx/sbin/nginx 36264 33126 root 0.0 1148 pause nginx: master process /usr/local/nginx/sbin/nginx 36265 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36266 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36267 36264 nobody 0.0 1364 kqread nginx: worker process (nginx)  应该注意的是，旧的主进程不会关闭其侦听套接字，并且可以管理它以在需要时再次启动其工作进程。 如果由于某种原因新的可执行文件无法接受，可以执行以下操作之一： </p>
</blockquote>
<ul>
<li>将HUP信号发送到旧的主进程。 旧的主进程将启动新的工作进程，而无需重新读取配置。 之后，通过将QUIT信号发送到新的主进程，可以正常关闭所有新进程。 </li>
</ul>
<ul>
<li>将TERM信号发送到新的主进程。 然后它会向其工作进程发送一条消息，要求它们立即退出，并且它们几乎都会立即退出。 （如果新进程由于某种原因没有退出，则应将KILL信号发送给它们以强制它们退出。）当新的主进程退出时，旧的主进程将自动启动新的进程进程。 </li>
</ul>
<p> 如果新的主进程退出，则旧的主进程将使用进程ID从文件名中丢弃.oldbin后缀。 </p>
<p> 如果升级成功，则应将QUIT信号发送到旧的主进程，并且只保留新进程： </p>
<blockquote>
<p> PID PPID USER %CPU VSZ WCHAN COMMAND 36264 1 root 0.0 1148 pause nginx: master process /usr/local/nginx/sbin/nginx 36265 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36266 36264 nobody 0.0 1364 kqread nginx: worker process (nginx) 36267 36264 nobody 0.0 1364 kqread nginx: worker process (nginx)  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[contributing_changes-nginx中文手册]]></title>
      <url>/ngx/contributing_changes.html</url>
      <content type="html"><![CDATA[<p>contributing_changes<br><a id="more"></a></p>
<h2 id="贡献变化"><a href="#贡献变化" class="headerlink" title=" 贡献变化"></a> 贡献变化</h2><p> Getting Sources<br> Formatting Changes<br> Before Submitting<br> Submitting Changes<br> License   </p>
<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p> Mercurial用于存储源代码。 可以使用以下命令克隆存储库 ： </p>
<blockquote>
<p>hg clone <a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">http://hg.nginx.org/nginx</a> ####  格式化更改</p>
</blockquote>
<p> 应根据nginx使用的代码样式格式化更改。 有时，没有明确的规则; 在这种情况下，检查现有nginx源的格式并模仿这种风格。 如果样式与周围的代码相对应，则更有可能接受更改。 </p>
<p> 提交更改以创建Mercurial 变更集 。 请确保更改作者的指定电子邮件地址和真实姓名正确无误。 </p>
<p> 提交消息应该有一个单行的概要，后面跟一个空行后的详细描述。 希望第一行不超过67个符号。 可以使用hg export命令获取作为补丁的结果变更集： </p>
<blockquote>
<h1 id="HG-changeset-patch-User-Filipe-Da-Silva-117-115-x65-x72-x6e-97-109-101-x40-x65-x78-x61-x6d-112-108-x65-x2e-x63-x6f-109-Date-1368089668-7200-Thu-May-09-10-54-28-2013-0200-Node-ID-2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2-Parent-822b82191940ef309cd1e6502f94d50d811252a1-Mail-removed-surplus-ngx-close-connection-call-It-is-already-called-for-a-peer-connection-a-few-lines-above-diff-r-822b82191940-r-2220de0521ca-src-mail-ngx-mail-auth-http-module-c-—-a-src-mail-ngx-mail-auth-http-module-c-Wed-May-15-15-04-49-2013-0400-b-src-mail-ngx-mail-auth-http-module-c-Thu-May-09-10-54-28-2013-0200-699-7-699-6-ngx-mail-auth-http-process-headers-ngx-m-p-ngx-pnalloc-s-gt-connection-gt-pool-ctx-gt-err-len-if-p-NULL-ngx-close-connection-ctx-gt-peer-connection-ngx-destroy-pool-ctx-gt-pool-ngx-mail-session-internal-server-error-s-return-在提交之前"><a href="#HG-changeset-patch-User-Filipe-Da-Silva-117-115-x65-x72-x6e-97-109-101-x40-x65-x78-x61-x6d-112-108-x65-x2e-x63-x6f-109-Date-1368089668-7200-Thu-May-09-10-54-28-2013-0200-Node-ID-2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2-Parent-822b82191940ef309cd1e6502f94d50d811252a1-Mail-removed-surplus-ngx-close-connection-call-It-is-already-called-for-a-peer-connection-a-few-lines-above-diff-r-822b82191940-r-2220de0521ca-src-mail-ngx-mail-auth-http-module-c-—-a-src-mail-ngx-mail-auth-http-module-c-Wed-May-15-15-04-49-2013-0400-b-src-mail-ngx-mail-auth-http-module-c-Thu-May-09-10-54-28-2013-0200-699-7-699-6-ngx-mail-auth-http-process-headers-ngx-m-p-ngx-pnalloc-s-gt-connection-gt-pool-ctx-gt-err-len-if-p-NULL-ngx-close-connection-ctx-gt-peer-connection-ngx-destroy-pool-ctx-gt-pool-ngx-mail-session-internal-server-error-s-return-在提交之前" class="headerlink" title="HG changeset patch # User Filipe Da Silva &#117;&#115;&#x65;&#x72;&#x6e;&#97;&#109;&#101;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109; # Date 1368089668 -7200 # Thu May 09 10:54:28 2013 +0200 # Node ID 2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2 # Parent 822b82191940ef309cd1e6502f94d50d811252a1 Mail: removed surplus ngx_close_connection() call. It is already called for a peer connection a few lines above. diff -r 822b82191940 -r 2220de0521ca src/mail/ngx_mail_auth_http_module.c — a/src/mail/ngx_mail_auth_http_module.c Wed May 15 15:04:49 2013 +0400 +++ b/src/mail/ngx_mail_auth_http_module.c Thu May 09 10:54:28 2013 +0200 @@ -699,7 +699,6 @@ ngx_mail_auth_http_process_headers(ngx_m p = ngx_pnalloc(s-&gt;connection-&gt;pool, ctx-&gt;err.len); if (p == NULL) { - ngx_close_connection(ctx-&gt;peer.connection); ngx_destroy_pool(ctx-&gt;pool); ngx_mail_session_internal_server_error(s); return; ####  在提交之前"></a>HG changeset patch # User Filipe Da Silva <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#117;&#115;&#x65;&#x72;&#x6e;&#97;&#109;&#101;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#117;&#115;&#x65;&#x72;&#x6e;&#97;&#109;&#101;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;</a> # Date 1368089668 -7200 # Thu May 09 10:54:28 2013 +0200 # Node ID 2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2 # Parent 822b82191940ef309cd1e6502f94d50d811252a1 Mail: removed surplus ngx_close_connection() call. It is already called for a peer connection a few lines above. diff -r 822b82191940 -r 2220de0521ca src/mail/ngx_mail_auth_http_module.c — a/src/mail/ngx_mail_auth_http_module.c Wed May 15 15:04:49 2013 +0400 +++ b/src/mail/ngx_mail_auth_http_module.c Thu May 09 10:54:28 2013 +0200 @@ -699,7 +699,6 @@ ngx_mail_auth_http_process_headers(ngx_m p = ngx_pnalloc(s-&gt;connection-&gt;pool, ctx-&gt;err.len); if (p == NULL) { - ngx_close_connection(ctx-&gt;peer.connection); ngx_destroy_pool(ctx-&gt;pool); ngx_mail_session_internal_server_error(s); return; ####  在提交之前</h1></blockquote>
<p> 在提交更改之前，有几点值得考虑： </p>
<ul>
<li>建议的更改应适用于广泛的受支持平台 。 </li>
<li>尽量明确为什么需要建议的更改，并尽可能提供用例。 </li>
<li><p>通过测试套件传递更改是确保它们不会导致回归的好方法。 可以使用以下命令克隆包含测试的存储库 ： </p>
<blockquote>
<p>hg clone <a href="http://hg.nginx.org/nginx-tests" target="_blank" rel="noopener">http://hg.nginx.org/nginx-tests</a> </p>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4></blockquote>
<p>建议的更改应发送到nginx开发邮件列表。 提交变更集的首选方便方法是使用patchbomb扩展。 </p>
</li>
</ul>
<h4 id="执照"><a href="#执照" class="headerlink" title="执照"></a>执照</h4><p> 提交更改意味着授予项目在相应许可下使用它的权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[configure-nginx中文手册]]></title>
      <url>/ngx/configure.html</url>
      <content type="html"><![CDATA[<p>configure<br><a id="more"></a></p>
<h2 id="从Sources构建nginx"><a href="#从Sources构建nginx" class="headerlink" title=" 从Sources构建nginx"></a> 从Sources构建nginx</h2><p> 使用configure命令配置构建。 它定义了系统的各个方面，包括允许nginx用于连接处理的方法。 最后它创建了一个Makefile 。 </p>
<p> configure命令支持以下参数： </p>
<p> –help   打印帮助信息。  –prefix= <em>path</em>   定义将保留服务器文件的目录。 该目录也将用于configure设置的所有相对路径（库源路径除外）和nginx.conf配置文件中。 默认设置为/usr/local/nginx目录。  –sbin-path= <em>path</em>   设置nginx可执行文件的名称。 此名称仅在安装期间使用。 默认情况下，该文件名为<em>prefix</em> /sbin/nginx 。  –modules-path= <em>path</em>   定义将安装nginx动态模块的目录。 默认情况下，使用<em>prefix</em> /modules目录。  –conf-path= <em>path</em>   设置nginx.conf配置文件的名称。 如果需要，可以始终使用不同的配置文件启动nginx，方法是在命令行参数-c <em>file</em>指定它。 默认情况下，该文件名为<em>prefix</em> /conf/nginx.conf 。  –error-log-path= <em>path</em>   设置主要错误，警告和诊断文件的名称。 安装后，可以使用error_log指令在nginx.conf配置文件中更改文件名。 默认情况下，该文件名为<em>prefix</em> /logs/error.log 。  –pid-path= <em>path</em>   设置将存储主进程的进程ID的nginx.pid文件的名称。 安装后，可以使用pid指令在nginx.conf配置文件中始终更改文件名。 默认情况下，该文件名为<em>prefix</em> /logs/nginx.pid 。  –lock-path= <em>path</em>   为锁定文件的名称设置前缀。 安装后，可以使用lock_file指令在nginx.conf配置文件中始终更改该值。 默认情况下，该值为<em>prefix</em> /logs/nginx.lock 。  –user= <em>name</em>   设置非特权用户的名称，其凭据将由工作进程使用。 安装后，可以使用user指令在nginx.conf配置文件中更改名称。 默认用户名是nobody。  –group= <em>name</em>   设置其凭据将由工作进程使用的组的名称。 安装后，可以使用user指令在nginx.conf配置文件中更改名称。 默认情况下，组名称设置为非特权用户的名称。  –build= <em>name</em>   设置可选的nginx构建名称。  –builddir= <em>path</em>   设置构建目录。  –with-select_module<br> –without-select_module   启用或禁用构建允许服务器使用select()方法的模块。 如果平台似乎不支持更合适的方法（如kqueue，epoll或/ dev / poll），则会自动构建此模块。  –with-poll_module<br> –without-poll_module   启用或禁用构建允许服务器使用poll()方法的模块。 如果平台似乎不支持更合适的方法（如kqueue，epoll或/ dev / poll），则会自动构建此模块。  –with-threads   允许使用线程池 。  –with-file-aio   允许在FreeBSD和Linux上使用异步文件I / O （AIO）。  –with-http_ssl_module   允许构建一个模块，将HTTPS协议支持添加到HTTP服务器。 默认情况下不构建此模块。 需要OpenSSL库来构建和运行此模块。  –with-http_v2_module   可以构建一个支持HTTP / 2的模块。 默认情况下不构建此模块。  –with-http_realip_module   允许构建ngx_http_realip_module模块，该模块将客户端地址更改为在指定的头字段中发送的地址。 默认情况下不构建此模块。  –with-http_addition_module   允许构建ngx_http_addition_module模块，该模块在响应之前和之后添加文本。 默认情况下不构建此模块。  –with-http_xslt_module<br> –with-http_xslt_module=dynamic   允许构建使用一个或多个XSLT样式表转换XML响应的ngx_http_xslt_module模块。 默认情况下不构建此模块。 需要libxml2和libxslt库来构建和运行此模块。  –with-http_image_filter_module<br> –with-http_image_filter_module=dynamic   可以构建ngx_http_image_filter_module模块，该模块可以转换JPEG，GIF，PNG和WebP格式的图像。 默认情况下不构建此模块。  –with-http_geoip_module<br> –with-http_geoip_module=dynamic   允许构建ngx_http_geoip_module模块，该模块根据客户端IP地址和预编译的MaxMind数据库创建变量。 默认情况下不构建此模块。  –with-http_sub_module   允许构建ngx_http_sub_module模块，该模块通过将一个指定的字符串替换为另一个来修改响应。 默认情况下不构建此模块。  –with-http_dav_module   支持构建ngx_http_dav_module模块，该模块通过WebDAV协议提供文件管理自动化。 默认情况下不构建此模块。  –with-http_flv_module   支持构建ngx_http_flv_module模块，该模块为Flash Video（FLV）文件提供伪流服务器端支持。 默认情况下不构建此模块。  –with-http_mp4_module   支持构建ngx_http_mp4_module模块，该模块为MP4文件提供伪流服务器端支持。 默认情况下不构建此模块。  –with-http_gunzip_module   对于不支持“gzip”编码方法的客户端，可以构建使用“ Content-Encoding: gzip ”解压缩响应的ngx_http_gunzip_module模块。 默认情况下不构建此模块。  –with-http_gzip_static_module   允许构建ngx_http_gzip_static_module模块，该模块允许使用“ .gz ”文件扩展名而不是常规文件发送预压缩文件。 默认情况下不构建此模块。  –with-http_auth_request_module   允许构建ngx_http_auth_request_module模块，该模块基于子请求的结果实现客户端授权。 默认情况下不构建此模块。  –with-http_random_index_module   允许构建ngx_http_random_index_module模块，该模块处理以斜杠字符（’ / ‘）结尾的请求，并选择目录中的随机文件作为索引文件。 默认情况下不构建此模块。  –with-http_secure_link_module   可以构建ngx_http_secure_link_module模块。 默认情况下不构建此模块。  –with-http_degradation_module   可以构建ngx_http_degradation_module模块。 默认情况下不构建此模块。  –with-http_slice_module   允许构建ngx_http_slice_module模块，该模块将请求拆分为子请求，每个模块都返回一定范围的响应。 该模块提供了更有效的大响应缓存。 默认情况下不构建此模块。  –with-http_stub_status_module   可以构建ngx_http_stub_status_module模块，该模块提供对基本状态信息的访问。 默认情况下不构建此模块。  –without-http_charset_module   禁用构建ngx_http_charset_module模块，该模块将指定的字符集添加到“Content-Type”响应头字段，还可以将数据从一个字符集转换为另一个字符集。  –without-http_gzip_module   禁用构建压缩 HTTP服务器响应的模块。 zlib库是构建和运行此模块所必需的。  –without-http_ssi_module   禁用构建ngx_http_ssi_module模块，该模块在通过它的响应中处理SSI（服务器端包含）命令。  –without-http_userid_module   禁用构建ngx_http_userid_module模块，该模块设置适合客户端识别的cookie。  –without-http_access_module   禁用构建ngx_http_access_module模块，该模块允许限制对某些客户端地址的访问。  –without-http_auth_basic_module   禁用构建ngx_http_auth_basic_module模块，该模块允许通过使用“HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。  –without-http_mirror_module   禁用构建ngx_http_mirror_module模块，该模块通过创建后台镜像子请求来实现原始请求的镜像。  –without-http_autoindex_module   禁用构建ngx_http_autoindex_module模块，该模块处理以斜杠字符（’ / ‘）结尾的请求，并在ngx_http_index_module模块找不到索引文件的情况下生成目录列表。  –without-http_geo_module   禁用构建ngx_http_geo_module模块，该模块使用取决于客户端IP地址的值创建变量。  –without-http_map_module   禁用构建ngx_http_map_module模块，该模块使用取决于其他变量值的值创建变量。  –without-http_split_clients_module   禁用构建ngx_http_split_clients_module模块，该模块为A / B测试创建变量。  –without-http_referer_module   禁用构建ngx_http_referer_module模块，该模块可以阻止对“Referer”头字段中具有无效值的请求访问站点。  –without-http_rewrite_module   禁用构建允许HTTP服务器重定向请求和更改请求URI的模块 。 需要PCRE库来构建和运行此模块。  –without-http_proxy_module   禁用构建HTTP服务器代理模块 。  –without-http_fastcgi_module   禁用构建将请求传递给FastCGI服务器的ngx_http_fastcgi_module模块。  –without-http_uwsgi_module   禁用构建将请求传递给uwsgi服务器的ngx_http_uwsgi_module模块。  –without-http_scgi_module   禁用构建将请求传递给SCGI服务器的ngx_http_scgi_module模块。  –without-http_grpc_module   禁用构建将请求传递给gRPC服务器的ngx_http_grpc_module模块。  –without-http_memcached_module   禁用构建ngx_http_memcached_module模块，该模块从memcached服务器获取响应。  –without-http_limit_conn_module   禁用构建ngx_http_limit_conn_module模块，该模块限制每个密钥的连接数，例如，来自单个IP地址的连接数。  –without-http_limit_req_module   禁用构建ngx_http_limit_req_module模块，该模块限制每个密钥的请求处理速率，例如，来自单个IP地址的请求的处理速率。  –without-http_empty_gif_module   禁用构建发出单像素透明GIF的模块。  –without-http_browser_module   禁用构建ngx_http_browser_module模块，该模块创建的值取决于“User-Agent”请求标头字段的值。  –without-http_upstream_hash_module   禁用构建实现散列负载平衡方法的模块。  –without-http_upstream_ip_hash_module   禁用构建实现ip_hash负载平衡方法的模块。  –without-http_upstream_least_conn_module   禁用构建实现least_conn负载平衡方法的模块。  –without-http_upstream_keepalive_module   禁用构建一个模块，该模块提供到上游服务器的连接缓存 。  –without-http_upstream_zone_module   禁用构建模块，该模块可以将上游组的运行时状态存储在共享内存区域中 。  –with-http_perl_module<br> –with-http_perl_module=dynamic   可以构建嵌入式Perl模块 。 默认情况下不构建此模块。  –with-perl_modules_path= <em>path</em>   定义一个将保留Perl模块的目录。  –with-perl= <em>path</em>   设置Perl二进制文件的名称。  –http-log-path= <em>path</em>   设置HTTP服务器的主要请求日志文件的名称。 安装后，可以使用access_log指令在nginx.conf配置文件中始终更改文件名。 默认情况下，该文件名为<em>prefix</em> /logs/access.log 。  –http-client-body-temp-path= <em>path</em>   定义用于存储保存客户端请求主体的临时文件的目录。 安装后，可以使用client_body_temp_path指令在nginx.conf配置文件中始终更改目录。 默认情况下，该目录名为<em>prefix</em> /client_body_temp 。  –http-proxy-temp-path= <em>path</em>   定义一个目录，用于存储临时文件和从代理服务器接收的数据。 安装后，可以使用proxy_temp_path指令在nginx.conf配置文件中更改目录。 默认情况下，该目录名为<em>prefix</em> /proxy_temp 。  –http-fastcgi-temp-path= <em>path</em>   定义一个目录，用于存储从FastCGI服务器接收的数据的临时文件。 安装后，可以使用fastcgi_temp_path指令在nginx.conf配置文件中始终更改目录。 默认情况下，该目录名为<em>prefix</em> /fastcgi_temp 。  –http-uwsgi-temp-path= <em>path</em>   定义一个目录，用于存储从uwsgi服务器接收的数据的临时文件。 安装后，可以使用uwsgi_temp_path指令在nginx.conf配置文件中始终更改目录。 默认情况下，该目录名为<em>prefix</em> /uwsgi_temp 。  –http-scgi-temp-path= <em>path</em>   定义了一个目录，用于存储从SCGI服务器接收的数据的临时文件。 安装后，可以使用scgi_temp_path指令在nginx.conf配置文件中始终更改目录。 默认情况下，该目录名为<em>prefix</em> /scgi_temp 。  –without-http   禁用HTTP服务器。  –without-http-cache   禁用HTTP缓存。  –with-mail<br> –with-mail=dynamic   启用POP3 / IMAP4 / SMTP 邮件代理服务器。  –with-mail_ssl_module   允许构建一个模块，将SSL / TLS协议支持添加到邮件代理服务器。 默认情况下不构建此模块。 需要OpenSSL库来构建和运行此模块。  –without-mail_pop3_module   禁用邮件代理服务器中的POP3协议。  –without-mail_imap_module   禁用邮件代理服务器中的IMAP协议。  –without-mail_smtp_module   禁用邮件代理服务器中的SMTP协议。  –with-stream<br> –with-stream=dynamic   允许构建流模块以进行通用TCP / UDP代理和负载平衡。 默认情况下不构建此模块。  –with-stream_ssl_module   可以构建一个模块，为流模块添加SSL / TLS协议支持 。 默认情况下不构建此模块。 需要OpenSSL库来构建和运行此模块。  –with-stream_realip_module   允许构建ngx_stream_realip_module模块，该模块将客户端地址更改为PROXY协议头中发送的地址。 默认情况下不构建此模块。  –with-stream_geoip_module<br> –with-stream_geoip_module=dynamic   允许构建ngx_stream_geoip_module模块，该模块根据客户端IP地址和预编译的MaxMind数据库创建变量。 默认情况下不构建此模块。  –with-stream_ssl_preread_module   允许构建ngx_stream_ssl_preread_module模块，该模块允许从ClientHello消息中提取信息而不终止SSL / TLS。 默认情况下不构建此模块。  –without-stream_limit_conn_module   禁用构建ngx_stream_limit_conn_module模块，该模块限制每个密钥的连接数，例如，来自单个IP地址的连接数。  –without-stream_access_module   禁用构建ngx_stream_access_module模块，该模块允许限制对某些客户端地址的访问。  –without-stream_geo_module   禁用构建ngx_stream_geo_module模块，该模块使用取决于客户端IP地址的值创建变量。  –without-stream_map_module   禁用构建ngx_stream_map_module模块，该模块使用取决于其他变量值的值创建变量。  –without-stream_split_clients_module   禁用构建ngx_stream_split_clients_module模块，该模块为A / B测试创建变量。  –without-stream_return_module   禁用构建ngx_stream_return_module模块，该模块将一些指定值发送到客户端，然后关闭连接。  –without-stream_upstream_hash_module   禁用构建实现散列负载平衡方法的模块。  –without-stream_upstream_least_conn_module   禁用构建实现least_conn负载平衡方法的模块。  –without-stream_upstream_zone_module   禁用构建模块，该模块可以将上游组的运行时状态存储在共享内存区域中 。  –with-google_perftools_module   可以构建ngx_google_perftools_module模块，该模块可以使用Google Performance Tools分析nginx工作进程。 该模块适用于nginx开发人员，默认情况下不构建。  –with-cpp_test_module   用于构建ngx_cpp_test_module模块。  –add-module= <em>path</em>   启用外部模块。  –add-dynamic-module= <em>path</em>   启用外部动态模块。  –with-compat   启用动态模块兼容性。  –with-cc= <em>path</em>   设置C编译器的名称。  –with-cpp= <em>path</em>   设置C预处理器的名称。  –with-cc-opt= <em>parameters</em>   设置将添加到CFLAGS变量的其他参数。 在FreeBSD下使用系统PCRE库时，应指定–with-cc-opt=”-I /usr/local/include” 。 如果需要增加select()支持的文件数，也可以在此处指定，例如： - –with-cc-opt=”-D FD_SETSIZE=2048” 。  –with-ld-opt= <em>parameters</em>   设置将在链接期间使用的其他参数。 在FreeBSD下使用系统PCRE库时，应指定–with-ld-opt=”-L /usr/local/lib” 。  –with-cpu-opt= <em>cpu</em>   支持按指定CPU构建： pentium ， pentiumpro ， pentium3 ， pentium4 ， athlon ， pentium4 ， sparc32 ， sparc64 ， ppc64 。  –without-pcre   禁用PCRE库的使用。  –with-pcre   强制使用PCRE库。  –with-pcre= <em>path</em>   设置PCRE库源的路径。 库分发（版本4.4 - 8.42）需要从PCRE站点下载并提取。 其余的由nginx的./configure和make 。 该位置指令和ngx_http_rewrite_module模块中的正则表达式支持需要该库。  –with-pcre-opt= <em>parameters</em>   为PCRE设置其他构建选项。  –with-pcre-jit   使用“即时编译”支持（1.1.12， pcre_jit指令）构建PCRE库。  –with-zlib= <em>path</em>   设置zlib库源的路径。 库分发（版本1.1.3 - 1.2.11）需要从zlib站点下载并解压缩。 其余的由nginx的./configure和make 。 ngx_http_gzip_module模块需要该库。  –with-zlib-opt= <em>parameters</em>   为zlib设置其他构建选项。  –with-zlib-asm= <em>cpu</em>   允许使用针对其中一个指定CPU优化的zlib汇编程序源： pentium ， pentiumpro 。  –with-libatomic   强制libatomic_ops库使用。  –with-libatomic= <em>path</em>   设置libatomic_ops库源的路径。  –with-openssl= <em>path</em>   设置OpenSSL库源的路径。  –with-openssl-opt= <em>parameters</em>   为OpenSSL设置其他构建选项。  –with-debug   启用调试日志 。  参数用法示例（所有这些都需要在一行中输入）： </p>
<blockquote>
<p>./configure –sbin-path=/usr/local/nginx/nginx –conf-path=/usr/local/nginx/nginx.conf –pid-path=/usr/local/nginx/nginx.pid –with-http_ssl_module –with-pcre=../pcre-8.42 –with-zlib=../zlib-1.2.11  配置完成后，使用make编译和安装nginx。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compatibility-nginx中文手册]]></title>
      <url>/ngx/compatibility.html</url>
      <content type="html"><![CDATA[<p>compatibility<br><a id="more"></a></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title=" 兼容性"></a> 兼容性</h2><p> What is currently supported<br> What is not supported yet<br> njs是根据ECMAScript 5.1 （严格模式）创建的，带有一些ECMAScript 6及更高版本的扩展。 合规性仍在不断发展。 </p>
<h4 id="目前支持什么"><a href="#目前支持什么" class="headerlink" title="目前支持什么"></a>目前支持什么</h4><ul>
<li>布尔值，数字，字符串，对象，数组，函数和正则表达式 </li>
<li>ES5.1运算符，ES7指数运算符 </li>
<li>ES5.1语句： var ， if ， else ， switch ， for ， for in ， while ， do while ， break ， continue ， return ， try ， catch ， throw ， finally </li>
<li>ES6 Number和Math属性和方法 </li>
<li><p>String方法： </p>
<ul>
<li>ES5.1： fromCharCode ， concat ， slice ， substring ， substr ， charAt ， indexOf ， lastIndexOf ， toLowerCase ， toUpperCase ， trim ， search ， match ， split ， replace </li>
<li>ES6： fromCodePoint ， codePointAt ， includes ， startsWith ， endsWith ， repeat </li>
<li>ES8： padStart ， padEnd </li>
<li>非标准： bytesFrom （ bytesFrom ） fromUTF8 ， toUTF8 ， fromBytes ， toBytes </li>
</ul>
</li>
<li><p>Object方法： </p>
<ul>
<li>ES5.1： create （不带属性列表的支持）， keys ， defineProperty ， defineProperties ， getOwnPropertyDescriptor ， getPrototypeOf ， hasOwnProperty ， isPrototypeOf ， preventExtensions ， isExtensible ， freeze ， isFrozen ， seal ， isSealed </li>
</ul>
</li>
<li><p>Array方法： </p>
<ul>
<li>ES5.1： isArray ， slice ， splice ， push ， pop ， unshift ， shift ， reverse ， sort ， join ， concat ， indexOf ， lastIndexOf ， forEach ， some ， every ， filter ， map ， reduce ， reduceRight </li>
<li>ES6： of ， fill ， find ， findIndex </li>
<li>ES7： includes </li>
</ul>
</li>
<li><p>ES5.1 Function方法： call ， apply ， bind </p>
</li>
<li>ES5.1 RegExp方法： test ， exec </li>
<li>ES5。1日期方法 </li>
<li>ES5.1 JSON对象 </li>
<li>ES5.1 arguments对象（0.2.5） </li>
<li>ES5.1全局函数： isFinite ， isNaN ， parseFloat ， parseInt ， decodeURI ， decodeURIComponent ， encodeURI ， encodeURIComponent </li>
<li>Error对象： Error ， EvalError ， InternalError ， RangeError ， ReferenceError ， SyntaxError ， TypeError ， URIError </li>
<li>setTimeout和clearTimeout函数（0.2.0） </li>
<li>Node.js样式 File system方法： fs.readFileSync ， fs.appendFileSync ， fs.writeFileSync </li>
<li><p>Node.js样式 Crypto方法（0.2.0）： crypto.createHash ， crypto.createHmac </p>
<h4 id="什么是不支持的"><a href="#什么是不支持的" class="headerlink" title="什么是不支持的"></a>什么是不支持的</h4></li>
<li><p>ES6 let和const声明 </p>
</li>
<li>标签 </li>
<li>eval功能 </li>
<li>new Function()构造函数 </li>
<li>setInterval ， setImmediate函数 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[changes-nginx中文手册]]></title>
      <url>/ngx/changes.html</url>
      <content type="html"><![CDATA[<p>changes<br><a id="more"></a></p>
<h2 id="变化"><a href="#变化" class="headerlink" title=" 变化"></a> 变化</h2><h4 id="变化为0-2-6"><a href="#变化为0-2-6" class="headerlink" title="变化为0.2.6"></a>变化为0.2.6</h4><p> 发布日期：2018年11月27日 </p>
<p> 核心： </p>
<ul>
<li>特点：使内置原型可变。 </li>
</ul>
<ul>
<li>特征：使全局对象变得可变。 </li>
</ul>
<ul>
<li>功能： console.time()和console.timeEnd()方法。 </li>
</ul>
<ul>
<li>功能：允许重新声明变量和函数。 </li>
</ul>
<ul>
<li>功能：扩展Object.defineProperty()规范一致性。 </li>
</ul>
<ul>
<li>功能：为CLI引入安静模式以处理来自stdin的简单表达式。 </li>
</ul>
<ul>
<li>特点：引入紧凑形式的回溯来处理堆栈溢出。 </li>
</ul>
<ul>
<li>改进：改进各种例外的措辞。 </li>
</ul>
<ul>
<li>修正：修复闭包值处理。 </li>
</ul>
<ul>
<li>修正：各种值类型的固定相等运算符。 </li>
</ul>
<ul>
<li>修正：修复了各种范围内“this”关键字的处理。 </li>
</ul>
<ul>
<li>修正：修复了Object.keys()处理非对象值的问题。 </li>
</ul>
<ul>
<li>修正：在if语句中修复了throw语句的解析。 </li>
</ul>
<ul>
<li>修正：修复throw语句后的换行符。 </li>
</ul>
<ul>
<li>修正：修复if语句中没有换行符的语句解析。 </li>
</ul>
<ul>
<li>修正： njs_array_expand()固定大小uint32_t溢出。 </li>
</ul>
<ul>
<li>修正： object_value类型的固定typeof运算符。 </li>
</ul>
<ul>
<li>修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-5"><a href="#变化为0-2-5" class="headerlink" title="变化为0.2.5"></a>变化为0.2.5</h4><p> 发布日期：2018年10月30日 </p>
<p> nginx模块： </p>
<ul>
<li>修正：在流模块中修复计数待处理事件。 </li>
</ul>
<ul>
<li>修正：修复了流模块中的s.off() 。 </li>
</ul>
<ul>
<li>修正：修复了流模块中js_filter中数据块的处理。 </li>
</ul>
<ul>
<li>修正：在http模块中修复了http status和contentType getter。 </li>
</ul>
<ul>
<li>修正：在http模块中修复了http响应和父getter。 </li>
</ul>
<p> 核心： </p>
<ul>
<li>功能：参数对象支持。 </li>
</ul>
<ul>
<li>特征：非整数分数支持。 </li>
</ul>
<ul>
<li>改进：处理Array.prototype.slice()非数组值。 </li>
</ul>
<ul>
<li>修正：修复了Array.prototype.length setter </li>
</ul>
<ul>
<li>修正：固定njs_array_alloc() ，长度&gt; 2 ** 31。 </li>
</ul>
<ul>
<li>修正：处理32位njs_array_alloc()上的njs_array_alloc() int溢出。 </li>
</ul>
<ul>
<li>修正：修复代码大小不匹配错误消息。 </li>
</ul>
<ul>
<li>修正：修复循环中的删除操作符。 </li>
</ul>
<ul>
<li>修正：修复了复杂对象的Object.getOwnPropertyDescriptor() （继承自Array和string值）。 </li>
</ul>
<ul>
<li>修正：修复了非对象属性的Object.prototype.hasOwnProperty() </li>
</ul>
<ul>
<li>修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-4"><a href="#变化为0-2-4" class="headerlink" title="变化为0.2.4"></a>变化为0.2.4</h4><p> 发布日期：2018年9月18日 </p>
<p> nginx模块： </p>
<ul>
<li><p>更改：重构的流模块处理程序。 </p>
<p>新方法和属性： s.on（） ， s.off（） ， s.allow（） ， s.done（） ， s.decline（） ， s.deny（） 。 </p>
<p>删除了Stream对象的属性： s.OK ， s.ABORT ， s.AGAIN ， s.DECLINED ， s.ERROR （替换为s.allow（） ， s.done（） ， s.deny（） ）。 </p>
<p>s.buffer （用于读取替换为相应回调的数据参数，用于写入使用s.send（） ）。 </p>
<p>s.fromUpstream （替换为相应事件的回调）。 </p>
<p>s.eof （替换为  flags.last ）。 </p>
</li>
</ul>
<p> 核心： </p>
<ul>
<li>功能：添加了Function.prototype.length 。 </li>
</ul>
<ul>
<li>功能：介绍沙盒模式。 </li>
</ul>
<ul>
<li>改进：适当时添加异常字符串。 </li>
</ul>
<ul>
<li>改进：改进了原始类型转换异常的措辞。 </li>
</ul>
<ul>
<li>修正：为尝试更改冻结属性而抛出TypeError 。 </li>
</ul>
<ul>
<li>修正：修复现有属性的Object.defineProperty() 。 </li>
</ul>
<ul>
<li>修正：在for for迭代时尊重可枚举属性。 </li>
</ul>
<ul>
<li>修正：尊重属性处理程序的可写属性。 </li>
</ul>
<ul>
<li>修正：修复了函数参数中的异常处理。 </li>
</ul>
<ul>
<li>修正：修复了不同值类型的Object.prototype.toString 。 </li>
</ul>
<ul>
<li>修正：修复了对象类型参数的Object()构造函数。 </li>
</ul>
<ul>
<li>修正：固定对象和字符串的比较。 </li>
</ul>
<ul>
<li>修正：修复了未定义参数的String.slice() 。 </li>
</ul>
<ul>
<li>修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-3"><a href="#变化为0-2-3" class="headerlink" title="变化为0.2.3"></a>变化为0.2.3</h4><p> 发布日期：2018年7月31日 </p>
<p> nginx模块： </p>
<ul>
<li>修正：从Reply对象进行子请求导致分段错误。 </li>
</ul>
<ul>
<li>修正：获取主HTTP Request对象的parent属性导致了分段错误。 </li>
</ul>
<p> 核心： </p>
<ul>
<li>功能：为值添加了漂亮的字符串表示。 </li>
</ul>
<ul>
<li>功能：正确打印浮点数。 </li>
</ul>
<ul>
<li>功能：正确解析浮点数。 </li>
</ul>
<ul>
<li>功能： String.bytesFrom（）方法（将hex ， base64 ， base64url解码为字节字符串）。 </li>
</ul>
<ul>
<li>功能： String.padStart（）和String.padEnd（）方法。 </li>
</ul>
<ul>
<li>功能：增加了对二进制文字的支持。 </li>
</ul>
<ul>
<li>改进：在数字解析中添加有关非法令牌的信息。 </li>
</ul>
<ul>
<li>改进：允许在八进制文字值中使用大写字母O </li>
</ul>
<ul>
<li>改进：在console.log()添加了对多个参数的支持。 </li>
</ul>
<ul>
<li>修正：修复了将call()应用于外部值的方法。 </li>
</ul>
<ul>
<li>修正：应用于对象的固定加法运算符。 </li>
</ul>
<ul>
<li>修正：在njs_vm_value_to_ext_string()修复异常处理。 </li>
</ul>
<ul>
<li>修正：使用布尔，null和未定义的参数修复Number() 。 </li>
</ul>
<ul>
<li>修正：修复了设置非数字Array.length错误处理。 </li>
</ul>
<ul>
<li>修正：修复全局对象的自动完成。 </li>
</ul>
<ul>
<li>修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-2"><a href="#变化为0-2-2" class="headerlink" title="变化为0.2.2"></a>变化为0.2.2</h4><p> 发布日期：2018年6月19日 </p>
<p> nginx模块： </p>
<ul>
<li>更改：合并HTTP Response和Reply到HTTP请求 。 新成员Request ： </li>
</ul>
<pre><code>+  req.status （ res.status ） 


+  req.parent （ reply.parent ） 


+  req.requestBody （ req.body ） 


+  req.responseBody （ reply.body ） 


+  req.headersIn （ req.headers ） 


+  req.headersOut （ res.headers ） 


+  req.sendHeader() （ res.sendHeader() ） 


+  req.send() （ res.send() ） 


+  req.finish() （ res.finish() ） 


+  req.return() （ res.return() ） 


 弃用的Request成员： 


+  req.body （使用req.requestBody或req.responseBody ） 


+  req.headers （使用req.headersIn或req.headersOut ） 


+  req.response 


 已弃用的属性将在下一版本中删除。 
</code></pre><ul>
<li>功能：HTTP internalRedirect（）方法。 </li>
</ul>
<p> 核心： </p>
<ul>
<li>修正：在crypto.createHmac()修复了heap-buffer-overflow。 </li>
</ul>
<h4 id="变化为0-2-1"><a href="#变化为0-2-1" class="headerlink" title="变化为0.2.1"></a>变化为0.2.1</h4><p> 发布日期：2018年5月31日 </p>
<p> nginx模块： </p>
<ul>
<li>功能：HTTP请求正文getter。 </li>
</ul>
<ul>
<li>改进：将njs vm移动到main配置。 </li>
</ul>
<ul>
<li>改进：改进了js_set和js_content指令的日志记录。 </li>
</ul>
<ul>
<li>改进：在js_content处理程序中默认将状态代码设置为500 </li>
</ul>
<ul>
<li>改进：在js_content处理程序中添加了返回状态代码的调试 </li>
</ul>
<ul>
<li>修正：修复了js_include中的错误记录。 </li>
</ul>
<p> 核心： </p>
<ul>
<li>功能：添加了数组长度设置器。 </li>
</ul>
<ul>
<li>改进：公共标头cleanup. njscript.h cleanup. njscript.h重命名为njs.h </li>
</ul>
<ul>
<li>修正：调用digest()后修复了crypto update()方法。 </li>
</ul>
<ul>
<li>修正：修复了大小&lt;= alg size&gt; 64的密钥的crypto.createHmac() 。 </li>
</ul>
<ul>
<li>修正：修复了带空单元格的数组的JSON.stringify() 。 </li>
</ul>
<ul>
<li>修正：修复了JSON.stringify()不支持的类型的异常类型。 </li>
</ul>
<ul>
<li>修正：修复了函数未定义参数的处理。 </li>
</ul>
<ul>
<li>修正：修复了对Object.getOwnPropertyDescriptor()缺失arg的处理。 </li>
</ul>
<ul>
<li>修正：修复了Object.getOwnPropertyDescriptor()中属性的处理。 </li>
</ul>
<ul>
<li>修正：修复了Array.length属性的可写标志。 </li>
</ul>
<ul>
<li>修正： clearTimeout()固定返回值类型。 </li>
</ul>
<ul>
<li>修正：修复了njs_vm_external_bind() 。 </li>
</ul>
<ul>
<li>修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-0"><a href="#变化为0-2-0" class="headerlink" title="变化为0.2.0"></a>变化为0.2.0</h4><p> 发布日期：2018年4月3日 </p>
<ul>
<li>功能：通过CLI报告njs版本。 </li>
</ul>
<ul>
<li>功能：转换异常的类型的文本描述。 </li>
</ul>
<ul>
<li>功能： setTimeout()和clearTimeout()方法。 </li>
<li>功能：字节字符串为hex ， base64 ， base64url编码。 </li>
</ul>
<ul>
<li>功能： Node.js样式 Crypto方法。 </li>
</ul>
<ul>
<li>功能：HTTP和流warn()和error()方法。 </li>
</ul>
<ul>
<li>功能：HTTP subrequest()方法。 </li>
</ul>
<ul>
<li>功能：HTTP return()方法。 </li>
</ul>
<ul>
<li>修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-15"><a href="#变化0-1-15" class="headerlink" title="变化0.1.15"></a>变化0.1.15</h4><p> 发布日期：2017年11月20日 </p>
<ul>
<li>功能： Error ， EvalError ， InternalError ， RangeError ， ReferenceError ， SyntaxError ， TypeError ， URIError对象。 </li>
</ul>
<ul>
<li>功能：八进制文字支持。 </li>
</ul>
<ul>
<li>功能： Node.js样式 File system访问方法： fs.readFile() ， fs.readFileSync() ， fs.appendFile() ， fs.appendFileSync() ， fs.writeFile() ， fs.writeFileSync() 。 </li>
</ul>
<ul>
<li>功能：nginx模块在异常时打印回溯。 </li>
</ul>
<ul>
<li>修正：杂项错误已得到修复。 </li>
</ul>
<h4 id="变化0-1-14"><a href="#变化0-1-14" class="headerlink" title="变化0.1.14"></a>变化0.1.14</h4><p> 发布日期：2017年10月9日 </p>
<ul>
<li>功能：JSON对象。 </li>
</ul>
<ul>
<li>功能：交互式shell中的对象级完成。 </li>
</ul>
<ul>
<li>功能：各种配置改进。 </li>
</ul>
<ul>
<li>修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-13"><a href="#变化0-1-13" class="headerlink" title="变化0.1.13"></a>变化0.1.13</h4><p> 发布日期：2017年8月31日 </p>
<ul>
<li>功能：交互式shell中的console.log()和console.help()方法。 </li>
</ul>
<ul>
<li>功能：交互式shell在异常时打印回溯。 </li>
</ul>
<ul>
<li>功能：如果libedit可用，默认情况下为交互式shell。 </li>
</ul>
<ul>
<li>修正：在命令行模式下从stdin处理大文件。 </li>
</ul>
<ul>
<li>修正：改进了editline检测。 </li>
</ul>
<h4 id="变化0-1-12"><a href="#变化0-1-12" class="headerlink" title="变化0.1.12"></a>变化0.1.12</h4><p> 发布日期：2017年8月8日 </p>
<ul>
<li>功能：交互式shell。 </li>
</ul>
<ul>
<li>修正：在Object.isSealed() 。 </li>
</ul>
<h4 id="0-1-11的变化"><a href="#0-1-11的变化" class="headerlink" title="0.1.11的变化"></a>0.1.11的变化</h4><p> 发行日期：2017年6月27日 </p>
<ul>
<li>功能： Object.keys() ， Object.prototype.hasOwnProperty()方法。 </li>
</ul>
<ul>
<li>功能： Object.defineProperty() ， Object.defineProperties() ， Object.getOwnPropertyDescriptor()方法。 </li>
</ul>
<ul>
<li>功能： Object.getPrototypeOf() ， Object.prototype.isPrototypeOf()方法。 </li>
</ul>
<ul>
<li>功能： Object.preventExtensions() ， Object.isExtensible() ， Object.freeze() ， Object.isFrozen() ， Object.seal() ， Object.isSealed()方法。 </li>
</ul>
<ul>
<li>特征：科学记数法（ 3.35e10 ）文字支持。 </li>
</ul>
<ul>
<li>功能：十六进制（ 0x1123 ）文字支持。 </li>
</ul>
<ul>
<li>修正：处理大型数组索引。 </li>
</ul>
<ul>
<li>修正：在parseInt()和Date.parse() 。 </li>
</ul>
<h4 id="变化0-1-10"><a href="#变化0-1-10" class="headerlink" title="变化0.1.10"></a>变化0.1.10</h4><p> 发行日期：2017年4月4日 </p>
<ul>
<li>功能：嵌套函数和函数闭包。 </li>
</ul>
<ul>
<li>功能： Array.of() ， Array.prototype.fill() ， Array.prototype.find() ， Array.prototype.findIndex()方法。 </li>
</ul>
<ul>
<li>修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-9"><a href="#变化0-1-9" class="headerlink" title="变化0.1.9"></a>变化0.1.9</h4><p> 发布日期：2017年2月1日 </p>
<ul>
<li>修正：在nginx中使用njs时，未初始化全局变量。 </li>
</ul>
<h4 id="变化0-1-8"><a href="#变化0-1-8" class="headerlink" title="变化0.1.8"></a>变化0.1.8</h4><p> 发布日期：2017年1月24日 </p>
<ul>
<li>更改：强制执行strict模式，必须显式声明变量。 </li>
</ul>
<ul>
<li>功能： for和for-in循环支持变量声明。 </li>
</ul>
<ul>
<li>修正：全局和功能范围已得到修复。 </li>
</ul>
<ul>
<li>修正：现在for-in循环不会丢弃属性变量的最后一个值。 </li>
</ul>
<ul>
<li>修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-7"><a href="#变化0-1-7" class="headerlink" title="变化0.1.7"></a>变化0.1.7</h4><p> 发布日期：2016年12月27日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用js_include指令。 </li>
</ul>
<ul>
<li>特征：取幂运算符。 </li>
</ul>
<ul>
<li>修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-6"><a href="#变化0-1-6" class="headerlink" title="变化0.1.6"></a>变化0.1.6</h4><p> 发布日期：2016年12月13日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用js_set指令。 </li>
</ul>
<ul>
<li>特征：ES6 Math方法。 </li>
</ul>
<ul>
<li>修正：修复了各种错误和分段错误。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[beginners_guide-nginx中文手册]]></title>
      <url>/ngx/beginners_guide.html</url>
      <content type="html"><![CDATA[<p>beginners_guide<br><a id="more"></a></p>
<h2 id="初学者指南"><a href="#初学者指南" class="headerlink" title=" 初学者指南"></a> 初学者指南</h2><p> Starting, Stopping, and Reloading Configuration<br> Configuration File’s Structure<br> Serving Static Content<br> Setting Up a Simple Proxy Server<br> Setting Up FastCGI Proxying<br> 本指南提供了对nginx的基本介绍，并介绍了可以使用它完成的一些简单任务。 据推测，nginx已安装在阅读器的机器上。 如果不是，请参阅安装nginx页面。 本指南介绍如何启动和停止nginx，重新加载其配置，解释配置文件的结构，并介绍如何设置nginx以提供静态内容，如何将nginx配置为代理服务器，以及如何将其与一个FastCGI应用程序。 </p>
<p> nginx有一个主进程和几个工作进程。 主进程的主要目的是读取和评估配置，并维护工作进程。 工作进程会对请求进行实际处理。 nginx使用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分发请求。 工作进程数在配置文件中定义，可以针对给定配置进行修复，也可以自动调整为可用CPU内核数（请参阅worker_processes ）。 </p>
<p> nginx及其模块的工作方式在配置文件中确定。 默认情况下，配置文件名为nginx.conf并放在目录/usr/local/nginx/conf ， /etc/nginx或/usr/local/etc/nginx 。 </p>
<h4 id="启动，停止和重新加载配置"><a href="#启动，停止和重新加载配置" class="headerlink" title="启动，停止和重新加载配置"></a>启动，停止和重新加载配置</h4><p> 要启动nginx，请运行可执行文件。 启动nginx后，可以通过使用-s参数调用可执行文件来控制它。 使用以下语法： </p>
<blockquote>
<p>nginx -s <em>signal</em>  <em>信号</em>可能是以下之一： </p>
</blockquote>
<ul>
<li>stop - 快速关机 </li>
<li>quit - 正常关机 </li>
<li>reload - 重新加载配置文件 </li>
<li>reopen - 重新打开日志文件<br>例如，要在等待工作进程完成当前请求的服务时停止nginx进程，可以执行以下命令： </li>
</ul>
<blockquote>
<p>nginx -s quit<br> 此命令应在启动nginx的同一用户下执行。  在将重新加载配置的命令发送到nginx或重新启动之前，将不会应用配置文件中所做的更改。 要重新加载配置，请执行： </p>
<p>nginx -s reload  一旦主进程收到重新加载配置的信号，它将检查新配置文件的语法有效性并尝试应用其中提供的配置。 如果成功，主进程将启动新的工作进程并向旧工作进程发送消息，请求它们关闭。 否则，主进程将回滚更改并继续使用旧配置。 旧工作进程，接收命令关闭，停止接受新连接并继续为当前请求提供服务，直到所有此类请求都得到服务。 之后，旧工作进程退出。 </p>
</blockquote>
<p> 也可以借助Unix工具（如kill实用程序）将信号发送到nginx进程。 在这种情况下，信号直接发送到具有给定进程ID的进程。 默认情况下，nginx主进程的进程ID写入目录/usr/local/nginx/logs或/var/run的nginx.pid 。 例如，如果主进程ID是1628，要发送导致nginx正常关闭的QUIT信号，请执行： </p>
<blockquote>
<p>kill -s QUIT 1628  要获取所有正在运行的nginx进程的列表，可以使用ps实用程序，例如，通过以下方式： </p>
<p>ps -ax | grep nginx  有关向nginx发送信号的更多信息，请参阅控制nginx 。 </p>
</blockquote>
<h4 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h4><p> nginx由模块组成，这些模块由配置文件中指定的指令控制。 指令分为简单指令和块指令。 一个简单的指令包括由空格分隔的名称和参数，以分号（ ; ）结尾。 块指令与简单指令具有相同的结构，但它不是以分号结尾，而是以大括号（ {和} ）包围的一组附加指令结束。 如果块指令可以在大括号内包含其他指令，则称为上下文（示例： events ， http ， server和location ）。 </p>
<p> 放置在任何上下文之外的配置文件中的指令被认为是在主上下文中。 events和http指令驻留在main上下文中， server位于http ，位于server 。 </p>
<p> #符号后面的其余部分被视为评论。 </p>
<h4 id="提供静态内容"><a href="#提供静态内容" class="headerlink" title="提供静态内容"></a>提供静态内容</h4><p> 一个重要的Web服务器任务是提供文件（例如图像或静态HTML页面）。 您将实现一个示例，根据请求，将从不同的本地目录提供文件： /data/www （可能包含HTML文件）和/data/images （包含图像）。 这将需要编辑配置文件并在http块内设置具有两个位置块的服务器块。 </p>
<p> 首先，创建/data/www目录并将包含任何文本内容的index.html文件放入其中，然后创建/data/images目录并在其中放置一些图像。 </p>
<p> 接下来，打开配置文件。 默认配置文件已包含几个server块的示例，主要是注释掉的。 现在注释掉所有这些块并启动一个新的server块： </p>
<blockquote>
<p>http { server { } }  通常，配置文件可以包括由它们监听的端口和服务器名称 区分的多个server块。 一旦nginx决定哪个server处理请求，它就会根据server块内定义的location指令的参数测试请求头中指定的URI。 </p>
</blockquote>
<p> 将以下location块添加到server块： </p>
<blockquote>
<p>location / { root /data/www; }  此location块指定与请求中的URI进行比较的“ / ”前缀。 对于匹配请求，URI将添加到根指令中指定的路径，即/data/www ，以形成本地文件系统上所请求文件的路径。 如果存在多个匹配的location块，则nginx选择具有最长前缀的location块。 上面的location块提供长度为1的最短前缀，因此仅当所有其他location块无法提供匹配时，才会使用此块。 </p>
</blockquote>
<p> 接下来，添加第二个location块： </p>
<blockquote>
<p>location /images/ { root /data; }  它将匹配以/images/开头的请求（ location /也匹配此类请求，但前缀较短）。 </p>
</blockquote>
<p> 生成的server块配置应如下所示： </p>
<blockquote>
<p>server { location / { root /data/www; } location /images/ { root /data; } }  这已经是服务器的工作配置，它可以侦听标准端口80，并且可以在本地计算机上访问<a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 。 响应具有以/images/开头的URI的请求，服务器将从/data/images目录发送文件。 例如，响应<a href="http://localhost/images/example.png请求，nginx将发送/data/images/example.png文件。" target="_blank" rel="noopener">http://localhost/images/example.png请求，nginx将发送/data/images/example.png文件。</a> 如果此类文件不存在，nginx将发送指示404错误的响应。 URI不以/images/开头的请求将映射到/data/www目录。 例如，响应<a href="http://localhost/some/example.html请求，nginx将发送/data/www/some/example.html文件。" target="_blank" rel="noopener">http://localhost/some/example.html请求，nginx将发送/data/www/some/example.html文件。</a> </p>
</blockquote>
<p> 要应用新配置，请启动nginx（如果尚未启动）或通过执行以下命令将reload信号发送到nginx的主进程： </p>
<blockquote>
<p>nginx -s reload<br> 如果某些内容无法按预期工作，您可以尝试在目录/usr/local/nginx/logs或/var/log/nginx中的access.log和error.log文件中找出原因。 ####  设置简单的代理服务器</p>
</blockquote>
<p> nginx的一个常见用途是将其设置为代理服务器，这意味着服务器接收请求，将它们传递给代理服务器，从中检索响应，然后将它们发送给客户端。 </p>
<p> 我们将配置一个基本代理服务器，它使用来自本地目录的文件处理图像请求，并将所有其他请求发送到代理服务器。 在此示例中，将在单个nginx实例上定义两个服务器。 </p>
<p> 首先，通过向nginx的配置文件添加一个以上的server块来定义代理服务器，其中包含以下内容： </p>
<blockquote>
<p>server { listen 8080; root /data/up1; location / { } }  这将是一个侦听端口8080的简单服务器（之前，自使用标准端口80以来尚未指定listen指令）并将所有请求映射到本地文件系统上的/data/up1目录。 创建此目录并将index.html文件放入其中。 请注意， root指令放在server上下文中。 当选择用于提供请求的location块不包括自己的root指令时，使用这样的root指令。 </p>
</blockquote>
<p> 接下来，使用上一节中的服务器配置并对其进行修改以使其成为代理服务器配置。 在第一个location块中，将proxy_pass指令与参数中指定的代理服务器的协议，名称和端口放在一起（在我们的示例中，它是<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ）： </p>
<blockquote>
<p>server { location / { proxy_pass <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>; } location /images/ { root /data; } }  我们将修改第二个location块，该块当前将带有/images/前缀的请求映射到/data/images目录下的文件，以使其与具有典型文件扩展名的图像请求相匹配。 修改后的location块如下所示： </p>
<p>location ~ .(gif|jpg|png)$ { root /data/images; }  该参数是一个正则表达式，匹配以.gif ， .jpg或.png结尾的所有URI。 正则表达式应该以~ 。 相应的请求将映射到/data/images目录。 </p>
</blockquote>
<p> 当nginx选择一个location块来提供请求时，它首先检查指定前缀的位置指令，记住具有最长前缀的location ，然后检查正则表达式。 如果与正则表达式匹配，则nginx选择此location ，否则，它会选择之前记住的那个。 </p>
<p> 生成的代理服务器配置如下所示： </p>
<blockquote>
<p>server { location / { proxy_pass <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>; } location ~ .(gif|jpg|png)$ { root /data/images; } }  此服务器将过滤以.gif ， .jpg或.png结尾的请求，并将它们映射到/data/images目录（通过将URI添加到root指令的参数），并将所有其他请求传递给上面配置的代理服务器。 </p>
</blockquote>
<p> 要应用新配置，请将reload信号发送到nginx，如前面部分所述。 </p>
<p> 可以使用更多指令来进一步配置代理连接。 </p>
<h4 id="设置FastCGI代理"><a href="#设置FastCGI代理" class="headerlink" title="设置FastCGI代理"></a>设置FastCGI代理</h4><p> nginx可用于将请求路由到FastCGI服务器，这些服务器运行使用各种框架和编程语言（如PHP）构建的应用程序。 </p>
<p> 使用FastCGI服务器的最基本的nginx配置包括使用fastcgi_pass指令而不是proxy_pass指令，以及fastcgi_param指令来设置传递给FastCGI服务器的参数。 假设可以在localhost:9000上访问FastCGI服务器。 以上一节中的代理配置为基础，将proxy_pass指令替换为fastcgi_pass指令，并将参数更改为localhost:9000 。 在PHP中， SCRIPT_FILENAME参数用于确定脚本名称， QUERY_STRING参数用于传递请求参数。 结果配置为： </p>
<blockquote>
<p>server { location / { fastcgi_pass localhost:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; } location ~ .(gif|jpg|png)$ { root /data/images; } }  这将设置一个服务器，该服务器将除静态图像请求之外的所有请求路由到通过FastCGI协议在localhost:9000上运行的代理服务器。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm学习]]></title>
      <url>/java/JVM%E5%AD%A6%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<p>JVM Java Virtual Machine (java虚拟机)</p>
<a id="more"></a>
<h1 id="JDK8-以后-Hotspot-JRockit-优秀特性"><a href="#JDK8-以后-Hotspot-JRockit-优秀特性" class="headerlink" title="JDK8 以后 Hotspot+JRockit 优秀特性"></a>JDK8 以后 Hotspot+JRockit 优秀特性</h1>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[guava教程]]></title>
      <url>/java/guava%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>guava教程</p>
<blockquote>
<p>guava谷歌出品,高效工具类<br>目标：节约时间，资源，提高生产力  Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<br>集合 [collections]<br>缓存 [caching]<br>原生类型支持 [primitives support]<br>并发库 [concurrency libraries]<br>通用注解 [common annotations]<br>字符串处理 [string processing]<br>I/O 等等<br><a id="more"></a></p>
</blockquote>
<h1 id="集合的创建-可变，不可变"><a href="#集合的创建-可变，不可变" class="headerlink" title="集合的创建, 可变，不可变"></a>集合的创建, 可变，不可变</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 普通Collection的创建</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">// 不变Collection的创建</span><br><span class="line">ImmutableList&lt;String&gt; iList = ImmutableList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(&quot;e1&quot;, &quot;e2&quot;);</span><br><span class="line">ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;);</span><br><span class="line"></span><br><span class="line">immutable(不可变)对象</span><br><span class="line">1.在多线程操作下，是线程安全的。</span><br><span class="line">2.所有不可变集合会比可变集合更有效的利用资源。</span><br><span class="line">3.中途不可改变</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList(&quot;Richard&quot;, &quot;Amy&quot;, &quot;Lily&quot;, &quot;Sarah&quot;);</span><br><span class="line">List&lt;Integer&gt; numbers = Lists.newArrayList(11, 78, 89, 45, 30);</span><br><span class="line">//创建加初始化</span><br></pre></td></tr></table></figure>
<h2 id="特殊的数据类型"><a href="#特殊的数据类型" class="headerlink" title="特殊的数据类型"></a>特殊的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单</span><br><span class="line">创建方式:  Multiset&lt;String&gt; set = HashMultiset.create();</span><br><span class="line">Multimap: key-value  key可以重复  </span><br><span class="line">创建方式: Multimap&lt;String, String&gt; teachers = ArrayListMultimap.create();</span><br><span class="line">BiMap: 双向Map(Bidirectional Map) 键与值都不能重复</span><br><span class="line">创建方式:  BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">Table: 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  //和sql中的联合主键有点像</span><br><span class="line">创建方式: Table&lt;String, String, Integer&gt; tables = HashBasedTable.create();</span><br></pre></td></tr></table></figure>
<h1 id="集合转字符串"><a href="#集合转字符串" class="headerlink" title="集合转字符串"></a>集合转字符串</h1><h2 id="list-转字符串"><a href="#list-转字符串" class="headerlink" title="list 转字符串"></a>list 转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for(int i=0; i&lt;list.size(); i++)&#123;</span><br><span class="line">	str = str + &quot;-&quot; +list.get(i);</span><br><span class="line">&#125;</span><br><span class="line">//str 为-aa-bb-cc</span><br><span class="line">//use guava</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String result = Joiner.on(&quot;-&quot;).join(list);</span><br><span class="line">//result为  aa-bb-cc</span><br></pre></td></tr></table></figure>
<h2 id="map转字符串"><a href="#map转字符串" class="headerlink" title="map转字符串"></a>map转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(&quot;xiaoming&quot;, 12);</span><br><span class="line">map.put(&quot;xiaohong&quot;,13);</span><br><span class="line">String result = Joiner.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).join(map);</span><br><span class="line">// result为 xiaoming=12,xiaohong=13</span><br></pre></td></tr></table></figure>
<h1 id="字符串转集合"><a href="#字符串转集合" class="headerlink" title="字符串转集合"></a>字符串转集合</h1><h2 id="字符串转list"><a href="#字符串转list" class="headerlink" title="字符串转list"></a>字符串转list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">String a = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">String[] strs = a.split(&quot;-&quot;);</span><br><span class="line">for(int i=0; i&lt;strs.length; i++)&#123;</span><br><span class="line">	list.add(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//use guava</span><br><span class="line">String str = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">List&lt;String&gt; list = Splitter.on(&quot;-&quot;).splitToList(str);</span><br><span class="line">//list为  [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h2 id="字符串转map"><a href="#字符串转map" class="headerlink" title="字符串转map"></a>字符串转map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;xiaoming=11,xiaohong=23&quot;;</span><br><span class="line">Map&lt;String,String&gt; map = Splitter.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).split(str);</span><br></pre></td></tr></table></figure>
<h1 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;aa.dd,,ff,,.&quot;;</span><br><span class="line">List&lt;String&gt; result = Splitter.onPattern(&quot;[.|,]&quot;).omitEmptyStrings().splitToList(input);</span><br></pre></td></tr></table></figure>
<h1 id="差集合集并集"><a href="#差集合集并集" class="headerlink" title="差集合集并集"></a>差集合集并集</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashSet setA = newHashSet(1, 2, 3, 4, 5);  </span><br><span class="line">HashSet setB = newHashSet(4, 5, 6, 7, 8);  </span><br><span class="line">   </span><br><span class="line">SetView union = Sets.union(setA, setB);  </span><br><span class="line">System.out.println(&quot;union:&quot;);  </span><br><span class="line">for (Integer integer : union)  </span><br><span class="line">    System.out.println(integer);           //union:12345867</span><br><span class="line">   </span><br><span class="line">SetView difference = Sets.difference(setA, setB);  </span><br><span class="line">System.out.println(&quot;difference:&quot;);  </span><br><span class="line">for (Integer integer : difference)  </span><br><span class="line">    System.out.println(integer);        //difference:123</span><br><span class="line">   </span><br><span class="line">SetView intersection = Sets.intersection(setA, setB);  </span><br><span class="line">System.out.println(&quot;intersection:&quot;);  </span><br><span class="line">for (Integer integer : intersection)  </span><br><span class="line">    System.out.println(integer);  //intersection:45</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapDifference differenceMap = Maps.difference(mapA, mapB);  </span><br><span class="line">differenceMap.areEqual();  </span><br><span class="line">Map entriesDiffering = differenceMap.entriesDiffering();  </span><br><span class="line">Map entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();  </span><br><span class="line">Map entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();  </span><br><span class="line">Map entriesInCommon = differenceMap.entriesInCommon();</span><br></pre></td></tr></table></figure>
<h1 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">       CharSource charSource = Resources.asByteSource(url).asCharSource(StandardCharsets.UTF_8);</span><br><span class="line">       charSource.readLines().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> guava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot常用的注解]]></title>
      <url>/spring-boot/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot 常用的注解<br><a id="more"></a></p>
<blockquote>
<p>@PropertySource(value = “classpath:test.properties”) 加载配置文件<br>@ConfigurationProperties(prefix=”spring”) 提取前缀<br>@ConditionOnProperty 根据配置文件加载class</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot @Import @ImportResource 注解]]></title>
      <url>/spring-boot/springboot%20@Import%20@ImportResource%20%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot @Import @ImportResource 注解<br><a id="more"></a></p>
<h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><blockquote>
<p>@Import注解在4.2之前只支持导入配置类；在4.2以及之后，@Import注解支持导入普通java类，并将其声明成一个bean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DemoService &#123;  </span><br><span class="line">    public void doSomething()&#123;  </span><br><span class="line">        System.out.println(&quot;everything is all fine&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@Configuration  </span><br><span class="line">@Import(DemoService.class)  </span><br><span class="line">public class DemoConfig &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AnnotationConfigApplicationContext context =  </span><br><span class="line">                new AnnotationConfigApplicationContext(&quot;com.example&quot;);  </span><br><span class="line">        DemoService ds = context.getBean(DemoService.class);  </span><br><span class="line">        ds.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h1><h2 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Controller</span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;url&#125;&quot;)</span><br><span class="line">	private String url;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	public String hello() &#123;</span><br><span class="line">		System.err.println(url);</span><br><span class="line">		return &quot;hello&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cons-java"><a href="#cons-java" class="headerlink" title="cons.java"></a>cons.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(&quot;classpath:test.xml&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class cons &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="test-xml"><a href="#test-xml" class="headerlink" title="test.xml"></a>test.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:/test.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="test-properties"><a href="#test-properties" class="headerlink" title="test.properties"></a>test.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">password=root</span><br><span class="line">url=127.0.0.1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单服务器开发]]></title>
      <url>/c/%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<p> 简单服务器开发</p>
 <a id="more"></a>
<h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	 struct  sockaddr_in  server,client;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 int cfd;</span><br><span class="line">	 int sfd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">     server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 int ret=bind(sfd,(struct sockaddr *)&amp;server,sizeof(server));</span><br><span class="line">	 if(ret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;bind error\n&quot;);</span><br><span class="line">	 	return -1; </span><br><span class="line">	 &#125;</span><br><span class="line">	 int lret=listen(sfd,10);</span><br><span class="line">	 if(lret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;listen error\n&quot;);</span><br><span class="line">	 	return -1;</span><br><span class="line">	 &#125;</span><br><span class="line">	 int len=sizeof(client);</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	cfd=accept(sfd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">	 	char str[]=&quot;hello world\n&quot;;</span><br><span class="line">	 	write(cfd,str,sizeof(str));</span><br><span class="line">	 	while(1)&#123;</span><br><span class="line">	 		read(cfd,buf,1000);</span><br><span class="line">		    printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	 		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	 	</span><br><span class="line">	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	 close(cfd);</span><br><span class="line">	 close(sfd);</span><br><span class="line">	 printf(&quot;over\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main()&#123;</span><br><span class="line">	 struct sockaddr_in server;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 char buff[1000];</span><br><span class="line">	 int fd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">	 server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 connect(fd,(struct sockaddr*)&amp;server,sizeof(server));</span><br><span class="line">	 read(fd,buf,1000);</span><br><span class="line">	 printf(&quot;%s\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	 </span><br><span class="line">	     scanf(&quot;%s&quot;,buff);</span><br><span class="line">        </span><br><span class="line">	     write(fd,buff,sizeof(buff));</span><br><span class="line">	     </span><br><span class="line">	   	</span><br><span class="line">	 &#125; </span><br><span class="line">	</span><br><span class="line">	 close(fd);	  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_image_filter_module应用]]></title>
      <url>/nginx/ngx_http_image_filter_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p> ngx_http_image_filter_module 缩略图应用</p>
 <a id="more"></a>
<h1 id="安装yum-install-y-gd-devel"><a href="#安装yum-install-y-gd-devel" class="headerlink" title="安装yum install -y gd-devel"></a>安装yum install -y gd-devel</h1><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-hhtp_image_filter_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	image_filter off;</span><br><span class="line">image_filter test;</span><br><span class="line">image_filter size;</span><br><span class="line">image_filter rotate 90 | 180 | 270;</span><br><span class="line">image_filter resize width height;</span><br><span class="line">image_filter crop width height;</span><br><span class="line">Default:	</span><br><span class="line">image_filter off;</span><br><span class="line">Context:	location</span><br></pre></td></tr></table></figure>
<h1 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~* /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ &#123;            </span><br><span class="line">    set $h $2;</span><br><span class="line">    set $w $3;</span><br><span class="line">    if ($h = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($w = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    #根据给定的长宽生成缩略图</span><br><span class="line">    image_filter resize $h $w;</span><br><span class="line">    #原图最大2M，要裁剪的图片超过2M返回415错误，需要调节参数image_filter_buffer </span><br><span class="line">    image_filter_buffer 2M;                          </span><br><span class="line">     </span><br><span class="line">    #error_page  415              /img/notfound.jpg;</span><br><span class="line">    try_files /img/$1.$4  /img/notfound.jpg;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问缩略图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003_90x90.jpg</span><br><span class="line"></span><br><span class="line">访问原图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003.jpg</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_addition_module应用]]></title>
      <url>/nginx/ngx_http_addition_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>ngx_http_addition_module在响应之前或者之后追加文本内容，比如js,html</p>
<a id="more"></a>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">cd nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_addition_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><blockquote>
<p>Syntax:    add_before_body uri;<br>Default:    —<br>Context:    http, server, location</p>
<p>Syntax:    add_after_body uri;<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<h1 id="nginx-conf-配置"><a href="#nginx-conf-配置" class="headerlink" title="nginx.conf 配置"></a>nginx.conf 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_before_body /head.html;</span><br><span class="line">    add_after_body  /foot.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim head.html</span><br><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim foot.html</span><br><span class="line"></span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用后</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot统一异常处理]]></title>
      <url>/java/springboot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
      <content type="html"><![CDATA[<p>springboot 统一异常处理</p>
<a id="more"></a>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">@EnableAutoConfiguration  //1</span><br><span class="line">@ComponentScan         //2 </span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	String home() &#123;</span><br><span class="line">		System.err.println(1 / 0);</span><br><span class="line">		return &quot;Hello World!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p> 标注 1,2 可以换成@SpringBootApplication<br> @SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScan</p>
</blockquote>
</blockquote>
<h1 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ex &#123;</span><br><span class="line">	@ExceptionHandler(RuntimeException.class)</span><br><span class="line">	@ResponseBody // 拦截返回是 json返回结果</span><br><span class="line">	public Map&lt;String, Object&gt; exceptionHandler() &#123;</span><br><span class="line">		Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		result.put(&quot;code&quot;, &quot;500&quot;);</span><br><span class="line">		result.put(&quot;msg&quot;, &quot;亲,系统错误,请稍后重试....&quot;);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"><a href="#ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常" class="headerlink" title="@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"></a>@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.cmc.schedule.handler;</span><br><span class="line"></span><br><span class="line">import com.gionee.base.entity.JsonResult;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.ConversionNotSupportedException;</span><br><span class="line">import org.springframework.beans.TypeMismatchException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotWritableException;</span><br><span class="line">import org.springframework.web.HttpMediaTypeNotAcceptableException;</span><br><span class="line">import org.springframework.web.HttpRequestMethodNotSupportedException;</span><br><span class="line">import org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常拦截处理器</span><br><span class="line"> *</span><br><span class="line"> * @author chenmc</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice</span><br><span class="line">@ResponseBody</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String logExceptionFormat = &quot;Capture Exception By GlobalExceptionHandler: Code: %s Detail: %s&quot;;</span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    //运行时异常  </span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    public String runtimeExceptionHandler(RuntimeException ex) &#123;</span><br><span class="line">        return resultFormat(1, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空指针异常  </span><br><span class="line">    @ExceptionHandler(NullPointerException.class)</span><br><span class="line">    public String nullPointerExceptionHandler(NullPointerException ex) &#123;</span><br><span class="line">        return resultFormat(2, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换异常  </span><br><span class="line">    @ExceptionHandler(ClassCastException.class)</span><br><span class="line">    public String classCastExceptionHandler(ClassCastException ex) &#123;</span><br><span class="line">        return resultFormat(3, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //IO异常  </span><br><span class="line">    @ExceptionHandler(IOException.class)</span><br><span class="line">    public String iOExceptionHandler(IOException ex) &#123;</span><br><span class="line">        return resultFormat(4, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //未知方法异常  </span><br><span class="line">    @ExceptionHandler(NoSuchMethodException.class)</span><br><span class="line">    public String noSuchMethodExceptionHandler(NoSuchMethodException ex) &#123;</span><br><span class="line">        return resultFormat(5, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组越界异常  </span><br><span class="line">    @ExceptionHandler(IndexOutOfBoundsException.class)</span><br><span class="line">    public String indexOutOfBoundsExceptionHandler(IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        return resultFormat(6, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMessageNotReadableException.class&#125;)</span><br><span class="line">    public String requestNotReadable(HttpMessageNotReadableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..requestNotReadable&quot;);</span><br><span class="line">        return resultFormat(7, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;TypeMismatchException.class&#125;)</span><br><span class="line">    public String requestTypeMismatch(TypeMismatchException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..TypeMismatchException&quot;);</span><br><span class="line">        return resultFormat(8, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;MissingServletRequestParameterException.class&#125;)</span><br><span class="line">    public String requestMissingServletRequest(MissingServletRequestParameterException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..MissingServletRequest&quot;);</span><br><span class="line">        return resultFormat(9, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //405错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpRequestMethodNotSupportedException.class&#125;)</span><br><span class="line">    public String request405(HttpRequestMethodNotSupportedException ex) &#123;</span><br><span class="line">        return resultFormat(10, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //406错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMediaTypeNotAcceptableException.class&#125;)</span><br><span class="line">    public String request406(HttpMediaTypeNotAcceptableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;406...&quot;);</span><br><span class="line">        return resultFormat(11, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //500错误  </span><br><span class="line">    @ExceptionHandler(&#123;ConversionNotSupportedException.class, HttpMessageNotWritableException.class&#125;)</span><br><span class="line">    public String server500(RuntimeException ex) &#123;</span><br><span class="line">        System.out.println(&quot;500...&quot;);</span><br><span class="line">        return resultFormat(12, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈溢出</span><br><span class="line">    @ExceptionHandler(&#123;StackOverflowError.class&#125;)</span><br><span class="line">    public String requestStackOverflow(StackOverflowError ex) &#123;</span><br><span class="line">        return resultFormat(13, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //其他错误</span><br><span class="line">    @ExceptionHandler(&#123;Exception.class&#125;)</span><br><span class="line">    public String exception(Exception ex) &#123;</span><br><span class="line">        return resultFormat(14, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T extends Throwable&gt; String resultFormat(Integer code, T ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        log.error(String.format(logExceptionFormat, code, ex.getMessage()));</span><br><span class="line">        return JsonResult.failed(code, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java动态代理实现连接池]]></title>
      <url>/java/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</url>
      <content type="html"><![CDATA[<p> java动态代理实现连接池</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">import sun.font.CreatedFontTracker;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author michael</span><br><span class="line"> * Description: </span><br><span class="line"> *代理：如果对某个接口中的某个指定的方法的功能进行扩展，而不想实现接口里所有方法，可以使用（动态代理）代理模式</span><br><span class="line"> *java中代理模式:静态/动态/cglib（Spring）</span><br><span class="line"> *使用动态代理，可以检测接口中方法的执行</span><br><span class="line"> *</span><br><span class="line"> *Proxy</span><br><span class="line"> *static Object newProxyInstance(</span><br><span class="line"> *ClassLoader loader,  定义代理类的类加载器</span><br><span class="line"> *Class&lt;?&gt;[] interfaces,   代理类要实现的接口列表</span><br><span class="line"> *InvocationHandler h)  指派方法调用的调用处理程序 </span><br><span class="line"> * 2017年5月1日</span><br><span class="line"> */</span><br><span class="line">public class Pool &#123;</span><br><span class="line">	private int init_count = 3;</span><br><span class="line">	private int max_count = 6;</span><br><span class="line">	private int current_count = 0;</span><br><span class="line">	private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	//1.构造函数，初始化连接放入连接池</span><br><span class="line">	public Pool()&#123;</span><br><span class="line">		for (int i = 0; i &lt; init_count; i++) &#123;</span><br><span class="line">			current_count++;</span><br><span class="line">			Connection conn = createConnection();</span><br><span class="line">			pool.add(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//2.创建一个新的连接方法</span><br><span class="line">	private Connection createConnection()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">			final Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">			//对con创建代理对象</span><br><span class="line">			Connection proxy = (Connection)Proxy.newProxyInstance(</span><br><span class="line">					con.getClass().getClassLoader(), </span><br><span class="line">					/*con.getClass().getInterfaces(),*/  //当目标对象是一个具体的类时</span><br><span class="line">					new Class[]&#123;Connection.class&#125;,   //目标对象实现的接口</span><br><span class="line">					new InvocationHandler() &#123;</span><br><span class="line">						</span><br><span class="line">						@Override</span><br><span class="line">						public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">								throws Throwable &#123;</span><br><span class="line">							//方法返回值</span><br><span class="line">							Object result = null;</span><br><span class="line">							//当前执行的方法名</span><br><span class="line">							String methodName = method.getName();</span><br><span class="line">							//判断是否执行了close方法的时候，把连接放到连接池</span><br><span class="line">							if(&quot;close&quot;.equals(methodName))&#123;</span><br><span class="line">								System.out.println(&quot;begin:当前执行了close方法&quot;);</span><br><span class="line">								//连接放入连接池</span><br><span class="line">								pool.addLast(con);</span><br><span class="line">								System.out.println(&quot;end:当前连接已经放入连接池&quot;);</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">							//调用目标对象方法</span><br><span class="line">							method.invoke(con, args);</span><br><span class="line">							&#125;</span><br><span class="line">							return result;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					);</span><br><span class="line">			return proxy;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			throw new RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//3.获取连接</span><br><span class="line">	public  Connection getConnection()&#123;</span><br><span class="line">		//3.1判断连接池中是否有链接，如果有连接，则直接用</span><br><span class="line">		if(pool.size()&gt;0)&#123;</span><br><span class="line">			return pool.removeFirst();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//3.2连接池中没有连接，判断，如果没有达到最大连接数，创建</span><br><span class="line">		if(current_count&lt;max_count)&#123;</span><br><span class="line">			//记录当前使用的连接数</span><br><span class="line">			current_count++;</span><br><span class="line">			return createConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		//3.3如果当前已经达到最大连接数，抛出异常</span><br><span class="line">		throw new RuntimeException(&quot;当前已经达到最大连接数！&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//4.释放连接</span><br><span class="line">	public void realeaseConnection(Connection con)&#123;</span><br><span class="line">		//4.1 判断：池的数目如果小于初始化练级，就放入池中</span><br><span class="line">		if(pool.size()&lt;init_count)&#123;</span><br><span class="line">			pool.addLast(con);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			//关闭</span><br><span class="line">			try &#123;</span><br><span class="line">				current_count-- ;</span><br><span class="line">				con.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">		Pool pool = new Pool();</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">		</span><br><span class="line">		//使用连接</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">	</span><br><span class="line">		Connection con1 = pool.getConnection();</span><br><span class="line">		con1.close();//如果没用动态代理，连接就关闭了</span><br><span class="line">		//希望：当关闭连接的时候，要把连接放入连接池。（当调用Connetion接口的close方法时候，希望触发pool.addLast(con)操作）</span><br><span class="line">		//解决1:实现Connection接口，重写close方法（方法太多，不太现实）</span><br><span class="line">		//解决2：</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		System.out.println(&quot;连接池&quot;+pool.pool.size());</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM中GC Minor-GC Major-GC Full-GC区别]]></title>
      <url>/java/JVM%E4%B8%ADGC%20Minor-GC%20Major-GC%20Full-GC%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p>JVM中GC Minor-GC Major-GC Full-GC区别</p>
<a id="more"></a>
<p>#JVM 内存分布</p>
<p>JVM堆包含 ，Eden,Survivor,Old 区</p>
<h1 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor-GC"></a>Minor-GC</h1><p>在Young space(Eden,survivor 区) 中的垃圾回收称为Minor-GC</p>
<blockquote>
<blockquote>
<p>不能为新对象分配空间的时候，Eden区满了，分配空间越快，Minor-GC越频繁<br>当内存池慢了后, 它的完整的内容会被复制出去，指针可以从0开始重新跟踪空闲内存。所以取代传统的标记-交换-压缩（Mark, Sweep , Compact）, Eden区和Survivor区使用标记-复制方式（Mark , Copy）. 因此在Eden区和Survivor区无内存碎片。写指针总是指向内存池的顶部。</p>
<p>在Minor GC时, 年老代（Tenured generation）可以被忽略. 年老代对年轻代的引用被认为是实际的GC根root。 在标记阶段年轻代对年老代的引用可以被简单的忽略。<br>出于常理, 所有的Minor GC都会触发stop-the-world暂停, 它意味着会暂停应用的所有线程. 对于大部分应用而言，暂停的延迟可以忽略不计。这是因为Eden中大部分的对象都可以垃圾回收掉，而不会被复制到Survivor/Old区。但如果相反，大部分的新对象不能被回收， Minor GC暂停会占用更多的时间。</p>
</blockquote>
</blockquote>
<h1 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major-GC"></a>Major-GC</h1><h2 id="Major-GC-清理年老区（old-space）"><a href="#Major-GC-清理年老区（old-space）" class="headerlink" title="Major GC 清理年老区（old space）"></a>Major GC 清理年老区（old space）</h2><h1 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full-GC"></a>Full-GC</h1><h2 id="清理年轻代，老年代"><a href="#清理年轻代，老年代" class="headerlink" title="清理年轻代，老年代"></a>清理年轻代，老年代</h2>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA自带的加密算法-MD5\SHA1\BASE64]]></title>
      <url>/java/BASE64.html</url>
      <content type="html"><![CDATA[<p>JAVA自带的加密算法-MD5\SHA1\BASE64<br>引入 commons-codec.jar<br><a id="more"></a></p>
<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.md5Hex(str);</span><br></pre></td></tr></table></figure>
<h1 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.shaHex(str);</span><br></pre></td></tr></table></figure>
<h1 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h1><blockquote>
<blockquote>
<p>加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str= &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">byte[] b = Base64.encodeBase64(str.getBytes(), true);</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
<p>解密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String  str = &quot;123&quot;;</span><br><span class="line">byte[] b = Base64.decodeBase64(str.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中常见的坑]]></title>
      <url>/java/java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91.html</url>
      <content type="html"><![CDATA[<p>Java中常见的坑</p>
<h1 id="System-out-println-Object-toString"><a href="#System-out-println-Object-toString" class="headerlink" title="System.out.println( Object.toString )"></a>System.out.println( Object.toString )</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123; “Hello”, “World” &#125;;</span><br><span class="line">System.out.println(words);</span><br><span class="line"></span><br><span class="line">output: [Ljava.lang.String;@45ee12b7</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>改造</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(words));</span><br><span class="line"></span><br><span class="line">output: [Hello, World]</span><br></pre></td></tr></table></figure>
<h1 id="list-toArray-T-array"><a href="#list-toArray-T-array" class="headerlink" title="list.toArray(T[] array)"></a>list.toArray(T[] array)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);</span><br><span class="line">  list.add(&quot;222&quot;); </span><br><span class="line">  list.add(&quot;111&quot;); </span><br><span class="line">  String[] array = new String[list.size()];  #list.size()</span><br><span class="line">  array = list.toArray(array);</span><br></pre></td></tr></table></figure>
<h1 id="不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"><a href="#不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。" class="headerlink" title="不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"></a>不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator(); </span><br><span class="line">  while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">#加锁</span><br><span class="line"></span><br><span class="line">Map m = Collections.synchronizedMap(new HashMap());</span><br><span class="line">synchronized(m) &#123;</span><br><span class="line">     while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> 创建线程安全集合</span><br><span class="line"> Collection c=Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"> List list=Collections.synchronizedList(new ArrayList());</span><br><span class="line"> Set s=Collections.synchronizedSet(new HashSet());</span><br><span class="line"> Map m=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Three.js展示全景图]]></title>
      <url>/%E5%9F%BA%E4%BA%8EThree.js%E5%B1%95%E7%A4%BA%E5%85%A8%E6%99%AF%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<p>基于Three.js展示全景图</p>
<a id="more"></a>
<h1 id="初始化插件-创建PhotoSphereViewer对象"><a href="#初始化插件-创建PhotoSphereViewer对象" class="headerlink" title="初始化插件,创建PhotoSphereViewer对象"></a>初始化插件,创建PhotoSphereViewer对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var PSV = new PhotoSphereViewer(&#123;</span><br><span class="line">        // 全景图的完整路径</span><br><span class="line">        panorama: img, </span><br><span class="line">        // 放全景图的元素</span><br><span class="line">        container: div,</span><br><span class="line">        // 可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。（设置为false禁用它）</span><br><span class="line">        time_anim: false,</span><br><span class="line">		tilt_up_max: 0,</span><br><span class="line">		tilt_down_max: 0,</span><br><span class="line"></span><br><span class="line">        // 可选值，默认为false。显示导航条。</span><br><span class="line">        navbar: true,</span><br><span class="line"></span><br><span class="line">        // 可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">        size: &#123;</span><br><span class="line">            width: &apos;100%&apos;,</span><br><span class="line">            height: canvasHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="配置参数备注"><a href="#配置参数备注" class="headerlink" title="配置参数备注"></a>配置参数备注</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">panorama：必填参数，全景图的路径。</span><br><span class="line">container：必填参数，放置全景图的div元素。</span><br><span class="line">autoload：可选，默认值为true，true为自动调用全景图，false为在后面加载全景图(通过.load()方法)。</span><br><span class="line">us empdata：可选，默认值为true，如果Photo Sphere Viewer必须读入XMP数据则为true。</span><br><span class="line">default_position：可选，默认值为&#123;&#125;，定义默认的位置，及用户看见的第一个点，例如：&#123;long: Math.PI, lat: Math.PI/2&#125;。</span><br><span class="line">min_fov：可选，默认值为30，观察的最小区域，单位degrees，在1-179之间。</span><br><span class="line">max_fov：可选，默认值为90，观察的最大区域，单位degrees，在1-179之间。</span><br><span class="line">allow_user_interactions：可选，默认值为true，设置为false则禁止用户和全景图交互(导航条不可用)。</span><br><span class="line">tilt_up_max：可选，默认值为Math.PI/2，向上倾斜的最大角度，单位radians。</span><br><span class="line">tilt_down_max：可选，默认值为Math.PI/2，向下倾斜的最大角度，单位radians。</span><br><span class="line">zoom_level：可选，默认值为0，默认的缩放级别，值在0-100之间。</span><br><span class="line">long_offset：可选，默认值为PI/360，mouse/touch移动时每像素经过的经度值。</span><br><span class="line">lat_offset：可选，默认值为PI/180，mouse/touch移动时每像素经过的纬度值。</span><br><span class="line">time_anim：可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。(设置为false禁用它)</span><br><span class="line">theta_offset：过时的选项，可选，默认值为1440，自动动画时水平方向的速度。</span><br><span class="line">anim_speed：可选，默认值为2rpm，动画的速度，每秒/分钟多少radians/degrees/revolutions。</span><br><span class="line">navbar：可选值，默认为false。显示导航条。</span><br><span class="line">navbar_style：可选值，默认为&#123;&#125;。导航条的自定义样式。下面是可用的样式列表：</span><br><span class="line">backgroundColor：导航条的背景颜色，默认值为rgba(61, 61, 61, 0.5)。</span><br><span class="line">buttonsColor：按钮的前景颜色，默认值为transparent。</span><br><span class="line">activeButtonsBackgroundColor：按钮激活状态的背景颜色，默认值为rgba(255, 255, 255, 0.1)。</span><br><span class="line">buttonsHeight：按钮的高度，单位像素，默认值为20。</span><br><span class="line">autorotateThickness：autorotate图标的厚度，单位像素，默认值为1。</span><br><span class="line">zoomRangeWidth：缩放的范围，单位显示，默认值50。</span><br><span class="line">zoomRangeThickness：缩放的范围的厚度，单位像素，默认值1。</span><br><span class="line">zoomRangeDisk：缩放范围的圆盘直径，单位像素，默认值为7。</span><br><span class="line">fullscreenRatio：全屏图标的比例，默认值为3/4。</span><br><span class="line">fullscreenThickness：全屏图标的厚度，单位像素，默认值为2。</span><br><span class="line">loading_msg：可选，默认值为Loading…，图片加载时的提示文字。</span><br><span class="line">loading_img：可选，默认值为null，在加载时显示的图片的路径。</span><br><span class="line">size：可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">onready：可选值，默认值为null。当全景图准备就绪并且第一张图片显示时的回调函数。</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Three.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Three.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot自义定错误返回页面和json格式]]></title>
      <url>/spring-boot%E8%87%AA%E4%B9%89%E5%AE%9A%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E5%92%8Cjson%E6%A0%BC%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<p>springboot发生错误时，在浏览器端访问和用测试接口的软件看到的返回页面是不一样的。</p>
<blockquote>
<p>浏览器端  返回 Whitelabel Error Page页面<br>测试接口的软件返回一个json 字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;timestamp&quot;: 1492063521109,</span><br><span class="line">&quot;status&quot;: 404,</span><br><span class="line">&quot;error&quot;: &quot;Not Found&quot;,</span><br><span class="line">&quot;message&quot;: &quot;No message available&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/test/auth&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h1 id="spring根据请求的-produces返回不同值"><a href="#spring根据请求的-produces返回不同值" class="headerlink" title="spring根据请求的 produces返回不同值"></a>spring根据请求的 produces返回不同值</h1><blockquote>
<p>BasicErrorController.java源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(produces = &quot;text/html&quot;) #浏览器访问</span><br><span class="line">public ModelAndView errorHtml(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping  #接口测试软件  application/json 默认没写</span><br><span class="line">@ResponseBody</span><br><span class="line">public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>@RequestMapping(value = “/produces”, produces = “application/json”)：表示将功能处理方法将生产json格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/json”时即可匹配;<br>@RequestMapping(value = “/produces”, produces = “application/xml”)：表示将功能处理方法将生产xml格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/xml”时即可匹配。</p>
</blockquote>
<h1 id="自定义浏览器端错误的返回页面"><a href="#自定义浏览器端错误的返回页面" class="headerlink" title="自定义浏览器端错误的返回页面"></a>自定义浏览器端错误的返回页面</h1><h2 id="重写BasicErrorController"><a href="#重写BasicErrorController" class="headerlink" title="重写BasicErrorController"></a>重写BasicErrorController</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		response.setStatus(getStatus(request).value());</span><br><span class="line">		Map&lt;String, Object&gt; model = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML));</span><br><span class="line">		return new ModelAndView(&quot;error/404.html&quot;, model);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-src-main-resources-public-error-404-html-页面"><a href="#创建-src-main-resources-public-error-404-html-页面" class="headerlink" title="创建 src/main/resources/public/error/404.html 页面"></a>创建 src/main/resources/public/error/404.html 页面</h2><h1 id="自定义测试软件返回json"><a href="#自定义测试软件返回json" class="headerlink" title="自定义测试软件返回json"></a>自定义测试软件返回json</h1><blockquote>
<p>重写BasicErrorController</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		map.put(&quot;msg&quot;, body.get(&quot;message&quot;));</span><br><span class="line">		map.put(&quot;code&quot;, body.get(&quot;status&quot;));</span><br><span class="line">		map.put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat启动流程]]></title>
      <url>/tomcat/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>tomcat 启动启动过程分析<br><a id="more"></a></p>
<h1 id="org-apache-catalina-startup-Bootstrap-main"><a href="#org-apache-catalina-startup-Bootstrap-main" class="headerlink" title="org.apache.catalina.startup.Bootstrap.main"></a>org.apache.catalina.startup.Bootstrap.main</h1><blockquote>
<blockquote>
<p>org.apache.catalina.startup.Bootstrap.main 启动的入口方法</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">           if (command.equals(&quot;startd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;start&quot;;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stopd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;stop&quot;;</span><br><span class="line">               daemon.stop();</span><br><span class="line">           &#125; else if (command.equals(&quot;start&quot;)) &#123;</span><br><span class="line">               daemon.setAwait(true);</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stop&quot;)) &#123;</span><br><span class="line">               daemon.stopServer(args);</span><br><span class="line">           &#125; else if (command.equals(&quot;configtest&quot;)) &#123;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               if (null==daemon.getServer()) &#123;</span><br><span class="line">                   System.exit(1);</span><br><span class="line">               &#125;</span><br><span class="line">               System.exit(0);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-gt-initClassLoaders"><a href="#main-gt-initClassLoaders" class="headerlink" title="main()-&gt;initClassLoaders()"></a>main()-&gt;initClassLoaders()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commonLoader = createClassLoader(&quot;common&quot;, null);</span><br><span class="line">#导入源码目录的 D:\apache-tomcat-xxxx-src\lib 的jar</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); </span><br><span class="line">#导入 org.apache.catalina.startup.Catalina</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  daemon.setAwait(true);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  daemon 可以看成 org.apache.catalina.startup.Catalina类</span><br></pre></td></tr></table></figure>
<h1 id="org-apache-catalina-startup-Catalina"><a href="#org-apache-catalina-startup-Catalina" class="headerlink" title="org.apache.catalina.startup.Catalina"></a>org.apache.catalina.startup.Catalina</h1><blockquote>
<blockquote>
<p>start()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">		if (getServer() == null) &#123;</span><br><span class="line">			load(); //重点处理server.xml</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	.......</span><br><span class="line">		try &#123;</span><br><span class="line">			getServer().start();</span><br><span class="line">		&#125; catch (LifecycleException e) &#123;</span><br><span class="line">			log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;), e);</span><br><span class="line">			try &#123;</span><br><span class="line">				getServer().destroy();</span><br><span class="line">			&#125; catch (LifecycleException e1) &#123;</span><br><span class="line">				log.debug(&quot;destroy() failed for failed Server &quot;, e1);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>load()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void load() &#123;</span><br><span class="line">.....</span><br><span class="line">Digester digester = createStartDigester(); </span><br><span class="line">.....</span><br><span class="line">getServer().setCatalina(this);</span><br><span class="line">getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line">#设置 catalina.home、catalina.base</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>createStartDigester() 加载解析server.xml</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br><span class="line"></span><br><span class="line">		// When the &apos;engine&apos; is found, set the parentClassLoader.</span><br><span class="line">		digester.addRule(&quot;Server/Service/Engine&quot;, new SetParentClassLoaderRule(parentClassLoader));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Cluster/&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>Catalina.java 创建 server service engine 添加监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Server的启动过程"><a href="#Server的启动过程" class="headerlink" title="Server的启动过程"></a>Server的启动过程</h1><blockquote>
<blockquote>
<p>Server 的默认实现是 org.apache.catalina.core.StandardServer，StandardServer 继承自 LifecycleMBeanBase，LifecycleMBeanBase又继承自 LifecycleBase。 init 和 start 方法就定义在 LifecycleBase 中，LifecycleBase 里的init和start方法又调用initInternal和startInternal方法，这两个方法都是模板方法有子类实现。所以 StandardServer 执行  initInternal 和 startInternal 方法。<br>同时 init 和 start 方法分别循环调用了每个Service的 init 和 start 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardServer</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line">		System.err.println(&quot;startInternal\n&quot;);</span><br><span class="line">		fireLifecycleEvent(CONFIGURE_START_EVENT, null);</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Services</span><br><span class="line">		synchronized (servicesLock) &#123;</span><br><span class="line">			for (int i = 0; i &lt; services.length; i++) &#123;</span><br><span class="line">				services[i].start(); //启动service</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Service-的启动过程"><a href="#Service-的启动过程" class="headerlink" title="Service 的启动过程"></a>Service 的启动过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardService</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">		if (log.isInfoEnabled())</span><br><span class="line">			log.info(sm.getString(&quot;standardService.start.name&quot;, this.name));</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		// Start our defined Container first</span><br><span class="line">		if (engine != null) &#123;</span><br><span class="line">			synchronized (engine) &#123;</span><br><span class="line">				engine.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		synchronized (executors) &#123;</span><br><span class="line">			for (Executor executor : executors) &#123;</span><br><span class="line">				executor.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mapperListener.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Connectors second</span><br><span class="line">		synchronized (connectorsLock) &#123;</span><br><span class="line">			for (Connector connector : connectors) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					// If it has already failed, don&apos;t try and start it</span><br><span class="line">					if (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">						connector.start();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					log.error(sm.getString(&quot;standardService.connector.startFailed&quot;, connector), e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Engine-的启动"><a href="#Engine-的启动" class="headerlink" title="Engine 的启动"></a>Engine 的启动</h1><blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardEngine<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       // Log our server identification information</span><br><span class="line">       if(log.isInfoEnabled())</span><br><span class="line">           log.info( &quot;Starting Servlet Engine: &quot; + ServerInfo.getServerInfo());</span><br><span class="line"></span><br><span class="line">       // Standard container startup</span><br><span class="line">       super.startInternal(); #调用父类方法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> org.apache.catalina.core.ContainerBase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        // Start our subordinate components, if any</span><br><span class="line">        logger = null;</span><br><span class="line">        getLogger();</span><br><span class="line">        Cluster cluster = getClusterInternal();</span><br><span class="line">        if (cluster instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) cluster).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Realm realm = getRealmInternal();</span><br><span class="line">        if (realm instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) realm).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start our child containers, if any</span><br><span class="line">        Container children[] = findChildren();</span><br><span class="line">        List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">            results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean fail = false;</span><br><span class="line">        for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;containerBase.threadedStartFailed&quot;), e);</span><br><span class="line">                fail = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (fail) &#123;</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;containerBase.threadedStartFailed&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start the Valves in our pipeline (including the basic), if any</span><br><span class="line">        if (pipeline instanceof Lifecycle)</span><br><span class="line">            ((Lifecycle) pipeline).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">        // Start our thread</span><br><span class="line">        threadStart(); #转Context 启动</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Context-启动"><a href="#Context-启动" class="headerlink" title="Context 启动"></a>Context 启动</h1><blockquote>
<blockquote>
<p>threadStart(); </p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  protected void threadStart() &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        thread = new Thread(new ContainerBackgroundProcessor(), threadName);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line">        thread.start(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected class ContainerBackgroundProcessor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">                processChildren(ContainerBase.this);</span><br><span class="line">        ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.ContainerBackgroundProcessor.processChildren(Container)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void processChildren(Container container) &#123;</span><br><span class="line">         ...</span><br><span class="line">               container.backgroundProcess();</span><br><span class="line">        ...   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardContext.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">	super.backgroundProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	# 此时 listener 为org.apache.catalina.startup.HostConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.lifecycleEvent(LifecycleEvent)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">check();</span><br><span class="line"></span><br><span class="line">deployApps(); # 部署webapps 下的应用</span><br><span class="line"></span><br><span class="line">protected void deployApps() &#123;</span><br><span class="line"></span><br><span class="line">        File appBase = host.getAppBaseFile();</span><br><span class="line">        File configBase = host.getConfigBaseFile();</span><br><span class="line">        String[] filteredAppPaths = filterAppPaths(appBase.list());</span><br><span class="line">        // Deploy XML descriptors from configBase</span><br><span class="line">        deployDescriptors(configBase, configBase.list());</span><br><span class="line">        // Deploy WARs</span><br><span class="line">        deployWARs(appBase, filteredAppPaths);</span><br><span class="line">        // Deploy expanded folders</span><br><span class="line">        deployDirectories(appBase, filteredAppPaths);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.createDigester(String)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected static Digester createDigester(String contextClassName) &#123;</span><br><span class="line">#contextClassName= org.apache.catalina.core.StandardContext</span><br><span class="line">       Digester digester = new Digester();</span><br><span class="line">       digester.setValidating(false);</span><br><span class="line">       // Add object creation rule</span><br><span class="line">       digester.addObjectCreate(&quot;Context&quot;, contextClassName, &quot;className&quot;);</span><br><span class="line">       // Set the properties on that object (it doesn&apos;t matter if extra</span><br><span class="line">       // properties are set)</span><br><span class="line">       digester.addSetProperties(&quot;Context&quot;);</span><br><span class="line">       return (digester);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.ContextConfig监听StandardContext的事件</p>
<blockquote>
<p>调用 org.apache.catalina.core.StandardContext.startInternal()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123; </span><br><span class="line">       ......</span><br><span class="line">       fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); // 解析web.xml的</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"> # 启动web.xml的 listener 例如 ：contextloaderlistener</span><br><span class="line">       if (ok) &#123;</span><br><span class="line">				if (!listenerStart()) &#123;</span><br><span class="line">log.error(sm.getString(&quot;standardContext.listenerFail&quot;));</span><br><span class="line">					ok = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<p> org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	#此时的listener 为 org.apache.catalina.startup.ContextConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>解析  web.xml org.apache.catalina.startup.ContextConfig.configureStart()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void configureStart() &#123;</span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">		webConfig();  #  真正解析 web.xml</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> tomcat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot-Access-Control-Allow-Origin]]></title>
      <url>/spring-boot/spring-boot-Access-Control-Allow-Origin.html</url>
      <content type="html"><![CDATA[<p>springboot 跨域研究</p>
<a id="more"></a>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><blockquote>
<p>在前后端开发的模式中，前端通常使用ajax调用后端服务器的接口，常见错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:8080’ is therefore not allowed access.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="springboot-解决跨域的方案"><a href="#springboot-解决跨域的方案" class="headerlink" title="springboot 解决跨域的方案"></a>springboot 解决跨域的方案</h1><h2 id="通过UrlBasedCorsConfigurationSource解决"><a href="#通过UrlBasedCorsConfigurationSource解决" class="headerlink" title="通过UrlBasedCorsConfigurationSource解决"></a>通过UrlBasedCorsConfigurationSource解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    private CorsConfiguration buildConfig() &#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1 设置访问源地址</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2 设置访问源请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3 设置访问源请求方法</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4 对接口配置跨域设置</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过拦截器解决"><a href="#通过拦截器解决" class="headerlink" title="通过拦截器解决"></a>通过拦截器解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CORSConfiguration &#123;</span><br><span class="line">	@Bean</span><br><span class="line">	public WebMvcConfigurer corsConfigurer() &#123;</span><br><span class="line">		return new WebMvcConfigurerAdapter() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">				registry.addMapping(&quot;/**&quot;).allowedHeaders(&quot;*&quot;).allowedMethods(&quot;*&quot;).allowedOrigins(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过注解解决"><a href="#通过注解解决" class="headerlink" title="通过注解解决"></a>通过注解解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &quot;http://a.com&quot;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot过滤器验证token]]></title>
      <url>/spring-boot/spring-token.html</url>
      <content type="html"><![CDATA[<p>springboot过滤器验证token<br><a id="more"></a></p>
<h1 id="token-java"><a href="#token-java" class="headerlink" title="token.java"></a>token.java</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TokenInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService adminService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">        String user = request.getHeader(&quot;userId&quot;);</span><br><span class="line">        if (token == null || user == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer userId = Integer.valueOf(user);</span><br><span class="line">        //获取Service实例</span><br><span class="line">        if (userService == null) &#123;</span><br><span class="line">            BeanFactory factory = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());</span><br><span class="line">            userService = (UserService) factory.getBean(&quot;userService&quot;);</span><br><span class="line">            adminService = (AdminService) factory.getBean(&quot;adminService&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //增加日活量</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            adminService.addAccessCount(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        String checkToken = userService.selectToken(userId);</span><br><span class="line">        //检查头部请求</span><br><span class="line">        if (!checkToken.equals(token)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> token </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> token </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-mybatis-druid整合]]></title>
      <url>/spring-boot-mybatis-druid%E6%95%B4%E5%90%88.html</url>
      <content type="html"><![CDATA[<p>springboot mybatis  druid简单整合</p>
<a id="more"></a>
<h1 id="在eclipse-中创建maven-工程-修改pom-xml-文件"><a href="#在eclipse-中创建maven-工程-修改pom-xml-文件" class="headerlink" title="在eclipse 中创建maven 工程, 修改pom.xml 文件"></a>在eclipse 中创建maven 工程, 修改pom.xml 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  </span><br><span class="line">   &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; </span><br><span class="line"> &lt;/parent&gt;  </span><br><span class="line"> &lt;dependencies&gt; </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.1.5&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.3.0&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">     &lt;scope&gt;runtime&lt;/scope&gt; </span><br><span class="line">   &lt;/dependency&gt; </span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h1 id="在-src-main-resources下创建application-properties"><a href="#在-src-main-resources下创建application-properties" class="headerlink" title="在 src/main/resources下创建application.properties"></a>在 src/main/resources下创建application.properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">server.session.timeout=10</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/service_data?characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#mybatis</span><br><span class="line">mybatis.type-aliases-package=com.we.pojo</span><br><span class="line">mybatis.mapper-locations=classpath*:com/we/mapperxml/*.xml</span><br></pre></td></tr></table></figure>
<h1 id="编写Application-java-类"><a href="#编写Application-java-类" class="headerlink" title="编写Application.java 类"></a>编写Application.java 类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication()</span><br><span class="line">@ComponentScan(&quot;com.we&quot;) #很重要不配  404 </span><br><span class="line">@MapperScan(value = &quot;com.we.mapper&quot;) #很重要</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编写业务逻辑-启动spring-boot"><a href="#编写业务逻辑-启动spring-boot" class="headerlink" title="编写业务逻辑,启动spring boot"></a>编写业务逻辑,启动spring boot</h1><h1 id="druid-sql-监控功能"><a href="#druid-sql-监控功能" class="headerlink" title="druid sql 监控功能"></a>druid sql 监控功能</h1><blockquote>
<p>项目启动后访问 <a href="http://localhost:8088/druid/" target="_blank" rel="noopener">http://localhost:8088/druid/</a> 可以看见登录界面<br>修改默认访问账号密码<br>新建一个java文件  例如：druidConfig.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class druidConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ServletRegistrationBean druidServlet() &#123;</span><br><span class="line">		ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean();</span><br><span class="line">		servletRegistrationBean.setServlet(new StatViewServlet());</span><br><span class="line">		servletRegistrationBean.addUrlMappings(&quot;/druid/*&quot;);</span><br><span class="line">		Map&lt;String, String&gt; initParameters = new HashMap&lt;String, String&gt;();</span><br><span class="line">		initParameters.put(&quot;loginUsername&quot;, &quot;admin&quot;); // ++监控页面登录用户名</span><br><span class="line">		initParameters.put(&quot;loginPassword&quot;, &quot;admin&quot;); // ++监控页面登录用户密码</span><br><span class="line">		servletRegistrationBean.setInitParameters(initParameters);</span><br><span class="line">		return servletRegistrationBean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这样就可以直接用 admin  admin 进入监控系统</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
            <tag> druid </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-feign伪rpc集成]]></title>
      <url>/spring-boot-feign%E4%BC%AArpc%E9%9B%86%E6%88%90.html</url>
      <content type="html"><![CDATA[<p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。可以认为是一种伪RPC。<br><a id="more"></a></p>
<h1 id="和springboot整合"><a href="#和springboot整合" class="headerlink" title="和springboot整合"></a>和springboot整合</h1><blockquote>
<p>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.3.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="配置application-properties-文件"><a href="#配置application-properties-文件" class="headerlink" title="配置application.properties 文件"></a>配置application.properties 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign.name=feignName</span><br><span class="line">feign.url=http://localhost:88</span><br><span class="line">feign.client.config.default.loggerLevel = full</span><br><span class="line">feign.connectTimeoutMillis=1000   #连接超时,单位毫秒</span><br><span class="line">feign.readTimeoutMillis=15000     #读超时,单位毫秒</span><br></pre></td></tr></table></figure>
<h1 id="编写feign的-interface"><a href="#编写feign的-interface" class="headerlink" title="编写feign的 interface"></a>编写feign的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(url = &quot;$&#123;feign.url&#125;&quot;, name = &quot;feign.name&quot;)</span><br><span class="line">public interface testfeign &#123;</span><br><span class="line">	@RequestMapping(value = &quot;/version&quot;, method = RequestMethod.GET)</span><br><span class="line">	public String version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在controller-注入上面的-interface"><a href="#在controller-注入上面的-interface" class="headerlink" title="在controller 注入上面的 interface"></a>在controller 注入上面的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private testfeign stestfeign;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;testfeign&quot;)</span><br><span class="line">	private String pub() &#123;</span><br><span class="line">		return stestfeign.version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置项目启动文件"><a href="#配置项目启动文件" class="headerlink" title="配置项目启动文件"></a>配置项目启动文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">@EnableFeignClients(basePackages = &quot;im.nginx.test&quot;)</span><br><span class="line">#im.nginx.test 为feign interface 文件所在的包</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> feign </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> feign </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_conf_get_module_loc_conf 分析]]></title>
      <url>/ngx_http_conf_get_module_loc_conf.html</url>
      <content type="html"><![CDATA[<p>自定义参数处理函数中会用到ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);<br>获取配置块</p>
<a id="more"></a>
<h1 id="ngx-http-conf-get-module-loc-conf"><a href="#ngx-http-conf-get-module-loc-conf" class="headerlink" title="ngx_http_conf_get_module_loc_conf"></a>ngx_http_conf_get_module_loc_conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_http_conf_get_module_loc_conf(cf, module)                         \</span><br><span class="line">    ((ngx_http_conf_ctx_t *) cf-&gt;ctx)-&gt;loc_conf[module.ctx_index]</span><br></pre></td></tr></table></figure>
<h1 id="引出loc-conf初始化函数-ngx-http-block"><a href="#引出loc-conf初始化函数-ngx-http-block" class="headerlink" title="引出loc_conf初始化函数 ngx_http_block"></a>引出loc_conf初始化函数 ngx_http_block</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> *ngx_http_commands 命令集的回调函数 </span><br><span class="line"> *HTTP模块初始化的入口函数 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">static char *  </span><br><span class="line">ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)  </span><br><span class="line">&#123;  </span><br><span class="line">    char                        *rv;  </span><br><span class="line">    ngx_uint_t                   mi, m, s;  </span><br><span class="line">    ngx_conf_t                   pcf;  </span><br><span class="line">    ngx_http_module_t           *module;  </span><br><span class="line">    ngx_http_conf_ctx_t         *ctx;  </span><br><span class="line">    ngx_http_core_loc_conf_t    *clcf;  </span><br><span class="line">    ngx_http_core_srv_conf_t   **cscfp;  </span><br><span class="line">    ngx_http_core_main_conf_t   *cmcf;  </span><br><span class="line">  </span><br><span class="line">    if (*(ngx_http_conf_ctx_t **) conf) &#123;  </span><br><span class="line">        return &quot;is duplicate&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* the main http context */  </span><br><span class="line">  </span><br><span class="line">    /* 分配一块内存，存放http配置上下文 */  </span><br><span class="line">    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t));  </span><br><span class="line">    if (ctx == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    *(ngx_http_conf_ctx_t **) conf = ctx;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* count the number of the http modules and set up their indices */  </span><br><span class="line">  </span><br><span class="line">    /* 计算http模块个数 */  </span><br><span class="line">    ngx_http_max_module = ngx_count_modules(cf-&gt;cycle, NGX_HTTP_MODULE);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* the http main_conf context, it is the same in the all http contexts */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 最外层的HTTP配置 </span><br><span class="line">     * http </span><br><span class="line">      &#123; </span><br><span class="line">      include       mime.types; </span><br><span class="line">      default_type  application/octet-stream; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool,  </span><br><span class="line">                                 sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;main_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null srv_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">    /** </span><br><span class="line">     * server层的配置 </span><br><span class="line">     *   server </span><br><span class="line">  &#123; </span><br><span class="line">    listen       80; </span><br><span class="line">    #server_name  blog.s135.com; </span><br><span class="line">    index index.html index.htm index.php; </span><br><span class="line">    root   /home/wwwroot/; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;srv_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null loc_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * location 层的配置 </span><br><span class="line">    location ~ .*\.(php|php5)?$ </span><br><span class="line">    &#123; </span><br><span class="line">      #fastcgi_pass  unix:/tmp/php-cgi.sock; </span><br><span class="line">      fastcgi_pass  127.0.0.1:9000; </span><br><span class="line">      fastcgi_index index.php; </span><br><span class="line">      include fcgi.conf; </span><br><span class="line">    &#125; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;loc_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * create the main_conf&apos;s, the null srv_conf&apos;s, and the null loc_conf&apos;s </span><br><span class="line">     * of the all http modules </span><br><span class="line">     */  </span><br><span class="line">     /** </span><br><span class="line">      * 调用：create_main_conf、create_srv_conf、create_loc_conf </span><br><span class="line">      * 创建配置 </span><br><span class="line">      */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_main_conf) &#123;  </span><br><span class="line">            ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf);  </span><br><span class="line">            if (ctx-&gt;main_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_srv_conf) &#123;  </span><br><span class="line">            ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf);  </span><br><span class="line">            if (ctx-&gt;srv_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_loc_conf) &#123;  </span><br><span class="line">            ctx-&gt;loc_conf[mi] = module-&gt;create_loc_conf(cf);  </span><br><span class="line">            if (ctx-&gt;loc_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    pcf = *cf;  </span><br><span class="line">    cf-&gt;ctx = ctx;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * preconfiguration 预先初始化配置信息 </span><br><span class="line">     */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;preconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;preconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* parse inside the http&#123;&#125; block */  </span><br><span class="line">  </span><br><span class="line">    cf-&gt;module_type = NGX_HTTP_MODULE;  </span><br><span class="line">    cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF;  </span><br><span class="line">    rv = ngx_conf_parse(cf, NULL);  </span><br><span class="line">  </span><br><span class="line">    if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">        goto failed;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * init http&#123;&#125; main_conf&apos;s, merge the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     * and its location&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 初始化main配置 </span><br><span class="line">     * 合并 server srv_conf </span><br><span class="line">     * 合并location loc_conf </span><br><span class="line">     */  </span><br><span class="line">    cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">    cscfp = cmcf-&gt;servers.elts;  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        /* init http&#123;&#125; main_conf&apos;s */  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;init_main_conf) &#123;  </span><br><span class="line">            rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]);  </span><br><span class="line">            if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">                goto failed;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        rv = ngx_http_merge_servers(cf, cmcf, module, mi);  </span><br><span class="line">        if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">            goto failed;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* create location trees */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 创建 location模块的trees </span><br><span class="line">     */  </span><br><span class="line">    for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) &#123;  </span><br><span class="line">  </span><br><span class="line">        clcf = cscfp[s]-&gt;ctx-&gt;loc_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;postconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;postconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_variables_init_vars(cf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * http&#123;&#125;&apos;s cf-&gt;ctx was needed while the configuration merging </span><br><span class="line">     * and in postconfiguration process </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* optimize the lists of ports, addresses and server names */  </span><br><span class="line">  </span><br><span class="line">    /* ngx_http_optimize_servers 初始化listen 端口号 ip地址 服务器等监听信息*/  </span><br><span class="line">    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return NGX_CONF_OK;  </span><br><span class="line">  </span><br><span class="line">failed:  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">    return rv;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ngx-http-conf-ctx-t"><a href="#ngx-http-conf-ctx-t" class="headerlink" title="ngx_http_conf_ctx_t"></a>ngx_http_conf_ctx_t</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">     void        **main_conf;</span><br><span class="line">     void        **srv_conf;</span><br><span class="line">     void        **loc_conf;</span><br><span class="line"> &#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/nginx%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p>title: nginx常用基本变量及数据结构<br>tags: [nginx]<br>categories: nginx</p>
<a id="more"></a>
<h1 id="nginx-常用基本变量"><a href="#nginx-常用基本变量" class="headerlink" title="nginx 常用基本变量"></a>nginx 常用基本变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int  ngx_fd_t;</span><br><span class="line">typedef intptr_t        ngx_int_t;</span><br><span class="line">typedef uintptr_t       ngx_uint_t;</span><br><span class="line">typedef intptr_t        ngx_flag_t;</span><br><span class="line">typedef void *          ngx_buf_tag_t;</span><br></pre></td></tr></table></figure>
<h1 id="nginx常用数据结构"><a href="#nginx常用数据结构" class="headerlink" title="nginx常用数据结构"></a>nginx常用数据结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct &#123;</span><br><span class="line">     size_t      len;</span><br><span class="line">     u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br><span class="line"></span><br><span class="line">typedef struct stat  ngx_file_info_t;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-if指令与全局变量]]></title>
      <url>/nginx-if%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</url>
      <content type="html"><![CDATA[<p>if判断指令<br>语法为if(condition){…}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：</p>
<blockquote>
<p>当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false<br>直接比较变量和内容时，使用=或!=<br>~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配</p>
</blockquote>
<a id="more"></a>
<h1 id="if-常用判断"><a href="#if-常用判断" class="headerlink" title="if 常用判断"></a>if 常用判断</h1><p>-f和!-f用来判断是否存在文件<br>-d和!-d用来判断是否存在目录<br>-e和!-e用来判断是否存在文件或目录<br>-x和!-x用来判断文件是否可执行</p>
<h2 id="if应用"><a href="#if应用" class="headerlink" title="if应用"></a>if应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; //限速，$slow可以通过 set 指令设置</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; //防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nginx-常用全局变量"><a href="#nginx-常用全局变量" class="headerlink" title="nginx 常用全局变量"></a>nginx 常用全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$args ： #这个变量等于请求行中的参数，同$query_string</span><br><span class="line">$is_args : 如果请求带有参数, 值为 ? 否则为空字符串</span><br><span class="line">$content_length ： 请求头中的Content-length字段。</span><br><span class="line">$content_type ： 请求头中的Content-Type字段。</span><br><span class="line">$document_root ： 当前请求在root指令中指定的值。</span><br><span class="line">$host ： 请求主机头字段，否则为服务器名称。</span><br><span class="line">$http_user_agent ： 客户端agent信息</span><br><span class="line">$http_cookie ： 客户端cookie信息</span><br><span class="line">$limit_rate ： 这个变量可以限制连接速率。</span><br><span class="line">$request_method ： 客户端请求的动作，通常为GET或POST。</span><br><span class="line">$remote_addr ： 客户端的IP地址。</span><br><span class="line">$remote_port ： 客户端的端口。</span><br><span class="line">$remote_user ： 已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$scheme ： HTTP方法（如http，https）。</span><br><span class="line">$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</span><br><span class="line">$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</span><br><span class="line">$server_name ： 服务器名称。</span><br><span class="line">$server_port ： 请求到达服务器的端口号。</span><br><span class="line">$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</span><br><span class="line">$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</span><br><span class="line">$document_uri ： 与$uri相同。</span><br><span class="line">$nginx_version： 当前nginx版本</span><br><span class="line">$request: 原始请求 GET /one/2222 HTTP/1.1</span><br><span class="line">$status:  响应状态码</span><br><span class="line">$http_referer: url跳转来源</span><br><span class="line">$request_body : 客户端请求主体</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> if </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-location正则表达式匹配规则及动静分离]]></title>
      <url>/nginx-location%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<p>nginx，location常用正则表达式，及nginx动静分离<br><a id="more"></a></p>
<h1 id="nginx匹配规则"><a href="#nginx匹配规则" class="headerlink" title="nginx匹配规则"></a>nginx匹配规则</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~      波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~     ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">=      进行普通字符精确匹配</span><br><span class="line">@      &quot;@&quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</span><br><span class="line">!~（!~*） 表示区分大小写不正则匹配和不区分大小写不正则匹配</span><br></pre></td></tr></table></figure>
<h1 id="nginx正则表达式"><a href="#nginx正则表达式" class="headerlink" title="nginx正则表达式"></a>nginx正则表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">. ： 匹配除换行符以外的任意字符</span><br><span class="line">? ： 重复0次或1次</span><br><span class="line">+ ： 重复1次或更多次</span><br><span class="line">* ： 重复0次或更多次</span><br><span class="line">\d ：匹配数字</span><br><span class="line">^ ： 匹配字符串的开始</span><br><span class="line">$ ： 匹配字符串的介绍</span><br><span class="line">&#123;n&#125; ： 重复n次</span><br><span class="line">&#123;n,&#125; ： 重复n次或更多次</span><br><span class="line">[c] ： 匹配单个字符c</span><br><span class="line">[a-z] ： 匹配a-z小写字母的任意一个</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 当正则表达式中含有 {} 是,必须将 正则表达式用 “” 引起来否则会报错<br>nginx: [emerg] pcre_compile() failed: missing ) in “/one/(\d” in /usr/local/nginx/conf/nginx.conf:56</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#rewrite ^/test/([\d]&#123;3&#125;)/$ /index.php?id=$1 break;  #报错</span><br><span class="line">#修改为</span><br><span class="line">rewrite &quot;^/test/([\d]&#123;3&#125;)/$&quot; /index.php?id=$1 break;</span><br><span class="line"></span><br><span class="line">#本条可以不用引号</span><br><span class="line">rewrite ^/(\d+)/$ /index.php?id=$1 break;</span><br></pre></td></tr></table></figure></p>
<h1 id="动静分离清单"><a href="#动静分离清单" class="headerlink" title="动静分离清单"></a>动静分离清单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /web/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /web/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> location </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-args-query-string-uri详解]]></title>
      <url>/nginx-args-query-string-uri%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>Nginx 中常见和url操作相关的变量</p>
<blockquote>
<p>$args<br>$query_string<br>$request_uri<br>$uri<br>$document_uri</p>
</blockquote>
<p>以上变量有什么联系和区别呢?</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url:  http://nginx.im/nginx/im/?page=1</span><br><span class="line">$args -&gt;    page=1</span><br><span class="line">$query_string -&gt; page=1</span><br><span class="line">$request_uri  -&gt; /nginx/im/?page=1</span><br><span class="line">$uri       -&gt;  /nginx/im</span><br><span class="line">$document_uri -&gt; /nginx/im</span><br><span class="line">**总结**</span><br><span class="line">$args &lt;=&gt; $query_string 获取？后面的参数</span><br><span class="line">$request_uri  获取除了host 之外所有的</span><br><span class="line">$uri &lt;=&gt; $cocuemnt_uri 获取请求路径</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> uri </tag>
            
            <tag> query_string </tag>
            
            <tag> request_uri </tag>
            
            <tag> document_uri </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON字符串转换为Map]]></title>
      <url>/json/fastjson.html</url>
      <content type="html"><![CDATA[<p>JSON字符串转换为Map<br><a id="more"></a></p>
<h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zkn.newlearn.json;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class JsonToMapTest01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        String str = &quot;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;&quot;;</span><br><span class="line">        //第一种方式</span><br><span class="line">        Map maps = (Map)JSON.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : maps.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;     &quot; + ((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式</span><br><span class="line">        Map mapTypes = JSON.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类的parseObject来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapTypes.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapTypes.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第三种方式</span><br><span class="line">        Map mapType = JSON.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类,指定解析类型，来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapType.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapType.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第四种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map json = (Map) JSONObject.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject类的parse方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第五种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第六种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map mapObj = JSONObject.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map: json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        String strArr = &quot;&#123;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;,&quot; +</span><br><span class="line">                &quot;&#123;\&quot;00\&quot;:\&quot;zhangsan\&quot;,\&quot;11\&quot;:\&quot;lisi\&quot;,\&quot;22\&quot;:\&quot;wangwu\&quot;,\&quot;33\&quot;:\&quot;maliu\&quot;&#125;&#125;&quot;;</span><br><span class="line">       // JSONArray.parse()</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java排列组合随机字符串应用]]></title>
      <url>/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>已知固定长度的字符串字典</p>
<blockquote>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
</blockquote>
<p>按字典序输出固定随机字符串</p>
<a id="more"></a>
<h1 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static String randomChar(String dict, String pre, Integer len) &#123;</span><br><span class="line"></span><br><span class="line">		Integer dictLen = dict.length() - 1;</span><br><span class="line">		char[] preChar = pre.toCharArray();</span><br><span class="line">		char[] chArray = new char[len];</span><br><span class="line">		char achar = preChar[len - 1];</span><br><span class="line">		Integer preCharIndex = dict.indexOf(achar);</span><br><span class="line">		if ((preCharIndex + 1) &gt; dictLen) &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(0);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(preCharIndex + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">			Integer preCharIndex1 = dict.indexOf(preChar[i + 1]); // 25</span><br><span class="line">			Integer preCharIndex2 = dict.indexOf(chArray[i + 1]); // 0</span><br><span class="line">			Integer preCharIndex3 = dict.indexOf(preChar[i]); //</span><br><span class="line">			if (Math.abs(preCharIndex1 - preCharIndex2) &gt; 1) &#123;</span><br><span class="line">				if (preCharIndex3 + 1 &gt; dictLen) &#123;</span><br><span class="line">					chArray[i] = dict.charAt(0);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				chArray[i] = dict.charAt(preCharIndex3 + 1);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				chArray[i] = preChar[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return new String(chArray);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 随机字符串 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java常用的一些代码片段]]></title>
      <url>/java%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<p>收集整理java开放中常用的一些代码片段（长期更新）</p>
<a id="more"></a>
<blockquote>
<p>字符串翻转</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String str)&#123;  </span><br><span class="line">        return new StringBuilder(str).reverse().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>spring 中读取 src/main/resource 下的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void testClassPathResource() throws IOException &#123;</span><br><span class="line">    Resource res = new      ClassPathResource(&quot;resource/ApplicationContext.xml&quot;);</span><br><span class="line">   InputStream input = res.getInputStream();</span><br><span class="line">   Assert.assertNotNull(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file = ResourceUtils.getFile(&quot;classpath:doc&quot;);</span><br><span class="line">str = FileUtils.readFileToString(file, &quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> java常用代码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-zip压缩单文件]]></title>
      <url>/java-zip%E5%8E%8B%E7%BC%A9%E5%8D%95%E6%96%87%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<p>java开发中经常用到压缩文件,在JDK中自带zip 压缩相关的类</p>
<blockquote>
<p>ZipOutputStream<br>ZipEntry</p>
<blockquote>
<p>在压缩文件中，每一个压缩的内容都可以用一个ZipEntry 表示，所以在进行压缩之前必须通过putNextEntry 设置一个ZipEntry 即可。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h1 id="单文件压缩"><a href="#单文件压缩" class="headerlink" title="单文件压缩"></a>单文件压缩</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># in为原始文件的绝对路径</span><br><span class="line">public static void zip(String in) throws Exception &#123;</span><br><span class="line">		File file = new File(in);</span><br><span class="line">		File zipFile = new File(in + &quot;.zip&quot;);</span><br><span class="line">		InputStream input = new FileInputStream(file);</span><br><span class="line">		ZipOutputStream zipOut = null;</span><br><span class="line">		zipOut = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">		zipOut.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">		zipOut.setComment(&quot;这是一个压缩文件&quot;);</span><br><span class="line">		int temp = 0;</span><br><span class="line">		while ((temp = input.read()) != -1) &#123;</span><br><span class="line">			zipOut.write(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">		zipOut.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> zip </tag>
            
            <tag> ZipInputStream </tag>
            
            <tag> ZipFile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson解析json字符串]]></title>
      <url>/fastjson%E8%A7%A3%E6%9E%90json%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      <content type="html"><![CDATA[<p>在微服务开发过程中,常要解析json 字符串, 用fastjson解析json 字符串</p>
<a id="more"></a>
<h1 id="获取单个value值"><a href="#获取单个value值" class="headerlink" title="获取单个value值"></a>获取单个value值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;&#123;\&quot;msg\&quot;:\&quot;111\&quot;,\&quot;code\&quot;:200,\&quot;data\&quot;:&#123;\&quot;total\&quot;:15,\&quot;pages\&quot;:8,\&quot;list\&quot;:[&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;,&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;],\&quot;pageNum\&quot;:1&#125;&#125;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Object test(String str, String key) &#123;</span><br><span class="line">		Map mapTypes = JSON.parseObject(str);</span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		return ((JSONObject) mapTypes).getString(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果json字符串是一个json数组"><a href="#如果json字符串是一个json数组" class="headerlink" title="如果json字符串是一个json数组"></a>如果json字符串是一个json数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;Map&lt;String, Object&gt;&gt; GetJsonList(String str) &#123;</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; retmap = JSON.parseObject(str, new TypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">		return retmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[error-assignment-to-expression-with-array-type-error]]></title>
      <url>/error-assignment-to-expression-with-array-type-error.html</url>
      <content type="html"><![CDATA[<p>在结构体赋值操作中，编译器报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: assignment to expression with array type error</span><br></pre></td></tr></table></figure></p>
<p>如何才能避免这种错误呢？<br><a id="more"></a></p>
<h1 id="代码现场"><a href="#代码现场" class="headerlink" title="代码现场"></a>代码现场</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        char ss[10];</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        struct test t1;</span><br><span class="line">        t1.a=10;</span><br><span class="line">        t1.b=20;</span><br><span class="line">        t1.ss=&quot;1111111&quot;; # 编译器报错</span><br><span class="line">        printf(&quot;%d, %d, %s\n&quot;, t1.a, t1.b, t1.ss);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把一个字符串赋值给一个字符数组？"><a href="#把一个字符串赋值给一个字符数组？" class="headerlink" title="把一个字符串赋值给一个字符数组？"></a>把一个字符串赋值给一个字符数组？</h2><p>如果我们这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        char s[10]=&quot;ssssss&quot;;</span><br><span class="line">        printf(&quot;%s\n&quot;,s);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序能完美运行。为什么在结构体中是不行的？</p>
<blockquote>
<p>C语言只有在定义字符数组的时候才能用“=”来初始化变量，其它情况下是不能直接用“=”来为字符数组赋值的，<br>结构体中数组成员ss表示数组名，是一个指针，具有常量特性，表示数组存储空间的开始地址，而C语言中不能对常量赋值。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote>
<p>声明字符串时直接赋值<br>用scanf函数给字符串输入值<br>用strcpy函数给字符串赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(t1.ss,&quot;1111111&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx启动流程]]></title>
      <url>/Nginx%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>nginx启动流程，从main函数开始,一个重要的结构体ngx_cycle_s</p>
<a id="more"></a>
<h1 id="ngx-cycle-s"><a href="#ngx-cycle-s" class="headerlink" title="ngx_cycle_s"></a>ngx_cycle_s</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0038 struct ngx_cycle_s &#123;</span><br><span class="line">0039     void                  ****conf_ctx;</span><br><span class="line">0040     ngx_pool_t               *pool;</span><br><span class="line">0041 </span><br><span class="line">0042     ngx_log_t                *log;</span><br><span class="line">0043     ngx_log_t                 new_log;</span><br><span class="line">0044 </span><br><span class="line">0045     ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */</span><br><span class="line">0046 </span><br><span class="line">0047     ngx_connection_t        **files;</span><br><span class="line">0048     ngx_connection_t         *free_connections;</span><br><span class="line">0049     ngx_uint_t                free_connection_n;</span><br><span class="line">0050 </span><br><span class="line">0051     ngx_module_t            **modules;</span><br><span class="line">0052     ngx_uint_t                modules_n;</span><br><span class="line">0053     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */</span><br><span class="line">0054 </span><br><span class="line">0055     ngx_queue_t               reusable_connections_queue;</span><br><span class="line">0056     ngx_uint_t                reusable_connections_n;</span><br><span class="line">0057 </span><br><span class="line">0058     ngx_array_t               listening;</span><br><span class="line">0059     ngx_array_t               paths;</span><br><span class="line">0060 </span><br><span class="line">0061     ngx_array_t               config_dump;</span><br><span class="line">0062     ngx_rbtree_t              config_dump_rbtree;</span><br><span class="line">0063     ngx_rbtree_node_t         config_dump_sentinel;</span><br><span class="line">0064 </span><br><span class="line">0065     ngx_list_t                open_files;</span><br><span class="line">0066     ngx_list_t                shared_memory;</span><br><span class="line">0067 </span><br><span class="line">0068     ngx_uint_t                connection_n;</span><br><span class="line">0069     ngx_uint_t                files_n;</span><br><span class="line">0070 </span><br><span class="line">0071     ngx_connection_t         *connections;</span><br><span class="line">0072     ngx_event_t              *read_events;</span><br><span class="line">0073     ngx_event_t              *write_events;</span><br><span class="line">0074 </span><br><span class="line">0075     ngx_cycle_t              *old_cycle;</span><br><span class="line">0076 </span><br><span class="line">0077     ngx_str_t                 conf_file;</span><br><span class="line">0078     ngx_str_t                 conf_param;</span><br><span class="line">0079     ngx_str_t                 conf_prefix;</span><br><span class="line">0080     ngx_str_t                 prefix;</span><br><span class="line">0081     ngx_str_t                 lock_file;</span><br><span class="line">0082     ngx_str_t                 hostname;</span><br><span class="line">0083 &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="填充ngx-cycle-t数据"><a href="#填充ngx-cycle-t数据" class="headerlink" title="填充ngx_cycle_t数据"></a>填充ngx_cycle_t数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">int ngx_cdecl</span><br><span class="line">main(int argc, char *const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_int_t         i;</span><br><span class="line">    ngx_log_t        *log;</span><br><span class="line">    ngx_cycle_t      *cycle, init_cycle;</span><br><span class="line">    ngx_core_conf_t  *ccf;</span><br><span class="line"></span><br><span class="line">    ngx_debug_init();</span><br><span class="line"></span><br><span class="line">    if (ngx_strerror_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 解析命令行参数 */</span><br><span class="line">    if (ngx_get_options(argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 显示版本号与帮助信息 */</span><br><span class="line">    if (ngx_show_version) &#123;</span><br><span class="line">        ngx_write_stderr(&quot;nginx version: &quot; NGINX_VER NGX_LINEFEED);</span><br><span class="line"></span><br><span class="line">        if (ngx_show_help) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">                &quot;Usage: nginx [-?hvVtq] [-s signal] [-c filename] &quot;</span><br><span class="line">                             &quot;[-p prefix] [-g directives]&quot; NGX_LINEFEED</span><br><span class="line">                             NGX_LINEFEED</span><br><span class="line">                &quot;Options:&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -?,-h         : this help&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -v            : show version and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -V            : show version and configure options then exit&quot;</span><br><span class="line">                                   NGX_LINEFEED</span><br><span class="line">                &quot;  -t            : test configuration and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -q            : suppress non-error messages &quot;</span><br><span class="line">                                   &quot;during configuration testing&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -s signal     : send signal to a master process: &quot;</span><br><span class="line">                                   &quot;stop, quit, reopen, reload&quot; NGX_LINEFEED</span><br><span class="line">#ifdef NGX_PREFIX</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: &quot;</span><br><span class="line">                                   NGX_PREFIX &quot;)&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: NONE)&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">                &quot;  -c filename   : set configuration file (default: &quot;</span><br><span class="line">                                   NGX_CONF_PATH &quot;)&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -g directives : set global directives out of configuration &quot;</span><br><span class="line">                                   &quot;file&quot; NGX_LINEFEED NGX_LINEFEED</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_show_configure) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">#ifdef NGX_COMPILER</span><br><span class="line">                &quot;built by &quot; NGX_COMPILER NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#if (NGX_SSL)</span><br><span class="line">#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME</span><br><span class="line">                &quot;TLS SNI support enabled&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;TLS SNI support disabled&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">                &quot;configure arguments:&quot; NGX_CONFIGURE NGX_LINEFEED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!ngx_test_config) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* TODO */ ngx_max_sockets = -1;</span><br><span class="line"></span><br><span class="line">    /* 初始化并更新时间 */</span><br><span class="line">    ngx_time_init();</span><br><span class="line"></span><br><span class="line">#if (NGX_PCRE)</span><br><span class="line">    ngx_regex_init();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ngx_pid = ngx_getpid();</span><br><span class="line"></span><br><span class="line">    /* 初始化日志信息 */</span><br><span class="line">    log = ngx_log_init(ngx_prefix);</span><br><span class="line">    if (log == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* STUB */</span><br><span class="line">#if (NGX_OPENSSL)</span><br><span class="line">    ngx_ssl_init(log);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * init_cycle-&gt;log is required for signal handlers and</span><br><span class="line">     * ngx_process_options()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 全局变量init_cycle清零，并创建改变量的内存池pool */</span><br><span class="line">    ngx_memzero(&amp;init_cycle, sizeof(ngx_cycle_t));</span><br><span class="line">    init_cycle.log = log;</span><br><span class="line">    ngx_cycle = &amp;init_cycle;</span><br><span class="line"></span><br><span class="line">    init_cycle.pool = ngx_create_pool(1024, log);</span><br><span class="line">    if (init_cycle.pool == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 保存命令行参数至全局变量ngx_os_argv、ngx_argc、ngx_argv */</span><br><span class="line">    if (ngx_save_argv(&amp;init_cycle, argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle中的成员：prefix、conf_prefix、conf_file、conf_param 等字段 */</span><br><span class="line">    if (ngx_process_options(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化系统相关变量，如：内存页面大小ngx_pagesize、最大连接数ngx_max_sockets等 */</span><br><span class="line">    if (ngx_os_init(log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 初始化 CRC 表（循环冗余校验表） */</span><br><span class="line">    if (ngx_crc32_table_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 通过环境变量NGINX完成socket的继承，将其保存在全局变量init_cycle的listening数组中 */</span><br><span class="line">    if (ngx_add_inherited_sockets(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化每个模块module的index，并计算ngx_max_module */</span><br><span class="line">    ngx_max_module = 0;</span><br><span class="line">    for (i = 0; ngx_modules[i]; i++) &#123;</span><br><span class="line">        ngx_modules[i]-&gt;index = ngx_max_module++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle ，这里很重要 */</span><br><span class="line">    cycle = ngx_init_cycle(&amp;init_cycle);</span><br><span class="line">    if (cycle == NULL) &#123;</span><br><span class="line">        if (ngx_test_config) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test failed&quot;,</span><br><span class="line">                           init_cycle.conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_test_config) &#123;</span><br><span class="line">        if (!ngx_quiet_mode) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test is successful&quot;,</span><br><span class="line">                           cycle-&gt;conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 信号处理 */</span><br><span class="line">    if (ngx_signal) &#123;</span><br><span class="line">        return ngx_signal_process(cycle, ngx_signal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_os_status(cycle-&gt;log);</span><br><span class="line"></span><br><span class="line">    ngx_cycle = cycle;</span><br><span class="line"></span><br><span class="line">    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line">    if (ccf-&gt;master &amp;&amp; ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        ngx_process = NGX_PROCESS_MASTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if !(NGX_WIN32)</span><br><span class="line"></span><br><span class="line">    /* 初始化信号，注册相关信号 */</span><br><span class="line">    if (ngx_init_signals(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 若无socket继承，则创建守护进程，并设置守护进程标志 */</span><br><span class="line">    if (!ngx_inherited &amp;&amp; ccf-&gt;daemon) &#123;</span><br><span class="line">        if (ngx_daemon(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_inherited) &#123;</span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* 记录进程ID */</span><br><span class="line">    if (ngx_create_pidfile(&amp;ccf-&gt;pid, cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_log_redirect_stderr(cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (log-&gt;file-&gt;fd != ngx_stderr) &#123;</span><br><span class="line">        if (ngx_close_file(log-&gt;file-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,</span><br><span class="line">                          ngx_close_file_n &quot; built-in log failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_use_stderr = 0;</span><br><span class="line"></span><br><span class="line">    /* 进入进程处理 */</span><br><span class="line">    if (ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        /* 单进程工作模式 */</span><br><span class="line">        ngx_single_process_cycle(cycle);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* master-worker 多进程模式工作 */</span><br><span class="line">        ngx_master_process_cycle(cycle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The real difference between $host and $http_host]]></title>
      <url>/The-real-difference-between-$host-and-$http_host.html</url>
      <content type="html"><![CDATA[<p>Nginx中$host与$http_host的区别<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The wiki page of &quot;$host&quot; says $host and $host_addr are different only when there is no &quot;Host&quot; header or the &quot;Host&quot; header is empty. But I found when &quot;Host&quot; contains port number, $host never contains the port number while $http_host is equal to the value of &quot;Host&quot; header. </span><br><span class="line"></span><br><span class="line">That is, if &quot;Host: foo:8080&quot;, then </span><br><span class="line">$http_host = foo:8080 </span><br><span class="line">$host = foo </span><br><span class="line"></span><br><span class="line">$http_host是request里的host header </span><br><span class="line">$host是server&#123;&#125;里的server_name里的第一个</span><br><span class="line"></span><br><span class="line">&quot;192.168.160.1&quot; http_host:&quot;192.168.160.159:808&quot; host:&quot;192.168.160.159&quot; &quot;[08/Apr/2016:15:37:06 +0800]&quot; &quot;GET / HTTP/1.1&quot; &quot;304&quot; &quot;0&quot; &quot;171&quot; &quot;-&quot; &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;0.000&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> host </tag>
            
            <tag> http_host </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7-rc-local不起作用修复]]></title>
      <url>/centos7-rc-local%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E4%BF%AE%E5%A4%8D.html</url>
      <content type="html"><![CDATA[<p>在centos7版本以下的系统中, 尝尝用rc.local 自动启动一些软件. 但是在centos7 中 默认rc.local 是不起作用的, centos7 中把 SysV 替换成  system 。centos7保留了rc.local ,只需要简单的设置就可以开启.</p>
<a id="more"></a>
<h1 id="设置rc-local-权限"><a href="#设置rc-local-权限" class="headerlink" title="设置rc.local 权限"></a>设置rc.local 权限</h1><p>我们在一下目录可以看见rc.local<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.local</span><br><span class="line">/etc/rc.d/rc.local</span><br><span class="line">#/etc/rc.local 是 /etc/rc.d/rc.local的软连接</span><br></pre></td></tr></table></figure></p>
<p>chmod +x /etc/rc.d/rc.local </p>
<h1 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable  rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="启动rc-local-service"><a href="#启动rc-local-service" class="headerlink" title="启动rc-local.service"></a>启动rc-local.service</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start   rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="在-etc-rc-local-编写启动软件指令"><a href="#在-etc-rc-local-编写启动软件指令" class="headerlink" title="在/etc/rc.local 编写启动软件指令"></a>在/etc/rc.local 编写启动软件指令</h1>]]></content>
      
        <categories>
            
            <category> centos7 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos7 </tag>
            
            <tag> rc.local </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言结构体研究]]></title>
      <url>/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%A0%94%E7%A9%B6.html</url>
      <content type="html"><![CDATA[<p>总结一些C语言结构体中常用的知识点</p>
<a id="more"></a>
<h1 id="C-语言结构体之点运算符-和箭头运算符-gt-的区别"><a href="#C-语言结构体之点运算符-和箭头运算符-gt-的区别" class="headerlink" title="C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别"></a>C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别</h1><blockquote>
<p>相同点：两者都是二元操作符，而且右边的操作数都是成员的名称。<br>不通点：点运算符( . )的左边操作数是一个结果为结构的表达式；</p>
<blockquote>
<p>箭头运算符( -&gt; )的左边的操作数是一个指向结构体的指针。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct          // 定义一个结构体类型：TEST</span><br><span class="line">&#123;</span><br><span class="line">    int age;            // 结构体成员：age</span><br><span class="line">&#125;TEST;</span><br><span class="line">TEST data;              // 声明一个结构体变量</span><br><span class="line">TEST *pdata;            // 声明一个指向结构体的指针</span><br><span class="line">// 访问数据操作如下：</span><br><span class="line">data.age = 24;          // 结构体变量通过点运算符( . )访问</span><br><span class="line">pdata-&gt;age = 24;        // 指向结构体的指针通过箭头运算符( -&gt; )访问</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Faile- to-star- component-Unable-to-register-MBean]]></title>
      <url>/Failed%20to%20start%20component.html</url>
      <content type="html"><![CDATA[<p>部署springboot war包到 tomcat出现以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[]]</span><br><span class="line">Caused by: org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><blockquote>
<p>需要为每个项目配置JMX的域，  修改application.properties中的属性spring.jmx.default-domain=applicationname</p>
</blockquote>
<h1 id="spring-jmx-default-domain"><a href="#spring-jmx-default-domain" class="headerlink" title="spring.jmx.default-domain"></a>spring.jmx.default-domain</h1><blockquote>
<p>解决tomcat同时部署两个SpringBoot应用提示InstanceAlreadyExistsException</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
