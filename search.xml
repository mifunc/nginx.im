<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[stream/stream_processing-nginx中文手册]]></title>
      <url>/ngx/stream/stream_processing.html</url>
      <content type="html"><![CDATA[<p>stream,stream_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理TCP-UDP会话"><a href="#nginx如何处理TCP-UDP会话" class="headerlink" title="nginx如何处理TCP / UDP会话"></a>nginx如何处理TCP / UDP会话</h2><p>  来自客户端的TCP / UDP会话在称为<strong>阶段的</strong>连续步骤中处理： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_zone_sync_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_zone_sync_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_zone_sync_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-zone-sync-module"><a href="#Module-ngx-stream-zone-sync-module" class="headerlink" title="Module ngx_stream_zone_sync_module"></a>Module ngx_stream_zone_sync_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#zone_sync">zone_sync</a> <br>     <a href="#zone_sync_buffers">zone_sync_buffers</a> <br>     <a href="#zone_sync_connect_retry_interval">zone_sync_connect_retry_interval</a> <br>     <a href="#zone_sync_connect_timeout">zone_sync_connect_timeout</a> <br>     <a href="#zone_sync_interval">zone_sync_interval</a> <br>     <a href="#zone_sync_recv_buffer_size">zone_sync_recv_buffer_size</a> <br>     <a href="#zone_sync_server">zone_sync_server</a> <br>     <a href="#zone_sync_ssl">zone_sync_ssl</a> <br>     <a href="#zone_sync_ssl_certificate">zone_sync_ssl_certificate</a> <br>     <a href="#zone_sync_ssl_certificate_key">zone_sync_ssl_certificate_key</a> <br>     <a href="#zone_sync_ssl_ciphers">zone_sync_ssl_ciphers</a> <br>     <a href="#zone_sync_ssl_crl">zone_sync_ssl_crl</a> <br>     <a href="#zone_sync_ssl_name">zone_sync_ssl_name</a> <br>     <a href="#zone_sync_ssl_password_file">zone_sync_ssl_password_file</a> <br>     <a href="#zone_sync_ssl_protocols">zone_sync_ssl_protocols</a> <br>     <a href="#zone_sync_ssl_server_name">zone_sync_ssl_server_name</a> <br>     <a href="#zone_sync_ssl_trusted_certificate">zone_sync_ssl_trusted_certificate</a> <br>     <a href="#zone_sync_ssl_verify">zone_sync_ssl_verify</a> <br>     <a href="#zone_sync_ssl_verify_depth">zone_sync_ssl_verify_depth</a> <br>     <a href="#zone_sync_timeout">zone_sync_timeout</a> <br> <a href="#stream_zone_sync_status">API endpoints</a> <br> <a href="#controlling_cluster_node">Starting, stopping, removing a cluster node</a> <br></td>

<p>   <code>ngx_stream_zone_sync_module</code>模块（1.13.8）为在集群节点之间同步<a href="ngx_stream_upstream_module.html#zone">共享内存区域的</a>内容提供必要的支持。  要为特定区域启用同步，相应的模块必须支持此功能。  目前，可以在<a href="http/ngx_http_keyval_module.html">http</a>和<a href="stream/ngx_stream_keyval_module.html">流中</a>同步HTTP <a href="http/ngx_http_upstream_module.html#sticky">粘性</a>会话，有关<a href="http/ngx_http_limit_req_module.html">过多HTTP请求的</a>信息和键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  最小配置： </p>
<pre class="notranslate">http {
    ...

    upstream backend {
       server backend1.example.com:8080;
       server backend2.example.com:8081;

       sticky learn
              create=$upstream_cookie_examplecookie
              lookup=$cookie_examplecookie
              zone=client_sessions:1m **sync** ;
    }

    ...
}

stream {
    ...


    server {
        zone_sync;

        listen 127.0.0.1:8090;

        # cluster of 2 nodes
        zone_sync_server a.example.com;
        zone_sync_server b.example.com;

    }
</pre>

<p>  启用了SSL并且由DNS定义的集群成员的更复杂配置： </p>
<pre class="notranslate">...

stream {
    ...

    resolver 127.0.0.1 valid=10s;

    server {
        zone_sync;

        # the name resolves to multiple addresses that correspond to cluster nodes
        zone_sync_server cluster.example.com resolve;

        listen 127.0.0.1:4433 ssl;

        ssl_certificate     localhost.crt;
        ssl_certificate_key localhost.key;

        zone_sync_ssl on;

        zone_sync_ssl_certificate     localhost.crt;
        zone_sync_ssl_certificate_key localhost.key;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  启用集群节点之间的共享内存区域同步。  使用<a href="#zone_sync_server">zone_sync_server</a>指令定义集群节点。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_buffers 256 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置用于推送区域内容的每个区域缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_connect_retry_interval*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_connect_retry_interval 1s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义到另一个群集节点的连接尝试之间的间隔。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_connect_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义与另一个群集节点建立连接的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_interval*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_interval 1s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义在共享内存区域中轮询更新的时间间隔。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_recv_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_recv_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置用于解析传入的同步消息流的每连接接收缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_server*address*</code> [ <code>resolve</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  定义群集节点的<code>*address*</code> 。  可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  解析为多个IP地址的域名一次定义多个节点。 </p>
<p>   <code>resolve</code>参数指示nginx监视与节点域名对应的IP地址的更改，并自动修改配置，而无需重新启动nginx。 </p>
<p>  群集节点可以动态指定为带有<code>resolve</code>参数的单个<code>zone_sync_server</code>指令，也可以静态指定为一系列不带参数的指令。 </p>
<blockquote>
<p>  每个群集节点只应指定一次。 </p>
<p>  所有群集节点都应使用相同的配置。 </p>
</blockquote>
<p>  为了使<code>resolve</code>参数起作用，必须在<a href="ngx_stream_core_module.html#stream">流</a>块中指定<a href="ngx_stream_core_module.html#resolver">解析器</a>指令。  例： </p>
<pre class="notranslate">stream {
    resolver 10.0.0.1;

    server {
        zone_sync;
        zone_sync_server cluster.example.com resolve;
        ...
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用S​​SL / TLS协议以连接到另一个群集服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对另一个群集服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对另一个群集服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定用于连接到另一个群集服务器的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#zone_sync_ssl_verify">验证</a>另一个群集服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_name host from zone_sync_server;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  允许覆盖用于<a href="#zone_sync_ssl_verify">验证</a>群集服务器证书的服务器名称，并在与群集服务器建立连接时<a href="#zone_sync_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#zone_sync_server">zone_sync_server</a>地址的主机部分，如果指定了<a href="#resolve">resolve</a>参数，则使用已解析的IP地址。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议以连接到另一个群集服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  在与另一个群集服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#zone_sync_ssl_verify">验证</a>另一个群集服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用或禁用其他群集服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在另一个群集服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置与另一个群集节点连接时两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<h4 id="API端点"><a href="#API端点" class="headerlink" title="API端点"></a>API端点</h4><p>  节点的同步状态可通过API的<a href="http/ngx_http_api_module.html#stream_zone_sync_">/ stream / zone_sync /</a> endpoint获得，它返回<a href="http/ngx_http_api_module.html#def_nginx_stream_zone_sync">以下</a>度量标准。 </p>
<h4 id="启动，停止，删除群集节点"><a href="#启动，停止，删除群集节点" class="headerlink" title="启动，停止，删除群集节点"></a>启动，停止，删除群集节点</h4><p>  要启动新节点，请使用新节点的IP地址更新群集主机名的DNS记录并启动实例。  新节点将从DNS或静态配置中发现其他节点，并将开始向它们发送更新。  其他节点最终将使用DNS发现新节点并开始向其推送更新。  在静态配置的情况下，需要重新加载其他节点以便将更新发送到新节点。 </p>
<p>  要停止节点，请将<code>QUIT</code>信号发送到实例。  该节点将完成区域同步并正常关闭打开的连接。 </p>
<p>  要删除节点，请更新群集主机名的DNS记录，并删除该节点的IP地址。  所有其他节点最终将发现节点已被删除，关闭与节点的连接，并且将不再尝试连接到节点。  移除节点后，可以如上所述停止节点。  在静态配置的情况下，需要重新加载其他节点以便停止向已删除节点发送更新。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-module"><a href="#Module-ngx-stream-upstream-module" class="headerlink" title="Module ngx_stream_upstream_module"></a>Module ngx_stream_upstream_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream">upstream</a> <br>     <a href="#server">server</a> <br>     <a href="#zone">zone</a> <br>     <a href="#state">state</a> <br>     <a href="#hash">hash</a> <br>     <a href="#least_conn">least_conn</a> <br>     <a href="#least_time">least_time</a> <br>     <a href="#random">random</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_upstream_module</code>模块（1.9.0）用于定义可由<a href="ngx_stream_proxy_module.html#proxy_pass">proxy_pass</a>指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream **backend** {
    hash $remote_addr consistent;

    server backend1.example.com:12345  weight=5;
    server backend2.example.com:12345;
    server unix:/tmp/backend3;

    server backup1.example.com:12345   backup;
    server backup2.example.com:12345   backup;
}

server {
    listen 12346;
    proxy_pass **backend** ;
}
</pre>



<p>  具有定期<a href="ngx_stream_upstream_hc_module.html">运行状况检查的</a>动态可配置组可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分： </p>
<pre class="notranslate">resolver 10.0.0.1;

upstream **dynamic** {
    zone upstream_dynamic 64k;

    server backend1.example.com:12345 weight=5;
    server backend2.example.com:12345 fail_timeout=5s slow_start=30s;
    server 192.0.2.1:12345            max_fails=3;
    server backend3.example.com:12345 resolve;
    server backend4.example.com       service=http resolve;

    server backup1.example.com:12345  backup;
    server backup2.example.com:12345  backup;
}

server {
    listen 12346;
    proxy_pass **dynamic** ;
    health_check;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  定义一组服务器。  服务器可以侦听不同的端口。  此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com:12345 weight=5;
    server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend2;
    server backend3.example.com:12345 resolve;

    server backup1.example.com:12345  backup;
}
</pre>



<p>  默认情况下，使用加权循环平衡方法在服务器之间分配连接。  在上面的示例中，每个7个连接将按如下方式分发：5个连接到<code>backend1.example.com:12345</code>并且每个连接到第二个和第三个服务器。  如果在与服务器通信期间发生错误，则连接将传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。  如果与所有服务器的通信失败，则将关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server*address*</code> [ <code>*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义服务器的<code>*address*</code>和其他<code>*parameters*</code> 。  可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  解析为多个IP地址的域名一次定义多个服务器。 </p>
<p>  可以定义以下参数： </p>
<blockquote>
<p>  在1.11.5版之前，此参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
<ul>
<li>指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; -   以及服务器被视为不可用的时间段。 </li>
</ul>
</blockquote>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<p>  要使此参数起作用，必须在<a href="ngx_stream_core_module.html#stream">流</a>块中指定<a href="ngx_stream_core_module.html#resolver">解析程序</a>指令。  例： </p>
<pre class="notranslate">stream {
    resolver 10.0.0.1;

    upstream u {
        zone ...;
        ...
        server example.com:12345 resolve;
    }
}
</pre>



<p>  如果服务名称不包含点（“ <code>.</code> ”），则构造符合<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC</a>的名称，并将TCP协议添加到服务前缀。  例如，要查找<code>_http._tcp.backend.example.com</code> SRV记录，必须指定该指令： </p>
<pre class="notranslate">server backend.example.com service=http resolve;
</pre>

<p>  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。  例如，要查找<code>_http._tcp.backend.example.com</code>和<code>server1.backend.example.com</code> SRV记录，必须指定指令： </p>
<pre class="notranslate">server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</pre>



<p>  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。  如果为服务器指定了<a href="#backup">backup</a>参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
<blockquote>
<p>  该参数不能与<a href="#hash">散列</a>负载平衡方法一起使用。 </p>
<p>  如果组中只有一个服务器，则忽略<code>max_fails</code> ， <code>fail_timeout</code>和<code>slow_start</code>参数，并且永远不会将此类服务器视为不可用。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone*name*</code> [ <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义共享内存区域的<code>*name*</code>和<code>*size*</code> ，该区域保持组工作进程之间共享的组配置和运行时状态。  几个组可能共享同一个区域。  在这种情况下，仅指定一次<code>*size*</code>就足够了。 </p>
<p>  此外，作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。  可通过<a href="http/ngx_http_api_module.html">API</a>模块（1.13.3）访问该配置。 </p>
<blockquote>
<p>  在1.13.3版之前，只能通过<a href="http/ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a>处理的特殊位置访问配置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**state*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  指定保持动态可配置组状态的<code>*file*</code> 。 </p>
<p>  例子： </p>
<pre class="notranslate">state /var/lib/nginx/state/servers.conf; # path for Linux
state /var/db/nginx/state/servers.conf;  # path for FreeBSD
</pre>



<p>  该状态目前仅限于具有其参数的服务器列表。  解析配置时会读取文件，每次<a href="http/ngx_http_api_module.html#stream_upstreams_stream_upstream_name_servers_">更改</a>上游配置时都会更新该文件。  应避免直接更改文件内容。  该指令不能与<a href="#server">server</a>指令一起使用。 </p>
<blockquote>
<p>   <a href="control.html#reconfiguration">配置重新加载</a>或<a href="control.html#upgrade">二进制升级</a>期间所做的更改可能会丢失。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hash*key*</code> [ <code>consistent</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<code>*key*</code> 。   <code>*key*</code>可以包含文本，变量及其组合（1.11.2）。  用法示例： </p>
<pre class="notranslate">hash $remote_addr;
</pre>

<p>  请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached" target="_blank" rel="noopener">Cache :: Memcached</a> Perl库兼容。 </p>
<p>  如果指定了<code>consistent</code>参数，则将使用<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="noopener">ketama</a>一致性哈希方法。  该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。  这有助于为缓存服务器实现更高的缓存命中率。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached::Fast" target="_blank" rel="noopener">Cache :: Memcached :: Fast</a> Perl库兼容，并将<code>*ketama_points*</code>参数设置为160。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_conn** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中将连接传递到具有最少活动连接的服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_time**     &lt;code class=&quot;notranslate&quot;&gt;connect</code> |    <code>first_byte</code> |    <code>last_byte</code>    [ <code>inflight</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中连接以最少的平均时间和最少的活动连接传递到服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p>  如果指定了<code>connect</code>参数，则使用<a href="#var_upstream_connect_time">连接</a>到上游服务器的时间。  如果指定了<code>first_byte</code>参数，则使用接收数据的<a href="#var_upstream_first_byte_time">第一个字节</a>的时间。  如果指定了<code>last_byte</code>则使用接收<a href="#var_upstream_session_time">最后一个</a>数据<a href="#var_upstream_session_time">字节</a>的时间。  如果指定了<code>inflight</code>参数（1.11.6），则还会考虑不完整的连接。 </p>
<blockquote>
<p>  在1.11.6版之前，默认情况下会考虑不完整的连接。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random** [ &lt;code class=&quot;notranslate&quot;&gt;two</code> [ <code>*method*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.1版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将连接传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p>  可选的<code>two</code>参数指示nginx随机选择<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="noopener">两个</a>服务器，然后使用指定的<code>method</code>选择服务器。  默认方法是<code>least_conn</code> ，它将连接传递给具有最少活动连接数的服务器。 </p>
<p>   <code>least_time</code>方法将连接传递给平均时间最短且活动连接数最少的服务器。  如果指定了<code>least_time=connect</code>参数，则使用<a href="#var_upstream_connect_time">连接</a>到上游服务器的时间。  如果指定了<code>least_time=first_byte</code>参数，则使用接收数据的<a href="#var_upstream_first_byte_time">第一个字节</a>的时间。  如果指定了<code>least_time=last_byte</code>则使用接收<a href="#var_upstream_session_time">最后一个</a>数据<a href="#var_upstream_session_time">字节</a>的时间。 </p>
<blockquote>
<p>   <code>least_time</code>方法可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅</a>的一部分。 </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_upstream_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-hc-module"><a href="#Module-ngx-stream-upstream-hc-module" class="headerlink" title="Module ngx_stream_upstream_hc_module"></a>Module ngx_stream_upstream_hc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#health_check">health_check</a> <br>     <a href="#health_check_timeout">health_check_timeout</a> <br>     <a href="#match">match</a> <br></td>

<p>   <code>ngx_stream_upstream_hc_module</code>模块（1.9.0）允许对<a href="ngx_stream_upstream_module.html#upstream">组</a>中的服务器启用定期运行状况检查。  服务器组必须驻留在<a href="ngx_stream_upstream_module.html#zone">共享内存中</a> 。 </p>
<p>  如果运行状况检查失败，则服务器将被视为运行状况不佳。  如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。  客户端连接不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream tcp {
    zone upstream_tcp 64k;

    server backend1.example.com:12345 weight=5;
    server backend2.example.com:12345 fail_timeout=5s slow_start=30s;
    server 192.0.2.1:12345            max_fails=3;

    server backup1.example.com:12345  backup;
    server backup2.example.com:12345  backup;
}

server {
    listen     12346;
    proxy_pass tcp;
    health_check;
}
</pre>

<p>  使用此配置，nginx将检查每五秒钟与<code>tcp</code>组中每个服务器建立TCP连接的能力。  当无法建立与服务器的连接时，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
<p>  可以为UDP协议配置运行状况检查： </p>
<pre class="notranslate">upstream dns_upstream {

    zone   dns_zone 64k;

    server dns1.example.com:53;
    server dns2.example.com:53;
    server dns3.example.com:53;
}

server {
    listen       53 udp;
    proxy_pass   dns_upstream;
    health_check udp;
}
</pre>

<p>  在这种情况下，预期缺少ICMP“ <code>Destination Unreachable</code> ”消息以回复发送的字符串“ <code>nginx health check</code> ”。 </p>
<p>  还可以配置运行状况检查以测试从服务器获取的数据。  测试使用<a href="#match">match</a>伪指令单独配置，并在<a href="#health_check">health_check</a>指令的<code>match</code>参数中引用。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check** [ &lt;code class=&quot;notranslate&quot;&gt;*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  启用对<a href="ngx_stream_upstream_module.html#upstream">组中</a>服务器的定期运行状况检查。 </p>
<p>  支持以下可选参数： </p>
<blockquote>
<p>  在1.11.7版之前，默认情况下，UDP运行状况检查需要带有<a href="#match_send">send</a>和<a href="#match_expect">expect</a>参数的<a href="#hc_match">匹配</a>块。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">health_check_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  覆盖<a href="ngx_stream_proxy_module.html#proxy_timeout">运行</a>状况检查的<a href="ngx_stream_proxy_module.html#proxy_timeout">proxy_timeout</a>值。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**match*name*</code>  { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  定义用于验证服务器对运行状况检查的响应的命名测试集。 </p>
<p>  可以配置以下参数： </p>
<p>   <code>send</code>和<code>expect</code>参数都可以包含十六进制文字，前缀为“ <code>\x</code> ”，后跟两个十六进制数字，例如“ <code>\x80</code> ”（1.9.12）。 </p>
<p>  在下列情况下通过健康检查 </p>
<ul>
<li>TCP连接成功建立; -    <code>send</code>参数中的<code>*string*</code> （如果已指定）已发送; -   如果指定，从服务器获取的数据与<code>expect</code>参数中的字符串或正则表达式匹配; -   经过的时间不超过<a href="#health_check_timeout">health_check_timeout</a>指令中指定的值。 </li>
</ul>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    zone     upstream_backend 10m;
    server   127.0.0.1:12345;
}

match http {
    send     "GET / HTTP/1.0\r\nHost: localhost\r\n\r\n";
    expect ~ "200 OK";
}

server {
    listen       12346;
    proxy_pass   backend;
    health_check match=http;
}
</pre>





<blockquote>
<p>  仅检查从服务器获得的第一个<a href="ngx_stream_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a>字节数据。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_preread_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_preread_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_preread_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-preread-module"><a href="#Module-ngx-stream-ssl-preread-module" class="headerlink" title="Module ngx_stream_ssl_preread_module"></a>Module ngx_stream_ssl_preread_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl_preread">ssl_preread</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_ssl_preread_module</code>模块（1.11.5）允许从<a href="https://tools.ietf.org/html/rfc5246#section-7.4.1.2" target="_blank" rel="noopener">ClientHello</a>消息中提取信息而不终止SSL / TLS，例如，通过<a href="https://tools.ietf.org/html/rfc6066#section-3" target="_blank" rel="noopener">SNI</a>请求的服务器名称或在<a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">ALPN中</a>通告的协议。  默认情况下不构建此模块，应使用<code>--with-stream_ssl_preread_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  根据服务器名称选择上游： </p>
<pre class="notranslate">map $ssl_preread_server_name $name {
    backend.example.com      backend;
    default                  backend2;
}

upstream backend {
    server 192.168.0.1:12345;
    server 192.168.0.2:12345;
}

upstream backend2 {
    server 192.168.0.3:12345;
    server 192.168.0.4:12345;
}

server {
    listen      12346;
    proxy_pass  $name;
    ssl_preread on;
}
</pre>



<p>  根据协议选择上游： </p>
<pre class="notranslate">map $ssl_preread_alpn_protocols $proxy {
    ~\bh2\b           127.0.0.1:8001;
    ~\bhttp/1.1\b     127.0.0.1:8002;
    ~\bxmpp-client\b  127.0.0.1:8003;
}

server {
    listen      9000;
    proxy_pass  $proxy;
    ssl_preread on;
}
</pre>



<p>  根据SSL协议版本选择上游： </p>
<pre class="notranslate">map $ssl_preread_protocol $upstream {
    ""        ssh.example.com:22;
    "TLSv1.2" new.example.com:443;
    default   tls.example.com:443;
}

# ssh and https on the same port
server {
    listen      192.168.0.1:443;
    proxy_pass  $upstream;
    ssl_preread on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prereadon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_preread off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许在<a href="stream_processing.html#preread_phase">预读</a>阶段从ClientHello消息中提取信息。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-module"><a href="#Module-ngx-stream-ssl-module" class="headerlink" title="Module ngx_stream_ssl_module"></a>Module ngx_stream_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_handshake_timeout">ssl_handshake_timeout</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_ssl_module</code>模块（1.9.0）为流代理服务器提供必要的支持，以使用SSL / TLS协议。  默认情况下不构建此模块，应使用<code>--with-stream_ssl_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

stream {

    ...

    server {
        listen              12345 ssl;

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              12345 ssl;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> ，该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_handshake_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_handshake_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定SSL握手完成的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">stream {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        listen 127.0.0.1:12345;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        listen 127.0.0.1:12346;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache**     &lt;code class=&quot;notranslate&quot;&gt;off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client**     &lt;code class=&quot;notranslate&quot;&gt;on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  启用客户端证书验证。  验证结果存储在<a href="#var_ssl_client_verify">$ ssl_client_verify</a>变量中。  如果在客户端证书验证期间发生错误或客户端未提供所需证书，则会关闭连接。 </p>
<p>   <code>optional</code>参数请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数请求客户端证书，但不要求它由可信CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="#var_ssl_client_cert">$ ssl_client_cert</a>变量访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  设置客户端证书链中的验证深度。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_ssl_module</code>模块支持自1.11.2以来的变量。 </p>
<pre class="notranslate">AES128-SHA:AES256-SHA:0x00ff
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。  对于旧版本，该变量仅适用于新会话，仅列出已知密码。 </p>
</blockquote>
<pre class="notranslate">0x001d:prime256v1:secp521r1:secp384r1
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。  对于旧版本，变量值将为空字符串。 </p>
<p>  该变量仅适用于新会话。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-split-clients-module"><a href="#Module-ngx-stream-split-clients-module" class="headerlink" title="Module ngx_stream_split_clients_module"></a>Module ngx_stream_split_clients_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#split_clients">split_clients</a> <br></td>

<p>   <code>ngx_stream_split_clients_module</code>模块（1.11.3）创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    ...
    split_clients "${remote_addr}AAA" $upstream {
                  0.5%                feature_test1;
                  2.0%                feature_test2;
                  *                   production;
    }

    server {
        ...
        proxy_pass $upstream;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**split_clients**     &lt;code class=&quot;notranslate&quot;&gt;*string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  为A / B测试创建变量，例如： </p>
<pre class="notranslate">split_clients "${remote_addr}AAA" $variant {
               0.5%               .one;
               2.0%               .two;
               *                  "";
}
</pre>

<p>  使用MurmurHash2对原始字符串的值进行哈希处理。  在给出的示例中，从0到21474835（0.5％）的哈希值对应于<code>$variant</code>变量的值<code>&quot;.one&quot;</code> ，从21474836到107374180（2％）的哈希值对应于值<code>&quot;.two&quot;</code>和哈希值从107374181到4294967295的值对应于值<code>&quot;&quot;</code> （空字符串）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_return_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_return_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_return_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-return-module"><a href="#Module-ngx-stream-return-module" class="headerlink" title="Module ngx_stream_return_module"></a>Module ngx_stream_return_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#return">return</a> <br></td>

<p>   <code>ngx_stream_return_module</code>模块（1.11.2）允许向客户端发送指定值，然后关闭连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 12345;
    return $time_iso8601;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**return*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  指定要发送到客户端的<code>*value*</code> 。  该值可以包含文本，变量及其组合。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_realip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_realip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-realip-module"><a href="#Module-ngx-stream-realip-module" class="headerlink" title="Module ngx_stream_realip_module"></a>Module ngx_stream_realip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#set_real_ip_from">set_real_ip_from</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_realip_module</code>模块用于将客户端地址和端口更改为PROXY协议头（1.11.4）中发送的端口和端口。  必须先通过在<code>listen</code>指令中设置<a href="ngx_stream_core_module.html#proxy_protocol">proxy_protocol</a>参数来启用PROXY协议。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-stream_realip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">listen 12345 proxy_protocol;

set_real_ip_from  192.168.1.0/24;
set_real_ip_from  192.168.2.1;
set_real_ip_from  2001:0db8::/32;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set_real_ip_from**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义已知可发送正确替换地址的可信地址。  如果指定了特殊值<code>unix:</code>则所有UNIX域套接字都将受信任。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_proxy_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_proxy_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-proxy-module"><a href="#Module-ngx-stream-proxy-module" class="headerlink" title="Module ngx_stream_proxy_module"></a>Module ngx_stream_proxy_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#proxy_bind">proxy_bind</a> <br>     <a href="#proxy_buffer_size">proxy_buffer_size</a> <br>     <a href="#proxy_connect_timeout">proxy_connect_timeout</a> <br>     <a href="#proxy_download_rate">proxy_download_rate</a> <br>     <a href="#proxy_next_upstream">proxy_next_upstream</a> <br>     <a href="#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> <br>     <a href="#proxy_next_upstream_tries">proxy_next_upstream_tries</a> <br>     <a href="#proxy_pass">proxy_pass</a> <br>     <a href="#proxy_protocol">proxy_protocol</a> <br>     <a href="#proxy_requests">proxy_requests</a> <br>     <a href="#proxy_responses">proxy_responses</a> <br>     <a href="#proxy_socket_keepalive">proxy_socket_keepalive</a> <br>     <a href="#proxy_ssl">proxy_ssl</a> <br>     <a href="#proxy_ssl_certificate">proxy_ssl_certificate</a> <br>     <a href="#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> <br>     <a href="#proxy_ssl_ciphers">proxy_ssl_ciphers</a> <br>     <a href="#proxy_ssl_crl">proxy_ssl_crl</a> <br>     <a href="#proxy_ssl_name">proxy_ssl_name</a> <br>     <a href="#proxy_ssl_password_file">proxy_ssl_password_file</a> <br>     <a href="#proxy_ssl_protocols">proxy_ssl_protocols</a> <br>     <a href="#proxy_ssl_server_name">proxy_ssl_server_name</a> <br>     <a href="#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> <br>     <a href="#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> <br>     <a href="#proxy_ssl_verify">proxy_ssl_verify</a> <br>     <a href="#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> <br>     <a href="#proxy_timeout">proxy_timeout</a> <br>     <a href="#proxy_upload_rate">proxy_upload_rate</a> <br></td>

<p>   <code>ngx_stream_proxy_module</code>模块（1.9.0）允许通过TCP，UDP（1.9.13）和UNIX域套接字代理数据流。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 127.0.0.1:12345;
    proxy_pass 127.0.0.1:8080;
}

server {
    listen 12345;
    proxy_connect_timeout 1s;
    proxy_timeout 1m;
    proxy_pass example.com:12345;
}

server {
    listen 53 udp reuseport;
    proxy_timeout 20s;
    proxy_pass dns.example.com:53;
}

server {
    listen [::1]:12345;
    proxy_pass unix:/tmp/stream.socket;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  使与代理服务器的传出连接源自指定的本地IP <code>*address*</code> 。  参数值可以包含变量（1.11.2）。  特殊值<code>off</code>取消了从先前配置级别继承的<code>proxy_bind</code>指令的效果，允许系统自动分配本地IP地址。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">proxy_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.4版本中。 </p>
<p>  设置用于从代理服务器读取数据的缓冲区的<code>*size*</code> 。  还设置用于从客户端读取数据的缓冲区的<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义与代理服务器建立连接的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_download_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_download_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.3版本中。 </p>
<p>  限制从代理服务器读取数据的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  每个连接设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstreamon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  当无法建立与代理服务器的连接时，确定是否将客户端连接传递给下一个服务器。 </p>
<p>  将连接传递到下一个服务器可能会受到<a href="#proxy_next_upstream_tries">尝试次数</a>和<a href="#proxy_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  限制将连接传递给<a href="#proxy_next_upstream">下一个服务器所</a>允许的时间。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  限制将连接传递到<a href="#proxy_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置代理服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">proxy_pass localhost:12345;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">proxy_pass unix:/tmp/stream.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_stream_upstream_module.html">服务器组</a> 。 </p>
<p>  也可以使用变量（1.11.3）指定地址： </p>
<pre class="notranslate">proxy_pass $upstream;
</pre>

<p>  在这种情况下，在所描述的<a href="ngx_stream_upstream_module.html">服务器组中</a>搜索服务器名称，并且如果未找到，则使用<a href="ngx_stream_core_module.html#resolver">解析器</a>来确定服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_protocolon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_protocol off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  启用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a>以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_requests 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  设置客户端与现有UDP流会话之间的绑定被删除的客户端数据报的数量。  在收到指定数量的数据报后，来自同一客户端的下一个数据报将启动一个新会话。  当所有客户端数据报都传输到代理服务器并且收到预期的<a href="#proxy_responses">响应</a>数时，或者当它达到<a href="#proxy_timeout">超时</a>时，会话终止。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_responses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.13版本中。 </p>
<p>  如果使用<a href="ngx_stream_core_module.html#udp">UDP</a>协议，则设置代理服务器响应客户端数据报所需的数据报数。  该号码用作会话终止的提示。  默认情况下，数据报的数量不受限制。 </p>
<p>  如果指定零值，则不期望响应。  但是，如果收到响应且会话仍未完成，则将处理响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到代理服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用S​​SL / TLS协议以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对代理服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对代理服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定与代理服务器的连接的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_name host from proxy_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许覆盖用于<a href="#proxy_ssl_verify">验证</a>代理服务器证书的服务器名称，并在与代理服务器建立连接时<a href="#proxy_ssl_server_name">通过SNI传递</a> 。  也可以使用变量（1.11.3）指定服务器名称。 </p>
<p>  默认情况下，使用<a href="#proxy_pass">proxy_pass</a>地址的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在与代理服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  确定在使用代理服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用或禁用代理服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在代理服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_timeout 10m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_upload_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_upload_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.3版本中。 </p>
<p>  限制从客户端读取数据的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据连接设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_map_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_map_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-map-module"><a href="#Module-ngx-stream-map-module" class="headerlink" title="Module ngx_stream_map_module"></a>Module ngx_stream_map_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#map">map</a> <br>     <a href="#map_hash_bucket_size">map_hash_bucket_size</a> <br>     <a href="#map_hash_max_size">map_hash_max_size</a> <br></td>

<p>   <code>ngx_stream_map_module</code>模块（1.11.2）创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">map $remote_addr $limit {
    127.0.0.1    "";
    default      $binary_remote_addr;
}

limit_conn_zone $limit zone=addr:10m;
limit_conn addr 1;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map**     &lt;code class=&quot;notranslate&quot;&gt;*string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使是大量“ <code>map</code> ”变量的声明也不会给连接处理增加任何额外成本。 </p>
</blockquote>
<p>  地图块内的参数指定源和结果值之间的映射。 </p>
<p>  源值指定为字符串或正则表达式。 </p>
<p>  字符串匹配忽略大小写。 </p>
<p>  正则表达式应该从“ <code>~</code> ”符号开始，用于区分大小写的匹配，或者从“ <code>~*</code> ”符号开始，用于不区分大小写的匹配。  正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p>  如果源值与下面描述的特殊参数名称之一匹配，则应使用“ <code>\</code> ”符号作为前缀。 </p>
<p>  结果值可以包含文本，变量及其组合。 </p>
<p>  还支持以下特殊参数： </p>
<pre class="notranslate">*.example.com 1;
example.*     1;
</pre>

<pre class="notranslate">example.com   1;
*.example.com 1;
</pre>

<pre class="notranslate">.example.com  1;
</pre>



<p>  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
<ol>
<li>没有掩码的字符串值 1.   带有前缀掩码的最长字符串值，例如“ <code>*.example.com</code> ” 1.   带有后缀掩码的最长字符串值，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） 1.   默认值 </li>
</ol>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_bucket_size 32|64|128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的存储区大小。  默认值取决于处理器的缓存行大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_log_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_log_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-log-module"><a href="#Module-ngx-stream-log-module" class="headerlink" title="Module ngx_stream_log_module"></a>Module ngx_stream_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#access_log">access_log</a> <br>     <a href="#log_format">log_format</a> <br>     <a href="#open_log_file_cache">open_log_file_cache</a> <br></td>

<p>   <code>ngx_stream_log_module</code>模块（1.11.4）以指定的格式写入会话日志。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">log_format basic '$remote_addr [$time_local] '
                 '$protocol $status $bytes_sent $bytes_received '
                 '$session_time';

access_log /spool/logs/nginx-access.log basic buffer=32k;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**access_log**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    <code>*format*</code>    [ <code>buffer</code> = <code>*size*</code> ]    [ <code>gzip[= &lt;code class=&quot;notranslate&quot;&gt;*level*</code> ] ]    [ <code>flush</code> = <code>*time*</code> ]    [ <code>if</code> = <code>*condition*</code> ]; <br> <code>**access_logoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">access_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置缓冲日志写入的路径， <a href="#log_format">格式</a>和配置。  可以在同一级别指定多个日志。  可以通过在第一个参数中指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  特殊值<code>off</code>取消当前级别的所有<code>access_log</code>指令。 </p>
<p>  如果使用<code>buffer</code>或<code>gzip</code>参数，则将缓冲对log的写入。 </p>
<blockquote>
<p>  缓冲区大小不得超过磁盘文件的原子写入大小。  对于FreeBSD，这个大小是无限的。 </p>
</blockquote>
<p>  启用缓冲后，数据将写入文件： </p>
<ul>
<li>如果下一个日志行不适合缓冲区; -   如果缓冲的数据早于<code>flush</code>参数指定的数据; -   当工作进程<a href="control.html">重新打开</a>日志文件或正在关闭时。 </li>
</ul>
<p>  如果使用<code>gzip</code>参数，则在写入文件之前将压缩缓冲的数据。  压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。  默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ <code>zcat</code> ”解压缩或读取。 </p>
<p>  例： </p>
<pre class="notranslate">access_log /path/to/log.gz basic gzip flush=5m;
</pre>





<blockquote>
<p>  要使gzip压缩起作用，必须使用zlib库构建nginx。 </p>
</blockquote>
<p>  文件路径可以包含变量，但是这样的日志有一些约束： </p>
<ul>
<li>工作进程使用其凭据的<a href="ngx_core_module.html#user">用户</a>应具有在具有此类日志的目录中创建文件的权限; -   缓冲写入不起作用; -   每个日志写入都会打开和关闭该文件。  但是，由于常用文件的描述符可以存储在<a href="#open_log_file_cache">缓存中</a> ，因此写入旧文件可以在<a href="#open_log_file_cache">open_log_file_cache</a>指令的<code>valid</code>参数指定的时间内继续写入 </li>
</ul>
<p>   <code>if</code>参数启用条件记录。  如果<code>*condition*</code>计算为“0”或空字符串，则不会记录会话。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**log_format**     &lt;code class=&quot;notranslate&quot;&gt;*name*</code>    [ <code>escape</code> = <code>default</code> | <code>json</code> | <code>none</code> ]    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定日志格式，例如： </p>
<pre class="notranslate">log_format proxy '$remote_addr [$time_local] '
                 '$protocol $status $bytes_sent $bytes_received '
                 '$session_time "$upstream_addr" '
                 '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';
</pre>



<p>   <code>escape</code>参数（1.11.8）允许设置在变量中转义的<code>json</code>或<code>default</code>字符，默认情况下，使用<code>default</code>转义。   <code>none</code>参数（1.13.10）禁用转义。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**open_log_file_cachemax</code> = <code>*N*</code>[ <code>inactive</code> = <code>*time*</code> ][ <code>min_uses</code> = <code>*N*</code> ][ <code>valid</code> = <code>*time*</code> ]; <br> <code>**open_log_file_cacheoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">open_log_file_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。  该指令具有以下参数： </p>
<p>  用法示例： </p>
<pre class="notranslate">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-limit-conn-module"><a href="#Module-ngx-stream-limit-conn-module" class="headerlink" title="Module ngx_stream_limit_conn_module"></a>Module ngx_stream_limit_conn_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_conn">limit_conn</a> <br>     <a href="#limit_conn_log_level">limit_conn_log_level</a> <br>     <a href="#limit_conn_zone">limit_conn_zone</a> <br></td>

<p>   <code>ngx_stream_limit_conn_module</code>模块（1.9.3）用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    limit_conn_zone $binary_remote_addr zone=addr:10m;

    ...

    server {

        ...

        limit_conn           addr 1;
        limit_conn_log_level error;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn*zone*</code> <code>*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置共享内存区域和给定键值的最大允许连接数。  超过此限制时，服务器将关闭连接。  例如，指令 </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    ...
    limit_conn addr 1;
}
</pre>

<p>  每次只允许一个IP地址连接一个。 </p>
<p>  如果指定了几个<code>limit_conn</code>指令，则将应用任何已配置的限制。 </p>
<p>  当且仅当当前级别没有<code>limit_conn</code>指令时，指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_zone**     &lt;code class=&quot;notranslate&quot;&gt;*key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态包括当前的连接数。   <code>*key*</code>可以包含文本，变量及其组合（1.11.2）。  不计算具有空键值的连接。  用法示例： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;
</pre>

<p>  这里，密钥是<code>$binary_remote_addr</code>变量设置的客户端IP地址。   <code>$binary_remote_addr</code>的大小为IPv4地址的4个字节或IPv6地址的16个字节。  存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。  一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。  如果区域存储耗尽，服务器将关闭连接。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_keyval_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_keyval_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-keyval-module"><a href="#Module-ngx-stream-keyval-module" class="headerlink" title="Module ngx_stream_keyval_module"></a>Module ngx_stream_keyval_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#keyval">keyval</a> <br>     <a href="#keyval_zone">keyval_zone</a> <br></td>

<p>   <code>ngx_stream_keyval_module</code>模块（1.13.7）创建的变量的值取自<a href="http/ngx_http_api_module.html#stream_keyvals_">API</a>管理的键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    server {
        ...
        location /api {
            api write=on;
        }
    }
}

stream {

    keyval_zone zone=one:32k state=one.keyval;
    keyval      $ssl_server_name $name zone=one;

    server {
        listen              12345 ssl;
        proxy_pass          $name;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval**     &lt;code class=&quot;notranslate&quot;&gt;*key*</code>    <code>*$variable*</code>    <code>zone</code> = <code>*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  创建一个新的<code>*$variable*</code>其值由<code>*key*</code>数据库中的键查找。  字符串匹配忽略大小写。  数据库存储在<code>zone</code>参数指定的共享内存区域中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval_zone**     &lt;code class=&quot;notranslate&quot;&gt;zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>state</code> = <code>*file*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置保留键值数据库的共享内存区域的<code>*name*</code>和<code>*size*</code> 。  键值对由<a href="http/ngx_http_api_module.html#stream_keyvals_">API</a>管理。 </p>
<p>  可选的<code>state</code>参数指定一个<code>*file*</code> ，该<code>*file*</code>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p>  可选的<code>timeout</code>参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p>  可选的<code>sync</code>参数（1.15.0）可以<a href="ngx_stream_zone_sync_module.html#zone_sync">同步</a>共享内存区域。  同步需要设置<a href="#keyval_timeout">超时</a>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_js_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_js_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-js-module"><a href="#Module-ngx-stream-js-module" class="headerlink" title="Module ngx_stream_js_module"></a>Module ngx_stream_js_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#js_access">js_access</a> <br>     <a href="#js_filter">js_filter</a> <br>     <a href="#js_include">js_include</a> <br>     <a href="#js_preread">js_preread</a> <br>     <a href="#js_set">js_set</a> <br> <a href="#properties">Session Object Properties</a> <br></td>

<p>   <code>ngx_stream_js_module</code>模块用于在<a href="njs/index.html">njs中</a>实现处理程序 - 这是JavaScript语言的一个子集。 </p>
<p>  默认情况下不构建此模块。  可<a href="njs/install.html">在此处</a>下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>  此示例适用于njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>及更高版本。  对于njs 0.2.3及更早版本，请使用<a href="njs/examples.html#legacy">此</a>示例。 </p>
</blockquote>
<pre class="notranslate">load_module modules/ngx_stream_js_module.so;
...

stream {
    js_include stream.js;

    js_set $bar bar;
    js_set $req_line req_line;

    server {
        listen 12345;

        js_preread preread;
        return     $req_line;
    }

    server {
        listen 12346;

        js_access  access;
        proxy_pass 127.0.0.1:8000;
        js_filter  header_inject;
    }
}

http {
    server {
        listen 8000;
        location / {
            return 200 $http_foo\n;
        }
    }
}
</pre>



<p>   <code>stream.js</code>文件： </p>
<pre class="notranslate">var line = '';

function bar(s) {
    var v = s.variables;
    s.log("hello from bar() handler!");
    return "bar-var" + v.remote_port + "; pid=" + v.pid;
}

function preread(s) {
    s.on('upload', function (data, flags) {
        var n = data.indexOf('\n');
        if (n != -1) {
            line = data.substr(0, n);
            s.done();
        }
    });
}

function req_line(s) {
    return line;
}

// Read HTTP request line.
// Collect bytes in 'req' until
// request line is read.
// Injects HTTP header into a client's request

var my_header =  'Foo: foo';
function header_inject(s) {
    var req = '';
    s.on('upload', function(data, flags) {
        req += data;
        var n = req.search('\n');
        if (n != -1) {
            var rest = req.substr(n + 1);
            req = req.substr(0, n + 1);
            s.send(req + my_header + '\r\n' + rest, flags);
            s.off('upload');
        }
    });
}

function access(s) {
    if (s.remoteAddress.match('^192.*')) {
        s.abort();
        return;
    }

    s.allow();
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_access*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置将在<a href="stream_processing.html#access_phase">访问</a>阶段调用的njs函数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_filter*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置数据过滤器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_include*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定在njs中实现服务器和变量处理程序的文件。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_preread*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置将在<a href="stream_processing.html#preread_phase">预读</a>阶段调用的njs函数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_set*$variable*</code> <code>*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  为指定的变量设置njs函数。 </p>
<h4 id="会话对象属性"><a href="#会话对象属性" class="headerlink" title="会话对象属性"></a>会话对象属性</h4><p>  每个流njs处理程序接收一个参数，即流会话<a href="njs/reference.html#stream">对象</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geo_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geo_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geo-module"><a href="#Module-ngx-stream-geo-module" class="headerlink" title="Module ngx_stream_geo_module"></a>Module ngx_stream_geo_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geo">geo</a> <br></td>

<p>   <code>ngx_stream_geo_module</code>模块（1.11.3）使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">geo $geo {
    default        0;

    127.0.0.1      2;
    192.168.1.0/24 1;
    10.1.0.0/16    1;

    ::1            2;
    2001:0db8::/32 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geo** [ &lt;code class=&quot;notranslate&quot;&gt;*$address*</code> ] <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  描述指定变量的值对客户端IP地址的依赖性。  默认情况下，地址取自<code>$remote_addr</code>变量，但也可以从另一个变量中获取，例如： </p>
<pre class="notranslate">geo $arg_remote_addr $geo {
    ...;
}
</pre>





<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使存在大量已声明的“ <code>geo</code> ”变量也不会导致连接处理的任何额外成本。 </p>
</blockquote>
<p>  如果变量的值不表示有效的IP地址，则使用“ <code>255.255.255.255</code> ”地址。 </p>
<p>  地址被指定为CIDR表示法中的前缀（包括单个地址）或作为范围。 </p>
<p>  还支持以下特殊参数： </p>
<p>  例： </p>
<pre class="notranslate">geo $country {
    default        ZZ;
    include        conf/geo.conf;
    delete         127.0.0.0/16;

    127.0.0.0/24   US;
    127.0.0.1/32   RU;
    10.1.0.0/16    RU;
    192.168.1.0/24 UK;
}
</pre>



<p>   <code>conf/geo.conf</code>文件可以包含以下行： </p>
<pre class="notranslate">10.2.0.0/16    RU;
192.168.2.0/24 RU;
</pre>



<p>  使用最具体匹配的值。  例如，对于127.0.0.1地址，将选择值“ <code>RU</code> ”，而不是“ <code>US</code> ”。 </p>
<p>  范围示例： </p>
<pre class="notranslate">geo $country {
    ranges;
    default                   ZZ;
    127.0.0.0-127.0.0.0       US;
    127.0.0.1-127.0.0.1       RU;
    127.0.0.1-127.0.0.255     US;
    10.1.0.0-10.1.255.255     RU;
    192.168.1.0-192.168.1.255 UK;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geoip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geoip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geoip-module"><a href="#Module-ngx-stream-geoip-module" class="headerlink" title="Module ngx_stream_geoip_module"></a>Module ngx_stream_geoip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geoip_country">geoip_country</a> <br>     <a href="#geoip_city">geoip_city</a> <br>     <a href="#geoip_org">geoip_org</a> <br></td>

<p>   <code>ngx_stream_geoip_module</code>模块（1.11.3）使用预编译的<a href="http://www.maxmind.com" target="_blank" rel="noopener">MaxMind</a>数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p>  使用支持IPv6的数据库时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-stream_geoip_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.maxmind.com/app/c" target="_blank" rel="noopener">MaxMind GeoIP</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    geoip_country         GeoIP.dat;
    geoip_city            GeoLiteCity.dat;

    map $geoip_city_continent_code $nearest_server {
        default        example.com;
        EU          eu.example.com;
        NA          na.example.com;
        AS          as.example.com;
    }
   ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_country*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家/地区的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_city*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。  使用此数据库时，以下变量可用： </p>
<blockquote>
<p>  此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_org*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定组织的数据库。  使用此数据库时，以下变量可用： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_core_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_core_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-core-module"><a href="#Module-ngx-stream-core-module" class="headerlink" title="Module ngx_stream_core_module"></a>Module ngx_stream_core_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#listen">listen</a> <br>     <a href="#preread_buffer_size">preread_buffer_size</a> <br>     <a href="#preread_timeout">preread_timeout</a> <br>     <a href="#proxy_protocol_timeout">proxy_protocol_timeout</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#server">server</a> <br>     <a href="#stream">stream</a> <br>     <a href="#tcp_nodelay">tcp_nodelay</a> <br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a> <br>     <a href="#variables_hash_max_size">variables_hash_max_size</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_core_module</code>模块自版本1.9.0起可用。  默认情况下不构建此模块，应使用<code>--with-stream</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">worker_processes auto;

error_log /var/log/nginx/error.log info;

events {
    worker_connections  1024;
}

stream {
    upstream backend {
        hash $remote_addr consistent;

        server backend1.example.com:12345 weight=5;
        server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
        server unix:/tmp/backend3;
    }

    upstream dns {
       server 192.168.0.1:53535;
       server dns.example.com:53;
    }

    server {
        listen 12345;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass backend;
    }

    server {
        listen 127.0.0.1:53 udp reuseport;
        proxy_timeout 20s;
        proxy_pass dns;
    }

    server {
        listen [::1]:12345;
        proxy_pass unix:/tmp/stream.socket;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**listen**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> : <code>*port*</code>    [ <code>ssl</code> ]    [ <code>udp</code> ]    [ <code>proxy_protocol</code> ]    [ <code>backlog</code> = <code>*number*</code> ]    [ <code>rcvbuf</code> = <code>*size*</code> ]    [ <code>sndbuf</code> = <code>*size*</code> ]    [ <code>bind</code> ]    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]    [ <code>reuseport</code> ]    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置服务器将接受连接的套接字的<code>*address*</code>和<code>*port*</code> 。  可以仅指定端口。  地址也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:12345;
listen *:12345;
listen 12345;     # same as *:12345
listen localhost:12345;
</pre>

<p>   IPv6地址在方括号中指定： </p>
<pre class="notranslate">listen [::1]:12345;
listen [::]:12345;
</pre>

<p>   UNIX域套接字使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>   <code>ssl</code>参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
<p>   <code>udp</code>参数配置一个侦听套接字以处理数据报（1.9.13）。 </p>
<p>   <code>proxy_protocol</code>参数（1.11.4）允许指定此端口上接受的所有连接都应使用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a> 。 </p>
<blockquote>
<p>  自版本1.13.11起支持PROXY协议版本2。 </p>
</blockquote>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
<blockquote>
<p>  不恰当地使用此选项可能会产生安全<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">隐患</a> 。 </p>
</blockquote>
<pre class="notranslate">so_keepalive=30m::10</pre>



<p>  不同的服务器必须侦听不同的<code>*address*</code> ： <code>*port*</code>对。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**preread_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">preread_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.5版中。 </p>
<p>  指定<a href="stream_processing.html#preread_phase">预读</a>缓冲区的<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**preread_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">preread_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.5版中。 </p>
<p>  指定<a href="stream_processing.html#preread_phase">预读</a>阶段的<code>*timeout*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_protocol_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_protocol_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.4版中。 </p>
<p>  指定读取PROXY协议标头以完成的<code>*timeout*</code> 。  如果在此时间内未传输整个标头，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> …    [ <code>valid</code> = <code>*time*</code> ]    [ <code>ipv6</code> = <code>on</code> | <code>off</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.3版中。 </p>
<p>  将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<p>  默认情况下，nginx将在解析时查找IPv4和IPv6地址。  如果不需要查找IPv6地址，可以指定<code>ipv6=off</code>参数。 </p>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在1.11.3版之前，该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.3版中。 </p>
<p>  设置名称解析的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>



<blockquote>
<p>  在1.11.3版之前，该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置服务器的配置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**stream** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供指定流服务器指令的配置文件上下文。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**tcp_nodelayon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">tcp_nodelay on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.4版本中。 </p>
<p>  启用或禁用<code>TCP_NODELAY</code>选项的使用。  为客户端和代理服务器连接启用该选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**variables_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">variables_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  该指令出现在1.11.2版中。 </p>
<p>  设置变量哈希表的桶大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**variables_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">variables_hash_max_size 1024;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  该指令出现在1.11.2版中。 </p>
<p>  设置变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_core_module</code>模块支持自1.11.2以来的变量。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  计算此变量的值通常需要一次系统调用。  为避免系统调用， <a href="#listen">listen</a>指令必须指定地址并使用<code>bind</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_access_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_access_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-access-module"><a href="#Module-ngx-stream-access-module" class="headerlink" title="Module ngx_stream_access_module"></a>Module ngx_stream_access_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#allow">allow</a> <br>     <a href="#deny">deny</a> <br></td>

<p>   <code>ngx_stream_access_module</code>模块（1.9.2）允许限制对某些客户端地址的访问。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    ...
    deny  192.168.1.1;
    allow 192.168.1.0/24;
    allow 10.1.1.0/16;
    allow 2001:0db8::/32;
    deny  all;
}
</pre>



<p>  按顺序检查规则，直到找到第一个匹配项。  在此示例中，仅允许IPv4网络<code>10.1.1.0/16</code>和<code>192.168.1.0/24</code>不包括地址<code>192.168.1.1</code> ）和IPv6网络<code>2001:0db8::/32</code> 。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**allow**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许访问指定的网络或地址。  如果指定了特殊值<code>unix:</code>则允许访问所有UNIX域套接字。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**deny**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  拒绝访问指定的网络或地址。  如果指定了特殊值<code>unix:</code>则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/install-nginx中文手册]]></title>
      <url>/ngx/njs/install.html</url>
      <content type="html"><![CDATA[<p>njs,install<br><a id="more"></a></p>
<h2 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h2><td align="left" class="notranslate"> <a href="#install_package">Installing as a Linux package</a> <br> <a href="#install_sources">Building from the sources</a> <br></td>

<h4 id="作为Linux软件包安装"><a href="#作为Linux软件包安装" class="headerlink" title="作为Linux软件包安装"></a>作为Linux软件包安装</h4><p>  对于Linux，可以使用njs模块<a href="linux_packages.html#dynmodules">包</a> ： </p>
<ul>
<li><code>nginx-module-njs</code> -  njs <a href="ngx_core_module.html#load_module">动态</a>模块 -    <code>nginx-module-njs-dbg</code> - <code>nginx-module-njs</code>包的调试符号 </li>
</ul>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p>  可以使用以下命令克隆具有njs源的<a href="http://hg.nginx.org/njs" target="_blank" rel="noopener">存储库</a> :(需要<a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>客户端）： </p>
<pre class="notranslate">hg clone http://hg.nginx.org/njs
</pre>

<p>  然后应使用<code>--add-module</code>配置参数编译<code>--add-module</code> ： </p>
<pre class="notranslate">./configure --add-module= `*path-to-njs*` /nginx
</pre>

<p>  模块也可以构建为<a href="ngx_core_module.html#load_module">动态</a> ： </p>
<pre class="notranslate">./configure --add-dynamic-module= `*path-to-njs*` /nginx
</pre>



<p>  要仅构建njs命令行<a href="cli.html">实用程序</a> ，请运行<code>./configure</code>并从njs根目录<code>make njs</code>命令。  该实用程序以<code>./build/njs</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/index-nginx中文手册]]></title>
      <url>/ngx/njs/index.html</url>
      <content type="html"><![CDATA[<p>njs,index<br><a id="more"></a></p>
<h2 id="njs脚本语言"><a href="#njs脚本语言" class="headerlink" title="njs脚本语言"></a>njs脚本语言</h2><p>   njs是JavaScript语言的一个子集，允许扩展nginx功能。   njs是根据<a href="http://www.ecma-international.org/ecma-262/5.1/" target="_blank" rel="noopener">ECMAScript 5.1</a> （严格模式）创建的，带有一些<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript 6</a>及更高版本的扩展。  合规性仍在<a href="compatibility.html">不断发展</a> 。 </p>
<ul>
<li><a href="install.html">下载并安装</a> -    <a href="changes.html">变化</a> -    <a href="reference.html">参考</a> -    <a href="examples.html">例子</a> -    <a href="compatibility.html">兼容性</a> -    <a href="cli.html">命令行界面</a> </li>
</ul>
<ul>
<li><a href="http/ngx_http_js_module.html">ngx_http_js_module</a> -    <a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a> </li>
</ul>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><ul>
<li>在请求到达上游服务器之前，njs中的复杂访问控制和安全性检查 -   操纵响应标头 -   编写灵活的异步内容处理程序和过滤器<br>有关更多njs用例，请参阅<a href="examples.html">示例</a>和<a href="https://www.nginx.com/blog/tag/nginx-javascript-module/" target="_blank" rel="noopener">博客文章</a> 。 </li>
</ul>
<h4 id="基本HTTP示例"><a href="#基本HTTP示例" class="headerlink" title="基本HTTP示例"></a>基本HTTP示例</h4><p>  要在nginx中使用njs： </p>
<ul>
<li><a href="install.html">安装</a> njs脚本语言 </li><li id="hello_world">  创建一个njs脚本文件，例如<code>hello_world.js</code> 。  有关njs属性和方法的列表，请参见<a href="reference.html">参考</a> 。 <blockquote class="example"><pre class="notranslate">function hello(r) {<br>r.return(200, “Hello world!”);<br>}<br></pre></blockquote></li><li>  在<code>nginx.conf</code>文件中，启用<a href="http/ngx_http_js_module.html">ngx_http_js_module</a>模块并使用<code>hello_world.js</code>脚本文件指定<a href="http/ngx_http_js_module.html#js_include">js_include</a>指令： <blockquote class="example"><pre class="notranslate">load_module modules/ngx_http_js_module.so;</pre></blockquote></li>
</ul>
<p>events {}</p>
<p>http {<br>    js_include hello_world.js;</p>
<pre><code>server {
    listen 8000;

    location / {
        js_content hello;
    }
}
</code></pre><p>}</p>
<p></p>
<pre class="notranslate">load_module modules/ngx_http_js_module.so;

events {}

http {
    js_include hello_world.js;

    server {
        listen 8000;

        location / {
            js_content hello;
        }
    }
}

</pre>

<p>  还有一个独立的<a href="cli.html">命令行</a>实用程序，可以独立于nginx用于njs开发和调试。 </p>
<h4 id="在2018年的nginx-conf上发表演讲"><a href="#在2018年的nginx-conf上发表演讲" class="headerlink" title="在2018年的nginx.conf上发表演讲"></a>在2018年的nginx.conf上发表演讲</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/examples-nginx中文手册]]></title>
      <url>/ngx/njs/examples.html</url>
      <content type="html"><![CDATA[<p>njs,examples<br><a id="more"></a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><td align="left" class="notranslate"> <a href="#helloword">Hello World</a> <br> <a href="#urldecode">URL Decoding</a> <br> <a href="#urlencode">URL Encoding</a> <br> <a href="#redirect">Internal Redirect</a> <br> <a href="#fast_response">Returning Fastest Response from Proxy</a> <br> <a href="#jwt">Creating HS JWT</a> <br> <a href="#subrequest">Accessing API from a Subrequest</a> <br> <a href="#secure_link">Creating secure_link Hash</a> <br> <a href="#legacy">Legacy Examples</a> <br>     <a href="#legacy_stream">Injecting HTTP header using stream proxy</a> <br></td>

<h4 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">load_module modules/ngx_http_js_module.so;

events {}

http {
    js_include hello_world.js;

    server {
        listen 8000;

        location / {
            js_content hello;
        }
    }
}

</pre>



<p>   <code>hello_world.js</code> ： </p>
<pre class="notranslate">function hello(r) {
    r.return(200, "Hello world!");
}
</pre>



<h4 id="网址解码"><a href="#网址解码" class="headerlink" title="网址解码"></a>网址解码</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include urldecode.js;

js_set $decoded_foo decoded_foo;
</pre>



<p>   <code>urldecode.js</code> ： </p>
<pre class="notranslate">function decoded_foo(r) {
    return decodeURIComponent(r.args.foo);
}
</pre>



<h4 id="网址编码"><a href="#网址编码" class="headerlink" title="网址编码"></a>网址编码</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include urlencode.js;

js_set $encoded_foo encoded_foo;
...

location / {
    proxy_pass http://example.com?foo=$encoded_foo;
}
</pre>



<p>   <code>urlencode.js</code> ： </p>
<pre class="notranslate">function encoded_foo(r) {
    return encodeURIComponent('foo &amp; bar?');
}
</pre>



<h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include redirect.js;

location /redirect {
    js_content redirect;
}

location @named {
    return 200 named;
}
</pre>



<p>   <code>redirect.js</code> ： </p>
<pre class="notranslate">function redirect(r) {
    r.internalRedirect('@named');
}
</pre>



<h4 id="从代理返回最快的响应"><a href="#从代理返回最快的响应" class="headerlink" title="从代理返回最快的响应"></a>从代理返回最快的响应</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include fastresponse.js;

location /start {
    js_content content;
}

location /foo {
    proxy_pass http://backend1;
}

location /bar {
    proxy_pass http://backend2;
}
</pre>



<p>   <code>fastresponse.js</code> ： </p>
<pre class="notranslate">function content(r) {
    var n = 0;

    function done(res) {
        if (n++ == 0) {
            r.return(res.status, res.responseBody);
        }
    }

    r.subrequest('/foo', r.variables.args, done);
    r.subrequest('/bar', r.variables.args, done);
}
</pre>



<h4 id="创建HS-JWT"><a href="#创建HS-JWT" class="headerlink" title="创建HS JWT"></a>创建HS JWT</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include hs_jwt.js;

js_set $jwt jwt;
</pre>



<p>   <code>hs_jwt.js</code> ： </p>
<pre class="notranslate">function create_hs256_jwt(claims, key, valid) {
    var header = { "typ" : "JWT", "alg" : "HS256", "exp" : Date.now() + valid };

    var s = JSON.stringify(header).toBytes().toString('base64url') + '.'
            + JSON.stringify(claims).toBytes().toString('base64url');

    var h = require('crypto').createHmac('sha256', key);

    return s + '.' + h.update(s).digest().toString('base64url');
}

function jwt(r) {
    var claims = {
        "iss" : "nginx",
        "sub" : "alice",
        "foo" : 123,
        "bar" : "qq",
        "zyx" : false
    };

    return create_hs256_jwt(claims, 'foo', 600);
}
</pre>



<h4 id="从子请求访问API"><a href="#从子请求访问API" class="headerlink" title="从子请求访问API"></a>从子请求访问API</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include subrequest.js;

keyval_zone zone=foo:10m;
...

location /keyval {
    js_content set_keyval;
}

location /version {
    js_content version;
}

location /api {
    api write=on;
}
</pre>



<p>   <code>subrequest.js</code> ： </p>
<pre class="notranslate">function set_keyval(r) {
    r.subrequest('/api/3/http/keyvals/foo',
        { method: 'POST',
          body: JSON.stringify({ foo: 789, bar: "ss dd 00" })},

        function(res) {
            if (res.status &gt;= 300) {
                r.return(res.status, res.responseBody);
                return;
            }
            r.return(500);
        });
}

function version(r) {
    r.subrequest('/api/3/nginx', { method: 'GET' }, function(res) {
        if (res.status != 200) {
            r.return(res.status);
            return;
        }

        var json = JSON.parse(res.responseBody);
        r.return(200, json.version);
    });
}
</pre>



<h4 id="创建secure-link哈希"><a href="#创建secure-link哈希" class="headerlink" title="创建secure_link哈希"></a>创建secure_link哈希</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include hash.js;

js_set $new_foo create_secure_link;
...

location / {
    secure_link $cookie_foo;
    secure_link_md5 "$uri mykey";
    ...
}

location @login {
    add_header Set-Cookie "foo=$new_foo; Max-Age=60";
    return 302 /;
}
</pre>



<p>   <code>hash.js</code> ： </p>
<pre class="notranslate">function create_secure_link(r) {
    return require('crypto').createHash('md5')
                            .update(r.uri).update(" mykey")
                            .digest('base64url');
}
</pre>



<h4 id="遗留的例子"><a href="#遗留的例子" class="headerlink" title="遗留的例子"></a>遗留的例子</h4><h4 id="使用流代理注入HTTP标头"><a href="#使用流代理注入HTTP标头" class="headerlink" title="使用流代理注入HTTP标头"></a>使用流代理注入HTTP标头</h4><p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，流配置<a href="stream/ngx_stream_js_module.html#example">示例</a>已更改。  对于njs 0.2.3及更早版本，请使用此配置示例： </p>
<pre class="notranslate">load_module modules/ngx_stream_js_module.so;
...

stream {
    js_include stream.js;

    js_set $foo foo;
    js_set $bar bar;

    server {
        listen 12345;

        js_preread qux;
        return     $foo;
    }

    server {
        listen 12346;

        js_access  xyz;
        proxy_pass 127.0.0.1:8000;
        js_filter  baz;
    }
}

http {
    server {
        listen 8000;
        location / {
            return 200 $http_foo\n;
        }
    }
}
</pre>



<p>   <code>stream.js</code>文件： </p>
<pre class="notranslate">var req = '';
var matched = 0;
var line = '';

function qux(s) {
    var n = s.buffer.indexOf('\n');
    if (n == -1) {
        return s.AGAIN;
    }

    line = s.buffer.substr(0, n);
}

function foo(s) {
    return line;
}

function bar(s) {
    var v = s.variables;
    s.log("hello from bar() handler!");
    return "foo-var" + v.remote_port + "; pid=" + v.pid;
}

// The filter processes one buffer per call.
// The buffer is available in s.buffer both for
// reading and writing.  Called for both directions.

function baz(s) {
    if (s.fromUpstream || matched) {
        return;
    }

    // Disable certain addresses.

    if (s.remoteAddress.match('^192.*')) {
        return s.ERROR;
    }

    // Read HTTP request line.
    // Collect bytes in 'req' until request
    // line is read.  Clear current buffer to
    // disable output.

    req = req + s.buffer;
    s.buffer = '';

    var n = req.search('\n');

    if (n != -1) {
        // Inject a new HTTP header.
        var rest = req.substr(n + 1);
        req = req.substr(0, n + 1);

        var addr = s.remoteAddress;

        s.log('req:' + req);
        s.log('rest:' + rest);

        // Output the result and skip further
        // processing.

        s.buffer = req + 'Foo: addr_' + addr + '\r\n' + rest;
        matched = 1;
    }
}

function xyz(s) {
    if (s.remoteAddress.match('^192.*')) {
        return s.ABORT;
    }
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_ssl_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_ssl_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-ssl-module"><a href="#Module-ngx-mail-ssl-module" class="headerlink" title="Module ngx_mail_ssl_module"></a>Module ngx_mail_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl">ssl</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br>     <a href="#starttls">starttls</a> <br></td>

<p>   <code>ngx_mail_ssl_module</code>模块为邮件代理服务器提供必要的支持，以使用SSL / TLS协议。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-mail_ssl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

mail {

    ...

    server {
        listen              993 ssl;

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令在1.15.0版本中已过时。  应该使用<a href="ngx_mail_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              993 ssl;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<blockquote>
<p>  以前版本的nginx默认使用<a href="http/configuring_https_servers.html#compatibility">不同的</a>密码。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.7.2版本中。 </p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.3版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">mail {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        server_name mail1.example.com;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        server_name mail2.example.com;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数（ <code>TLSv1.2</code> ）仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache**     &lt;code class=&quot;notranslate&quot;&gt;off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client**     &lt;code class=&quot;notranslate&quot;&gt;on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用客户端证书验证。  验证结果在<a href="ngx_mail_auth_http_module.html#auth_http">验证</a>请求的“Auth-SSL-Verify”标头中传递。 </p>
<p>   <code>optional</code>参数请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数请求客户端证书，但不要求它由可信CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="ngx_mail_auth_http_module.html#auth_http_pass_client_cert">发送</a>到身份验证服务器的请求访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  设置客户端证书链中的验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**starttls**   &lt;code class=&quot;notranslate&quot;&gt;on</code> |  <code>off</code> |  <code>only</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">starttls off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_smtp_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_smtp_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_smtp_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-smtp-module"><a href="#Module-ngx-mail-smtp-module" class="headerlink" title="Module ngx_mail_smtp_module"></a>Module ngx_mail_smtp_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#smtp_auth">smtp_auth</a> <br>     <a href="#smtp_capabilities">smtp_capabilities</a> <br>     <a href="#smtp_client_buffer">smtp_client_buffer</a> <br>     <a href="#smtp_greeting_delay">smtp_greeting_delay</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_auth login plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为SMTP客户端设置允许的<a href="https://tools.ietf.org/html/rfc2554" target="_blank" rel="noopener">SASL身份验证</a>方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置传递给客户端以响应<code>EHLO</code>命令的SMTP协议扩展列表。   <a href="#smtp_auth">smtp_auth</a>指令和<a href="https://tools.ietf.org/html/rfc3207" target="_blank" rel="noopener">STARTTLS</a>中指定的身份验证方法将根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的MTA支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/mail-parameters" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_client_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_client_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于读取SMTP命令的缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_greeting_delay*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_greeting_delay 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  允许在发送SMTP问候语之前设置延迟，以便在发送SMTP命令之前拒绝未能等待问候语的客户端。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_proxy_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_proxy_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-proxy-module"><a href="#Module-ngx-mail-proxy-module" class="headerlink" title="Module ngx_mail_proxy_module"></a>Module ngx_mail_proxy_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#proxy_buffer">proxy_buffer</a> <br>     <a href="#proxy_pass_error_message">proxy_pass_error_message</a> <br>     <a href="#proxy_timeout">proxy_timeout</a> <br>     <a href="#xclient">xclient</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于代理的缓冲区的大小。  默认情况下，缓冲区大小等于一个内存页面。  根据平台，它是4K或8K。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_error_messageon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_error_message off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指示是否将后端身份验证期间获取的错误消息传递给客户端。 </p>
<p>  通常，如果nginx中的身份验证成功，则后端无法返回错误。  如果它仍然返回错误，则表示发生了一些内部错误。  在这种情况下，后端消息可以包含不应向客户端显示的信息。  但是，对于某些POP3服务器，使用正确密码的错误进行响应是正常行为。  例如，CommuniGatePro通过定期输出<a href="http://www.stalker.com/CommuniGatePro/POP.html#Alerts" target="_blank" rel="noopener">身份验证错误</a>通知用户<a href="http://www.stalker.com/CommuniGatePro/Alerts.html#Quota" target="_blank" rel="noopener">邮箱溢出</a>或其他事件。  在这种情况下应该启用该指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_timeout 24h;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xclienton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xclient on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  连接到SMTP后端时，启用或禁用带有客户端参数的<a href="http://www.postfix.org/XCLIENT_README.html" target="_blank" rel="noopener">XCLIENT</a>命令的传递。 </p>
<p>  使用<code>XCLIENT</code> ，MTA能够将客户端信息写入日志，并根据此数据应用各种限制。 </p>
<p>  如果启用了<code>XCLIENT</code> ，则nginx在连接到后端时会传递以下命令： </p>
<ul>
<li><code>EHLO</code>与<a href="ngx_mail_core_module.html#server_name">服务器名称</a> -  <code>XCLIENT</code>  -    <code>EHLO</code>或<code>HELO</code> ，由客户通过 </li>
</ul>
<p>  如果客户端IP地址<a href="ngx_mail_core_module.html#resolver">找到</a>的名称指向同一地址，则会在<code>XCLIENT</code>命令的<code>NAME</code>参数中传递该<code>NAME</code> 。  如果找不到名称，指向不同的地址，或未指定<a href="ngx_mail_core_module.html#resolver">解析器</a> ，则在<code>NAME</code>参数中传递<code>[UNAVAILABLE]</code> 。  如果在解析过程中发生错误，则使用<code>[TEMPUNAVAIL]</code>值。 </p>
<p>  如果禁用了<code>XCLIENT</code> ，那么如果客户端已通过<code>EHLO</code> ，则nginx在连接到后端时传递带有<a href="ngx_mail_core_module.html#server_name">服务器名称</a>的<code>EHLO</code>命令，否则传递带有服务器名称的<code>HELO</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_pop3_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_pop3_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_pop3_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-pop3-module"><a href="#Module-ngx-mail-pop3-module" class="headerlink" title="Module ngx_mail_pop3_module"></a>Module ngx_mail_pop3_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#pop3_auth">pop3_auth</a> <br>     <a href="#pop3_capabilities">pop3_capabilities</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pop3_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pop3_auth plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为POP3客户端设置允许的身份验证方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pop3_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pop3_capabilities TOP USER UIDL;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置为响应<code>CAPA</code>命令而传递给客户端的<a href="https://tools.ietf.org/html/rfc2449" target="_blank" rel="noopener">POP3协议</a>扩展列表。   <a href="#pop3_auth">pop3_auth</a>指令（ <a href="https://tools.ietf.org/html/rfc2449" target="_blank" rel="noopener">SASL</a>扩展名）和<a href="https://tools.ietf.org/html/rfc2595" target="_blank" rel="noopener">STLS</a>中指定的身份验证方法将根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的POP3后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/pop3-extension-mechanism" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_imap_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_imap_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_imap_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-imap-module"><a href="#Module-ngx-mail-imap-module" class="headerlink" title="Module ngx_mail_imap_module"></a>Module ngx_mail_imap_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#imap_auth">imap_auth</a> <br>     <a href="#imap_capabilities">imap_capabilities</a> <br>     <a href="#imap_client_buffer">imap_client_buffer</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_auth plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为IMAP客户端设置允许的身份验证方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_capabilities IMAP4 IMAP4rev1 UIDPLUS;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置传递给客户端以响应<code>CAPABILITY</code>命令的<a href="https://tools.ietf.org/html/rfc3501" target="_blank" rel="noopener">IMAP协议</a>扩展列表。   <a href="#imap_auth">imap_auth</a>指令和<a href="https://tools.ietf.org/html/rfc2595" target="_blank" rel="noopener">STARTTLS</a>中指定的身份验证方法会根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的IMAP后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/imap4-capabilities" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_client_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_client_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于读取IMAP命令的缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_core_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_core_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-core-module"><a href="#Module-ngx-mail-core-module" class="headerlink" title="Module ngx_mail_core_module"></a>Module ngx_mail_core_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#listen">listen</a> <br>     <a href="#mail">mail</a> <br>     <a href="#protocol">protocol</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#server">server</a> <br>     <a href="#server_name">server_name</a> <br>     <a href="#timeout">timeout</a> <br></td>

<p>  默认情况下不构建此模块，应使用<code>--with-mail</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">worker_processes 1;

error_log /var/log/nginx/error.log info;

events {
    worker_connections  1024;
}

mail {
    server_name       mail.example.com;
    auth_http         localhost:9000/cgi-bin/nginxauth.cgi;

    imap_capabilities IMAP4rev1 UIDPLUS IDLE LITERAL+ QUOTA;

    pop3_auth         plain apop cram-md5;
    pop3_capabilities LAST TOP USER PIPELINING UIDL;

    smtp_auth         login plain cram-md5;
    smtp_capabilities "SIZE 10485760" ENHANCEDSTATUSCODES 8BITMIME DSN;
    xclient           off;

    server {
        listen   25;
        protocol smtp;
    }
    server {
        listen   110;
        protocol pop3;
        proxy_pass_error_message on;
    }
    server {
        listen   143;
        protocol imap;
    }
    server {
        listen   587;
        protocol smtp;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**listen**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> : <code>*port*</code>    [ <code>ssl</code> ]    [ <code>backlog</code> = <code>*number*</code> ]    [ <code>rcvbuf</code> = <code>*size*</code> ]    [ <code>sndbuf</code> = <code>*size*</code> ]    [ <code>bind</code> ]    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置服务器将接受请求的套接字的<code>*address*</code>和<code>*port*</code> 。  可以仅指定端口。  地址也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:110;
listen *:110;
listen 110;     # same as *:110
listen localhost:110;
</pre>

<p>   IPv6地址（0.7.58）在方括号中指定： </p>
<pre class="notranslate">listen [::1]:110;
listen [::]:110;
</pre>

<p>   UNIX域套接字（1.3.5）使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>  不同的服务器必须侦听不同的<code>*address*</code> ： <code>*port*</code>对。 </p>
<p>   <code>ssl</code>参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
<pre class="notranslate">so_keepalive=30m::10</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mail** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供指定邮件服务器指令的配置文件上下文。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**protocol**   &lt;code class=&quot;notranslate&quot;&gt;imap</code> |  <code>pop3</code> |  <code>smtp</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置代理服务器的协议。  支持的协议是<a href="ngx_mail_imap_module.html">IMAP</a> ， <a href="ngx_mail_pop3_module.html">POP3</a>和<a href="ngx_mail_smtp_module.html">SMTP</a> 。 </p>
<p>  如果未设置该指令，则可以根据<a href="#listen">listen</a>指令中指定的已知端口自动检测协议： </p>
<ul>
<li><code>imap</code> ：143,993 -    <code>pop3</code> ：110,995 -    <code>smtp</code> ：25,587,465 </li>
</ul>
<p>  可以使用<a href="configure.html">配置</a>参数<code>--without-mail_imap_module</code> ， <code>--without-mail_pop3_module</code>和<code>--without-mail_smtp_module</code>禁用不必要的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver*address*</code> …[ <code>valid</code> = <code>*time*</code> ]; <br> <code>**resolveroff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  配置用于查找客户端主机名的名称服务器以将其传递给<a href="ngx_mail_auth_http_module.html">身份验证服务器</a> ，并在代理SMTP时配置<a href="ngx_mail_proxy_module.html#xclient">XCLIENT</a>命令。  例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<blockquote>
<p>  在1.1.7版之前，只能配置一个名称服务器。  从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。 </p>
</blockquote>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。 </p>
</blockquote>
<p>  特殊值<code>off</code>禁用解析。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置DNS操作的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> <br>                </td></p>
<p>  设置服务器的配置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">server_name hostname;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置使用的服务器名称： </p>
<ul>
<li>在初始POP3 / SMTP服务器问候语中; -   在SASL CRAM-MD5认证期间的盐; -   如果启用了<a href="ngx_mail_proxy_module.html#xclient">XCLIENT</a>命令的传递，则在连接到SMTP后端时在<code>EHLO</code>命令中。 </li>
</ul>
<p>  如果未指定该指令，则使用计算机的主机名。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置代理到后端开始之前使用的超时。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_auth_http_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_auth_http_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_auth_http_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-auth-http-module"><a href="#Module-ngx-mail-auth-http-module" class="headerlink" title="Module ngx_mail_auth_http_module"></a>Module ngx_mail_auth_http_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#auth_http">auth_http</a> <br>     <a href="#auth_http_header">auth_http_header</a> <br>     <a href="#auth_http_pass_client_cert">auth_http_pass_client_cert</a> <br>     <a href="#auth_http_timeout">auth_http_timeout</a> <br> <a href="#protocol">Protocol</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置HTTP身份验证服务器的URL。  该协议<a href="#protocol">如下所述</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_header*header*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  将指定的标头附加到发送到身份验证服务器的请求。  此标头可用作共享密钥，以验证请求是否来自nginx。  例如： </p>
<pre class="notranslate">auth_http_header X-Auth-Key "secret_string";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_pass_client_certon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_http_pass_client_cert off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  将具有PEM格式（urlencoded）的<a href="ngx_mail_ssl_module.html#ssl_verify_client">客户端</a>证书的“Auth-SSL-Cert”标头附加到发送到身份验证服务器的请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_http_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置与身份验证服务器通信的超时。 </p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>   HTTP协议用于与身份验证服务器通信。  响应正文中的数据将被忽略，信息仅在标题中传递。 </p>
<p>  请求和响应的示例： </p>
<p>  请求： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: plain # plain/apop/cram-md5/external
Auth-User: user
Auth-Pass: password
Auth-Protocol: imap # imap/pop3/smtp
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
</pre>

<p>  反应良好： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: OK
Auth-Server: 198.51.100.1
Auth-Port: 143
</pre>

<p>  不好的回应： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: Invalid login or password
Auth-Wait: 3
</pre>



<p>  如果没有“Auth-Wait”标头，将返回错误并关闭连接。  当前实现为每次身份验证尝试分配内存。  仅在会话结束时释放内存。  因此，必须限制单个会话中无效身份验证尝试的次数 - 服务器必须在10-20次尝试后响应而不使用“Auth-Wait”标头（尝试号码在“Auth-Login-Attempt”标头中传递） 。 </p>
<p>  使用APOP或CRAM-MD5时，请求 - 响应将如下所示： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: apop
Auth-User: user
Auth-Salt: &lt;238188073.1163692009@mail.example.com&gt;
Auth-Pass: auth_response
Auth-Protocol: imap
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
</pre>

<p>  反应良好： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: OK
Auth-Server: 198.51.100.1
Auth-Port: 143
Auth-Pass: plain-text-pass
</pre>



<p>  如果响应中存在“Auth-User”标头，它将覆盖用于通过后端进行身份验证的用户名。 </p>
<p>  对于SMTP，响应还考虑了“Auth-Error-Code”标头 - 如果存在，则在发生错误时用作响应代码。  否则，535 5.7.0代码将添加到“Auth-Status”标头中。 </p>
<p>  例如，如果从身份验证服务器收到以下响应： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: Temporary server problem, try again later
Auth-Error-Code: 451 4.3.0
Auth-Wait: 3
</pre>

<p>  然后SMTP客户端将收到错误 </p>
<pre class="notranslate">451 4.3.0 Temporary server problem, try again later
</pre>



<p>  如果代理SMTP不需要身份验证，请求将如下所示： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: none
Auth-User:
Auth-Pass:
Auth-Protocol: smtp
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
Auth-SMTP-Helo: client.example.org
Auth-SMTP-From: MAIL FROM: &lt;&gt;
Auth-SMTP-To: RCPT TO: &lt;postmaster@mail.example.com&gt;
</pre>



<p>  对于SSL / TLS客户端连接（1.7.11），添加了“Auth-SSL”标头，“Auth-SSL-Verify”将包含客户端证书验证的结果（如果已<a href="ngx_mail_ssl_module.html#ssl_verify_client">启用）</a> ：“ <code>SUCCESS</code> ”，“ <code>FAILED:</code>如果证书不存在，则“和” <code>NONE</code> “。 </p>
<blockquote>
<p>  在1.11.7版之前，“ <code>FAILED</code> ”结果不包含<code>*reason*</code>字符串。 </p>
</blockquote>
<p>  当客户端证书存在时，其详细信息将在以下请求标头中传递：“Auth-SSL-Subject”，“Auth-SSL-Issuer”，“Auth-SSL-Serial”和“Auth-SSL-Fingerprint”。  如果启用了<a href="#auth_http_pass_client_cert">auth_http_pass_client_cert</a> ，则证书本身将在“Auth-SSL-Cert”标头中传递。  请求如下： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: plain
Auth-User: user
Auth-Pass: password
Auth-Protocol: imap
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Auth-SSL: on
Auth-SSL-Verify: SUCCESS
Auth-SSL-Subject: /CN=example.com
Auth-SSL-Issuer: /CN=example.com
Auth-SSL-Serial: C07AD56B846B5BFF
Auth-SSL-Fingerprint: 29d6a80a123d13355ed16b4b04605e29cb55a5ad
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/websocket-nginx中文手册]]></title>
      <url>/ngx/http/websocket.html</url>
      <content type="html"><![CDATA[<p>http,websocket<br><a id="more"></a></p>
<h2 id="WebSocket代理"><a href="#WebSocket代理" class="headerlink" title="WebSocket代理"></a>WebSocket代理</h2><p>  要将客户端和服务器之间的连接从HTTP / 1.1转换为WebSocket，请使用HTTP / 1.1中提供的<a href="https://tools.ietf.org/html/rfc2616#section-14.42" target="_blank" rel="noopener">协议交换</a>机制。 </p>
<p>  然而，有一个微妙之处：由于“升级”是<a href="https://tools.ietf.org/html/rfc2616#section-13.5.1" target="_blank" rel="noopener">逐跳</a>标头，因此它不会从客户端传递到代理服务器。  使用正向代理，客户端可以使用<code>CONNECT</code>方法来规避此问题。  但是，这不适用于反向代理，因为客户端不知道任何代理服务器，并且需要在代理服务器上进行特殊处理。 </p>
<p>  从版本1.3.13开始，nginx实现了特殊的操作模式，如果代理服务器返回带有代码101（交换协议）的响应，则允许在客户端和代理服务器之间建立隧道，并且客户端要求通过请求中的“升级”标头。 </p>
<p>  如上所述，包括“升级”和“连接”的逐跳头不会从客户端传递到代理服务器，因此为了让代理服务器知道客户端将协议切换到WebSocket的意图，这些头必须明确传递： </p>
<pre class="notranslate">location /chat/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
</pre>

<p>  一个更复杂的示例，其中对代理服务器的请求中的“连接”头字段的值取决于客户端请求头中是否存在“升级”字段： </p>
<pre class="notranslate">http {
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    server {
        ...

        location /chat/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
</pre>



<p>  默认情况下，如果代理服务器在60秒内未传输任何数据，则将关闭连接。  使用<a href="ngx_http_proxy_module.html#proxy_read_timeout">proxy_read_timeout</a>指令可以增加此超时。  或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/server_names-nginx中文手册]]></title>
      <url>/ngx/http/server_names.html</url>
      <content type="html"><![CDATA[<p>http,server_names<br><a id="more"></a></p>
<h2 id="服务器名称"><a href="#服务器名称" class="headerlink" title="服务器名称"></a>服务器名称</h2><td align="left" class="notranslate"> <a href="#wildcard_names">Wildcard names</a> <br> <a href="#regex_names">Regular expressions names</a> <br> <a href="#miscellaneous_names">Miscellaneous names</a> <br> <a href="#idn">Internationalized names</a> <br> <a href="#optimization">Optimization</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>  服务器名称使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令定义，并确定用于给定请求的<a href="ngx_http_core_module.html#server">服务器</a>块。  另请参阅“ <a href="request_processing.html">nginx如何处理请求</a> ”。  可以使用确切名称，通配符名称或正则表达式来定义它们： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org;
    ...
}

server {
    listen       80;
    server_name  *.example.org;
    ...
}

server {
    listen       80;
    server_name  mail.*;
    ...
}

server {
    listen       80;
    server_name  ~^(?&lt;user&gt;.+)\.example\.net$;
    ...
}
</pre>



<p>  按名称搜索虚拟服务器时，如果name匹配多个指定的变体，例如通配符名称和正则表达式匹配，则将按以下优先顺序选择第一个匹配的变体： </p>
<ol>
<li>确切的名字 1.   最长的通配符名称以星号开头，例如“ <code>*.example.org</code> ” 1.   最长的通配符名称以星号结尾，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） </li>
</ol>
<h4 id="通配符名称"><a href="#通配符名称" class="headerlink" title="通配符名称"></a>通配符名称</h4><p>  通配符名称可能仅在名称的开头或结尾包含星号，并且仅在点边框上包含星号。  名称“ <code>www.*.example.org</code> ”和“ <code>w*.example.org</code> ”无效。  但是，可以使用正则表达式指定这些名称，例如“ <code>~^www\..+\.example\.org$</code> ”和“ <code>~^w.*\.example\.org$</code> ”。  星号可以匹配多个名称部分。  名称“ <code>*.example.org</code> ”不仅匹配<code>www.example.org</code>还匹配<code>www.sub.example.org</code> 。 </p>
<p>   “ <code>.example.org</code> ”形式的特殊通配符名称可用于匹配确切名称“ <code>example.org</code> ”和通配符名称“ <code>*.example.org</code> ”。 </p>
<h4 id="正则表达式名称"><a href="#正则表达式名称" class="headerlink" title="正则表达式名称"></a>正则表达式名称</h4><p>   nginx使用的正则表达式与Perl编程语言（PCRE）使用的正则表达式兼容。  要使用正则表达式，服务器名称必须以波浪号开头： </p>
<pre class="notranslate">server_name  ~^www\d+\.example\.net$;
</pre>

<p>  否则它将被视为一个确切的名称，或者如果表达式包含星号，则视为通配符名称（并且很可能是无效的名称）。  不要忘记设置“ <code>^</code> ”和“ <code>$</code> ”锚点。  它们在语法上不是必需的，但在逻辑上是必需的。  另请注意，域名点应使用反斜杠进行转义。  应引用包含字符“ <code>{</code> ”和“ <code>}</code> ”的正则表达式： </p>
<pre class="notranslate">server_name  "~^(?&lt;name&gt;\w\d **{** 1,3 **}** +)\.example\.net$";
</pre>

<p>  否则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">directive "server_name" is not terminated by ";" in ...
</pre>

<p>  命名的正则表达式捕获稍后可以用作变量： </p>
<pre class="notranslate">server {
    server_name   ~^(www\.)?( **?&lt;domain&gt;** .+)$;

    location / {
        root   /sites/ **$domain** ;
    }
}
</pre>

<p>   PCRE库使用以下语法支持命名捕获： </p>
<blockquote>
<table width="100%"><tbody><td class="notranslate"> <code>?&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; </td><td class="notranslate">Perl 5.10 compatible syntax, supported since PCRE-7.0</td><br><td class="notranslate"> <code>?&#39; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> ‘ </td><td class="notranslate">Perl 5.10 compatible syntax, supported since PCRE-7.0</td><br><td class="notranslate"> <code>?P&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; </td><td class="notranslate">Python compatible syntax, supported since PCRE-4.0</td><br></tbody></table>



</blockquote>
<pre class="notranslate">pcre_compile() failed: unrecognized character after (?&lt; in ...
</pre>

<p>  这意味着PCRE库已经过时了，应该尝试使用语法“ <code>?P&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; ”。  捕获也可以以数字形式使用： </p>
<pre class="notranslate">server {
    server_name   ~^(www\.)?(.+)$;

    location / {
        root   /sites/ **$2** ;
    }
}
</pre>

<p>  但是，这种用法应限于简单的情况（如上所述），因为数字参考可以很容易地被覆盖。 </p>
<h4 id="杂项名称"><a href="#杂项名称" class="headerlink" title="杂项名称"></a>杂项名称</h4><p>  有一些服务器名称是专门处理的。 </p>
<p>  如果需要处理没有默认<a href="ngx_http_core_module.html#server">服务器</a>块中“Host”头字段的<a href="ngx_http_core_module.html#server">请求</a> ，则应指定一个空名称： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org  "";
    ...
}
</pre>



<p>  如果<a href="ngx_http_core_module.html#server">服务器</a>块中未定义<a href="ngx_http_core_module.html#server_name">server_name</a> ，则nginx使用空名称作为服务器名称。 </p>
<blockquote>
<p>  在这种情况下，最高为0.8.48的nginx版本使用机器的主机名作为服务器名称。 </p>
</blockquote>
<p>  如果服务器名称定义为“ <code>$hostname</code> ”（0.9.4），则使用计算机的主机名。 </p>
<p>  如果有人使用IP地址而不是服务器名称发出请求，则“主机”请求标头字段将包含IP地址，并且可以使用IP地址作为服务器名称来处理请求： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org
                 www.example.org
                 ""
                 **192.168.1.1**
                 ;
    ...
}
</pre>



<p>  在catch-all服务器示例中，可以看到奇怪的名称“ <code>_</code> ”： </p>
<pre class="notranslate">server {
    listen       80  default_server;
    server_name  _;
    return       444;
}
</pre>

<p>  这个名称没有什么特别之处，它只是无数域名之一，永远不会与任何真实姓名相交。  也可以使用诸如“ <code>--</code> ”和“ <code>!@#</code> ”之类的其他无效名称。 </p>
<p>   nginx版本高达0.6.25支持特殊名称“ <code>*</code> ”，它被错误地解释为一个包罗万象的名称。  它从不作为全能或通配符服务器名称运行。  相反，它提供了<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>指令现在提供的功能。  现在不推荐使用特殊名称“ <code>*</code> ”，并且应使用<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>指令。  请注意，无法使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令指定catch-all名称或缺省服务器。  这是<a href="ngx_http_core_module.html#listen">listen</a>指令的属性，而不是<a href="ngx_http_core_module.html#server_name">server_name</a>指令的属性。  另请参阅“ <a href="request_processing.html">nginx如何处理请求</a> ”。  可以定义侦听端口<em>：80和</em>：8080的服务器，并指示一个端口将是端口<em>的默认服务器：8080，而另一个将是端口</em>的默认值：80： </p>
<pre class="notranslate">server {
    listen       80;
    listen       8080  default_server;
    server_name  example.net;
    ...
}

server {
    listen       80  default_server;
    listen       8080;
    server_name  example.org;
    ...
}
</pre>



<h4 id="国际化名称"><a href="#国际化名称" class="headerlink" title="国际化名称"></a>国际化名称</h4><p>  应使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令中的ASCII（Punycode）表示来指定国际化域名（ <a href="https://en.wikipedia.org/wiki/Internationalized_domain_name" target="_blank" rel="noopener">IDN</a> ）： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  xn--e1afmkfd.xn--80akhbyknj4f;  # пример.испытание
    ...
}
</pre>



<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>  确切名称，以星号开头的通配符名称以及以星号结尾的通配符名称存储在绑定到侦听端口的三个哈希表中。  散列表的大小在配置阶段进行了优化，因此可以找到最少CPU缓存未命中的名称。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p>  首先搜索确切的名称哈希表。  如果未找到名称，则搜索带有以星号开头的通配符名称的哈希表。  如果在那里找不到名称，则搜索带有以星号结尾的通配符名称的哈希表。 </p>
<p>  搜索通配符名称哈希表比搜索确切名称哈希表要慢，因为域名部分会搜索名称。  请注意，特殊通配符形式“ <code>.example.org</code> ”存储在通配符名称哈希表中，而不是存储在精确名称哈希表中。 </p>
<p>  正则表达式是按顺序测试的，因此是最慢的方法，并且是不可伸缩的。 </p>
<p>  出于这些原因，最好在可能的情况下使用确切的名称。  例如，如果服务器的最常请求名称是<code>example.org</code>和<code>www.example.org</code> ，则明确定义它们会更有效： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org  *.example.org;
    ...
}
</pre>

<p>  而不是使用简化形式： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  .example.org;
    ...
}
</pre>



<p>  如果定义了大量服务器名称，或者定义了异常长的服务器名称，则可能需要在<em>http</em>级别调整<a href="ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>和<a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a>指令。   <a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a>指令的默认值可能等于32或64，或其他值，具体取决于CPU缓存行大小。  如果默认值为32且服务器名称定义为“ <code>too.long.server.name.example.org</code> ”，则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">could not build the server_names_hash,
you should increase server_names_hash_bucket_size: 32
</pre>

<p>  在这种情况下，指令值应该增加到下一个2的幂： </p>
<pre class="notranslate">http {
    server_names_hash_bucket_size  64;
    ...
</pre>

<p>  如果定义了大量服务器名称，则会显示另一条错误消息： </p>
<pre class="notranslate">could not build the server_names_hash,
you should increase either server_names_hash_max_size: 512
or server_names_hash_bucket_size: 32
</pre>

<p>  在这种情况下，首先尝试将<a href="ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>设置为接近服务器名称数的数字。  只有当这没有帮助时，或者如果nginx的开始时间长得令人无法接受，请尝试增加<a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> 。 </p>
<p>  如果服务器是监听端口的唯一服务器，则nginx根本不会测试服务器名称（并且不会为监听端口构建哈希表）。  但是，有一个例外。  如果服务器名称是带捕获的正则表达式，则nginx必须执行表达式才能获取捕获。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>自0.9.4以来一直支持特殊服务器名称“ <code>$hostname</code> ”。 -   默认服务器名称值是自0.8.48以来的空名称“”。 -   自0.8.25起，支持命名正则表达式服务器名称捕获。 -   自0.7.40起支持正则表达式服务器名称捕获。 -   自0.7.12起，支持空服务器名称“”。 -   支持使用通配符服务器名称或正则表达式作为自0.6.25以来的第一个服务器名称。 -   自0.6.7起支持正则表达式服务器名称。 -   自0.6.0以来一直支持通配符表单<code>example.*</code> 。 -   从0.3.18开始支持特殊格式<code>.example.org</code> 。 -   自0.1.13起支持通配符<code>*.example.org</code> 。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/request_processing-nginx中文手册]]></title>
      <url>/ngx/http/request_processing.html</url>
      <content type="html"><![CDATA[<p>http,request_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理请求"><a href="#nginx如何处理请求" class="headerlink" title="nginx如何处理请求"></a>nginx如何处理请求</h2><td align="left" class="notranslate"> <a href="#how_to_prevent_undefined_server_names">How to prevent processing requests with undefined server names</a> <br> <a href="#mixed_name_ip_based_servers">Mixed name-based and IP-based virtual servers</a> <br> <a href="#simple_php_site_configuration">A simple PHP site configuration</a> <br></td>

<h4 id="基于名称的虚拟服务器"><a href="#基于名称的虚拟服务器" class="headerlink" title="基于名称的虚拟服务器"></a>基于名称的虚拟服务器</h4><p>   nginx首先决定哪个<em>服务器</em>应该处理请求。  让我们从一个简单的配置开始，其中所有三个虚拟服务器都在端口*：80上侦听： </p>
<pre class="notranslate">server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
</pre>



<p>  在此配置中，nginx仅测试请求的标头字段“Host”，以确定请求应路由到哪个服务器。  如果其值与任何服务器名称都不匹配，或者请求根本不包含此标头字段，则nginx会将请求路由到此端口的默认服务器。  在上面的配置中，默认服务器是第一个 - 这是nginx的标准默认行为。  也可以使用<a href="ngx_http_core_module.html#listen">listen</a>指令中的<code>default_server</code>参数明确设置哪个服务器应该是默认的： </p>
<pre class="notranslate">server {
    listen      80 **default_server** ;
    server_name example.net www.example.net;
    ...
}
</pre>



<blockquote>
<p>   <code>default_server</code>参数自版本0.8.21起可用。  在早期版本中，应使用<code>default</code>参数。 </p>
</blockquote>
<p>  请注意，默认服务器是侦听端口的属性，而不是服务器名称的属性。  稍后会详细介绍。 </p>
<h4 id="如何使用未定义的服务器名称防止处理请求"><a href="#如何使用未定义的服务器名称防止处理请求" class="headerlink" title="如何使用未定义的服务器名称防止处理请求"></a>如何使用未定义的服务器名称防止处理请求</h4><p>  如果不允许没有“Host”头字段的请求，则可以定义只删除请求的服务器： </p>
<pre class="notranslate">server {
    listen      80;
    server_name "";
    return      444;
}
</pre>

<p>  这里，服务器名称设置为一个空字符串，它将匹配没有“Host”头字段的请求，并返回一个特殊的nginx非标准代码444来关闭连接。 </p>
<blockquote>
<p>  从版本0.8.48开始，这是服务器名称的默认设置，因此可以省略<code>server_name &quot;&quot;</code> 。  在早期版本中，计算机的<em>主机名</em>用作默认服务器名称。 </p>
</blockquote>
<h4 id="基于名称的混合和基于IP的虚拟服务器"><a href="#基于名称的混合和基于IP的虚拟服务器" class="headerlink" title="基于名称的混合和基于IP的虚拟服务器"></a>基于名称的混合和基于IP的虚拟服务器</h4><p>  让我们看一个更复杂的配置，其中一些虚拟服务器监听不同的地址： </p>
<pre class="notranslate">server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80;
    server_name example.com www.example.com;
    ...
}
</pre>

<p>  在此配置中，nginx首先根据<a href="ngx_http_core_module.html#server">服务器</a>块的<a href="ngx_http_core_module.html#listen">listen</a>指令测试请求的IP地址和端口。  然后，它针对与IP地址和端口匹配的<a href="ngx_http_core_module.html#server">服务器</a>块的<a href="ngx_http_core_module.html#server_name">server_name</a>条目测试请求的“Host”头字段。  如果未找到服务器名称，则默认服务器将处理该请求。  例如，在192.168.1.1:80端口上收到的<code>www.example.com</code>请求将由192.168.1.1:80端口的默认服务器处理，即由第一台服务器处理，因为没有<code>www.example.com</code>为此端口定义。 </p>
<p>  如前所述，默认服务器是监听端口的属性，可以为不同的端口定义不同的默认服务器： </p>
<pre class="notranslate">server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80 **default_server** ;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80 **default_server** ;
    server_name example.com www.example.com;
    ...
}
</pre>



<h4 id="一个简单的PHP站点配置"><a href="#一个简单的PHP站点配置" class="headerlink" title="一个简单的PHP站点配置"></a>一个简单的PHP站点配置</h4><p>  现在让我们看看nginx如何选择一个<em>位置</em>来处理一个典型的简单PHP站点的请求： </p>
<pre class="notranslate">server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
</pre>



<p>   nginx首先搜索由文字字符串给出的最具体的前缀位置，而不管列出的顺序如何。  在上面的配置中，唯一的前缀位置是“ <code>/</code> ”，因为它匹配任何请求，它将被用作最后的手段。  然后nginx按照配置文件中列出的顺序检查正则表达式给出的位置。  第一个匹配表达式将停止搜索，nginx将使用此位置。  如果没有正则表达式与请求匹配，则nginx使用先前找到的最具体的前缀位置。 </p>
<p>  请注意，所有类型的位置仅测试不带参数的请求行的URI部分。  这样做是因为查询字符串中的参数可以通过多种方式给出，例如： </p>
<pre class="notranslate">/index.php?user=john&amp;page=1
/index.php?page=1&amp;user=john
</pre>

<p>  此外，任何人都可以在查询字符串中请求任何内容 </p>
<pre class="notranslate">/index.php?page=1&amp;something+else&amp;user=john
</pre>



<p>  现在让我们看看如何在上面的配置中处理请求： </p>
<ul>
<li>请求“ <code>/logo.gif</code> ”首先与前缀位置“ <code>/</code> ”匹配，然后由正则表达式“ <code>\.(gif|jpg|png)$</code> ”匹配，因此，它由后一个位置处理。  使用指令“ <code>root /data/www</code> ”将请求映射到文件<code>/data/www/logo.gif</code> ，并将文件发送到客户端。 -   请求“ <code>/index.php</code> ”也首先与前缀位置“ <code>/</code> ”匹配，然后由正则表达式“ <code>\.(php)$</code> ”匹配。  因此，它由后一个位置处理，请求被传递给侦听localhost：9000的FastCGI服务器。   <a href="ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a>指令将FastCGI参数<code>SCRIPT_FILENAME</code>为“ <code>/data/www/index.php</code>服务器执行该文件。  变量<code>$document_root</code>等于<a href="ngx_http_core_module.html#root">root</a>指令的值，变量<code>$fastcgi_script_name</code>等于请求URI，即“ <code>/index.php</code> ”。 -   请求“ <code>/about.html</code> ”仅与前缀位置“ <code>/</code> ”匹配，因此，它在此位置处理。  使用指令“ <code>root /data/www</code> ”将请求映射到文件<code>/data/www/about.html</code> ，并将文件发送到客户端。 -   处理请求“ <code>/</code> ”更复杂。  它仅与前缀位置“ <code>/</code> ”匹配，因此，它由此位置处理。  然后<a href="ngx_http_index_module.html#index">索引</a>指令根据其参数和“ <code>root /data/www</code> ”指令测试索引文件是否存在。  如果文件<code>/data/www/index.html</code>不存在，并且文件<code>/data/www/index.php</code>存在，则该指令执行内部重定向到“ <code>/index.php</code> ”，并且nginx再次搜索位置如果请求是由客户发送的。  正如我们之前看到的，重定向的请求最终将由FastCGI服务器处理。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_xslt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_xslt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_xslt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-xslt-module"><a href="#Module-ngx-http-xslt-module" class="headerlink" title="Module ngx_http_xslt_module"></a>Module ngx_http_xslt_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#xml_entities">xml_entities</a> <br>     <a href="#xslt_last_modified">xslt_last_modified</a> <br>     <a href="#xslt_param">xslt_param</a> <br>     <a href="#xslt_string_param">xslt_string_param</a> <br>     <a href="#xslt_stylesheet">xslt_stylesheet</a> <br>     <a href="#xslt_types">xslt_types</a> <br></td>

<p>   <code>ngx_http_xslt_module</code> （0.7.8+）是一个使用一个或多个XSLT样式表转换XML响应的过滤器。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_xslt_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://xmlsoft.org" target="_blank" rel="noopener">libxml2</a>和<a href="http://xmlsoft.org/XSLT/" target="_blank" rel="noopener">libxslt</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    xml_entities    /site/dtd/entities.dtd;
    xslt_stylesheet /site/xslt/one.xslt param=value;
    xslt_stylesheet /site/xslt/two.xslt;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xml_entities*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定声明字符实体的DTD文件。  此文件在配置阶段编译。  由于技术原因，模块无法使用已处理XML中声明的外部子集，因此将忽略该模块并使用特殊定义的文件。  此文件不应描述XML结构。  仅声明所需的字符实体就足够了，例如： </p>
<pre class="notranslate">&lt;!ENTITY nbsp "&amp;#xa0;"&gt;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xslt_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在XSLT转换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在转换期间修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_param*parameter*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.18版中。 </p>
<p>  定义XSLT样式表的参数。  该<code>*value*</code>被视为XPath表达式。  该<code>*value*</code>可以包含变量。  要将字符串值传递给样式表，可以使用<a href="#xslt_string_param">xslt_string_param</a>指令。 </p>
<p>  可能有几个<code>xslt_param</code>指令。  当且仅当在当前级别上没有定义<code>xslt_param</code>和<a href="#xslt_string_param">xslt_string_param</a>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_string_param*parameter*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.18版中。 </p>
<p>  定义XSLT样式表的字符串参数。  不解释<code>*value*</code>中的XPath表达式。  该<code>*value*</code>可以包含变量。 </p>
<p>  可能有几个<code>xslt_string_param</code>指令。  当且仅当在当前级别上没有定义<a href="#xslt_param">xslt_param</a>和<code>xslt_string_param</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_stylesheet**     &lt;code class=&quot;notranslate&quot;&gt;*stylesheet*</code>    [ <code>*parameter*</code> = <code>*value*</code> …];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义XSLT样式表及其可选参数。  样式表在配置阶段编译。 </p>
<p>  参数既可以单独指定，也可以使用“ <code>:</code> ”分隔符分组在一行中。  如果参数包含“ <code>:</code> ”字符，则应将其转义为“ <code>%3A</code> ”。  此外， <code>libxslt</code>要求将包含非字母数字字符的参数括在单引号或双引号中，例如： </p>
<pre class="notranslate">param1='http%3A//www.example.com':param2=value2
</pre>



<p>  参数描述可以包含变量，例如，整行参数可以从单个变量中获取： </p>
<pre class="notranslate">location / {
    xslt_stylesheet /site/xslt/one.xslt
                    $arg_xslt_params
                    param1='$value1':param2=value2
                    param3=value3;
}
</pre>



<p>  可以指定多个样式表。  它们将按指定的顺序依次应用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xslt_types text/xml;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/xml</code> ”之外，还启用具有指定MIME类型的响应中的转换。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。  如果转换结果是HTML响应，则其MIME类型将更改为“ <code>text/html</code> ”。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_v2_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_v2_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_v2_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-v2-module"><a href="#Module-ngx-http-v2-module" class="headerlink" title="Module ngx_http_v2_module"></a>Module ngx_http_v2_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#http2_body_preread_size">http2_body_preread_size</a> <br>     <a href="#http2_chunk_size">http2_chunk_size</a> <br>     <a href="#http2_idle_timeout">http2_idle_timeout</a> <br>     <a href="#http2_max_concurrent_pushes">http2_max_concurrent_pushes</a> <br>     <a href="#http2_max_concurrent_streams">http2_max_concurrent_streams</a> <br>     <a href="#http2_max_field_size">http2_max_field_size</a> <br>     <a href="#http2_max_header_size">http2_max_header_size</a> <br>     <a href="#http2_max_requests">http2_max_requests</a> <br>     <a href="#http2_push">http2_push</a> <br>     <a href="#http2_push_preload">http2_push_preload</a> <br>     <a href="#http2_recv_buffer_size">http2_recv_buffer_size</a> <br>     <a href="#http2_recv_timeout">http2_recv_timeout</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_v2_module</code>模块（1.9.5）提供对<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">HTTP / 2的</a>支持并取代<a href="ngx_http_spdy_module.html">ngx_http_spdy_module</a>模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_v2_module</code>配置参数启用它。 </p>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  在版本1.9.14之前，无论<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>和<a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 443 ssl http2;

    ssl_certificate server.crt;
    ssl_certificate_key server.key;
}
</pre>

<p>  请注意，通过TLS接受HTTP / 2连接需要“应用程序层协议协商”（ALPN）TLS扩展支持，该支持仅在<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>版本1.0.2之后可用。  为此目的使用“下一协议协商”（NPN）TLS扩展（自OpenSSL版本1.0.1起可用）不能保证有效。 </p>
<p>  另请注意，如果<a href="ngx_http_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a>指令设置为值“ <code>on</code> ”，则应将<a href="ngx_http_ssl_module.html#ssl_ciphers">密码</a>配置为符合<a href="https://tools.ietf.org/html/rfc7540#appendix-A" target="_blank" rel="noopener">RFC 7540，附录A</a>黑名单并由客户端支持。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_body_preread_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_body_preread_size 64k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.0版本中。 </p>
<p>  设置在开始处理请求主体之前可以保存请求主体的每个请求的缓冲区<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_chunk_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_chunk_size 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置响应主体被切片到的块的最大大小。  值太低会导致更高的开销。  由于<a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener">HOL阻塞，</a>太高的值会损害优先级。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_idle_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_idle_timeout 3m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置关闭连接之前的不活动超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_concurrent_pushes*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_concurrent_pushes 10;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  限制连接中的最大并发<a href="#http2_push">推送</a>请求数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_concurrent_streams*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_concurrent_streams 128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置连接中的最大并发HTTP / 2流数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_field_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_field_size 4k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  限制<a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK</a>压缩请求标头字段的最大大小。  该限制同样适用于名称和价值。  请注意，如果应用了霍夫曼编码，则解压缩的名称和值字符串的实际大小可能会更大。  对于大多数请求，默认限制应该足够。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_header_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_header_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  在<a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK</a>解压缩后限制整个请求标头列表的最大大小。  对于大多数请求，默认限制应该足够。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_requests 1000;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置可通过一个HTTP / 2连接提供的最大请求数（包括<a href="#http2_push">推送</a>请求），之后下一个客户端请求将导致连接关闭以及建立新连接的需要。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_push*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_push off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  先发制人地将请求发送（ <a href="https://tools.ietf.org/html/rfc7540#section-8.2" target="_blank" rel="noopener">推送</a> ）到指定的<code>*uri*</code>以及对原始请求的响应。  仅处理具有绝对路径的相对URI，例如： </p>
<pre class="notranslate">http2_push /static/css/main.css;
</pre>

<p>   <code>*uri*</code>值可以包含变量。 </p>
<p>  可以在同一配置级别指定多个<code>http2_push</code>指令。   <code>off</code>参数取消了从先前配置级别继承的<code>http2_push</code>指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_push_preloadon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_push_preload off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  允许将“链接”响应头字段中指定的<a href="https://www.w3.org/TR/preload/#server-push-http-2" target="_blank" rel="noopener">预加载链接</a>自动转换为<a href="https://tools.ietf.org/html/rfc7540#section-8.2" target="_blank" rel="noopener">推送</a>请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_recv_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_recv_buffer_size 256k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置每个<a href="ngx_core_module.html#worker_processes">工作者</a>输入缓冲区的大小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_recv_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_recv_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置从客户端获取更多数据的超时，然后关闭连接。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_v2_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_uwsgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_uwsgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_uwsgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-uwsgi-module"><a href="#Module-ngx-http-uwsgi-module" class="headerlink" title="Module ngx_http_uwsgi_module"></a>Module ngx_http_uwsgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#uwsgi_bind">uwsgi_bind</a> <br>     <a href="#uwsgi_buffer_size">uwsgi_buffer_size</a> <br>     <a href="#uwsgi_buffering">uwsgi_buffering</a> <br>     <a href="#uwsgi_buffers">uwsgi_buffers</a> <br>     <a href="#uwsgi_busy_buffers_size">uwsgi_busy_buffers_size</a> <br>     <a href="#uwsgi_cache">uwsgi_cache</a> <br>     <a href="#uwsgi_cache_background_update">uwsgi_cache_background_update</a> <br>     <a href="#uwsgi_cache_bypass">uwsgi_cache_bypass</a> <br>     <a href="#uwsgi_cache_key">uwsgi_cache_key</a> <br>     <a href="#uwsgi_cache_lock">uwsgi_cache_lock</a> <br>     <a href="#uwsgi_cache_lock_age">uwsgi_cache_lock_age</a> <br>     <a href="#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a> <br>     <a href="#uwsgi_cache_max_range_offset">uwsgi_cache_max_range_offset</a> <br>     <a href="#uwsgi_cache_methods">uwsgi_cache_methods</a> <br>     <a href="#uwsgi_cache_min_uses">uwsgi_cache_min_uses</a> <br>     <a href="#uwsgi_cache_path">uwsgi_cache_path</a> <br>     <a href="#uwsgi_cache_purge">uwsgi_cache_purge</a> <br>     <a href="#uwsgi_cache_revalidate">uwsgi_cache_revalidate</a> <br>     <a href="#uwsgi_cache_use_stale">uwsgi_cache_use_stale</a> <br>     <a href="#uwsgi_cache_valid">uwsgi_cache_valid</a> <br>     <a href="#uwsgi_connect_timeout">uwsgi_connect_timeout</a> <br>     <a href="#uwsgi_force_ranges">uwsgi_force_ranges</a> <br>     <a href="#uwsgi_hide_header">uwsgi_hide_header</a> <br>     <a href="#uwsgi_ignore_client_abort">uwsgi_ignore_client_abort</a> <br>     <a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a> <br>     <a href="#uwsgi_intercept_errors">uwsgi_intercept_errors</a> <br>     <a href="#uwsgi_limit_rate">uwsgi_limit_rate</a> <br>     <a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a> <br>     <a href="#uwsgi_modifier1">uwsgi_modifier1</a> <br>     <a href="#uwsgi_modifier2">uwsgi_modifier2</a> <br>     <a href="#uwsgi_next_upstream">uwsgi_next_upstream</a> <br>     <a href="#uwsgi_next_upstream_timeout">uwsgi_next_upstream_timeout</a> <br>     <a href="#uwsgi_next_upstream_tries">uwsgi_next_upstream_tries</a> <br>     <a href="#uwsgi_no_cache">uwsgi_no_cache</a> <br>     <a href="#uwsgi_param">uwsgi_param</a> <br>     <a href="#uwsgi_pass">uwsgi_pass</a> <br>     <a href="#uwsgi_pass_header">uwsgi_pass_header</a> <br>     <a href="#uwsgi_pass_request_body">uwsgi_pass_request_body</a> <br>     <a href="#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a> <br>     <a href="#uwsgi_read_timeout">uwsgi_read_timeout</a> <br>     <a href="#uwsgi_request_buffering">uwsgi_request_buffering</a> <br>     <a href="#uwsgi_send_timeout">uwsgi_send_timeout</a> <br>     <a href="#uwsgi_socket_keepalive">uwsgi_socket_keepalive</a> <br>     <a href="#uwsgi_ssl_certificate">uwsgi_ssl_certificate</a> <br>     <a href="#uwsgi_ssl_certificate_key">uwsgi_ssl_certificate_key</a> <br>     <a href="#uwsgi_ssl_ciphers">uwsgi_ssl_ciphers</a> <br>     <a href="#uwsgi_ssl_crl">uwsgi_ssl_crl</a> <br>     <a href="#uwsgi_ssl_name">uwsgi_ssl_name</a> <br>     <a href="#uwsgi_ssl_password_file">uwsgi_ssl_password_file</a> <br>     <a href="#uwsgi_ssl_protocols">uwsgi_ssl_protocols</a> <br>     <a href="#uwsgi_ssl_server_name">uwsgi_ssl_server_name</a> <br>     <a href="#uwsgi_ssl_session_reuse">uwsgi_ssl_session_reuse</a> <br>     <a href="#uwsgi_ssl_trusted_certificate">uwsgi_ssl_trusted_certificate</a> <br>     <a href="#uwsgi_ssl_verify">uwsgi_ssl_verify</a> <br>     <a href="#uwsgi_ssl_verify_depth">uwsgi_ssl_verify_depth</a> <br>     <a href="#uwsgi_store">uwsgi_store</a> <br>     <a href="#uwsgi_store_access">uwsgi_store_access</a> <br>     <a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a> <br>     <a href="#uwsgi_temp_path">uwsgi_temp_path</a> <br></td>

<p>   <code>ngx_http_uwsgi_module</code>模块允许将请求传递给uwsgi服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    include    uwsgi_params;
    uwsgi_pass localhost:9000;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到uwsgi服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>uwsgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到uwsgi服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">uwsgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自uwsgi服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从uwsgi服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用缓冲来自uwsgi服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从uwsgi服务器接收响应，并将其保存到<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#uwsgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a>和<a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从uwsgi服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从uwsgi服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用<a href="#uwsgi_buffering">缓冲</a>来自uwsgi服务器的响应时，限制可能忙于向客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>受<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的两个缓冲区<code>*size*</code>的限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#uwsgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">uwsgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
uwsgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#uwsgi_no_cache">uwsgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">uwsgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给<a href="#uwsgi_cache_key">uwsgi</a>服务器，一次只允许一个请求填充根据<a href="#uwsgi_cache_key">uwsgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存此元素的缓存锁定，直到<a href="#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给uwsgi服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给uwsgi服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#uwsgi_cache_lock">uwsgi_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给uwsgi服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给uwsgi服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_methods**     &lt;code class=&quot;notranslate&quot;&gt;GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#uwsgi_no_cache">uwsgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#uwsgi_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">uwsgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#uwsgi_temp_path">uwsgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#uwsgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#uwsgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#uwsgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">uwsgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        uwsgi_pass        backend;
        uwsgi_cache       cache_zone;
        uwsgi_cache_key   $uri;
        uwsgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_use_stale**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与uwsgi服务器通信期间发生错误时，在哪些情况下可以使用过时的缓存响应。  该指令的参数与<a href="#uwsgi_next_upstream">uwsgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择要处理请求的uwsgi服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对uwsgi服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对uwsgi服务器的访问次数，可以使用<a href="#uwsgi_cache_lock">uwsgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_valid** [ &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">uwsgi_cache_valid 200 302 10m;
uwsgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">uwsgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">uwsgi_cache_valid 200 302 10m;
uwsgi_cache_valid 301      1h;
uwsgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与uwsgi服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_force_rangeson</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_force_ranges off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.7.7版本中。 </p>
<p>无论这些响应中的“Accept-Ranges”字段如何，都可以对来自uwsgi服务器的缓存和未缓存响应启用字节范围支持。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_hide_header*field*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>默认情况下，nginx不会从uwsgi服务器对客户端的响应中传递标题字段“Status”和“X-Accel -…”。   <code>uwsgi_hide_header</code>指令设置了不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#uwsgi_pass_header">uwsgi_pass_header</a>指令。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ignore_client_abort off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>确定客户端在不等待响应的情况下关闭连接时是否应关闭与uwsgi服务器的连接。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ignore_headers*field*</code> …;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>禁用从uwsgi服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#uwsgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#uwsgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的uwsgi服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从uwsgi服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到uwsgi服务器的连接，则总速率将是指定限制的两倍。  仅当启用了来自uwsgi服务器的响应<a href="#uwsgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用<a href="#uwsgi_buffering">缓冲</a>来自uwsgi服务器的响应，并且整个响应不适合<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#uwsgi_cache">缓存</a>或<a href="#uwsgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_modifier1*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_modifier1 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">uwsgi数据包标头中</a> <code>modifier1</code>字段的<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">值</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_modifier2*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_modifier2 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">uwsgi数据包标头中</a> <code>modifier2</code>字段的<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">值</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#uwsgi_next_upstream_tries">尝试次数</a>和<a href="#uwsgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#uwsgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#uwsgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">uwsgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
uwsgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#uwsgi_cache_bypass">uwsgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_param**     &lt;code class=&quot;notranslate&quot;&gt;*parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给uwsgi服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>uwsgi_param</code>指令时，这些指令才从先前级别继承。 </p>
<p>  标准<a href="https://tools.ietf.org/html/rfc3875#section-4.1" target="_blank" rel="noopener">CGI环境变量</a>应作为uwsgi标头提供，请参阅分发中提供的<code>uwsgi_params</code>文件： </p>
<pre class="notranslate">location / {
    include uwsgi_params;
    ...
}
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">uwsgi_param HTTPS $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass** [ &lt;code class=&quot;notranslate&quot;&gt;*protocol*</code> ://] <code>*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置uwsgi服务器的协议和地址。  作为<code>*protocol*</code> ，可以指定“ <code>suwsgi</code> ”或“ <code>suwsgi</code> ”（安全的<code>suwsgi</code> over SSL）。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">uwsgi_pass localhost:9000;
uwsgi_pass uwsgi://localhost:9000;
uwsgi_pass suwsgi://[2001:db8::1]:9090;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">uwsgi_pass unix:/tmp/uwsgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<blockquote>
<p>  从版本1.5.8开始支持安全的uwsgi协议。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将来自uwsgi服务器的<a href="#uwsgi_hide_header">其他禁用的</a>头字段传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给uwsgi服务器。  另请参见<a href="#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给uwsgi服务器。  另请参见<a href="#uwsgi_pass_request_body">uwsgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从uwsgi服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果uwsgi服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到uwsgi服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到uwsgi服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#uwsgi_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到uwsgi服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果uwsgi服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  为uwsgi服务器的传出连接配置“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对安全的uwsgi服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对安全的uwsgi服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  指定对安全的uwsgi服务器的请求的启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#uwsgi_ssl_verify">验证</a>受保护的uwsgi服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_name host from uwsgi_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  允许覆盖用于<a href="#uwsgi_ssl_verify">验证</a>安全uwsgi服务器证书的服务器名称，并在与安全uwsgi服务器建立连接时<a href="#uwsgi_ssl_server_name">通过SNI</a>传递。 </p>
<p>  默认情况下，使用<a href="#uwsgi_pass">uwsgi_pass</a>的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  为安全的uwsgi服务器启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在与安全的uwsgi服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  确定在使用安全的uwsgi服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#uwsgi_ssl_verify">验证</a>安全uwsgi服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  启用或禁用安全uwsgi服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在安全的uwsgi服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_store**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">uwsgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，保存的文件和保存临时文件的目录（由<a href="#uwsgi_temp_path">uwsgi_temp_path</a>指令设置）都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = /fetch$uri;
}

location /fetch/ {
    internal;

    uwsgi_pass         backend:9000;
    ...

    uwsgi_store        on;
    uwsgi_store_access user:rw group:rw all:r;
    uwsgi_temp_path    /data/temp;

    alias              /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">uwsgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">uwsgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从uwsgi服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>受<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_temp_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_temp_path uwsgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从uwsgi服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">uwsgi_temp_path /spool/nginx/uwsgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/uwsgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#uwsgi_cache_path">uwsgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_userid_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_userid_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_userid_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-userid-module"><a href="#Module-ngx-http-userid-module" class="headerlink" title="Module ngx_http_userid_module"></a>Module ngx_http_userid_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#userid">userid</a> <br>     <a href="#userid_domain">userid_domain</a> <br>     <a href="#userid_expires">userid_expires</a> <br>     <a href="#userid_mark">userid_mark</a> <br>     <a href="#userid_name">userid_name</a> <br>     <a href="#userid_p3p">userid_p3p</a> <br>     <a href="#userid_path">userid_path</a> <br>     <a href="#userid_service">userid_service</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_userid_module</code>模块设置适合客户端识别的cookie。  可以使用嵌入变量<a href="#var_uid_got">$ uid_got</a>和<a href="#var_uid_set">$ uid_set</a>记录已接收和设置的cookie。  该模块与Apache的<a href="http://www.lexa.ru/programs/mod-uid-eng.html" target="_blank" rel="noopener">mod_uid</a>模块兼容。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">userid         on;
userid_name    uid;
userid_domain  example.com;
userid_path    /;
userid_expires 365d;
userid_p3p     'policyref="/w3c/p3p.xml", CP="CUR ADM OUR NOR STA NID"';
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>v1</code> |    <code>log</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用设置cookie并记录收到的cookie： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_domain*name*</code> | <code>none</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_domain none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义为其设置cookie的域。   <code>none</code>参数禁用cookie的域设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_expires*time*</code> | <code>max</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_expires off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置浏览器保留cookie的时间。  参数<code>max</code>将导致cookie在“ <code>31 Dec 2037 23:55:55 GMT</code> ”到期。  参数<code>off</code>将导致cookie在浏览器会话结束时到期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_mark**     &lt;code class=&quot;notranslate&quot;&gt;*letter*</code> | <code>*digit*</code> |    <code>=</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_mark off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果参数未<code>off</code> ，则启用cookie标记机制并设置用作标记的字符。  此机制用于在保留客户端标识符的同时添加或更改<a href="#userid_p3p">userid_p3p</a>和/或cookie过期时间。  标记可以是英文字母（区分大小写），数字或“ <code>=</code> ”字符的任何字母。 </p>
<p>  如果设置了标记，则将其与cookie中传递的客户端标识符的base64表示中的第一个填充符号进行比较。  如果它们不匹配，则会使用指定的标记，到期时间和“P3P”标头重新发送cookie。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_name uid;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置cookie名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_p3p*string*</code> | <code>none</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_p3p none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将与cookie一起发送的“P3P”标题字段的值。  如果指令设置为特殊值<code>none</code> ，则不会在响应中发送“P3P”标头。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_path*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_path /;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义cookie的设置路径。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_service*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_service IP address of the server;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果标识符由多个服务器（服务）发出，则应为每个服务分配其自己的<code>*number*</code>以确保客户端标识符是唯一的。  对于版本1 cookie，默认值为零。  对于版本2 cookie，默认值是由服务器IP地址的最后四个八位字节组成的数字。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_userid_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-module"><a href="#Module-ngx-http-upstream-module" class="headerlink" title="Module ngx_http_upstream_module"></a>Module ngx_http_upstream_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream">upstream</a> <br>     <a href="#server">server</a> <br>     <a href="#zone">zone</a> <br>     <a href="#state">state</a> <br>     <a href="#hash">hash</a> <br>     <a href="#ip_hash">ip_hash</a> <br>     <a href="#keepalive">keepalive</a> <br>     <a href="#keepalive_requests">keepalive_requests</a> <br>     <a href="#keepalive_timeout">keepalive_timeout</a> <br>     <a href="#ntlm">ntlm</a> <br>     <a href="#least_conn">least_conn</a> <br>     <a href="#least_time">least_time</a> <br>     <a href="#queue">queue</a> <br>     <a href="#random">random</a> <br>     <a href="#sticky">sticky</a> <br>     <a href="#sticky_cookie_insert">sticky_cookie_insert</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_upstream_module</code>模块用于定义可由<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>和<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream **backend** {
    server backend1.example.com       weight=5;
    server backend2.example.com:8080;
    server unix:/tmp/backend3;

    server backup1.example.com:8080   backup;
    server backup2.example.com:8080   backup;
}

server {
    location / {
        proxy_pass http:// **backend** ;
    }
}
</pre>



<p>  具有定期<a href="ngx_http_upstream_hc_module.html">运行状况检查的</a>动态可配置组可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分： </p>
<pre class="notranslate">resolver 10.0.0.1;

upstream **dynamic** {
    zone upstream_dynamic 64k;

    server backend1.example.com      weight=5;
    server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
    server 192.0.2.1                 max_fails=3;
    server backend3.example.com      resolve;
    server backend4.example.com      service=http resolve;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
}

server {
    location / {
        proxy_pass http:// **dynamic** ;
        health_check;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义一组服务器。  服务器可以侦听不同的端口。  此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com weight=5;
    server 127.0.0.1:8080       max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend3;

    server backup1.example.com  backup;
}
</pre>



<p>  默认情况下，使用加权循环平衡方法在服务器之间分配请求。  在上面的示例中，每个7个请求将按如下方式分发：5个请求转到<code>backend1.example.com</code> ，1个请求转发给第二个和第三个服务器。  如果在与服务器通信期间发生错误，请求将被传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。  如果无法从任何服务器获得成功的响应，则客户端将接收与最后一个服务器的通信结果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server*address*</code> [ <code>*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义服务器的<code>*address*</code>和其他<code>*parameters*</code> 。  可以将地址指定为域名或IP地址，带有可选端口，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  如果未指定端口，则使用端口80。  解析为多个IP地址的域名一次定义多个服务器。 </p>
<p>  可以定义以下参数： </p>
<blockquote>
<p>  如果启用了<a href="#keepalive">空闲keepalive</a>连接，多个<a href="ngx_core_module.html#worker_processes">工作程序</a>和<a href="#zone">共享内存</a> ，则代理服务器的活动和空闲连接总数可能会超过<code>max_conns</code>值。 </p>
<p>  自版本1.5.9和版本1.11.5之前，此参数作为我们的<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
<ul>
<li>指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; -   以及服务器被视为不可用的时间段。 </li>
</ul>
</blockquote>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<p>  要使此参数起作用，必须在<a href="ngx_http_core_module.html#http">http</a>块中指定<a href="ngx_http_core_module.html#resolver">解析程序</a>指令。  例： </p>
<pre class="notranslate">http {
    resolver 10.0.0.1;

    upstream u {
        zone ...;
        ...
        server example.com resolve;
    }
}
</pre>



<p>  如果服务名称不包含点（“ <code>.</code> ”），则构造符合<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC</a>的名称，并将TCP协议添加到服务前缀。  例如，要查找<code>_http._tcp.backend.example.com</code> SRV记录，必须指定该指令： </p>
<pre class="notranslate">server backend.example.com service=http resolve;
</pre>

<p>  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。  例如，要查找<code>_http._tcp.backend.example.com</code>和<code>server1.backend.example.com</code> SRV记录，必须指定指令： </p>
<pre class="notranslate">server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</pre>



<p>  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。  如果为服务器指定了<a href="#backup">backup</a>参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
<blockquote>
<p>  该参数不能与<a href="#hash">hash</a>和<a href="#ip_hash">ip_hash</a>负载平衡方法一起使用。 </p>
<p>  在1.13.6版之前，只能使用<a href="ngx_http_api_module.html">API</a>模块更改参数。 </p>
<p>  如果组中只有一个服务器，则忽略<code>max_fails</code> ， <code>fail_timeout</code>和<code>slow_start</code>参数，并且永远不会将此类服务器视为不可用。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone*name*</code> [ <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.0版本中。 </p>
<p>  定义共享内存区域的<code>*name*</code>和<code>*size*</code> ，该区域保持组工作进程之间共享的组配置和运行时状态。  几个组可能共享同一个区域。  在这种情况下，仅指定一次<code>*size*</code>就足够了。 </p>
<p>  此外，作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。  可通过<a href="ngx_http_api_module.html">API</a>模块（1.13.3）访问该配置。 </p>
<blockquote>
<p>  在1.13.3版之前，只能通过<a href="ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a>处理的特殊位置访问配置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**state*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  指定保持动态可配置组状态的<code>*file*</code> 。 </p>
<p>  例子： </p>
<pre class="notranslate">state /var/lib/nginx/state/servers.conf; # path for Linux
state /var/db/nginx/state/servers.conf;  # path for FreeBSD
</pre>



<p>  该状态目前仅限于具有其参数的服务器列表。  解析配置时会读取文件，每次<a href="ngx_http_api_module.html#http_upstreams_http_upstream_name_servers_">更改</a>上游配置时都会更新该文件。  应避免直接更改文件内容。  该指令不能与<a href="#server">server</a>指令一起使用。 </p>
<blockquote>
<p>   <a href="control.html#reconfiguration">配置重新加载</a>或<a href="control.html#upgrade">二进制升级</a>期间所做的更改可能会丢失。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hash*key*</code> [ <code>consistent</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.7.2版本中。 </p>
<p>  指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<code>*key*</code> 。   <code>*key*</code>可以包含文本，变量及其组合。  请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached" target="_blank" rel="noopener">Cache :: Memcached</a> Perl库兼容。 </p>
<p>  如果指定了<code>consistent</code>参数，则将使用<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="noopener">ketama</a>一致性哈希方法。  该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。  这有助于为缓存服务器实现更高的缓存命中率。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached::Fast" target="_blank" rel="noopener">Cache :: Memcached :: Fast</a> Perl库兼容，并将<code>*ketama_points*</code>参数设置为160。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ip_hash** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中请求根据客户端IP地址在服务器之间分配。  客户端IPv4地址的前三个八位字节或整个IPv6地址用作散列密钥。  该方法确保来自同一客户端的请求将始终传递到同一服务器，除非此服务器不可用。  在后一种情况下，客户端请求将被传递到另一个服务器。  最有可能的是，它也将始终是同一台服务器。 </p>
<blockquote>
<p>  从版本1.3.2和1.2.2开始支持IPv6地址。 </p>
</blockquote>
<p>  如果需要临时删除其中一个服务器，则应使用<code>down</code>参数对其进行标记，以保留客户端IP地址的当前哈希值。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    ip_hash;

    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com **down** ;
    server backend4.example.com;
}
</pre>





<blockquote>
<p>  在版本1.3.1和1.2.2之前，无法使用<code>ip_hash</code>负载平衡方法为服务器指定权重。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive*connections*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  激活缓存以连接到上游服务器。 </p>
<p>   <code>*connections*</code>参数设置在每个工作进程的缓存中保留的上游服务器的最大空闲keepalive连接数。  超过此数量时，将关闭最近最少使用的连接。 </p>
<blockquote>
<p>  应特别注意的是， <code>keepalive</code>指令不限制nginx工作进程可以打开的上游服务器的连接总数。   <code>*connections*</code>参数应设置为足够小的数字，以便上游服务器也可以处理新的传入连接。 </p>
</blockquote>
<p>  使用keepalive连接的memcached上游示例配置： </p>
<pre class="notranslate">upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;

    keepalive 32;
}

server {
    ...

    location /memcached/ {
        set $memcached_key $uri;
        memcached_pass memcached_backend;
    }

}
</pre>



<p>  对于HTTP， <a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>指令应设置为“ <code>1.1</code> ”，并且应清除“Connection”头字段： </p>
<pre class="notranslate">upstream http_backend {
    server 127.0.0.1:8080;

    keepalive 16;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre>





<blockquote>
<p>  或者，可以通过将“Connection：Keep-Alive”头字段传递给上游服务器来使用HTTP / 1.0持久连接，但不建议使用此方法。 </p>
</blockquote>
<p>  对于FastCGI服务器，需要设置<a href="ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a>才能使keepalive连接正常工作： </p>
<pre class="notranslate">upstream fastcgi_backend {
    server 127.0.0.1:9000;

    keepalive 8;
}

server {
    ...

    location /fastcgi/ {
        fastcgi_pass fastcgi_backend;
        fastcgi_keep_conn on;
        ...
    }
}
</pre>





<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>keepalive</code>指令之前激活它们。 </p>
<p>   SCGI和uwsgi协议没有keepalive连接的概念。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">keepalive_requests 100;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  设置可通过一个keepalive连接提供的最大请求数。  在发出最大请求数后，将关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">keepalive_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  设置超时，在此期间与上游服务器的空闲keepalive连接将保持打开状态。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ntlm** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  允许使用<a href="https://en.wikipedia.org/wiki/Integrated_Windows_Authentication" target="_blank" rel="noopener">NTLM身份验证</a>代理请求。  一旦客户端发送具有以“ <code>Negotiate</code> ”或“ <code>NTLM</code> ”开头的“Authorization”头字段值的请求，上游连接就绑定到客户端连接。  进一步的客户端请求将通过相同的上游连接进行代理，从而保持身份验证上下文。 </p>
<p>  为了使NTLM身份验证起作用，必须启用与上游服务器的keepalive连接。   <a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>指令应设置为“ <code>1.1</code> ”，并且应清除“Connection”头字段： </p>
<pre class="notranslate">upstream http_backend {
    server 127.0.0.1:8080;

    ntlm;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre>





<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>ntlm</code>指令之前激活它们。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_conn** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.3.1和1.2.2版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将请求传递到具有最少活动连接的服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_time**     &lt;code class=&quot;notranslate&quot;&gt;header</code> |    <code>last_byte</code>    [ <code>inflight</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.7.10版本中。 </p>
<p>  指定组应使用负载平衡方法，其中请求以最少的平均响应时间和最少的活动连接传递给服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p>  如果指定了<code>header</code>参数，则使用接收<a href="#var_upstream_header_time">响应头的</a>时间。  如果指定了<code>last_byte</code>参数，则使用接收<a href="#var_upstream_response_time">完整响应的</a>时间。  如果指定了<code>inflight</code>参数（1.11.6），则还会考虑不完整的请求。 </p>
<blockquote>
<p>  在1.11.6版之前，默认情况下会考虑不完整的请求。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**queue*number*</code>[ <code>timeout</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.5.12版本中。 </p>
<p>  如果在处理请求时无法立即选择上游服务器，则请求将被放入队列中。  该指令指定了可以同时在队列中的最大请求<code>*number*</code> 。  如果队列已满，或者在<code>timeout</code>参数中指定的时间段内无法选择要传递请求的服务器，则会将502（错误网关）错误返回给客户端。 </p>
<p>   <code>timeout</code>参数的默认值为60秒。 </p>
<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>queue</code>指令之前激活它们。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random** [ &lt;code class=&quot;notranslate&quot;&gt;two</code> [ <code>*method*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.1版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将请求传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p>  可选的<code>two</code>参数指示nginx随机选择<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="noopener">两个</a>服务器，然后使用指定的<code>method</code>选择服务器。  默认方法是<code>least_conn</code> ，它将请求传递给活动连接数最少的服务器。 </p>
<p>   <code>least_time</code>方法将请求传递给具有最少平均响应时间和最少活动连接数的服务器。  如果指定了<code>least_time=header</code> ，则使用接收<a href="#var_upstream_header_time">响应头</a>的时间。  如果指定了<code>least_time=last_byte</code> ，则使用接收<a href="#var_upstream_response_time">完整响应</a>的时间。 </p>
<blockquote>
<p>   <code>least_time</code>方法可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅</a>的一部分。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sticky**     &lt;code class=&quot;notranslate&quot;&gt;cookie</code> <code>*name*</code>    [ <code>expires=</code> <code>*time*</code> ]    [ <code>domain=</code> <code>*domain*</code> ]    [ <code>httponly</code> ]    [ <code>secure</code> ]    [ <code>path=</code> <code>*path*</code> ]; <br> <code>**sticky**     &lt;code class=&quot;notranslate&quot;&gt;route</code> <code>*$variable*</code> …; <br> <code>**sticky**     &lt;code class=&quot;notranslate&quot;&gt;learn</code>    <code>create=</code> <code>*$variable*</code>    <code>lookup=</code> <code>*$variable*</code>    <code>zone=</code> <code>*name*</code> : <code>*size*</code>    [ <code>timeout=</code> <code>*time*</code> ]    [ <code>header</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  启用会话关联，这会将来自同一客户端的请求传递到一组服务器中的同一服务器。  有三种方法可供选择： </p>
<p>  使用<code>cookie</code>方法时，有关指定服务器的信息将在nginx生成的HTTP cookie中传递： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com;
    server backend2.example.com;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre>



<p>  来自尚未绑定到特定服务器的客户端的请求将传递到由配置的balance方法选择的服务器。  使用此cookie的进一步请求将传递到指定的服务器。  如果指定的服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
<p>  第一个参数设置要设置或检查的cookie的名称。   cookie值是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。  但是，如果指定了<a href="#server">server</a>指令的“ <code>route</code> ”参数，则cookie值将是“ <code>route</code> ”参数的值： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com route= **a** ;
    server backend2.example.com route= **b** ;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre>

<p>  在这种情况下，“ <code>srv_id</code> ”cookie的值将是<code>*a*</code>或<code>*b*</code> 。 </p>
<p>  其他参数可能如下： </p>
<p>  如果省略任何参数，则不会设置相应的cookie字段。 </p>
<p>  使用<code>route</code>方法时，代理服务器在收到第一个请求时为客户端分配路由。  来自此客户端的所有后续请求将在cookie或URI中携带路由信息。  将此信息与<a href="#server">服务器</a>指令的“ <code>route</code> ”参数进行比较，以标识应将请求代理到的服务器。  如果未指定“ <code>route</code> ”参数，则路由名称将是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。  如果指定的服务器无法处理请求，则配置的平衡方法将选择新服务器，就好像请求中没有路由信息一样。 </p>
<p>   <code>route</code>方法的参数指定可能包含路由信息的变量。  第一个非空变量用于查找匹配服务器。 </p>
<p>  例： </p>
<pre class="notranslate">map $cookie_jsessionid $route_cookie {
    ~.+\.(?P&lt;route&gt;\w+)$ $route;
}

map $request_uri $route_uri {
    ~jsessionid=.+\.(?P&lt;route&gt;\w+)$ $route;
}

upstream backend {
    server backend1.example.com route=a;
    server backend2.example.com route=b;

    sticky route $route_cookie $route_uri;
}
</pre>

<p>  这里，路由取自“ <code>JSESSIONID</code> ”cookie（如果请求中存在）。  否则，使用来自URI的路由。 </p>
<p>  当使用<code>learn</code>方法（1.7.1）时，nginx会分析上游服务器响应并学习通常在HTTP cookie中传递的服务器启动的会话。 </p>
<pre class="notranslate">upstream backend {
   server backend1.example.com:8080;
   server backend2.example.com:8081;

   sticky learn
          create=$upstream_cookie_examplecookie
          lookup=$cookie_examplecookie
          zone=client_sessions:1m;
}
</pre>

<p>  在该示例中，上游服务器通过在响应中设置cookie“ <code>EXAMPLECOOKIE</code> ”来创建会话。  使用此cookie的进一步请求将传递到同一服务器。  如果服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
<p>  参数<code>create</code>和<code>lookup</code>指定分别指示如何创建新会话和搜索现有会话的变量。  两个参数可以多次指定，在这种情况下使用第一个非空变量。 </p>
<p>  会话存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>zone</code>参数配置。  一兆字节区域可以在64位平台上存储大约4000个会话。  在<code>timeout</code>参数指定的时间内未访问的会话将从区域中删除。  默认情况下， <code>timeout</code>设置为10分钟。 </p>
<p>   <code>header</code>参数（1.13.1）允许在从上游服务器接收响应头之后立即创建会话。 </p>
<p>   <code>sync</code>参数（1.13.8）启用共享内存区域的<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a> 。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sticky_cookie_insert*name*</code>[ <code>expires=</code> <code>*time*</code> ][ <code>domain=</code> <code>*domain*</code> ][ <code>path=</code> <code>*path*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  从1.5.7版开始，该指令已过时。  应该使用具有新语法的等效<a href="#sticky">粘性</a>指令： </p>
<blockquote>
<p>   <code>sticky cookie</code> <code>*name*</code> [ <code>expires=</code> <code>*time*</code> ] [ <code>domain=</code> <code>*domain*</code> ] [ <code>path=</code> <code>*path*</code> ]; </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_upstream_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-hc-module"><a href="#Module-ngx-http-upstream-hc-module" class="headerlink" title="Module ngx_http_upstream_hc_module"></a>Module ngx_http_upstream_hc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#health_check">health_check</a> <br>     <a href="#match">match</a> <br></td>

<p>   <code>ngx_http_upstream_hc_module</code>模块允许对周围位置中引用的<a href="ngx_http_upstream_module.html#upstream">组</a>中的服务器进行定期运行状况检查。  服务器组必须驻留在<a href="ngx_http_upstream_module.html#zone">共享内存中</a> 。 </p>
<p>  如果运行状况检查失败，则服务器将被视为运行状况不佳。  如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。  客户端请求不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p>  请注意，与健康检查一起使用时，大多数变量都将具有空值。 </p>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream dynamic {
    zone upstream_dynamic 64k;

    server backend1.example.com      weight=5;
    server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
    server 192.0.2.1                 max_fails=3;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
}

server {
    location / {
        proxy_pass http://dynamic;
        health_check;
    }
}
</pre>

<p>  使用此配置，nginx将每隔五秒向<code>backend</code>组中的每个服务器发送“ <code>/</code> ”请求。  如果发生任何通信错误或超时，或者代理服务器使用2xx或3xx以外的状态代码进行响应，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
<p>  可以配置运行状况检查以测试响应的状态代码，某些标题字段及其值的存在以及正文内容。  测试使用<a href="#match">match</a>伪指令单独配置，并在<a href="#health_check">health_check</a>指令的<code>match</code>参数中引用： </p>
<pre class="notranslate">http {
    server {
    ...
        location / {
            proxy_pass http://backend;
            health_check match=welcome;
        }
    }

    match welcome {
        status 200;
        header Content-Type = text/html;
        body ~ "Welcome to nginx!";
    }
}
</pre>

<p>  此配置显示，为了通过运行状况检查，对运行状况检查请求的响应应该成功，状态为200，并包含“ <code>Welcome to nginx!</code>   “ 在身体里。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check** [ &lt;code class=&quot;notranslate&quot;&gt;*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  启用对周围位置中引用的<a href="ngx_http_upstream_module.html#upstream">组</a>中的服务器的定期运行状况检查。 </p>
<p>  支持以下可选参数： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**match*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义用于验证对运行状况检查请求的响应的命名测试集。 </p>
<p>  可以在响应中测试以下项目： </p>
<p>  如果指定了多个测试，则响应仅在匹配所有测试时才匹配。 </p>
<blockquote>
<p>  仅检查响应体的前256k。 </p>
</blockquote>
<p>  例子： </p>
<pre class="notranslate"># status is 200, content type is "text/html",
# and body contains "Welcome to nginx!"
match welcome {
    status 200;
    header Content-Type = text/html;
    body ~ "Welcome to nginx!";
}
</pre>



<pre class="notranslate"># status is not one of 301, 302, 303, or 307, and header does not have "Refresh:"
match not_redirect {
    status ! 301-303 307;
    header ! Refresh;
}
</pre>



<pre class="notranslate"># status ok and not in maintenance mode
match server_ok {
    status 200-399;
    body !~ "maintenance mode";
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_conf_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_conf_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_conf_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-conf-module"><a href="#Module-ngx-http-upstream-conf-module" class="headerlink" title="Module ngx_http_upstream_conf_module"></a>Module ngx_http_upstream_conf_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream_conf">upstream_conf</a> <br></td>

<p>   <code>ngx_http_upstream_conf_module</code>模块允许通过简单的HTTP接口即时配置上游服务器组，而无需重新启动nginx。   <a href="ngx_http_upstream_module.html#zone">http</a>或<a href="stream/ngx_stream_upstream_module.html#zone">流</a>服务器组必须驻留在共享内存中。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供，直到1.13.10。  它被1.13.3中的<a href="ngx_http_api_module.html">ngx_http_api_module</a>模块取代。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream backend {
    zone upstream_backend 64k;

    ...
}

server {
    location /upstream_conf {
        **upstream_conf** ;
        allow 127.0.0.1;
        deny all;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream_conf** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的上游配置的HTTP接口。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p>  配置命令可用于： </p>
<ul>
<li>查看组配置; -   查看，修改或删除服务器; -   添加新服务器。 </li>
</ul>
<blockquote>
<p>  由于组中的地址不需要是唯一的，因此组中的特定服务器由其ID引用。  添加新服务器或查看组配置时，会自动分配ID并显示ID。 </p>
</blockquote>
<p>  配置命令由作为请求参数传递的参数组成，例如： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend
</pre>



<p>  支持以下参数： </p>
<blockquote>
<p>  在1.7.2版之前，还需要<code>backup=</code>来查看，修改或删除现有备份服务器。 </p>
</blockquote>
<p>  添加服务器时，可以将其指定为域名。  在这种情况下，将监视与域名对应的IP地址的更改并自动应用于上游配置，而无需重新启动nginx（1.7.2）。  这需要<a href="ngx_http_core_module.html#resolver">http</a>或<a href="stream/ngx_stream_core_module.html#resolver">流</a>块中的“ <code>resolver</code> ”指令。  另请参阅<a href="ngx_http_upstream_module.html#resolve">http</a>或<a href="stream/ngx_stream_upstream_module.html#resolve">流</a>上游服务器的“ <code>resolve</code> ”参数。 </p>
<p>  前三个参数选择一个对象。  这可以是整个http或流上游服务器组，也可以是特定服务器。  如果没有其他参数，则会显示所选组或服务器的配置。 </p>
<p>  例如，要查看整个组的配置，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend
</pre>

<p>  要查看特定服务器的配置，还要指定其ID： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42
</pre>



<p>  要添加新服务器，请在“ <code>server=</code> ”参数中指定其地址。  如果未指定其他参数，将添加服务器，并将其他参数设置为其默认值（请参阅<a href="ngx_http_upstream_module.html#server">http</a>或<a href="stream/ngx_stream_upstream_module.html#server">流</a> “ <code>server</code> ”指令）。 </p>
<p>  例如，要添加新的主服务器，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080
</pre>

<p>  要添加新的备份服务器，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;backup=&amp;server=127.0.0.1:8080
</pre>

<p>  要添加新的主服务器，请将其参数设置为非默认值并将其标记为“ <code>down</code> ”，发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080&amp;weight=2&amp;down=
</pre>

<p>  要删除服务器，请指定其ID： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?remove=&amp;upstream=backend&amp;id=42
</pre>

<p>  要将现有服务器标记为“ <code>down</code> ”，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;down=
</pre>

<p>  要修改现有服务器的地址，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;server=192.0.2.3:8123
</pre>

<p>  要修改现有服务器的其他参数，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;max_fails=3&amp;weight=4
</pre>

<p>  以上示例适用于<a href="ngx_http_upstream_module.html">http</a>上游服务器组。   <a href="stream/ngx_stream_upstream_module.html">流</a>上游服务器组的类似示例需要“ <code>stream=</code> ”参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_sub_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_sub_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_sub_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-sub-module"><a href="#Module-ngx-http-sub-module" class="headerlink" title="Module ngx_http_sub_module"></a>Module ngx_http_sub_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#sub_filter">sub_filter</a> <br>     <a href="#sub_filter_last_modified">sub_filter_last_modified</a> <br>     <a href="#sub_filter_once">sub_filter_once</a> <br>     <a href="#sub_filter_types">sub_filter_types</a> <br></td>

<p>   <code>ngx_http_sub_module</code>模块是一个过滤器，它通过将一个指定的字符串替换为另一个来修改响应。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_sub_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    sub_filter '&lt;a href="http://127.0.0.1:8080/'  '&lt;a href="https://$host/';
    sub_filter '&lt;img src="http://127.0.0.1:8080/' '&lt;img src="https://$host/';
    sub_filter_once on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter*string*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置要替换的字符串和替换字符串。  忽略大小写匹配的字符串匹配。  要替换的字符串（1.9.4）和替换字符串可以包含变量。  可以在一个配置级别（1.9.4）上指定几个<code>sub_filter</code>指令。  当且仅当在当前级别上没有定义<code>sub_filter</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在替换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在处理期间修改响应的内容时，将删除标头字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_onceon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_once on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是查找要重复替换的每个字符串。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还在具有指定MIME类型的响应中启用字符串替换。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_stub_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_stub_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_stub_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-stub-status-module"><a href="#Module-ngx-http-stub-status-module" class="headerlink" title="Module ngx_http_stub_status_module"></a>Module ngx_http_stub_status_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#stub_status">stub_status</a> <br> <a href="#data">Data</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_stub_status_module</code>模块提供对基本状态信息的访问。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_stub_status_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location = /basic_status {
    stub_status;
}
</pre>

<p>  此配置创建一个简单的网页，其基本状态数据可能如下所示： </p>
<pre class="notranslate">Active connections: 291 
server accepts handled requests
 16630948 16630948 31070465 
Reading: 6 Writing: 179 Waiting: 106 
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**stub_status** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  可从周围位置访问基本状态信息。 </p>
<blockquote>
<p>  在1.7.5之前的版本中，指令语法需要任意参数，例如“ <code>stub_status on</code> ”。 </p>
</blockquote>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>  提供以下状态信息： </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_stub_status_module</code>模块支持以下嵌入变量（1.3.14）： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-status-module"><a href="#Module-ngx-http-status-module" class="headerlink" title="Module ngx_http_status_module"></a>Module ngx_http_status_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#status">status</a> <br>     <a href="#status_format">status_format</a> <br>     <a href="#status_zone">status_zone</a> <br> <a href="#data">Data</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>   <code>ngx_http_status_module</code>模块提供对各种状态信息的访问。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供，直到1.13.10。  它被1.13.3中的<a href="ngx_http_api_module.html">ngx_http_api_module</a>模块取代。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    upstream **backend** {
        **zone** http_backend 64k;

        server backend1.example.com weight=5;
        server backend2.example.com;
    }

    proxy_cache_path /data/nginx/cache_backend keys_zone= **cache_backend** :10m;

    server {
        server_name backend.example.com;

        location / {
            proxy_pass  http://backend;
            proxy_cache cache_backend;

            health_check;
        }

        **status_zone server_backend;**
    }

    server {
        listen 127.0.0.1;

        location /upstream_conf {
            upstream_conf;
        }

        location /status {
            status;
        }

        location = /status.html {
        }
    }
}

stream {
    upstream **backend** {
        **zone** stream_backend 64k;

        server backend1.example.com:12345 weight=5;
        server backend2.example.com:12345;
    }

    server {
        listen      127.0.0.1:12345;
        proxy_pass  backend;
        **status_zone server_backend;**
        health_check;
    }
}
</pre>



<p>  使用此配置的状态请求示例： </p>
<pre class="notranslate">http://127.0.0.1/status
http://127.0.0.1/status/nginx_version
http://127.0.0.1/status/caches/cache_backend
http://127.0.0.1/status/upstreams
http://127.0.0.1/status/upstreams/backend
http://127.0.0.1/status/upstreams/backend/peers/1
http://127.0.0.1/status/upstreams/backend/peers/1/weight
http://127.0.0.1/status/stream
http://127.0.0.1/status/stream/upstreams
http://127.0.0.1/status/stream/upstreams/backend
http://127.0.0.1/status/stream/upstreams/backend/peers/1
http://127.0.0.1/status/stream/upstreams/backend/peers/1/weight
</pre>



<p>  简单监视页面随附此发行版一起提供，可在默认配置中以“ <code>/status.html</code> ”身份访问。  它需要配置位置“ <code>/status</code> ”和“ <code>/status.html</code> ”，如上所示。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  可以从周围的位置访问状态信息。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status_formatjson</code> ; <br> <code>**status_formatjsonp</code> [ <code>*callback*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">status_format json;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，状态信息以JSON格式输出。 </p>
<p>  或者，数据可以输出为JSONP。   <code>*callback*</code>参数指定回调函数的名称。  该值可以包含变量。  如果省略参数，或者计算的值是空字符串，则使用“ <code>ngx_status_jsonp_callback</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status_zone*zone*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  允许在指定<code>*zone*</code>收集虚拟<a href="ngx_http_core_module.html#server">http</a>或<a href="stream/ngx_stream_core_module.html#server">流</a> （1.7.11）服务器状态信息。  多个服务器可能共享同一个区域。 </p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>  提供以下状态信息： </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li><a href="#version">版本</a> 8中添加了<a href="#upstreams">http</a>和<a href="#stream_upstreams">流</a>上游中的<a href="#zone">区域</a>字段。 -    <a href="#version">版本</a> 8中添加了<a href="#slabs">slab</a>状态数据。 -    <a href="#version">版本</a> 8中添加了<a href="#state">检查</a>状态。 -    <a href="#version">版本</a> 8中添加了<a href="#upstreams">http</a>和<a href="#stream_upstreams">流</a>上游中的<a href="#name">名称</a>和<a href="#service">服务</a>字段。 -    <a href="#version">版本</a> 8中添加了<a href="#nginx_build">nginx_build</a>和<a href="#ppid">ppid</a>字段。 -    <a href="#version">版本</a> 7中添加了<a href="#sessions">会话</a>状态数据和流<a href="#stream_server_zones">server_zones</a>中的<a href="#stream_discarded">丢弃</a>字段。 -    <a href="#zombies">僵尸</a>字段是从<a href="#version">版本</a> 6中的nginx <a href="debugging_log.html">调试</a>版本移动的。 -    <a href="#version">版本</a> 6中添加了<a href="#ssl">ssl</a>状态数据。 -    <a href="#server_zones">server_zones中</a>的<a href="#discarded">丢弃</a>字段已在<a href="#version">版本</a> 6中添加。 -    <a href="#queue">队列</a>状态数据已在<a href="#version">版本</a> 6中添加。 -    <a href="#pid">pid</a>字段已在<a href="#version">版本</a> 6中添加。 -    <a href="#upstreams">上游</a>中的服务器列表已移至<a href="#version">版本</a> 6中的<a href="#peers">对等项</a> 。 -   在<a href="#version">版本</a> 5中删除了上游服务器的<code>keepalive</code>字段。 -    <a href="#stream">流</a>状态数据已在<a href="#version">版本</a> 5中添加。 -    <a href="#generation">生成</a>字段已在<a href="#version">版本</a> 5中添加。 -    <a href="#processes">进程中</a>重新<a href="#respawned">生成的</a>字段已在<a href="#version">版本</a> 5中添加。 -    <a href="#version">版本</a> 5中添加了<a href="#upstreams">上游</a>中的<a href="#header_time">header_time</a>和<a href="#response_time">response_time</a>字段。 -    <a href="#version">版本</a> 4中添加了<a href="#upstreams">上游中</a>的<a href="#selected">选定</a>字段。 -    <a href="#version">版本</a> 4中添加了<a href="#upstreams">上游</a>的<a href="#state">排水</a>状态。 -    <a href="#upstreams">上游</a>中的<a href="#id">id</a>和<a href="#max_conns">max_conns</a>字段已在<a href="#version">版本</a> 3中添加。 -    <a href="#version">版本</a> 3中添加了<a href="#caches">缓存</a>中<code>revalidated</code>字段。 -    <a href="#version">版本</a> 2中添加了<a href="#server_zones">server_zones</a> ， <a href="#caches">caches</a>和<a href="#load_timestamp">load_timestamp</a>状态数据。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssl-module"><a href="#Module-ngx-http-ssl-module" class="headerlink" title="Module ngx_http_ssl_module"></a>Module ngx_http_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl">ssl</a> <br>     <a href="#ssl_buffer_size">ssl_buffer_size</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_early_data">ssl_early_data</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_stapling">ssl_stapling</a> <br>     <a href="#ssl_stapling_file">ssl_stapling_file</a> <br>     <a href="#ssl_stapling_responder">ssl_stapling_responder</a> <br>     <a href="#ssl_stapling_verify">ssl_stapling_verify</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br> <a href="#errors">Error Processing</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_ssl_module</code>模块为HTTPS提供必要的支持。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_ssl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="ngx_http_core_module.html#keepalive_timeout">保持活动</a>连接， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

http {

    ...

    server {
        listen              443 ssl;
        **keepalive_timeout   70;**

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令在1.15.0版本中已过时。  应该使用<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  设置用于发送数据的缓冲区的大小。 </p>
<p>  默认情况下，缓冲区大小为16k，这对应于发送大响应时的最小开销。  要最小化第一个字节的时间，使用较小的值可能是有益的，例如： </p>
<pre class="notranslate">ssl_buffer_size 4k;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定虚拟服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              443 ssl;
    server_name         example.com;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同<a href="configuring_https_servers.html#chains">证书的</a>单独<a href="configuring_https_servers.html#chains">证书链</a> 。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p>  应该记住，由于HTTPS协议对最大互操作性的限制，虚拟服务器应该监听<a href="configuring_https_servers.html#name_based_https_servers">不同的IP地址</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定虚拟服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<blockquote>
<p>  以前版本的nginx默认使用<a href="configuring_https_servers.html#compatibility">不同的</a>密码。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  如果启用了<a href="#ssl_stapling">ssl_stapling，</a>则指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#ssl_verify_client">验证</a>客户端证书和OCSP响应。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.8.7版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.7.2版本中。 </p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_early_dataon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_early_data off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  启用或禁用TLS 1.3 <a href="https://tools.ietf.org/html/rfc8446#section-2.3" target="_blank" rel="noopener">早期数据</a> 。 </p>
<blockquote>
<p>  在早期数据中发送的请求会受到<a href="https://tools.ietf.org/html/rfc8470" target="_blank" rel="noopener">重播攻击</a> 。  为了防止应用程序层发生此类攻击，应使用<a href="#var_ssl_early_data">$ ssl_early_data</a>变量。 </p>
</blockquote>
<pre class="notranslate">proxy_set_header Early-Data $ssl_early_data;
</pre>



<blockquote>
<p>  使用OpenSSL 1.1.1或更高版本（1.15.4）和<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">BoringSSL</a>时，支持该指令。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.3版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">http {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        server_name www1.example.com;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        server_name www2.example.com;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数（ <code>TLSv1.2</code> ）仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache**     &lt;code class=&quot;notranslate&quot;&gt;off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_staplingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_stapling off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  启用或禁用服务器<a href="https://tools.ietf.org/html/rfc6066#section-8" target="_blank" rel="noopener">对OCSP响应</a>的<a href="https://tools.ietf.org/html/rfc6066#section-8" target="_blank" rel="noopener">装订</a> 。  例： </p>
<pre class="notranslate">ssl_stapling on;
resolver 192.0.2.1;
</pre>



<p>  要使OCSP装订起作用，应该知道服务器证书颁发者的证书。  如果<a href="#ssl_certificate">ssl_certificate</a>文件不包含中间证书，则服务器证书颁发者的证书应存在于<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>文件中。 </p>
<p>  要解析OCSP响应程序主机名，还应指定<a href="ngx_http_core_module.html#resolver">解析程序</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  设置后，将从指定的<code>*file*</code>获取装订的OCSP响应，而不是查询服务器证书中指定的OCSP响应程序。 </p>
<p>  该文件应为DER格式，由“ <code>openssl ocsp</code> ”命令生成。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_responder*url*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  覆盖“ <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.1" target="_blank" rel="noopener">Authority Information Access</a> ”证书扩展中指定的OCSP响应程序的URL。 </p>
<p>  仅支持“ <code>http://</code> ”OCSP响应者： </p>
<pre class="notranslate">ssl_stapling_responder http://ocsp.example.com/;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_stapling_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  启用或禁用服务器对OCSP响应的验证。 </p>
<p>  要使验证<a href="#ssl_trusted_certificate">生效，</a>应使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令将服务器证书颁发者的证书，根证书和所有中间证书配置为受信任。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  如果启用了<a href="#ssl_stapling">ssl_stapling，</a>则指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#ssl_verify_client">验证</a>客户端证书和OCSP响应。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client**     &lt;code class=&quot;notranslate&quot;&gt;on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  启用客户端证书验证。  验证结果存储在<a href="#var_ssl_client_verify">$ ssl_client_verify</a>变量中。 </p>
<p>   <code>optional</code>参数（0.8.7+）请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数（1.3.8,1.2.5）请求客户端证书，但不要求它由受信任的CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="#var_ssl_client_cert">$ ssl_client_cert</a>变量访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端证书链中的验证深度。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>   <code>ngx_http_ssl_module</code>模块支持几个非标准错误代码，可以使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令用于重定向： </p>
<p>  重定向发生在完全解析请求并且变量（例如<code>$request_uri</code> ， <code>$uri</code> ， <code>$args</code>和其他变量）可用之后。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_ssl_module</code>模块支持几个嵌入变量： </p>
<pre class="notranslate">AES128-SHA:AES256-SHA:0x00ff
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。  对于旧版本，该变量仅适用于新会话，仅列出已知密码。 </p>
<p>  不推荐使用该变量，应该使用<code>$ssl_client_escaped_cert</code>变量。 </p>
<p>  在1.11.6版之前，变量名称为<code>$ssl_client_i_dn</code> 。 </p>
<p>  在1.11.6版之前，变量名称为<code>$ssl_client_s_dn</code> 。 </p>
<p>  在1.11.7版之前，“ <code>FAILED</code> ”结果不包含<code>*reason*</code>字符串。 </p>
</blockquote>
<pre class="notranslate">0x001d:prime256v1:secp521r1:secp384r1
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。  对于旧版本，变量值将为空字符串。 </p>
<p>  该变量仅适用于新会话。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssi-module"><a href="#Module-ngx-http-ssi-module" class="headerlink" title="Module ngx_http_ssi_module"></a>Module ngx_http_ssi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssi">ssi</a> <br>     <a href="#ssi_last_modified">ssi_last_modified</a> <br>     <a href="#ssi_min_file_chunk">ssi_min_file_chunk</a> <br>     <a href="#ssi_silent_errors">ssi_silent_errors</a> <br>     <a href="#ssi_types">ssi_types</a> <br>     <a href="#ssi_value_length">ssi_value_length</a> <br> <a href="#commands">SSI Commands</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_ssi_module</code>模块是一个过滤器，用于处理通过它的响应中的SSI（服务器端包含）命令。  目前，支持的SSI命令列表不完整。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    ssi on;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssion</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用响应中SSI命令的处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在SSI处理期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在处理过程中修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_min_file_chunksize</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_min_file_chunk 1k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置存储在磁盘上的响应部分的最小<code>*size*</code> ，从使用<a href="ngx_http_core_module.html#sendfile">sendfile</a>发送它们开始是有意义的。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_silent_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_silent_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果启用，则在SSI处理期间发生<code>[an error occurred while processing the directive]</code> ，禁止输出“ <code>[an error occurred while processing the directive]</code> ”字符串。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还可以在具有指定MIME类型的响应中处理SSI命令。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_value_length*length*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_value_length 256;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置SSI命令中参数值的最大长度。 </p>
<h4 id="SSI命令"><a href="#SSI命令" class="headerlink" title="SSI命令"></a>SSI命令</h4><p>   SSI命令具有以下通用格式： </p>
<pre class="notranslate">&lt;!--# command parameter1=value1 parameter2=value2 ... --&gt;
</pre>



<p>  支持以下命令： </p>
<pre class="notranslate">&lt;!--# block name="one" --&gt;
stub
&lt;!--# endblock --&gt;
</pre>

<pre class="notranslate">[an error occurred while processing the directive]
</pre>

<pre class="notranslate">"%A, %d-%b-%Y %H:%M:%S %Z"
</pre>

<pre class="notranslate">&lt;!--# echo var="name" default=" **no** " --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="$name" --&gt;&lt;!--# echo var="name" --&gt;&lt;!--#
       else --&gt; **no** &lt;!--# endif --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="..." --&gt;
...
&lt;!--# elif expr="..." --&gt;
...
&lt;!--# else --&gt;
...
&lt;!--# endif --&gt;
</pre>
<li>  变量存在检查： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name" --&gt;
</pre></blockquote></li><li>  变量与文本的比较： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name = `*text*` " --&gt;
&lt;!--# if expr="$name != `*text*` " --&gt;
</pre></blockquote></li><li>  变量与正则表达式的比较： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name = / `*text*` /" --&gt;
&lt;!--# if expr="$name != / `*text*` /" --&gt;
</pre></blockquote></li>
<pre class="notranslate">&lt;!--# if expr="$name = `*text*` " --&gt;
&lt;!--# if expr="$name != `*text*` " --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="$name = /(.+)@(?P&lt;domain&gt;.+)/" --&gt;
    &lt;!--# echo var="1" --&gt;
    &lt;!--# echo var="domain" --&gt;
&lt;!--# endif --&gt;
</pre>

<pre class="notranslate">&lt;!--# include file="footer.html" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" --&gt;
</pre>

<pre class="notranslate">&lt;!--# block name="one" --&gt;&amp;nbsp;&lt;!--# endblock --&gt;
&lt;!--# include virtual="/remote/body.php?argument=value" stub="one" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" wait="yes" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" set="one" --&gt;
</pre>

<pre class="notranslate">location /remote/ {
    subrequest_output_buffer_size 64k;
    ...
}
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_ssi_module</code>模块支持两个嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-split-clients-module"><a href="#Module-ngx-http-split-clients-module" class="headerlink" title="Module ngx_http_split_clients_module"></a>Module ngx_http_split_clients_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#split_clients">split_clients</a> <br></td>

<p>   <code>ngx_http_split_clients_module</code>模块创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    split_clients "${remote_addr}AAA" $variant {
                   0.5%               .one;
                   2.0%               .two;
                   *                  "";
    }

    server {
        location / {
            index index${variant}.html;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**split_clients**     &lt;code class=&quot;notranslate&quot;&gt;*string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为A / B测试创建变量，例如： </p>
<pre class="notranslate">split_clients "${remote_addr}AAA" $variant {
               0.5%               .one;
               2.0%               .two;
               *                  "";
}
</pre>

<p>  使用MurmurHash2对原始字符串的值进行哈希处理。  在给出的示例中，从0到21474835（0.5％）的哈希值对应于<code>$variant</code>变量的值<code>&quot;.one&quot;</code> ，从21474836到107374180（2％）的哈希值对应于值<code>&quot;.two&quot;</code>和哈希值从107374181到4294967295的值对应于值<code>&quot;&quot;</code> （空字符串）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_spdy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_spdy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_spdy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-spdy-module"><a href="#Module-ngx-http-spdy-module" class="headerlink" title="Module ngx_http_spdy_module"></a>Module ngx_http_spdy_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#spdy_chunk_size">spdy_chunk_size</a> <br>     <a href="#spdy_headers_comp">spdy_headers_comp</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_spdy_module</code>模块为<a href="http://www.chromium.org/spdy/spdy-protocol" target="_blank" rel="noopener">SPDY</a>提供实验支持。  目前，已实施SPDY协议<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1" target="_blank" rel="noopener">草案3.1</a> 。 </p>
<blockquote>
<p>  在1.5.10版之前，实施了SPDY协议<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2" target="_blank" rel="noopener">草案2</a> 。 </p>
</blockquote>
<p>  默认情况下不构建此模块，应使用<code>--with-http_spdy_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块已被1.9.5中的<a href="ngx_http_v2_module.html">ngx_http_v2_module</a>模块取代。 </p>
</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  该模块是实验性的，需要注意的是经纪人。 </p>
<p>   SPDY协议的当前实现不支持“服务器推送”。 </p>
<p>  在1.5.9之前的版本中，SPDY连接中的响应不能受<a href="ngx_http_core_module.html#limit_rate">速率限制</a> 。 </p>
<p>  无论<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>和<a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 443 ssl spdy;

    ssl_certificate server.crt;
    ssl_certificate_key server.key;
    ...
}
</pre>



<blockquote>
<p>  请注意，为了在同一端口上同时接受<a href="ngx_http_ssl_module.html">HTTPS</a>和SPDY连接，所使用的<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库应支持“Next Protocol Negotiation”TLS扩展，自Ope​​nSSL 1.0.1版开始可用。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**spdy_chunk_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">spdy_chunk_size 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  设置响应主体被<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2#TOC-Data-frames" target="_blank" rel="noopener">切片</a>到的块的最大大小。  值太低会导致更高的开销。  由于<a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener">HOL阻塞，</a>太高的值会损害优先级。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**spdy_headers_comp*level*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">spdy_headers_comp 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置响应的标头压缩<code>*level*</code> ，范围从1（最快，压缩程度较低）到9（最慢，最佳压缩）。  特殊值0关闭标头压缩。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_spdy_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_slice_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_slice_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_slice_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-slice-module"><a href="#Module-ngx-http-slice-module" class="headerlink" title="Module ngx_http_slice_module"></a>Module ngx_http_slice_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#slice">slice</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_slice_module</code>模块（1.9.8）是一个过滤器，它将请求拆分为子请求，每个子请求都返回一定范围的响应。  过滤器提供更有效的大响应缓存。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_slice_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    **slice**             1m;
    proxy_cache       cache;
    proxy_cache_key   $uri$is_args$args **$slice_range** ;
    proxy_set_header  Range **$slice_range** ;
    proxy_cache_valid 200 206 1h;
    proxy_pass        http://localhost:8000;
}
</pre>

<p>  在此示例中，响应被拆分为1兆字节的可缓存切片。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**slice*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">slice 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置切片的<code>*size*</code> 。  零值禁用将响应拆分为切片。  请注意，值太低可能会导致内存使用过多并打开大量文件。 </p>
<p>  为了使子请求返回所需的范围， <code>$slice_range</code>变量应作为<code>Range</code>请求头字段<a href="ngx_http_proxy_module.html#proxy_set_header">传递</a>给代理服务器。  如果启用了<a href="ngx_http_proxy_module.html#proxy_cache">缓存</a> ，则应将<code>$slice_range</code>添加到<a href="ngx_http_proxy_module.html#proxy_cache_key">缓存键，</a>并<a href="ngx_http_proxy_module.html#proxy_cache_valid">启用</a>具有206状态代码的响应缓存。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_slice_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_session_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_session_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_session_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-session-log-module"><a href="#Module-ngx-http-session-log-module" class="headerlink" title="Module ngx_http_session_log_module"></a>Module ngx_http_session_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#session_log">session_log</a> <br>     <a href="#session_log_format">session_log_format</a> <br>     <a href="#session_log_zone">session_log_zone</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_session_log_module</code>模块启用日志记录会话（即多个HTTP请求的聚合），而不是单个HTTP请求。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  以下配置根据请求客户端地址和“User-Agent”请求标头字段设置会话日志并将请求映射到会话： </p>
<pre class="notranslate">    session_log_zone /path/to/log format=combined
                     zone=one:1m timeout=30s
                     md5=$binary_remote_addr$http_user_agent;

    location /media/ {
        session_log one;
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log*name*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">session_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许使用指定的会话日志。  特殊值<code>off</code>取消从先前配置级别继承的所有<code>session_log</code>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log_format**     &lt;code class=&quot;notranslate&quot;&gt;*name*</code>    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">session_log_format combined “…”;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定日志的输出格​​式。   <code>$body_bytes_sent</code>变量的值在会话中的所有请求中聚合。  可用于记录的所有其他变量的值对应于会话中的第一个请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log_zone**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>format</code> = <code>*format*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>id</code> = <code>*id*</code> ]    [ <code>md5</code> = <code>*md5*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置日志文件的路径，并配置用于存储当前活动会话的共享内存区域。 </p>
<p>  只要会话中的最后一个请求自指定<code>timeout</code> （默认为30秒）以来经过的时间，会话就被视为活动状态。  会话不再处于活动状态时，会将其写入日志。 </p>
<p>   <code>id</code>参数标识请求映射到的会话。   <code>id</code>参数设置为MD5哈希的十六进制表示（例如，使用变量从cookie获取）。  如果未指定此参数或不表示有效的MD5哈希，则nginx将根据<code>md5</code>参数的值计算MD5哈希，并使用此哈希创建新会话。   <code>id</code>和<code>md5</code>参数都可以包含变量。 </p>
<p>   <code>format</code>参数设置<a href="#session_log_format">session_log_format</a>指令配置的自定义会话日志格式。  如果未指定format，则使用预定义的“ <code>combined</code> ”格式。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_session_log_module</code>模块支持两个嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_secure_link_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_secure_link_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_secure_link_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-secure-link-module"><a href="#Module-ngx-http-secure-link-module" class="headerlink" title="Module ngx_http_secure_link_module"></a>Module ngx_http_secure_link_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#secure_link">secure_link</a> <br>     <a href="#secure_link_md5">secure_link_md5</a> <br>     <a href="#secure_link_secret">secure_link_secret</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_secure_link_module</code>模块（0.7.18）用于检查请求链路的真实性，保护资源免受未经授权的访问，并限制链路生存期。 </p>
<p>  通过将请求中传递的校验和值与为请求计算的值进行比较来验证所请求链接的真实性。  如果链接的生命周期有限且时间已过，则该链接将被视为过时。  这些检查的状态在<code>$secure_link</code>变量中可用。 </p>
<p>  该模块提供两种备选操作模式。  第一种模式由<a href="#secure_link_secret">secure_link_secret</a>指令启用，用于检查请求链接的真实性以及保护资源免受未经授权的访问。  第二种模式（0.8.50）由<a href="#secure_link">secure_link</a>和<a href="#secure_link_md5">secure_link_md5</a>指令启用，也用于限制链接的生命周期。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_secure_link_module</code>配置参数启用它。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link*expression*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义一个包含变量的字符串，从中提取链接的校验和值和生命周期。 </p>
<p>   <code>*expression*</code>中使用的变量通常与请求相关联;  见下面的<a href="#secure_link_md5">例子</a> 。 </p>
<p>  将从字符串中提取的校验和值与<a href="#secure_link_md5">secure_link_md5</a>指令定义的表达式的MD5哈希值进行比较。  如果校验和不同，则<code>$secure_link</code>变量设置为空字符串。  如果校验和相同，则检查链路生存期。  如果链接的生命周期有限且时间已过，则<code>$secure_link</code>变量设置为“ <code>0</code> ”。  否则，它被设置为“ <code>1</code> ”。  请求中传递的MD5哈希值在<a href="https://tools.ietf.org/html/rfc4648#section-5" target="_blank" rel="noopener">base64url中</a>编码。 </p>
<p>  如果链接的生命周期有限，则到期时间设置为自Epoch（Thu，1970年1月1日1970:00 00:00:00 GMT）以来的秒数。  该值在MD5哈希之后的表达式中指定，并以逗号分隔。  请求中传递的到期时间可通过<code>$secure_link_expires</code>变量获得，以便在<a href="#secure_link_md5">secure_link_md5</a>指令中使用。  如果未指定到期时间，则链接具有无限生存期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link_md5*expression*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义将为其计算MD5哈希值并与请求中传递的值进行比较的表达式。 </p>
<p>  表达式应包含链接（资源）和秘密成分的安全部分。  如果链接的生命周期有限，则表达式还应包含<code>$secure_link_expires</code> 。 </p>
<p>  为防止未经授权的访问，表达式可能包含有关客户端的一些信息，例如其地址和浏览器版本。 </p>
<p>  例： </p>
<pre class="notranslate">location /s/ {
    secure_link $arg_md5,$arg_expires;
    secure_link_md5 "$secure_link_expires$uri$remote_addr secret";

    if ($secure_link = "") {
        return 403;
    }

    if ($secure_link = "0") {
        return 410;
    }

    ...
}
</pre>

<p>   “ <code>/s/link?md5=_e4Nc3iduzkWRm01TBBNYw&amp;amp;expires=2147483647</code> ”链接限制对IP地址为127.0.0.1的客户端的“ <code>/s/link</code> ”访问。  该链接的使用寿命有限，直到2038年1月19日（GMT）。 </p>
<p>  在UNIX上， <code>*md5*</code>请求参数值可以获取为： </p>
<pre class="notranslate">echo -n '2147483647/s/link127.0.0.1 secret' | \
    openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d =
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link_secret*word*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义用于检查所请求链接的真实性的密码。 </p>
<p>  请求链接的完整URI如下所示： </p>
<pre class="notranslate">/ `*prefix*` / `*hash*` / `*link*`
</pre>

<p>   <code>*hash*</code>是为链接和秘密字的串联计算的MD5哈希的十六进制表示，而<code>*prefix*</code>是没有斜杠的任意字符串。 </p>
<p>  如果请求的链接通过了真实性检查，则<code>$secure_link</code>变量将设置为从请求URI中提取的链接。  否则， <code>$secure_link</code>变量设置为空字符串。 </p>
<p>  例： </p>
<pre class="notranslate">location /p/ {
    secure_link_secret secret;

    if ($secure_link = "") {
        return 403;
    }

    rewrite ^ /secure/$secure_link;
}

location /secure/ {
    internal;
}
</pre>

<p>   “ <code>/p/5e814704a28d9bc1914ff19fa0c4a00a/link</code> ”的请求将在内部重定向到“ <code>/secure/link</code> ”。 </p>
<p>  在UNIX上，此示例的哈希值可以获得为： </p>
<pre class="notranslate">echo -n 'linksecret' | openssl md5 -hex
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_scgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_scgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_scgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-scgi-module"><a href="#Module-ngx-http-scgi-module" class="headerlink" title="Module ngx_http_scgi_module"></a>Module ngx_http_scgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#scgi_bind">scgi_bind</a> <br>     <a href="#scgi_buffer_size">scgi_buffer_size</a> <br>     <a href="#scgi_buffering">scgi_buffering</a> <br>     <a href="#scgi_buffers">scgi_buffers</a> <br>     <a href="#scgi_busy_buffers_size">scgi_busy_buffers_size</a> <br>     <a href="#scgi_cache">scgi_cache</a> <br>     <a href="#scgi_cache_background_update">scgi_cache_background_update</a> <br>     <a href="#scgi_cache_bypass">scgi_cache_bypass</a> <br>     <a href="#scgi_cache_key">scgi_cache_key</a> <br>     <a href="#scgi_cache_lock">scgi_cache_lock</a> <br>     <a href="#scgi_cache_lock_age">scgi_cache_lock_age</a> <br>     <a href="#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a> <br>     <a href="#scgi_cache_max_range_offset">scgi_cache_max_range_offset</a> <br>     <a href="#scgi_cache_methods">scgi_cache_methods</a> <br>     <a href="#scgi_cache_min_uses">scgi_cache_min_uses</a> <br>     <a href="#scgi_cache_path">scgi_cache_path</a> <br>     <a href="#scgi_cache_purge">scgi_cache_purge</a> <br>     <a href="#scgi_cache_revalidate">scgi_cache_revalidate</a> <br>     <a href="#scgi_cache_use_stale">scgi_cache_use_stale</a> <br>     <a href="#scgi_cache_valid">scgi_cache_valid</a> <br>     <a href="#scgi_connect_timeout">scgi_connect_timeout</a> <br>     <a href="#scgi_force_ranges">scgi_force_ranges</a> <br>     <a href="#scgi_hide_header">scgi_hide_header</a> <br>     <a href="#scgi_ignore_client_abort">scgi_ignore_client_abort</a> <br>     <a href="#scgi_ignore_headers">scgi_ignore_headers</a> <br>     <a href="#scgi_intercept_errors">scgi_intercept_errors</a> <br>     <a href="#scgi_limit_rate">scgi_limit_rate</a> <br>     <a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a> <br>     <a href="#scgi_next_upstream">scgi_next_upstream</a> <br>     <a href="#scgi_next_upstream_timeout">scgi_next_upstream_timeout</a> <br>     <a href="#scgi_next_upstream_tries">scgi_next_upstream_tries</a> <br>     <a href="#scgi_no_cache">scgi_no_cache</a> <br>     <a href="#scgi_param">scgi_param</a> <br>     <a href="#scgi_pass">scgi_pass</a> <br>     <a href="#scgi_pass_header">scgi_pass_header</a> <br>     <a href="#scgi_pass_request_body">scgi_pass_request_body</a> <br>     <a href="#scgi_pass_request_headers">scgi_pass_request_headers</a> <br>     <a href="#scgi_read_timeout">scgi_read_timeout</a> <br>     <a href="#scgi_request_buffering">scgi_request_buffering</a> <br>     <a href="#scgi_send_timeout">scgi_send_timeout</a> <br>     <a href="#scgi_socket_keepalive">scgi_socket_keepalive</a> <br>     <a href="#scgi_store">scgi_store</a> <br>     <a href="#scgi_store_access">scgi_store_access</a> <br>     <a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a> <br>     <a href="#scgi_temp_path">scgi_temp_path</a> <br></td>

<p>   <code>ngx_http_scgi_module</code>模块允许将请求传递给SCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    include   scgi_params;
    scgi_pass localhost:9000;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到SCGI服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>scgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到SCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">scgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自SCGI服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从SCGI服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用缓冲来自SCGI服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从SCGI服务器接收响应，并将其保存到<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#scgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a>和<a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从SCGI服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#scgi_buffer_size">scgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从SCGI服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自SCGI服务器的响应<a href="#scgi_buffering">缓冲</a>时，限制在响应尚未完全读取时可能忙于向客户端发送响应的缓冲区的总<code>*size*</code> 。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>受<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#scgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">scgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
scgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#scgi_no_cache">scgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">scgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给SCGI服务器，一次只允许一个请求填充根据<a href="#scgi_cache_key">scgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给SCGI服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给SCGI服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#scgi_cache_lock">scgi_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给SCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给SCGI服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_methods**     &lt;code class=&quot;notranslate&quot;&gt;GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#scgi_no_cache">scgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#scgi_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">scgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#scgi_temp_path">scgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#scgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#scgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#scgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">scgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        scgi_pass        backend;
        scgi_cache       cache_zone;
        scgi_cache_key   $uri;
        scgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_use_stale**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与SCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。  该指令的参数与<a href="#scgi_next_upstream">scgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择处理请求的SCGI服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对SCGI服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对SCGI服务器的访问次数，可以使用<a href="#scgi_cache_lock">scgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_valid** [ &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">scgi_cache_valid 200 302 10m;
scgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">scgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">scgi_cache_valid 200 302 10m;
scgi_cache_valid 301      1h;
scgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与SCGI服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_force_rangeson</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_force_ranges off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.7.7版本中。 </p>
<p>无论来自这些响应中的“Accept-Ranges”字段，都可以对来自SCGI服务器的缓存和未缓存响应启用字节范围支持。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_hide_header*field*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>默认情况下，nginx不会将SCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。   <code>scgi_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#scgi_pass_header">scgi_pass_header</a>指令。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_ignore_client_abort off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>确定客户端在不等待响应的情况下关闭连接时是否应关闭与SCGI服务器的连接。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_ignore_headers*field*</code> …;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>禁用从SCGI服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#scgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#scgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的SCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从SCGI服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到SCGI服务器的连接，则总速率将是指定限制的两倍。  仅当启用了来自SCGI服务器的响应<a href="#scgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自SCGI服务器的响应<a href="#scgi_buffering">缓冲</a> ，并且整个响应不适合<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#scgi_cache">缓存</a>或<a href="#scgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#scgi_next_upstream_tries">尝试次数</a>和<a href="#scgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#scgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#scgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">scgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
scgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#scgi_cache_bypass">scgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_param**     &lt;code class=&quot;notranslate&quot;&gt;*parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给SCGI服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>scgi_param</code>指令时，这些指令才从先前级别继承。 </p>
<p>  标准<a href="https://tools.ietf.org/html/rfc3875#section-4.1" target="_blank" rel="noopener">CGI环境变量</a>应作为SCGI头提供，请参阅分发中提供的<code>scgi_params</code>文件： </p>
<pre class="notranslate">location / {
    include scgi_params;
    ...
}
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">scgi_param HTTPS $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置SCGI服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">scgi_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">scgi_pass unix:/tmp/scgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将已<a href="#scgi_hide_header">禁用的</a>头字段从SCGI服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给SCGI服务器。  另请参见<a href="#scgi_pass_request_headers">scgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给SCGI服务器。  另请参见<a href="#scgi_pass_request_body">scgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从SCGI服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果SCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到SCGI服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到SCGI服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#scgi_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求发送到SCGI服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果SCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置与SCGI服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_store**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">scgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#scgi_temp_path">scgi_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root              /data/www;
    error_page        404 = /fetch$uri;
}

location /fetch/ {
    internal;

    scgi_pass         backend:9000;
    ...

    scgi_store        on;
    scgi_store_access user:rw group:rw all:r;
    scgi_temp_path    /data/temp;

    alias             /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">scgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">scgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从SCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_temp_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_temp_path scgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储包含从SCGI服务器接收的数据的临时文件的目录。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">scgi_temp_path /spool/nginx/scgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/scgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#scgi_cache_path">scgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_rewrite_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_rewrite_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_rewrite_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-rewrite-module"><a href="#Module-ngx-http-rewrite-module" class="headerlink" title="Module ngx_http_rewrite_module"></a>Module ngx_http_rewrite_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#break">break</a> <br>     <a href="#if">if</a> <br>     <a href="#return">return</a> <br>     <a href="#rewrite">rewrite</a> <br>     <a href="#rewrite_log">rewrite_log</a> <br>     <a href="#set">set</a> <br>     <a href="#uninitialized_variable_warn">uninitialized_variable_warn</a> <br> <a href="#internals">Internal Implementation</a> <br></td>

<p>   <code>ngx_http_rewrite_module</code>模块用于使用PCRE正则表达式更改请求URI，返回重定向和有条件地选择配置。 </p>
<p>   <a href="#break">break</a> ， <a href="#if">if</a> ， <a href="#return">return</a> ， <a href="#rewrite">rewrite</a>和<a href="#set">set</a>指令按以下顺序处理： </p>
<ul>
<li>在<a href="ngx_http_core_module.html#server">服务器</a>级别指定的此模块的指令是按顺序执行的; -   反复： <ul class="compact"><li>  基于请求URI搜索<a href="ngx_http_core_module.html#location">位置</a> ; -   在找到的位置内指定的该模块的指令是顺序执行的; -   如果<a href="#rewrite">重写</a>请求URI，则重复循环，但不超过<a href="ngx_http_core_module.html#internal">10次</a> 。 </li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**break** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  停止处理当前的<code>ngx_http_rewrite_module</code>指令集。 </p>
<p>  如果在该<a href="ngx_http_core_module.html#location">位置</a>内指定了指令，则在该<a href="ngx_http_core_module.html#location">位置</a>继续进一步处理该请求。 </p>
<p>  例： </p>
<pre class="notranslate">if ($slow) {
    limit_rate 10k;
    break;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**if** ( &lt;code class=&quot;notranslate&quot;&gt;*condition*</code> ) { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  评估指定的<code>*condition*</code> 。  如果为true，则执行在大括号内指定的此模块指令，并在<code>if</code>指令内为该请求分配配置。   <code>if</code>指令内的配置继承自先前的配置级别。 </p>
<p>  条件可以是以下任何一种： </p>
<ul>
<li>变量名;  如果变量的值为空字符串或“ <code>0</code> ”，则为false; <blockquote class="note">  在版本1.0.1之前，任何以“ <code>0</code> ”开头的字符串都被视为错误值。 </blockquote>-   使用“ <code>=</code> ”和“ <code>!=</code> ”运算符比较变量和字符串; -   使用“ <code>~</code> ”（对于区分大小写的匹配）和“ <code>~*</code> ”（对于不区分大小写的匹配）运算符，将变量与正则表达式进行匹配。  正则表达式可以包含可供以后在<code>$1</code> .. <code>$9</code>变量中重用的捕获。  负操作符“ <code>!~</code> ”和“ <code>!~*</code> ”也可用。  如果正则表达式包含“ <code>}</code> ”或“ <code>;</code>   “字符，整个表达式应该用单引号或双引号括起来。 -   使用“ <code>-f</code> ”和“ <code>!-f</code> ”运算符检查文件是否存在; -   使用“ <code>-d</code> ”和“ <code>!-d</code> ”运算符检查目录是否存在; -   使用“ <code>-e</code> ”和“ <code>!-e</code> ”运算符检查文件，目录或符号链接是否存在; -   使用“ <code>-x</code> ”和“ <code>!-x</code> ”运算符检查可执行文件。 </li>
</ul>
<p>  例子： </p>
<pre class="notranslate">if ($http_user_agent ~ MSIE) {
    rewrite ^(.*)$ /msie/$1 break;
}

if ($http_cookie ~* "id=([^;]+)(?:;|$)") {
    set $id $1;
}

if ($request_method = POST) {
    return 405;
}

if ($slow) {
    limit_rate 10k;
}

if ($invalid_referer) {
    return 403;
}
</pre>



<blockquote>
<p>   <code>$invalid_referer</code>嵌入变量的值由<a href="ngx_http_referer_module.html#valid_referers">valid_referers</a>指令设置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**return*code*</code> [ <code>*text*</code> ]; <br> <code>**return*code*</code> <code>*URL*</code> ; <br> <code>**return*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  停止处理并将指定的<code>*code*</code>返回给客户端。  非标准代码444在不发送响应头的情况下关闭连接。 </p>
<p>  从版本0.8.42开始，可以指定重定向URL（对于代码301,302,303,307和308）或响应正文<code>*text*</code> （对于其他代码）。  响应正文文本和重定向URL可以包含变量。  作为特殊情况，可以将重定向URL指定为此服务器的本地URI，在这种情况下，根据请求方案（ <code>$scheme</code> ）以及<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>和<a href="ngx_http_core_module.html#port_in_redirect">port_in_redirect</a>指令形成完整重定向URL。 </p>
<p>  另外，可以将用于具有代码302的临时重定向的<code>*URL*</code>指定为唯一参数。  这样的参数应该以“ <code>http://</code> ”，“ <code>https://</code> ”或“ <code>$scheme</code> ”字符串开头。   <code>*URL*</code>可以包含变量。 </p>
<blockquote>
<p>  在版本0.7.51之前只能返回以下代码：204,400,402-406,408,410,411,413,416和500-504。 </p>
<p>  在版本1.1.16和1.0.13之前，代码307不被视为重定向。 </p>
<p>  在版本1.13.0之前，代码308不被视为重定向。 </p>
</blockquote>
<p>  另请参见<a href="ngx_http_core_module.html#error_page">error_page</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**rewrite**     &lt;code class=&quot;notranslate&quot;&gt;*regex*</code>    <code>*replacement*</code>    [ <code>*flag*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  如果指定的正则表达式与请求URI匹配，则URI将根据<code>*replacement*</code>字符串中的指定进行更改。   <code>rewrite</code>指令按照它们在配置文件中的出现顺序依次执行。  可以使用标志终止对指令的进一步处理。  如果替换字符串以“ <code>http://</code> ”，“ <code>https://</code> ”或“ <code>$scheme</code> ”开头，则处理停止并将重定向返回给客户端。 </p>
<p>  可选的<code>*flag*</code>参数可以是以下之一： </p>
<p>  完整重定向URL根据请求方案（ <code>$scheme</code> ）以及<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>和<a href="ngx_http_core_module.html#port_in_redirect">port_in_redirect</a>指令形成。 </p>
<p>  例： </p>
<pre class="notranslate">server {
    ...
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
    return  403;
    ...
}
</pre>



<p>  但是如果这些指令放在“ <code>/download/</code> ”位置， <code>last</code>标志应该用<code>break</code>替换，否则nginx会生成10个周期并返回500错误： </p>
<pre class="notranslate">location /download/ {
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  break;
    return  403;
}
</pre>



<p>  如果<code>*replacement*</code>字符串包含新请求参数，则先前的请求参数将附加在它们之后。  如果这是不希望的，在替换字符串的末尾加上一个问号可以避免附加它们，例如： </p>
<pre class="notranslate">rewrite ^/users/(.*)$ /show?user=$1? last;
</pre>



<p>  如果正则表达式包含“ <code>}</code> ”或“ <code>;</code>   “字符，整个表达式应该用单引号或双引号括起来。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**rewrite_logon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">rewrite_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  启用或禁用将<code>ngx_http_rewrite_module</code>模块指令处理结果记录到<code>notice</code>级别的<a href="ngx_core_module.html#error_log">error_log</a>中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set*$variable*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  设置指定<code>*variable*</code>的<code>*value*</code> 。  该<code>*value*</code>可以包含文本，变量及其组合。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uninitialized_variable_warnon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uninitialized_variable_warn on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  控制是否记录有关未初始化变量的警告。 </p>
<h4 id="内部实施"><a href="#内部实施" class="headerlink" title="内部实施"></a>内部实施</h4><p>   <code>ngx_http_rewrite_module</code>模块指令在配置阶段编译为在请求处理期间解释的内部指令。  解释器是一个简单的虚拟堆栈机器。 </p>
<p>  例如，指令 </p>
<pre class="notranslate">location /download/ {
    if ($forbidden) {
        return 403;
    }

    if ($slow) {
        limit_rate 10k;
    }

    rewrite ^/(download/.*)/media/(.*)\..*$ /$1/mp3/$2.mp3 break;
}
</pre>

<p>  将被翻译成这些说明： </p>
<pre class="notranslate">variable $forbidden
check against zero
    return 403
    end of code
variable $slow
check against zero
match of regular expression
copy "/"
copy $1
copy "/mp3/"
copy $2
copy ".mp3"
end of regular expression
end of code
</pre>



<p>  请注意，上面的<a href="ngx_http_core_module.html#limit_rate">limit_rate</a>指令没有说明，因为它与<code>ngx_http_rewrite_module</code>模块无关。  为<a href="#if">if</a>块创建单独的配置。  如果条件成立，则为此配置分配一个请求，其中<code>limit_rate</code>等于10k。 </p>
<p>  指令 </p>
<pre class="notranslate">rewrite ^/(download/.*)/media/(.*)\..*$ /$1/mp3/$2.mp3 break;
</pre>

<p>  如果正则表达式中的第一个斜杠放在括号内，则可以通过一条指令变小： </p>
<pre class="notranslate">rewrite ^( **/** download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;
</pre>

<p>  相应的说明将如下所示： </p>
<pre class="notranslate">match of regular expression
copy $1
copy "/mp3/"
copy $2
copy ".mp3"
end of regular expression
end of code
</pre>





</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_referer_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_referer_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_referer_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-referer-module"><a href="#Module-ngx-http-referer-module" class="headerlink" title="Module ngx_http_referer_module"></a>Module ngx_http_referer_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#referer_hash_bucket_size">referer_hash_bucket_size</a> <br>     <a href="#referer_hash_max_size">referer_hash_max_size</a> <br>     <a href="#valid_referers">valid_referers</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_referer_module</code>模块用于阻止对“Referer”头字段中具有无效值的请求访问站点。  应该记住，使用适当的“Referer”字段值来构造请求非常容易，因此本模块的预期目的不是要彻底阻止此类请求，而是阻止常规浏览器发送的请求的大量流量。  还应该考虑到，即使对于有效请求，常规浏览器也可能不发送“Referer”字段。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">valid_referers none blocked server_names
               *.example.com example.* www.example.org/galleries/
               ~\.google\.;

if ($invalid_referer) {
    return 403;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**referer_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">referer_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.0.5版本中。 </p>
<p>  设置有效引用散列表的存储区大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**referer_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">referer_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.0.5版本中。 </p>
<p>  设置有效引用者哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**valid_referers**     &lt;code class=&quot;notranslate&quot;&gt;none</code> |    <code>blocked</code> |    <code>server_names</code> |    <code>*string*</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定将导致嵌入的<code>$invalid_referer</code>变量设置为空字符串的“Referer”请求标头字段值。  否则，变量将设置为“ <code>1</code> ”。  搜索匹配不区分大小写。 </p>
<p>  参数可以如下： </p>
<p>  例： </p>
<pre class="notranslate">valid_referers none blocked server_names
               *.example.com example.* www.example.org/galleries/
               ~\.google\.;
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_realip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_realip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-realip-module"><a href="#Module-ngx-http-realip-module" class="headerlink" title="Module ngx_http_realip_module"></a>Module ngx_http_realip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#set_real_ip_from">set_real_ip_from</a> <br>     <a href="#real_ip_header">real_ip_header</a> <br>     <a href="#real_ip_recursive">real_ip_recursive</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_realip_module</code>模块用于将客户端地址和可选端口更改为在指定的头字段中发送的端口。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_realip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">set_real_ip_from  192.168.1.0/24;
set_real_ip_from  192.168.2.1;
set_real_ip_from  2001:0db8::/32;
real_ip_header    X-Forwarded-For;
real_ip_recursive on;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set_real_ip_from**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义已知可发送正确替换地址的可信地址。  如果指定了特殊值<code>unix:</code>则所有UNIX域套接字都将受信任。  也可以使用主机名（1.13.1）指定可信地址。 </p>
<blockquote>
<p>  从版本1.3.0和1.2.1开始支持IPv6地址。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**real_ip_header**     &lt;code class=&quot;notranslate&quot;&gt;*field*</code> |    <code>X-Real-IP</code> |    <code>X-Forwarded-For</code> |    <code>proxy_protocol</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">real_ip_header X-Real-IP;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义请求标头字段，其值将用于替换客户端地址。 </p>
<p>  包含可选端口的请求标头字段值也用于替换客户端端口（1.11.0）。  应根据<a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">RFC 3986</a>指定地址和端口。 </p>
<p>   <code>proxy_protocol</code>参数（1.5.12）将客户端地址更改为PROXY协议头中的地址。  必须先通过在<a href="ngx_http_core_module.html#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**real_ip_recursiveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">real_ip_recursive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  如果禁用递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为<a href="#real_ip_header">real_ip_header</a>指令定义的请求头字段中发送的最后一个地址。  如果启用了递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为请求头字段中发送的最后一个非受信任地址。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_random_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_random_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_random_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-random-index-module"><a href="#Module-ngx-http-random-index-module" class="headerlink" title="Module ngx_http_random_index_module"></a>Module ngx_http_random_index_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#random_index">random_index</a> <br></td>

<p>   <code>ngx_http_random_index_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求，并在目录中选择一个随机文件作为索引文件。  在<a href="ngx_http_index_module.html">ngx_http_index_module</a>模块之前处理该模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_random_index_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    random_index on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random_indexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">random_index off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  启用或禁用周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_proxy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_proxy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-proxy-module"><a href="#Module-ngx-http-proxy-module" class="headerlink" title="Module ngx_http_proxy_module"></a>Module ngx_http_proxy_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#proxy_bind">proxy_bind</a> <br>     <a href="#proxy_buffer_size">proxy_buffer_size</a> <br>     <a href="#proxy_buffering">proxy_buffering</a> <br>     <a href="#proxy_buffers">proxy_buffers</a> <br>     <a href="#proxy_busy_buffers_size">proxy_busy_buffers_size</a> <br>     <a href="#proxy_cache">proxy_cache</a> <br>     <a href="#proxy_cache_background_update">proxy_cache_background_update</a> <br>     <a href="#proxy_cache_bypass">proxy_cache_bypass</a> <br>     <a href="#proxy_cache_convert_head">proxy_cache_convert_head</a> <br>     <a href="#proxy_cache_key">proxy_cache_key</a> <br>     <a href="#proxy_cache_lock">proxy_cache_lock</a> <br>     <a href="#proxy_cache_lock_age">proxy_cache_lock_age</a> <br>     <a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a> <br>     <a href="#proxy_cache_max_range_offset">proxy_cache_max_range_offset</a> <br>     <a href="#proxy_cache_methods">proxy_cache_methods</a> <br>     <a href="#proxy_cache_min_uses">proxy_cache_min_uses</a> <br>     <a href="#proxy_cache_path">proxy_cache_path</a> <br>     <a href="#proxy_cache_purge">proxy_cache_purge</a> <br>     <a href="#proxy_cache_revalidate">proxy_cache_revalidate</a> <br>     <a href="#proxy_cache_use_stale">proxy_cache_use_stale</a> <br>     <a href="#proxy_cache_valid">proxy_cache_valid</a> <br>     <a href="#proxy_connect_timeout">proxy_connect_timeout</a> <br>     <a href="#proxy_cookie_domain">proxy_cookie_domain</a> <br>     <a href="#proxy_cookie_path">proxy_cookie_path</a> <br>     <a href="#proxy_force_ranges">proxy_force_ranges</a> <br>     <a href="#proxy_headers_hash_bucket_size">proxy_headers_hash_bucket_size</a> <br>     <a href="#proxy_headers_hash_max_size">proxy_headers_hash_max_size</a> <br>     <a href="#proxy_hide_header">proxy_hide_header</a> <br>     <a href="#proxy_http_version">proxy_http_version</a> <br>     <a href="#proxy_ignore_client_abort">proxy_ignore_client_abort</a> <br>     <a href="#proxy_ignore_headers">proxy_ignore_headers</a> <br>     <a href="#proxy_intercept_errors">proxy_intercept_errors</a> <br>     <a href="#proxy_limit_rate">proxy_limit_rate</a> <br>     <a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a> <br>     <a href="#proxy_method">proxy_method</a> <br>     <a href="#proxy_next_upstream">proxy_next_upstream</a> <br>     <a href="#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> <br>     <a href="#proxy_next_upstream_tries">proxy_next_upstream_tries</a> <br>     <a href="#proxy_no_cache">proxy_no_cache</a> <br>     <a href="#proxy_pass">proxy_pass</a> <br>     <a href="#proxy_pass_header">proxy_pass_header</a> <br>     <a href="#proxy_pass_request_body">proxy_pass_request_body</a> <br>     <a href="#proxy_pass_request_headers">proxy_pass_request_headers</a> <br>     <a href="#proxy_read_timeout">proxy_read_timeout</a> <br>     <a href="#proxy_redirect">proxy_redirect</a> <br>     <a href="#proxy_request_buffering">proxy_request_buffering</a> <br>     <a href="#proxy_send_lowat">proxy_send_lowat</a> <br>     <a href="#proxy_send_timeout">proxy_send_timeout</a> <br>     <a href="#proxy_set_body">proxy_set_body</a> <br>     <a href="#proxy_set_header">proxy_set_header</a> <br>     <a href="#proxy_socket_keepalive">proxy_socket_keepalive</a> <br>     <a href="#proxy_ssl_certificate">proxy_ssl_certificate</a> <br>     <a href="#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> <br>     <a href="#proxy_ssl_ciphers">proxy_ssl_ciphers</a> <br>     <a href="#proxy_ssl_crl">proxy_ssl_crl</a> <br>     <a href="#proxy_ssl_name">proxy_ssl_name</a> <br>     <a href="#proxy_ssl_password_file">proxy_ssl_password_file</a> <br>     <a href="#proxy_ssl_protocols">proxy_ssl_protocols</a> <br>     <a href="#proxy_ssl_server_name">proxy_ssl_server_name</a> <br>     <a href="#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> <br>     <a href="#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> <br>     <a href="#proxy_ssl_verify">proxy_ssl_verify</a> <br>     <a href="#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> <br>     <a href="#proxy_store">proxy_store</a> <br>     <a href="#proxy_store_access">proxy_store_access</a> <br>     <a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a> <br>     <a href="#proxy_temp_path">proxy_temp_path</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_proxy_module</code>模块允许将请求传递到另一台服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    proxy_pass       http://localhost:8000;
    proxy_set_header Host      $host;
    proxy_set_header X-Real-IP $remote_addr;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使与可选端口（1.11.2）的指定本地IP地址建立到代理服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>proxy_bind</code>指令的效果，允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">proxy_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从代理服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用来自代理服务器的响应缓冲。 </p>
<p>  启用缓冲后，nginx会尽快从代理服务器接收响应，并将其保存到<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#proxy_temp_path">临时文件中</a> 。  写入临时文件由<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a>和<a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从代理服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#proxy_buffer_size">proxy_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#proxy_ignore_headers">proxy_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从代理服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自代理服务器的响应<a href="#proxy_buffering">缓冲</a>时，限制可能忙于向响应客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>由<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#proxy_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
proxy_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#proxy_no_cache">proxy_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_convert_headon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_convert_head on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  启用或禁用将“ <code>HEAD</code> ”方法转换为“ <code>GET</code> ”以进行缓存。  禁用转换时，应将<a href="#proxy_cache_key">缓存键</a>配置为包含<code>$request_method</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_key $scheme$proxy_host$request_uri;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">proxy_cache_key "$host$request_uri $cookie_user";
</pre>

<p>  默认情况下，指令的值接近字符串 </p>
<pre class="notranslate">proxy_cache_key $scheme$proxy_host$uri$is_args$args;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给代理服务器，一次只允许一个请求填充根据<a href="#proxy_cache_key">proxy_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给代理服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#proxy_cache_lock">proxy_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给代理服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递到代理服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_methods**     &lt;code class=&quot;notranslate&quot;&gt;GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.59版本中。 </p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#proxy_no_cache">proxy_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#proxy_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  临时文件的目录是根据<code>use_temp_path</code>参数（1.7.10）设置的。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#proxy_temp_path">proxy_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#proxy_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#proxy_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#proxy_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        proxy_pass http://backend;
        proxy_cache cache_zone;
        proxy_cache_key $uri;
        proxy_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_use_stale**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与代理服务器通信期间可以在哪些情况下使用过时的缓存响应。  该指令的参数与<a href="#proxy_next_upstream">proxy_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择代理服务器来处理请求，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对代理服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对代理服务器的访问次数，可以使用<a href="#proxy_cache_lock">proxy_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_valid** [ &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">proxy_cache_valid 200 302 10m;
proxy_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">proxy_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">proxy_cache_valid 200 302 10m;
proxy_cache_valid 301      1h;
proxy_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#proxy_ignore_headers">proxy_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与代理服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cookie_domainoff</code> ; <br> <code>**proxy_cookie_domain*domain*</code> <code>*replacement*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cookie_domain off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.1.15版中。 </p>
<p>设置应在代理服务器响应的“Set-Cookie”标头字段的<code>domain</code>属性中更改的文本。  假设代理服务器返回带有“ <code>domain=localhost</code> ”属性的“Set-Cookie”头字段。  指令 </p>
</li>
</ul>
<pre class="notranslate">proxy_cookie_domain localhost example.org;
</pre>

<p>  将此属性重写为“ <code>domain=example.org</code> ”。 </p>
<p>   <code>*domain*</code>开头处的点和<code>*replacement*</code>字符串以及<code>domain</code>属性将被忽略。  匹配不区分大小写。 </p>
<p>   <code>*domain*</code>和<code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_cookie_domain www.$host $host;
</pre>



<p>  也可以使用正则表达式指定该指令。  在这种情况下， <code>*domain*</code>应该从“ <code>~</code> ”符号开始。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_cookie_domain ~\.(?P&lt;sl_domain&gt;[-0-9a-z]+\.[a-z]+)$ $sl_domain;
</pre>



<p>  可能有几个<code>proxy_cookie_domain</code>指令： </p>
<pre class="notranslate">proxy_cookie_domain localhost example.org;
proxy_cookie_domain ~\.([a-z]+\.[a-z]+)$ $1;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_cookie_domain</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_cookie_domain off;
proxy_cookie_domain localhost example.org;
proxy_cookie_domain www.example.org example.org;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cookie_pathoff</code> ; <br> <code>**proxy_cookie_path*path*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cookie_path off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.15版中。 </p>
<p>  设置应在代理服务器响应的“Set-Cookie”标头字段的<code>path</code>属性中更改的文本。  假设代理服务器返回带有属性“ <code>path=/two/some/uri/</code> ”的“Set-Cookie”头字段。  指令 </p>
<pre class="notranslate">proxy_cookie_path /two/ /;
</pre>

<p>  将此属性重写为“ <code>path=/some/uri/</code> ”。 </p>
<p>   <code>*path*</code>和<code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_cookie_path $uri /some$uri;
</pre>



<p>  也可以使用正则表达式指定该指令。  在这种情况下， <code>*path*</code>应该从用于区分大小写匹配的“ <code>~</code> ”符号开始，或者从用于区分大小写匹配的“ <code>~*</code> ”符号开始。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre>



<p>  可能有几个<code>proxy_cookie_path</code>指令： </p>
<pre class="notranslate">proxy_cookie_path /one/ /;
proxy_cookie_path / /two/;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_cookie_path</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_cookie_path off;
proxy_cookie_path /two/ /;
proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论代理服务器中的“Accept-Ranges”字段如何，都可以对代理服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_headers_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_headers_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="#proxy_hide_header">proxy_hide_header</a>和<a href="#proxy_set_header">proxy_set_header</a>指令使用的哈希表的桶<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_headers_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_headers_hash_max_size 512;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="#proxy_hide_header">proxy_hide_header</a>和<a href="#proxy_set_header">proxy_set_header</a>指令使用的哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会从代理服务器对客户端的响应中传递标题字段“Date”，“Server”，“X-Pad”和“X-Accel -…”。   <code>proxy_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#proxy_pass_header">proxy_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_http_version1.0</code> | <code>1.1</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_http_version 1.0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  设置代理的HTTP协议版本。  默认情况下，使用版本1.0。  建议将1.1版与<a href="ngx_http_upstream_module.html#keepalive">keepalive</a>连接和<a href="ngx_http_upstream_module.html#ntlm">NTLM身份验证配合使用</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ignore_client_aborton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ignore_client_abort off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在客户端关闭连接而不等待响应时是否应关闭与代理服务器的连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从代理服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#proxy_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#proxy_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的代理响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从代理服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。  仅当启用了代理服务器的响应<a href="#proxy_buffering">缓冲时</a> ，此限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自代理服务器的响应<a href="#proxy_buffering">缓冲</a> ，并且整个响应不适合<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#proxy_cache">缓存</a>或<a href="#proxy_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_method*method*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定在转发到代理服务器的请求中使用的HTTP <code>*method*</code> ，而不是客户端请求中的方法。  参数值可以包含变量（1.11.6）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_502</code> ， <code>http_503</code> ， <code>http_504</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#proxy_next_upstream_tries">尝试次数</a>和<a href="#proxy_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#proxy_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#proxy_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;
proxy_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#proxy_cache_bypass">proxy_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> , <code>limit_except</code> <br>                </td></p>
<p>  设置代理服务器的协议和地址以及应映射位置的可选URI。  作为协议，可以指定“ <code>http</code> ”或“ <code>https</code> ”。  可以将地址指定为域名或IP地址，以及可选端口： </p>
<pre class="notranslate">proxy_pass http://localhost:8000/uri/;
</pre>

<p>  或者作为在单词“ <code>unix</code> ”之后指定并用冒号括起来的UNIX域套接字路径： </p>
<pre class="notranslate">proxy_pass http://unix:/tmp/backend.socket:/uri/;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p>  请求URI按如下方式传递给服务器： </p>
<p><li>  如果使用URI指定了<code>proxy_pass</code>指令，那么当请求传递给服务器时，与该位置匹配的<a href="ngx_http_core_module.html#location">规范化</a>请求URI的一部分将被指令中指定的URI替换： <blockquote class="example"><pre class="notranslate">location /name/ {<br>    proxy_pass <a href="http://127.0.0.1/remote/" target="_blank" rel="noopener">http://127.0.0.1/remote/</a>;<br>}<br></pre></blockquote></li><li>  如果指定了<code>proxy_pass</code>而没有URI，则请求URI将以与处理原始请求时客户端发送的格式相同的形式传递给服务器，或者在处理更改的URI时传递完整的规范化请求URI： <blockquote class="example"><pre class="notranslate">location /some/path/ {<br>    proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>;<br>}<br></pre></blockquote><blockquote class="note">  在版本1.1.12之前，如果指定了<code>proxy_pass</code>而没有URI，则在某些情况下可能会传递原始请求URI而不是更改的URI。 </blockquote></li></p>
<pre class="notranslate">location /some/path/ {
    proxy_pass http://127.0.0.1;
}
</pre>



<p>  在某些情况下，无法确定要替换的请求URI的部分： </p>
<ul>
<li>使用正则表达式指定位置时，以及在命名位置内指定位置。   在这些情况下，应指定<code>proxy_pass</code>而不使用URI。 </li><li>  使用<a href="ngx_http_rewrite_module.html#rewrite">rewrite</a>指令在代理位置内更改URI时，将使用相同的配置来处理请求（ <code>break</code> ）： <blockquote class="example"><pre class="notranslate">location /name/ {<br>rewrite    /name/([^/]+) /users?name=$1 break;<br>proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>;<br>}<br></pre></blockquote>  在这种情况下，将忽略指令中指定的URI，并将完整更改的请求URI传递给服务器。 </li><li>  在<code>proxy_pass</code>中使用变量时： <blockquote class="example"><pre class="notranslate">location /name/ {<br>proxy_pass <a href="http://127.0.0.1$request_uri" target="_blank" rel="noopener">http://127.0.0.1$request_uri</a>;<br>}<br></pre></blockquote>  在这种情况下，如果在指令中指定了URI，则将其原样传递给服务器，替换原始请求URI。 </li><pre class="notranslate">location /name/ {
proxy_pass http://127.0.0.1$request_uri;
}
</pre>




</ul>
<p>   <a href="websocket.html">WebSocket</a>代理需要特殊配置，从版本1.3.13开始支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将已<a href="#proxy_hide_header">禁用的</a>头字段从代理服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给代理服务器。 </p>
<pre class="notranslate">location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";

    proxy_pass ...
}
</pre>

<p>  另请参阅<a href="#proxy_set_header">proxy_set_header</a>和<a href="#proxy_pass_request_headers">proxy_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求的标头字段传递给代理服务器。 </p>
<pre class="notranslate">location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_headers off;
    proxy_pass_request_body off;

    proxy_pass ...
}
</pre>

<p>  另请参阅<a href="#proxy_set_header">proxy_set_header</a>和<a href="#proxy_pass_request_body">proxy_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从代理服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果代理服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_redirectdefault</code> ; <br> <code>**proxy_redirectoff</code> ; <br> <code>**proxy_redirect*redirect*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_redirect default;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应在代理服务器响应的“位置”和“刷新”标头字段中更改的文本。  假设代理服务器返回标题字段“ <code>Location: http://localhost:8000/two/some/uri/</code> ”。  指令 </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/two/ http://frontend/one/;
</pre>

<p>  将此字符串重写为“ <code>Location: http://frontend/one/some/uri/</code> ”。 </p>
<p>   <code>*replacement*</code>字符串中可能省略了服务器名称： </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/two/ /;
</pre>

<p>  然后将插入主服务器的名称和端口（如果与80不同）。 </p>
<p>   <code>default</code>参数指定的默认替换使用<a href="ngx_http_core_module.html#location">location</a>和<a href="#proxy_pass">proxy_pass</a>指令的参数。  因此，以下两种配置是等效的： </p>
<pre class="notranslate">location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect default;
</pre>



<pre class="notranslate">location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect http://upstream:port/two/ /one/;
</pre>

<p>  如果使用变量指定<a href="#proxy_pass">proxy_pass，</a>则不允许使用<code>default</code>参数。 </p>
<p>   <code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/ http://$host:$server_port/;
</pre>



<p>   <code>*redirect*</code>还可以包含（1.1.11）变量： </p>
<pre class="notranslate">proxy_redirect http://$proxy_host:8000/ /;
</pre>



<p>  可以使用正则表达式指定（1.1.11）指令。  在这种情况下， <code>*redirect*</code>应该以“ <code>~</code> ”符号开头，以区分大小写的匹配，或者使用“ <code>~*</code> ”符号以区分大小写匹配。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
</pre>



<p>  可能有几个<code>proxy_redirect</code>指令： </p>
<pre class="notranslate">proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_redirect</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_redirect off;
proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre>



<p>  使用此指令，还可以将主机名添加到代理服务器发出的相对重定向： </p>
<pre class="notranslate">proxy_redirect / /;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到代理服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到代理服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#proxy_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码发送原始请求主体时，无论指令值如何，都将缓冲请求主体，除非为代理<a href="#proxy_http_version">启用</a>了HTTP / 1.1。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_send_lowat*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_send_lowat 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令设置为非零值，则nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或具有指定<code>*size*</code>的<code>SO_SNDLOWAT</code>套接字选项来最小化到代理服务器的传出连接上的发送操作数。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到代理服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果代理服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_set_body*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许重新定义传递给代理服务器的请求正文。  该<code>*value*</code>可以包含文本，变量及其组合。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_set_header*field*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_set_header Host $proxy_host;</pre><pre class="notranslate">proxy_set_header Connection close;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将字段重新定义或附加到<a href="#proxy_pass_request_headers">传递</a>给代理服务器的请求标头。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>proxy_set_header</code>指令时，这些指令才从先前级别继承。  默认情况下，只重新定义了两个字段： </p>
<pre class="notranslate">proxy_set_header Host       $proxy_host;
proxy_set_header Connection close;
</pre>

<p>  如果启用了缓存，则标题字段为“If-Modified-Since”，“If-Unmodified-Since”，“If-None-Match”，“If-Match”，“Range”和“If-Range”来自原始请求不会传递给代理服务器。 </p>
<p>  未更改的“主机”请求标头字段可以像这样传递： </p>
<pre class="notranslate">proxy_set_header Host       $http_host;
</pre>



<p>  但是，如果客户端请求标头中不存在此字段，则不会传递任何内容。  在这种情况下，最好使用<code>$host</code>变量 - 它的值等于“Host”请求头字段中的服务器名称，或者如果此字段不存在则等于主服务器名称： </p>
<pre class="notranslate">proxy_set_header Host       $host;
</pre>



<p>  此外，服务器名称可以与代理服务器的端口一起传递： </p>
<pre class="notranslate">proxy_set_header Host       $host:$proxy_port;
</pre>



<p>  如果标头字段的值为空字符串，则此字段将不会传递给代理服务器： </p>
<pre class="notranslate">proxy_set_header Accept-Encoding "";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到代理服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对代理的HTTPS服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对代理的HTTPS服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  指定对代理HTTPS服务器的请求的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_name $proxy_host;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  允许覆盖用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器证书的服务器名称，并在与代理HTTPS服务器建立连接时<a href="#proxy_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#proxy_pass">proxy_pass</a> URL的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  为代理HTTPS服务器的请求启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在与代理的HTTPS服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在使用代理服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  启用或禁用代理HTTPS服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在代理的HTTPS服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_store**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">proxy_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#proxy_temp_path">proxy_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = /fetch$uri;
}

location /fetch/ {
    internal;

    proxy_pass         http://backend/;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    alias              /data/www/;
}
</pre>



<p>  或者像这样： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = @fetch;
}

location @fetch {
    internal;

    proxy_pass         http://backend;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    root               /data/www;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">proxy_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">proxy_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从代理服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_temp_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_temp_path proxy_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从代理服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">proxy_temp_path /spool/nginx/proxy_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/proxy_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参阅<a href="#proxy_cache_path">proxy_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_proxy_module</code>模块支持嵌入式变量，这些变量可用于使用<a href="#proxy_set_header">proxy_set_header</a>指令组合头： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_perl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_perl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_perl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-perl-module"><a href="#Module-ngx-http-perl-module" class="headerlink" title="Module ngx_http_perl_module"></a>Module ngx_http_perl_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#perl">perl</a> <br>     <a href="#perl_modules">perl_modules</a> <br>     <a href="#perl_require">perl_require</a> <br>     <a href="#perl_set">perl_set</a> <br> <a href="#ssi">Calling Perl from SSI</a> <br> <a href="#methods">The $r Request Object Methods</a> <br></td>

<p>   <code>ngx_http_perl_module</code>模块用于在Perl中实现位置和变量处理程序，并将Perl调用插入到SSI中。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_perl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  此模块需要<a href="https://www.perl.org/get.html" target="_blank" rel="noopener">Perl</a> 5.6.1或更高版本。   C编译器应该与用于构建Perl的编译器兼容。 </p>
</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  该模块是实验性的，需要注意的是经纪人。 </p>
<p>  为了让Perl在重新配置期间重新编译已修改的模块，它应该使用<code>-Dusemultiplicity=yes</code>或<code>-Dusethreads=yes</code>参数<code>-Dusethreads=yes</code> 。  另外，为了使Perl在运行时泄漏更少的内存，应该使用<code>-Dusemymalloc=no</code>参数构建它。  要在已构建的Perl中检查这些参数的值（在示例中指定了首选值），请运行： </p>
<pre class="notranslate">$ perl -V:usemultiplicity -V:usemymalloc
usemultiplicity='define';
usemymalloc='n';
</pre>



<p>  请注意，在使用新的<code>-Dusemultiplicity=yes</code>或<code>-Dusethreads=yes</code>参数重建Perl之后，还必须重建所有二进制Perl模块 - 它们将停止使用新的Perl。 </p>
<p>  每次重新配置后，主进程和工作进程都有可能增大。  如果主进程增长到不可接受的大小，则可以在不更改可执行文件的情况下应用<a href="control.html#upgrade">实时升级</a>过程。 </p>
<p>  当Perl模块执行长时间运行的操作（例如解析域名，连接到另一个服务器或查询数据库）时，将不会处理分配给当前工作进程的其他请求。  因此，建议仅执行具有可预测和短执行时间的此类操作，例如访问本地文件系统。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    perl_modules perl/lib;
    perl_require hello.pm;

    perl_set $msie6 '

        sub {
            my $r = shift;
            my $ua = $r-&gt;header_in("User-Agent");

            return "" if $ua =~ /Opera/;
            return "1" if $ua =~ / MSIE [6-9]\.\d+/;
            return "";
        }

    ';

    server {
        location / {
            perl hello::handler;
        }
    }
</pre>



<p>   <code>perl/lib/hello.pm</code>模块： </p>
<pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    $r-&gt;send_http_header("text/html");
    return OK if $r-&gt;header_only;

    $r-&gt;print("hello!\n&lt;br/&gt;");

    if (-f $r-&gt;filename or -d _) {
        $r-&gt;print($r-&gt;uri, " exists!\n");
    }

    return OK;
}

1;
__END__
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl*module*</code> :: <code>*function*</code> |’sub { … }’;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  为给定位置设置Perl处理程序。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_modules*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为Perl模块设置其他路径。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_require*module*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义将在每次重新配置期间加载的模块的名称。  可以存在几个<code>perl_require</code>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_set**     &lt;code class=&quot;notranslate&quot;&gt;*$variable*</code>    <code>*module*</code> :: <code>*function*</code> |’sub { … }’;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为指定的变量安装Perl处理程序。 </p>
<h4 id="从SSI调用Perl"><a href="#从SSI调用Perl" class="headerlink" title="从SSI调用Perl"></a>从SSI调用Perl</h4><p>  调用Perl的SSI命令具有以下格式： </p>
<pre class="notranslate">&lt;!--# perl sub=" `*module*` :: `*function*` " arg=" `*parameter1*` " arg=" `*parameter2*` " ...
--&gt;
</pre>



<h4 id="r请求对象方法"><a href="#r请求对象方法" class="headerlink" title="$ r请求对象方法"></a>$ r请求对象方法</h4><pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    if ($r-&gt;request_method ne "POST") {
        return DECLINED;
    }

    if ($r-&gt;has_request_body( **\&amp;post** )) {
        return OK;
    }

    return HTTP_BAD_REQUEST;
}

sub **post** {
    my $r = shift;

    $r-&gt;send_http_header;

    $r-&gt;print("request_body: \"", $r-&gt;request_body, "\"&lt;br/&gt;");
    $r-&gt;print("request_body_file: \"", $r-&gt;request_body_file, "\"&lt;br/&gt;\n");

    return OK;
}

1;

__END__
</pre>

<blockquote>
<p>  目前不支持重定向到命名位置。 </p>
</blockquote>
<pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    $r-&gt;discard_request_body;
    $r-&gt;variable("var", "OK");
    $r-&gt;sleep(1000, **\&amp;next** );

    return OK;
}

sub **next** {
    my $r = shift;

    $r-&gt;send_http_header;
    $r-&gt;print($r-&gt;variable("var"));

    return OK;
}

1;

__END__
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mp4_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mp4_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mp4_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mp4-module"><a href="#Module-ngx-http-mp4-module" class="headerlink" title="Module ngx_http_mp4_module"></a>Module ngx_http_mp4_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#mp4">mp4</a> <br>     <a href="#mp4_buffer_size">mp4_buffer_size</a> <br>     <a href="#mp4_max_buffer_size">mp4_max_buffer_size</a> <br>     <a href="#mp4_limit_rate">mp4_limit_rate</a> <br>     <a href="#mp4_limit_rate_after">mp4_limit_rate_after</a> <br></td>

<p>   <code>ngx_http_mp4_module</code>模块为MP4文件提供伪流服务器端支持。  此类文件通常具有<code>.mp4</code> ， <code>.m4v</code>或<code>.m4a</code>文件扩展名。 </p>
<p>  伪流与兼容的Flash播放器结合使用。  播放器使用查询字符串参数中指定的开始时间（仅命名为<code>start</code>并以秒为单位指定）向服务器发送HTTP请求，服务器以流响应，使其起始位置对应于请求的时间，例如： </p>
<pre class="notranslate">http://example.com/elephants_dream.mp4?start=238.88
</pre>

<p>  这允许在任何时间执行随机搜索，或者在时间线的中间开始回放。 </p>
<p>  为了支持搜索，基于H.264的格式将元数据存储在所谓的“moov原子”中。  它是文件的一部分，用于保存整个文件的索引信息。 </p>
<p>  要开始播放，播放器首先需要读取元数据。  这是通过使用<code>start=0</code>参数发送特殊请求来完成的。  许多编码软件在文件末尾插入元数据。  这对于伪流是次优的，因为播放器必须在开始播放之前下载整个文件。  如果元数据位于文件的开头，则nginx只需开始发回文件内容就足够了。  如果元数据位于文件末尾，则nginx必须读取整个文件并准备新流，以便元数据位于媒体数据之前。  这涉及一些CPU，内存和磁盘I / O开销，因此最好事先<a href="http://flowplayer.org/plugins/streaming/pseudostreaming.html#prepare" target="_blank" rel="noopener">准备一个用于伪流的原始文件</a> ，而不是让nginx在每个这样的请求上执行此操作。 </p>
<p>  该模块还支持HTTP请求的<code>end</code>参数（1.5.13），该请求设置回放的结束点。   <code>end</code>参数可以使用<code>start</code>参数指定，也可以单独指定： </p>
<pre class="notranslate">http://example.com/elephants_dream.mp4?start=238.88&amp;end=555.55
</pre>



<p>  对于具有非零<code>start</code>或<code>end</code>参数的匹配请求，nginx将从文件中读取元数据，准备具有所请求时间范围的流，并将其发送到客户端。  这具有与上述相同的开销。 </p>
<p>  如果匹配请求不包含<code>start</code>和<code>end</code>参数，则没有开销，并且文件仅作为静态资源发送。  一些播放器也支持字节范围请求，因此不需要此模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_mp4_module</code>配置参数启用它。 </p>
<blockquote>
<p>  如果以前使用过第三方mp4模块，则应禁用它。 </p>
</blockquote>
<p>   <a href="ngx_http_flv_module.html">ngx_http_flv_module</a>模块提供了对FLV文件的类似伪流支持。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /video/ {
    mp4;
    mp4_buffer_size       1m;
    mp4_max_buffer_size   5m;
    mp4_limit_rate        on;
    mp4_limit_rate_after  30s;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_buffer_size 512K;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于处理MP4文件的缓冲区的初始<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_max_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_max_buffer_size 10M;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在元数据处理期间，可能需要更大的缓冲区。  它的大小不能超过指定的<code>*size*</code> ，否则nginx将返回500（内部服务器错误）服务器错误，并记录以下消息： </p>
<pre class="notranslate">"/some/movie/file.mp4" mp4 moov atom is too large:
12583268, you may want to increase mp4_max_buffer_size
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_limit_rate**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>*factor*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_limit_rate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制向客户端传输的响应速率。  根据所服务的MP4文件的平均比特率限制速率。  要计算速率，比特率乘以指定的<code>*factor*</code> 。  特殊值“ <code>on</code> ”对应于因子1.1。  特殊值“ <code>off</code> ”禁用速率限制。  根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_limit_rate_after*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_limit_rate_after 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置媒体数据的初始量（以回放时间测量），之后对客户端的进一步传输将是速率限制的。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mirror_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mirror_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mirror_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mirror-module"><a href="#Module-ngx-http-mirror-module" class="headerlink" title="Module ngx_http_mirror_module"></a>Module ngx_http_mirror_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#mirror">mirror</a> <br>     <a href="#mirror_request_body">mirror_request_body</a> <br></td>

<p>   <code>ngx_http_mirror_module</code>模块（1.13.4）通过创建后台镜像子请求来实现原始请求的镜像。  忽略对镜像子请求的响应。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    mirror /mirror;
    proxy_pass http://backend;
}

location = /mirror {
    internal;
    proxy_pass http://test_backend$request_uri;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mirror*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mirror off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将镜像原始请求的URI。  可以在同一级别指定多个镜像。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mirror_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mirror_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否镜像客户端请求正文。  启用后，将在创建镜像子请求之前读取客户端请求正文。  在这种情况下，将禁用由<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>和<a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>指令设置的无缓冲客户机请求正文代理。 </p>
<pre class="notranslate">location / {
    mirror /mirror;
    mirror_request_body off;
    proxy_pass http://backend;
}

location = /mirror {
    internal;
    proxy_pass http://log_backend;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_memcached_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_memcached_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_memcached_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-memcached-module"><a href="#Module-ngx-http-memcached-module" class="headerlink" title="Module ngx_http_memcached_module"></a>Module ngx_http_memcached_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#memcached_bind">memcached_bind</a> <br>     <a href="#memcached_buffer_size">memcached_buffer_size</a> <br>     <a href="#memcached_connect_timeout">memcached_connect_timeout</a> <br>     <a href="#memcached_force_ranges">memcached_force_ranges</a> <br>     <a href="#memcached_gzip_flag">memcached_gzip_flag</a> <br>     <a href="#memcached_next_upstream">memcached_next_upstream</a> <br>     <a href="#memcached_next_upstream_timeout">memcached_next_upstream_timeout</a> <br>     <a href="#memcached_next_upstream_tries">memcached_next_upstream_tries</a> <br>     <a href="#memcached_pass">memcached_pass</a> <br>     <a href="#memcached_read_timeout">memcached_read_timeout</a> <br>     <a href="#memcached_send_timeout">memcached_send_timeout</a> <br>     <a href="#memcached_socket_keepalive">memcached_socket_keepalive</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_memcached_module</code>模块用于从memcached服务器获取响应。  密钥在<code>$memcached_key</code>变量中设置。  响应应该通过nginx外部的方式预先存储在memcached中。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    location / {
        set            $memcached_key "$uri?$args";
        memcached_pass host:11211;
        error_page     404 502 504 = @fallback;
    }

    location @fallback {
        proxy_pass     http://backend;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到memcached服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>memcached_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到memcached服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">memcached_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自memcached服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从memcached服务器接收的响应的缓冲区的<code>*size*</code> 。  一旦收到响应，响应就会同步传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与memcached服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论来自这些响应中的“Accept-Ranges”字段，都可以对来自memcached服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_gzip_flag*flag*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.6版本中。 </p>
<p>  如果设置了<code>*flag*</code> ，则在memcached服务器响应中启用<code>*flag*</code>存在的测试，并将“ <code>Content-Encoding</code> ”响应头字段设置为“ <code>gzip</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_response</code> |    <code>not_found</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_response</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>not_found</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#memcached_next_upstream_tries">尝试次数</a>和<a href="#memcached_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#memcached_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#memcached_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置memcached服务器地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">memcached_pass localhost:11211;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">memcached_pass unix:/tmp/memcached.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从memcached服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果memcached服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到memcached服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果memcached服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到memcached服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_map_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_map_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-map-module"><a href="#Module-ngx-http-map-module" class="headerlink" title="Module ngx_http_map_module"></a>Module ngx_http_map_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#map">map</a> <br>     <a href="#map_hash_bucket_size">map_hash_bucket_size</a> <br>     <a href="#map_hash_max_size">map_hash_max_size</a> <br></td>

<p>   <code>ngx_http_map_module</code>模块创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">map $http_host $name {
    hostnames;

    default       0;

    example.com   1;
    *.example.com 1;
    example.org   2;
    *.example.org 2;
    .example.net  3;
    wap.*         4;
}

map $http_user_agent $mobile {
    default       0;
    "~Opera Mini" 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map**     &lt;code class=&quot;notranslate&quot;&gt;*string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p>  在0.9.0版之前，只能在第一个参数中指定单个变量。 </p>
<p>  由于变量仅在使用时进行评估，因此即使是大量“ <code>map</code> ”变量的声明也不会增加请求处理的额外成本。 </p>
</blockquote>
<p>  地图块内的参数指定源和结果值之间的映射。 </p>
<p>  源值指定为字符串或正则表达式（0.9.6）。 </p>
<p>  字符串匹配忽略大小写。 </p>
<p>  对于区分大小写的匹配，正则表达式应该从“ <code>~</code> ”符号开始，或者对于不区分大小写的匹配，应该从“ <code>~*</code> ”符号（1.0.4）开始。  正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p>  如果源值与下面描述的特殊参数名称之一匹配，则应使用“ <code>\</code> ”符号作为前缀。 </p>
<p>  结果值可以包含文本，变量（0.9.0）及其组合（1.11.0）。 </p>
<p>  还支持以下特殊参数： </p>
<pre class="notranslate">*.example.com 1;
example.*     1;
</pre>

<pre class="notranslate">example.com   1;
*.example.com 1;
</pre>

<pre class="notranslate">.example.com  1;
</pre>



<p>  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
<ol>
<li>没有掩码的字符串值 1.   带有前缀掩码的最长字符串值，例如“ <code>*.example.com</code> ” 1.   带有后缀掩码的最长字符串值，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） 1.   默认值 </li>
</ol>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_bucket_size 32|64|128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的存储区大小。  默认值取决于处理器的缓存行大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-log-module"><a href="#Module-ngx-http-log-module" class="headerlink" title="Module ngx_http_log_module"></a>Module ngx_http_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#access_log">access_log</a> <br>     <a href="#log_format">log_format</a> <br>     <a href="#open_log_file_cache">open_log_file_cache</a> <br></td>

<p>   <code>ngx_http_log_module</code>模块以指定的格式写入请求日志。 </p>
<p>  请求记录在处理结束的位置的上下文中。  如果在请求处理期间发生<a href="ngx_http_core_module.html#internal">内部重定向</a> ，则它可能与原始位置不同。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">log_format compression '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $bytes_sent '
                       '"$http_referer" "$http_user_agent" "$gzip_ratio"';

access_log /spool/logs/nginx-access.log compression buffer=32k;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**access_log**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>*format*</code>    [ <code>buffer</code> = <code>*size*</code> ]    [ <code>gzip[= &lt;code class=&quot;notranslate&quot;&gt;*level*</code> ] ]    [ <code>flush</code> = <code>*time*</code> ]    [ <code>if</code> = <code>*condition*</code> ]]; <br> <code>**access_logoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">access_log logs/access.log combined;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> , <code>limit_except</code> <br>                </td></p>
<p>  设置缓冲日志写入的路径，格式和配置。  可以在同一级别指定多个日志。  可以通过在第一个参数中指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  特殊值<code>off</code>取消当前级别的所有<code>access_log</code>指令。  如果未指定格式，则使用预定义的“ <code>combined</code> ”格式。 </p>
<p>  如果使用<code>buffer</code>或<code>gzip</code> （1.3.10,1.2.7）参数，则将缓冲写入日志。 </p>
<blockquote>
<p>  缓冲区大小不得超过磁盘文件的原子写入大小。  对于FreeBSD，这个大小是无限的。 </p>
</blockquote>
<p>  启用缓冲后，数据将写入文件： </p>
<ul>
<li>如果下一个日志行不适合缓冲区; -   如果缓冲的数据早于<code>flush</code>参数（1.3.10,1.2.7）指定的数据; -   当工作进程<a href="control.html">重新打开</a>日志文件或正在关闭时。 </li>
</ul>
<p>  如果使用<code>gzip</code>参数，则在写入文件之前将压缩缓冲的数据。  压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。  默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ <code>zcat</code> ”解压缩或读取。 </p>
<p>  例： </p>
<pre class="notranslate">access_log /path/to/log.gz combined gzip flush=5m;
</pre>





<blockquote>
<p>  要使gzip压缩起作用，必须使用zlib库构建nginx。 </p>
</blockquote>
<p>  文件路径可以包含变量（0.7.6+），但是这样的日志有一些约束： </p>
<ul>
<li>工作进程使用其凭据的<a href="ngx_core_module.html#user">用户</a>应具有在具有此类日志的目录中创建文件的权限; -   缓冲写入不起作用; -   每个日志写入都会打开和关闭该文件。  但是，由于常用文件的描述符可以存储在<a href="#open_log_file_cache">缓存中</a> ，因此写入旧文件可以在<a href="#open_log_file_cache">open_log_file_cache</a>指令的<code>valid</code>参数指定的时间内继续写入 </li><li>  在每个日志写入期间，检查是否存在请求的<a href="ngx_http_core_module.html#root">根目录</a> ，如果它不存在，则不会创建日志。  因此，在同一级别指定<a href="ngx_http_core_module.html#root">root</a>和<code>access_log</code>是个好主意： <blockquote class="example"><pre class="notranslate">server {<br>root       /spool/vhost/data/$host;<br>access_log /spool/vhost/logs/$host;<br>…<br></pre></blockquote></li>
</ul>
<p>   <code>if</code>参数（1.7.0）启用条件记录。  如果<code>*condition*</code>评估为“0”或空字符串，则不会记录请求。  在以下示例中，将不记录响应代码为2xx和3xx的请求： </p>
<pre class="notranslate">map $status $loggable {
    ~^[23]  0;
    default 1;
}

access_log /path/to/access.log combined if=$loggable;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**log_format**     &lt;code class=&quot;notranslate&quot;&gt;*name*</code>    [ <code>escape</code> = <code>default</code> | <code>json</code> | <code>none</code> ]    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">log_format combined “…”;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定日志格式。 </p>
<p>   <code>escape</code>参数（1.11.8）允许设置在变量中转义的<code>json</code>或<code>default</code>字符，默认情况下，使用<code>default</code>转义。   <code>none</code>值（1.13.10）禁用转义。 </p>
<p>  日志格式可以包含公共变量，以及仅在日志写入时存在的变量： </p>
<blockquote>
<p>  在现代nginx版本变量<a href="ngx_http_core_module.html#var_status">$ status</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.2,1.2.2</a> ）， <a href="ngx_http_core_module.html#var_bytes_sent">$ bytes_sent</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2.5</a> ）， <a href="ngx_http_core_module.html#var_connection">$ connection</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2.5</a> ）， <a href="ngx_http_core_module.html#var_connection">$ connection_requests</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2</a> ） .5）， <a href="ngx_http_core_module.html#var_msec">$ msec</a> （1.3.9,1.2.6）， <a href="ngx_http_core_module.html#var_request_time">$ request_time</a> （1.3.9,1.2.6）， <a href="ngx_http_core_module.html#var_pipe">$ pipe</a> （1.3.12,1.2.7）， <a href="ngx_http_core_module.html#var_request_length">$ request_length</a> （1.3.12,1.2.7） ）， <a href="ngx_http_core_module.html#var_time_iso8601">$ time_iso8601</a> （ <a href="ngx_http_core_module.html#var_time_iso8601">1.3.12,1.2.7</a> ）和<a href="ngx_http_core_module.html#var_time_local">$ time_local</a> （1.3.12,1.2.7）也可用作公共变量。 </p>
</blockquote>
<p>  发送到客户端的标题行具有前缀“ <code>sent_http_</code> ”，例如<code>$sent_http_content_range</code> 。 </p>
<p>  配置始终包含预定义的“ <code>combined</code> ”格式： </p>
<pre class="notranslate">log_format combined '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent"';
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**open_log_file_cachemax</code> = <code>*N*</code>[ <code>inactive</code> = <code>*time*</code> ][ <code>min_uses</code> = <code>*N*</code> ][ <code>valid</code> = <code>*time*</code> ]; <br> <code>**open_log_file_cacheoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">open_log_file_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。  该指令具有以下参数： </p>
<p>  用法示例： </p>
<pre class="notranslate">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_req_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_req_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_req_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-req-module"><a href="#Module-ngx-http-limit-req-module" class="headerlink" title="Module ngx_http_limit_req_module"></a>Module ngx_http_limit_req_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_req">limit_req</a> <br>     <a href="#limit_req_log_level">limit_req_log_level</a> <br>     <a href="#limit_req_status">limit_req_status</a> <br>     <a href="#limit_req_zone">limit_req_zone</a> <br></td>

<p>   <code>ngx_http_limit_req_module</code>模块（0.7.21）用于限制每个定义密钥的请求处理速率，特别是来自单个IP地址的请求的处理速率。  使用“漏桶”方法进行限制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

    ...

    server {

        ...

        location /search/ {
            limit_req zone=one burst=5;
        }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req**     &lt;code class=&quot;notranslate&quot;&gt;zone</code> = <code>*name*</code>    [ <code>burst</code> = <code>*number*</code> ]    [ <code>nodelay</code> |     <code>delay</code> = <code>*number*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置共享内存区域和请求的最大突发大小。  如果请求速率超过为区域配置的速率，则延迟其处理，以便以定义的速率处理请求。  过多的请求被延迟，直到它们的数量超过最大突发大小，在这种情况下请求以<a href="#limit_req_status">错误</a>终止。  默认情况下，最大突发大小等于零。  例如，指令 </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

server {
    location /search/ {
        limit_req zone=one burst=5;
    }
</pre>

<p>  允许每秒平均不超过1个请求，突发不超过5个请求。 </p>
<p>  如果不希望在请求受限的情况下延迟过多的请求，则应使用参数<code>nodelay</code> ： </p>
<pre class="notranslate">limit_req zone=one burst=5 nodelay;
</pre>



<p>   <code>delay</code>参数（1.15.7）指定过多请求被延迟的限制。  默认值为零，即所有过多的请求都会延迟。 </p>
<p>  可能有几个<code>limit_req</code>指令。  例如，以下配置将限制来自单个IP地址的请求的处理速率，同时限制虚拟服务器的请求处理速率： </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s;
limit_req_zone $server_name zone=perserver:10m rate=10r/s;

server {
    ...
    limit_req zone=perip burst=5 nodelay;
    limit_req zone=perserver burst=10;
}
</pre>



<p>  当且仅当当前级别上没有<code>limit_req</code>指令时，这些指令才从先前级别继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_req_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.18版本中。 </p>
<p>  为服务器因速率超过或延迟请求处理而拒绝处理请求的情况设置所需的日志记录级别。  延迟的记录水平比拒绝的记录水平低一个点;  例如，如果指定了“ <code>limit_req_log_level notice</code> ”，则会使用<code>info</code>级别记录延迟。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_status*code*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_req_status 503;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  设置要响应拒绝的请求而返回的状态代码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_zone**     &lt;code class=&quot;notranslate&quot;&gt;*key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code>    <code>rate</code> = <code>*rate*</code>    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态存储当前的过多请求数。   <code>*key*</code>可以包含文本，变量及其组合。  具有空键值的请求不计算在内。 </p>
<blockquote>
<p>  在1.7.6版之前， <code>*key*</code>可以只包含一个变量。 </p>
</blockquote>
<p>  用法示例： </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
</pre>



<p>  这里，状态保持在10兆字节区域“1”，并且该区域的平均请求处理速率不能超过每秒1个请求。 </p>
<p>  客户端IP地址用作密钥。  请注意，此处使用<code>$binary_remote_addr</code>变量而不是<code>$remote_addr</code> 。  对于IPv4地址， <code>$binary_remote_addr</code>变量的大小始终为4个字节，对于IPv6地址，则为16个字节。  存储状态在32位平台上总是占用64个字节，在64位平台上占用128个字节。  一兆字节区域可以保留大约16,000个64字节状态或大约8千个128字节状态。 </p>
<p>  如果区域存储耗尽，则删除最近最少使用的状态。  即使在此之后无法创建新状态，该请求也会因<a href="#limit_req_status">错误</a>而终止。 </p>
<p>  速率以每秒请求数（r / s）指定。  如果需要每秒少于一个请求的速率，则在每分钟请求（r / m）中指定。  例如，每秒半请求为30r / m。 </p>
<p>   <code>sync</code>参数（1.15.3）启用共享内存区域的<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a> 。 </p>
<blockquote>
<p>   <code>sync</code>参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-conn-module"><a href="#Module-ngx-http-limit-conn-module" class="headerlink" title="Module ngx_http_limit_conn_module"></a>Module ngx_http_limit_conn_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_conn">limit_conn</a> <br>     <a href="#limit_conn_log_level">limit_conn_log_level</a> <br>     <a href="#limit_conn_status">limit_conn_status</a> <br>     <a href="#limit_conn_zone">limit_conn_zone</a> <br>     <a href="#limit_zone">limit_zone</a> <br></td>

<p>   <code>ngx_http_limit_conn_module</code>模块用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<p>  并非所有连接都被计算在内  仅当连接具有服务器正在处理的请求并且已经读取了整个请求标头时才计算连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    limit_conn_zone $binary_remote_addr zone=addr:10m;

    ...

    server {

        ...

        location /download/ {
            limit_conn addr 1;
        }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn*zone*</code> <code>*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置共享内存区域和给定键值的最大允许连接数。  超过此限制时，服务器将返回<a href="#limit_conn_status">错误</a>以回复请求。  例如，指令 </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    location /download/ {
        limit_conn addr 1;
    }
</pre>

<p>  每次只允许一个IP地址连接一个。 </p>
<blockquote>
<p>  在HTTP / 2和SPDY中，每个并发请求被视为单独的连接。 </p>
</blockquote>
<p>  可能有几个<code>limit_conn</code>指令。  例如，以下配置将限制每个客户端IP与服务器的连接数，同时限制与虚拟服务器的连接总数： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;

server {
    ...
    limit_conn perip 10;
    limit_conn perserver 100;
}
</pre>



<p>  当且仅当当前级别上没有<code>limit_conn</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.18版本中。 </p>
<p>  为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_status*code*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_status 503;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  设置要响应拒绝的请求而返回的状态代码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_zone**     &lt;code class=&quot;notranslate&quot;&gt;*key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态包括当前的连接数。   <code>*key*</code>可以包含文本，变量及其组合。  具有空键值的请求不计算在内。 </p>
<blockquote>
<p>  在1.7.6版之前， <code>*key*</code>可以只包含一个变量。 </p>
</blockquote>
<p>  用法示例： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;
</pre>

<p>  这里，客户端IP地址用作密钥。  请注意，此处使用<code>$binary_remote_addr</code>变量而不是<code>$remote_addr</code> 。   <code>$remote_addr</code>变量的大小可以在7到15个字节之间变化。  存储状态在32位平台上占用32或64字节的内存，在64位平台上占用64字节。  对于IPv4地址， <code>$binary_remote_addr</code>变量的大小始终为4个字节，对于IPv6地址，则为16个字节。  存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。  一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。  如果区域存储空间耗尽，服务器将向所有其他请求返回<a href="#limit_conn_status">错误</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_zone**     &lt;code class=&quot;notranslate&quot;&gt;*name*</code>    <code>*$variable*</code>    <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令在1.1.8版本中已过时，已在1.7.6版本中删除。  应使用具有更改语法的等效<a href="#limit_conn_zone">limit_conn_zone</a>指令： </p>
<blockquote>
<p>   <code>limit_conn_zone</code> <code>*$variable*</code> <code>zone</code> = <code>*name*</code> ： <code>*size*</code> ; </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_keyval_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_keyval_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-keyval-module"><a href="#Module-ngx-http-keyval-module" class="headerlink" title="Module ngx_http_keyval_module"></a>Module ngx_http_keyval_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#keyval">keyval</a> <br>     <a href="#keyval_zone">keyval_zone</a> <br></td>

<p>   <code>ngx_http_keyval_module</code>模块（1.13.3）创建的变量的值取自<a href="ngx_http_api_module.html#http_keyvals_">API</a>管理的键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    keyval_zone zone=one:32k state=one.keyval;
    keyval $arg_text $text zone=one;
    ...
    server {
        ...
        location / {
            return 200 $text;
        }

        location /api {
            api write=on;
        }
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval**     &lt;code class=&quot;notranslate&quot;&gt;*key*</code>    <code>*$variable*</code>    <code>zone</code> = <code>*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  创建一个新的<code>*$variable*</code>其值由<code>*key*</code>数据库中的键查找。  字符串匹配忽略大小写。  数据库存储在<code>zone</code>参数指定的共享内存区域中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval_zone**     &lt;code class=&quot;notranslate&quot;&gt;zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>state</code> = <code>*file*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置保留键值数据库的共享内存区域的<code>*name*</code>和<code>*size*</code> 。  键值对由<a href="ngx_http_api_module.html#http_keyvals_">API</a>管理。 </p>
<p>  可选的<code>state</code>参数指定一个<code>*file*</code> ，该<code>*file*</code>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p>  可选的<code>timeout</code>参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p>  可选的<code>sync</code>参数（1.15.0）可以<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a>共享内存区域。  同步需要设置<a href="#keyval_timeout">超时</a>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_js_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_js_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-js-module"><a href="#Module-ngx-http-js-module" class="headerlink" title="Module ngx_http_js_module"></a>Module ngx_http_js_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#js_content">js_content</a> <br>     <a href="#js_include">js_include</a> <br>     <a href="#js_set">js_set</a> <br> <a href="#arguments">Request Argument</a> <br></td>

<p>   <code>ngx_http_js_module</code>模块用于在<a href="njs/index.html">njs中</a>实现位置和变量处理程序 - 这是JavaScript语言的一个子集。 </p>
<p>  默认情况下不构建此模块。  可<a href="njs/install.html">在此处</a>下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">load_module modules/ngx_http_js_module.so;
...

http {
    js_include http.js;

    js_set $foo     foo;
    js_set $summary summary;

    server {
        listen 8000;

        location / {
            add_header X-Foo $foo;
            js_content baz;
        }

        location = /summary {
            return 200 $summary;
        }

        location = /hello {
            js_content hello;
        }
    }
}
</pre>



<p>   <code>http.js</code>文件： </p>
<pre class="notranslate">function foo(r) {
    r.log("hello from foo() handler");
    return "foo";
}

function summary(r) {
    var a, s, h;

    s = "JS summary\n\n";

    s += "Method: " + r.method + "\n";
    s += "HTTP version: " + r.httpVersion + "\n";
    s += "Host: " + r.headersIn.host + "\n";
    s += "Remote Address: " + r.remoteAddress + "\n";
    s += "URI: " + r.uri + "\n";

    s += "Headers:\n";
    for (h in r.headersIn) {
        s += "  header '" + h + "' is '" + r.headersIn[h] + "'\n";
    }

    s += "Args:\n";
    for (a in r.args) {
        s += "  arg '" + a + "' is '" + r.args[a] + "'\n";
    }

    return s;
}

function baz(r) {
    r.status = 200;
    r.headersOut.foo = 1234;
    r.headersOut['Content-Type'] = "text/plain; charset=utf-8";
    r.headersOut['Content-Length'] = 15;
    r.sendHeader();
    r.send("nginx");
    r.send("java");
    r.send("script");

    r.finish();
}

function hello(r) {
    r.return(200, "Hello world!");
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_content*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  将njs函数设置为位置内容处理程序。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_include*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定在njs中实现位置和变量处理程序的文件。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_set*$variable*</code> <code>*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为指定的变量设置njs函数。 </p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>  每个HTTP njs处理程序都接收一个参数，一个请求<a href="njs/reference.html#http">对象</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-index-module"><a href="#Module-ngx-http-index-module" class="headerlink" title="Module ngx_http_index_module"></a>Module ngx_http_index_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#index">index</a> <br></td>

<p>   <code>ngx_http_index_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求。  这些请求也可以由<a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a>和<a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>模块处理。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    index index.$geo.html index.html;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**index*file*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">index index.html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义将用作索引的文件。   <code>*file*</code>名可以包含变量。  按指定顺序检查文件。  列表的最后一个元素可以是具有绝对路径的文件。  例： </p>
<pre class="notranslate">index index.$geo.html index.0.html /index.html;
</pre>



<p>  应该注意，使用索引文件会导致内部重定向，并且可以在不同的位置处理请求。  例如，使用以下配置： </p>
<pre class="notranslate">location = / {
    index index.html;
}

location / {
    ...
}
</pre>

<p>   “ <code>/</code> ”请求实际上将在第二个位置处理为“ <code>/index.html</code> ”。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_image_filter_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_image_filter_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_image_filter_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-image-filter-module"><a href="#Module-ngx-http-image-filter-module" class="headerlink" title="Module ngx_http_image_filter_module"></a>Module ngx_http_image_filter_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#image_filter">image_filter</a> <br>     <a href="#image_filter_buffer">image_filter_buffer</a> <br>     <a href="#image_filter_interlace">image_filter_interlace</a> <br>     <a href="#image_filter_jpeg_quality">image_filter_jpeg_quality</a> <br>     <a href="#image_filter_sharpen">image_filter_sharpen</a> <br>     <a href="#image_filter_transparency">image_filter_transparency</a> <br>     <a href="#image_filter_webp_quality">image_filter_webp_quality</a> <br></td>

<p>   <code>ngx_http_image_filter_module</code>模块（0.7.54+）是一个过滤器，可以转换JPEG，GIF，PNG和WebP格式的图像。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_image_filter_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块使用<a href="http://libgd.org" target="_blank" rel="noopener">libgd</a>库。  建议使用最新版本的库。 </p>
<p>   WebP格式支持出现在1.11.6版中。  要以此格式转换图像，必须使用WebP支持编译<code>libgd</code>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /img/ {
    proxy_pass   http://backend;
    image_filter resize 150 100;
    image_filter rotate 90;
    error_page   415 = /empty;
}

location = /empty {
    empty_gif;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filteroff</code> ; <br> <code>**image_filtertest</code> ; <br> <code>**image_filtersize</code> ; <br> <code>**image_filter**     &lt;code class=&quot;notranslate&quot;&gt;rotate</code>    <code>90</code> | <code>180</code> |    <code>270</code> ; <br> <code>**image_filter**     &lt;code class=&quot;notranslate&quot;&gt;resize</code>    <code>*width*</code>    <code>*height*</code> ; <br> <code>**image_filter**     &lt;code class=&quot;notranslate&quot;&gt;crop</code>    <code>*width*</code>    <code>*height*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  设置要对图像执行的转换类型： </p>
<pre class="notranslate">{ "img" : { "width": 100, "height": 100, "type": "gif" } }
</pre>

<pre class="notranslate">{}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_buffer 1M;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取图像的缓冲区的最大大小。  超出大小时，服务器返回错误415（不支持的介质类型）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_interlaceon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_interlace off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  如果启用，最终图像将被隔行扫描。  对于JPEG，最终图像将采用“渐进式JPEG”格式。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_jpeg_quality*quality*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_jpeg_quality 75;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置变换后的JPEG图像的所需<code>*quality*</code> 。  可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。  建议的最大值为95.参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_sharpen*percent*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_sharpen 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  增加最终图像的清晰度。  锐度百分比可以超过100.零值禁用锐化。  参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_transparencyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_transparency on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义在使用调色板指定的颜色转换GIF图像或PNG图像时是否应保留透明度。  透明度的丧失导致图像质量更好。  始终保留PNG中的Alpha通道透明度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_webp_quality*quality*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_webp_quality 80;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置转换的WebP图像的所需<code>*quality*</code> 。  可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。  参数值可以包含变量。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_hls_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_hls_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_hls_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-hls-module"><a href="#Module-ngx-http-hls-module" class="headerlink" title="Module ngx_http_hls_module"></a>Module ngx_http_hls_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#hls">hls</a> <br>     <a href="#hls_buffers">hls_buffers</a> <br>     <a href="#hls_forward_args">hls_forward_args</a> <br>     <a href="#hls_fragment">hls_fragment</a> <br>     <a href="#hls_mp4_buffer_size">hls_mp4_buffer_size</a> <br>     <a href="#hls_mp4_max_buffer_size">hls_mp4_max_buffer_size</a> <br></td>

<p>   <code>ngx_http_hls_module</code>模块为MP4和MOV媒体文件提供HTTP实时流（HLS）服务器端支持。  此类文件通常具有<code>.mp4</code> ， <code>.m4v</code> ， <code>.m4a</code> ， <code>.mov</code>或<code>.qt</code>文件扩展名。  该模块支持H.264视频编解码器，AAC和MP3音频编解码器。 </p>
<p>  对于每个媒体文件，支持两个URI： </p>
<ul>
<li>带有“ <code>.m3u8</code> ”文件扩展名的播放列表URI。   URI可以接受可选参数： <ul class="compact"><li>   “ <code>start</code> ”和“ <code>end</code> ”以秒为单位定义播放列表边界（1.9.0）。 -    “ <code>offset</code> ”将初始播放位置移动到以秒为单位的时间偏移（1.9.0）。  正值设置从播放列表开头的时间偏移量。  负值设置播放列表中最后一个片段末尾的时间偏移量。 -    “ <code>len</code> ”以秒为单位定义片段长度。 -    “ <code>start</code> ”和“ <code>end</code> ”以秒为单位定义片段边界。 </li>
</ul>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    hls;
    hls_fragment            5s;
    hls_buffers             10 10m;
    hls_mp4_buffer_size     1m;
    hls_mp4_max_buffer_size 5m;
    root /var/video/;
}
</pre>

<p>  使用此配置，“/ <code>/var/video/test.mp4</code> ”文件支持以下URI： </p>
<pre class="notranslate">http://hls.example.com/test.mp4.m3u8?offset=1.000&amp;start=1.000&amp;end=2.200
http://hls.example.com/test.mp4.m3u8?len=8.000
http://hls.example.com/test.mp4.ts?start=1.000&amp;end=2.200
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的HLS流。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_buffers 8 2m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取和写入数据帧的缓冲区的最大<code>*number*</code>和<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_forward_argson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_forward_args off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.12版本中。 </p>
<p>  将播放列表请求中的参数添加到片段的URI中。  这对于在请求片段时或在使用<a href="ngx_http_secure_link_module.html">ngx_http_secure_link_module</a>模块保护HLS流时执行客户端授权可能很有用。 </p>
<p>  例如，如果客户端请求播放列表<code>http://example.com/hls/test.mp4.m3u8?a=1&amp;amp;b=2</code> ，则参数<code>a=1</code>和<code>b=2</code>将添加到参数后的片段的URI中<code>start</code>和<code>end</code> ： </p>
<pre class="notranslate">#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:15
#EXT-X-PLAYLIST-TYPE:VOD

#EXTINF:9.333,
test.mp4.ts?start=0.000&amp;end=9.333&amp;a=1&amp;b=2
#EXTINF:7.167,
test.mp4.ts?start=9.333&amp;end=16.500&amp;a=1&amp;b=2
#EXTINF:5.416,
test.mp4.ts?start=16.500&amp;end=21.916&amp;a=1&amp;b=2
#EXTINF:5.500,
test.mp4.ts?start=21.916&amp;end=27.416&amp;a=1&amp;b=2
#EXTINF:15.167,
test.mp4.ts?start=27.416&amp;end=42.583&amp;a=1&amp;b=2
#EXTINF:9.626,
test.mp4.ts?start=42.583&amp;end=52.209&amp;a=1&amp;b=2

#EXT-X-ENDLIST
</pre>



<p>  如果使用<a href="ngx_http_secure_link_module.html">ngx_http_secure_link_module</a>模块保护HLS流，则不应在<a href="ngx_http_secure_link_module.html#secure_link_md5">secure_link_md5</a>表达式中使用<code>$uri</code> ，因为这会在请求片段时导致错误。  应该使用<a href="ngx_http_map_module.html#map">基URI</a>而不是<code>$uri</code> （ <code>$hls_uri</code>中为<code>$hls_uri</code> ）： </p>
<pre class="notranslate">http {
    ...

    map $uri $hls_uri {
        ~^(?&lt;base_uri&gt;.*).m3u8$ $base_uri;
        ~^(?&lt;base_uri&gt;.*).ts$   $base_uri;
        default                 $uri;
    }

    server {
        ...

        location /hls/ {
            hls;
            hls_forward_args on;

            alias /var/videos/;

            secure_link $arg_md5,$arg_expires;
            secure_link_md5 "$secure_link_expires$hls_uri$remote_addr secret";

            if ($secure_link = "") {
                return 403;
            }

            if ($secure_link = "0") {
                return 410;
            }
        }
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_fragment*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_fragment 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为没有“ <code>len</code> ”参数的请求的播放列表URI定义默认片段长度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_mp4_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_mp4_buffer_size 512k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于处理MP4和MOV文件的缓冲区的初始<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_mp4_max_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_mp4_max_buffer_size 10m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在元数据处理期间，可能需要更大的缓冲区。  它的大小不能超过指定的<code>*size*</code> ，否则nginx将返回服务器错误500（内部服务器错误），并记录以下消息： </p>
<pre class="notranslate">"/some/movie/file.mp4" mp4 moov atom is too large:
12583268, you may want to increase hls_mp4_max_buffer_size
</pre>





</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_headers_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_headers_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_headers_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-headers-module"><a href="#Module-ngx-http-headers-module" class="headerlink" title="Module ngx_http_headers_module"></a>Module ngx_http_headers_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#add_header">add_header</a> <br>     <a href="#add_trailer">add_trailer</a> <br>     <a href="#expires">expires</a> <br></td>

<p>   <code>ngx_http_headers_module</code>模块允许将“Expires”和“Cache-Control”头字段以及任意字段添加到响应头。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">expires    24h;
expires    modified +24h;
expires    @24h;
expires    0;
expires    -1;
expires    epoch;
expires    $expires;
add_header Cache-Control private;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_header*name*</code> <code>*value*</code>[ <code>always</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  将指定字段添加到响应头，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1.16,1.0.13）或308（1.13） .0）。  该值可以包含变量。 </p>
<p>  可能有几个<code>add_header</code>指令。  当且仅当在当前级别上没有定义<code>add_header</code>指令时，这些指令才从前一级继承。 </p>
<p>  如果指定了<code>always</code>参数（1.7.5），则无论响应代码如何，都将添加标题字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_trailer*name*</code> <code>*value*</code>[ <code>always</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  该指令出现在1.13.2版中。 </p>
<p>  如果响应代码等于200,201,206,301,302,303,307或308，则将指定字段添加到响应的末尾。该值可以包含变量。 </p>
<p>  可能有几个<code>add_trailer</code>指令。  当且仅当在当前级别上没有定义<code>add_trailer</code>指令时，这些指令才从先前级别继承。 </p>
<p>  如果指定了<code>always</code>参数，则无论响应代码如何，都将添加指定的字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**expires** [ &lt;code class=&quot;notranslate&quot;&gt;modified</code> ] <code>*time*</code> ; <br> <code>**expires**     &lt;code class=&quot;notranslate&quot;&gt;epoch</code> |    <code>max</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">expires off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用添加或修改“Expires”和“Cache-Control”响应头字段，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1。 16,1.0.13）或308（1.13.0）。  参数可以是正<a href="syntax.html">时间</a>或负<a href="syntax.html">时间</a> 。 </p>
<p>   “Expires”字段中的时间计算为指令中指定的当前时间和<code>*time*</code>的总和。  如果使用<code>modified</code>参数（0.7.0,0.6.32），则计算时间为文件修改时间与指令中指定时间的总和。 </p>
<p>  此外，可以使用“ <code>@</code> ”前缀（0.7.9,0.6.34）指定一天中的时间： </p>
<pre class="notranslate">expires @15h30m;
</pre>



<p>   <code>epoch</code>参数对应于绝对时间“ <code>Thu, 01 Jan 1970 00:00:01 GMT</code> ”。   “Cache-Control”字段的内容取决于指定时间的符号： </p>
<ul>
<li>时间是负面的 - “Cache-Control：no-cache”。 -   时间为正或零 - “Cache-Control：max-age = <code>*t*</code> ”，其中<code>*t*</code>是指令中指定的时间，以秒为单位。 </li>
</ul>
<p>   <code>max</code>参数将“Expires”设置为值“ <code>Thu, 31 Dec 2037 23:55:55 GMT</code> ”，并将“Cache-Control”设置为10年。 </p>
<p>   <code>off</code>参数禁用添加或修改“Expires”和“Cache-Control”响应头字段。 </p>
<p>  最后一个参数值可以包含变量（1.7.9）： </p>
<pre class="notranslate">map $sent_http_content_type $expires {
    default         off;
    application/pdf 42d;
    ~image/         max;
}

expires $expires;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_static_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_static_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_static_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-static-module"><a href="#Module-ngx-http-gzip-static-module" class="headerlink" title="Module ngx_http_gzip_static_module"></a>Module ngx_http_gzip_static_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gzip_static">gzip_static</a> <br></td>

<p>   <code>ngx_http_gzip_static_module</code>模块允许发送带有“ <code>.gz</code> ”文件扩展名的预压缩文件，而不是常规文件。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_gzip_static_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">gzip_static  on;
gzip_proxied expired no-cache no-store private auth;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_static**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>always</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_static off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用（“ <code>on</code> ”）或禁用（“ <code>off</code> ”）检查预压缩文件是否存在。  还考虑了以下指令： <a href="ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> ， <a href="ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a> ， <a href="ngx_http_gzip_module.html#gzip_disable">gzip_disable</a>和<a href="ngx_http_gzip_module.html#gzip_vary">gzip_vary</a> 。 </p>
<p>  使用“ <code>always</code> ”值（1.3.6），在所有情况下都使用gzip压缩文件，而不检查客户端是否支持它。  如果磁盘上没有未压缩的文件或者使用了<a href="ngx_http_gunzip_module.html">ngx_http_gunzip_module，</a>则非常有用。 </p>
<p>  可以使用<code>gzip</code>命令或任何其他兼容的文件压缩文件。  建议原始文件和压缩文件的修改日期和时间相同。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-module"><a href="#Module-ngx-http-gzip-module" class="headerlink" title="Module ngx_http_gzip_module"></a>Module ngx_http_gzip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gzip">gzip</a> <br>     <a href="#gzip_buffers">gzip_buffers</a> <br>     <a href="#gzip_comp_level">gzip_comp_level</a> <br>     <a href="#gzip_disable">gzip_disable</a> <br>     <a href="#gzip_http_version">gzip_http_version</a> <br>     <a href="#gzip_min_length">gzip_min_length</a> <br>     <a href="#gzip_proxied">gzip_proxied</a> <br>     <a href="#gzip_types">gzip_types</a> <br>     <a href="#gzip_vary">gzip_vary</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_gzip_module</code>模块是一个使用“gzip”方法压缩响应的过滤器。  这通常有助于将传输数据的大小减少一半甚至更多。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">gzip            on;
gzip_min_length 1000;
gzip_proxied    expired no-cache no-store private auth;
gzip_types      text/plain application/xml;
</pre>



<p>   <code>$gzip_ratio</code>变量可用于记录实现的压缩比。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzipon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用gzipping响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_buffers 32 4k|16 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于压缩响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<blockquote>
<p>  在版本0.7.28之前，默认使用四个4K或8K缓冲区。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_comp_level*level*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_comp_level 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置响应的gzip压缩<code>*level*</code> 。  可接受的值范围为1到9。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_disable*regex*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.6.23版本中。 </p>
<p>  对具有与任何指定正则表达式匹配的“User-Agent”标头字段的请求禁用gzipping响应。 </p>
<p>  特殊掩码“ <code>msie6</code> ”（0.7.12）对应于正则表达式“ <code>MSIE [4-6]\.</code>   “，但工作得更快。  从版本0.8.11开始，“ <code>MSIE 6.0; ... SV1</code>   <code>MSIE 6.0; ... SV1</code>此掩码中不包括“ <code>MSIE 6.0; ... SV1</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_http_version1.0</code> | <code>1.1</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_http_version 1.1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置压缩响应所需的最低HTTP请求版本。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_min_length*length*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_min_length 20;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将被gzip压缩的响应的最小长度。  长度仅由“Content-Length”响应头字段确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_proxied**     &lt;code class=&quot;notranslate&quot;&gt;off</code> |    <code>expired</code> |    <code>no-cache</code> |    <code>no-store</code> |    <code>private</code> |    <code>no_last_modified</code> |    <code>no_etag</code> |    <code>auth</code> |    <code>any</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_proxied off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  根据请求和响应启用或禁用对代理请求的响应的gzipping。  代理请求的事实由“Via”请求头字段的存在确定。  该指令接受多个参数： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还允许对指定的MIME类型进行gzipping响应。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。  始终压缩“ <code>text/html</code> ”类型的响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_varyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_vary off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令<a href="#gzip">gzip</a> ， <a href="ngx_http_gzip_static_module.html#gzip_static">gzip_static</a>或<a href="ngx_http_gunzip_module.html#gunzip">gunzip</a>处于活动状态，则启用或禁用插入“Vary：Accept-Encoding”响应头字段。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gunzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gunzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gunzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gunzip-module"><a href="#Module-ngx-http-gunzip-module" class="headerlink" title="Module ngx_http_gunzip_module"></a>Module ngx_http_gunzip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gunzip">gunzip</a> <br>     <a href="#gunzip_buffers">gunzip_buffers</a> <br></td>

<p>   <code>ngx_http_gunzip_module</code>模块是一个过滤器，它使用“ <code>Content-Encoding: gzip</code> ”解压缩响应，用于不支持“gzip”编码方法的客户端。  当需要存储压缩数据以节省空间并降低I / O成本时，该模块将非常有用。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_gunzip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /storage/ {
    gunzip on;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gunzipon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gunzip off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用对缺少gzip支持的客户端的gzip压缩解压缩。  如果启用，则在确定客户端是否支持gzip时还会考虑以下指令： <a href="ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> ， <a href="ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a>和<a href="ngx_http_gzip_module.html#gzip_disable">gzip_disable</a> 。  另请参见<a href="ngx_http_gzip_module.html#gzip_vary">gzip_vary</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gunzip_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gunzip_buffers 32 4k|16 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于解压缩响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_grpc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_grpc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_grpc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-grpc-module"><a href="#Module-ngx-http-grpc-module" class="headerlink" title="Module ngx_http_grpc_module"></a>Module ngx_http_grpc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#grpc_bind">grpc_bind</a> <br>     <a href="#grpc_buffer_size">grpc_buffer_size</a> <br>     <a href="#grpc_connect_timeout">grpc_connect_timeout</a> <br>     <a href="#grpc_hide_header">grpc_hide_header</a> <br>     <a href="#grpc_ignore_headers">grpc_ignore_headers</a> <br>     <a href="#grpc_intercept_errors">grpc_intercept_errors</a> <br>     <a href="#grpc_next_upstream">grpc_next_upstream</a> <br>     <a href="#grpc_next_upstream_timeout">grpc_next_upstream_timeout</a> <br>     <a href="#grpc_next_upstream_tries">grpc_next_upstream_tries</a> <br>     <a href="#grpc_pass">grpc_pass</a> <br>     <a href="#grpc_pass_header">grpc_pass_header</a> <br>     <a href="#grpc_read_timeout">grpc_read_timeout</a> <br>     <a href="#grpc_send_timeout">grpc_send_timeout</a> <br>     <a href="#grpc_set_header">grpc_set_header</a> <br>     <a href="#grpc_socket_keepalive">grpc_socket_keepalive</a> <br>     <a href="#grpc_ssl_certificate">grpc_ssl_certificate</a> <br>     <a href="#grpc_ssl_certificate_key">grpc_ssl_certificate_key</a> <br>     <a href="#grpc_ssl_ciphers">grpc_ssl_ciphers</a> <br>     <a href="#grpc_ssl_crl">grpc_ssl_crl</a> <br>     <a href="#grpc_ssl_name">grpc_ssl_name</a> <br>     <a href="#grpc_ssl_password_file">grpc_ssl_password_file</a> <br>     <a href="#grpc_ssl_protocols">grpc_ssl_protocols</a> <br>     <a href="#grpc_ssl_server_name">grpc_ssl_server_name</a> <br>     <a href="#grpc_ssl_session_reuse">grpc_ssl_session_reuse</a> <br>     <a href="#grpc_ssl_trusted_certificate">grpc_ssl_trusted_certificate</a> <br>     <a href="#grpc_ssl_verify">grpc_ssl_verify</a> <br>     <a href="#grpc_ssl_verify_depth">grpc_ssl_verify_depth</a> <br></td>

<p>   <code>ngx_http_grpc_module</code>模块允许将请求传递到gRPC服务器（1.13.10）。  该模块需要<a href="ngx_http_v2_module.html">ngx_http_v2_module</a>模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 9000 http2;

    location / {
        grpc_pass 127.0.0.1:9000;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口从指定的本地IP地址发出到gRPC服务器的传出连接。  参数值可以包含变量。  特殊值<code>off</code>取消了从先前配置级别继承的<code>grpc_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数允许到gRPC服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">grpc_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要像指定<code>transparent</code>参数那样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自gRPC服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从gRPC服务器接收的响应的缓冲区的<code>*size*</code> 。  一旦收到响应，响应就会同步传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与gRPC服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会从gRPC服务器对客户端的响应中传递标题字段“Date”，“Server”和“X-Accel -…”。   <code>grpc_hide_header</code>指令设置了不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#grpc_pass_header">grpc_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从gRPC服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”和“X-Accel-Charset”。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的gRPC服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_502</code> ， <code>http_503</code> ， <code>http_504</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#grpc_next_upstream_tries">尝试次数</a>和<a href="#grpc_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制请求可以传递到<a href="#grpc_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制将请求传递到<a href="#grpc_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置gRPC服务器地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">grpc_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">grpc_pass unix:/tmp/grpc.socket;
</pre>

<p>  或者，可以使用“ <code>grpc://</code> ”方案： </p>
<pre class="notranslate">grpc_pass grpc://127.0.0.1:9000;
</pre>

<p>  要通过SSL使用gRPC，应使用“ <code>grpcs://</code> ”方案： </p>
<pre class="notranslate">grpc_pass grpcs://127.0.0.1:443;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将<a href="#grpc_hide_header">其他禁用的</a>头字段从gRPC服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从gRPC服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果gRPC服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求发送到gRPC服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果gRPC服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_set_header*field*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_set_header Content-Length $content_length;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将字段重新定义或附加到<a href="#grpc_pass_request_headers">传递</a>给gRPC服务器的请求标头。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>grpc_set_header</code>指令时，这些指令才从前一级继承。 </p>
<p>  如果标头字段的值是空字符串，则该字段将不会传递给gRPC服务器： </p>
<pre class="notranslate">grpc_set_header Accept-Encoding "";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置与gRPC服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> ，该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定对gRPC SSL服务器的请求的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_name host from grpc_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许覆盖用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器证书的服务器名称，并在与gRPC SSL服务器建立连接时<a href="#grpc_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#grpc_pass">grpc_pass</a>的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_protocols**     [ &lt;code class=&quot;notranslate&quot;&gt;SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为gRPC SSL服务器的请求启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在与gRPC SSL服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在使用gRPC服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用gRPC SSL服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置gRPC SSL服务器证书链中的验证深度。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geo_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geo_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geo-module"><a href="#Module-ngx-http-geo-module" class="headerlink" title="Module ngx_http_geo_module"></a>Module ngx_http_geo_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geo">geo</a> <br></td>

<p>   <code>ngx_http_geo_module</code>模块使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">geo $geo {
    default        0;

    127.0.0.1      2;
    192.168.1.0/24 1;
    10.1.0.0/16    1;

    ::1            2;
    2001:0db8::/32 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geo** [ &lt;code class=&quot;notranslate&quot;&gt;*$address*</code> ] <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  描述指定变量的值对客户端IP地址的依赖性。  默认情况下，地址取自<code>$remote_addr</code>变量，但也可以从另一个变量（0.7.27）获取，例如： </p>
<pre class="notranslate">geo $arg_remote_addr $geo {
    ...;
}
</pre>





<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使存在大量已声明的“ <code>geo</code> ”变量也不会导致请求处理的任何额外成本。 </p>
</blockquote>
<p>  如果变量的值不表示有效的IP地址，则使用“ <code>255.255.255.255</code> ”地址。 </p>
<p>  地址指定为CIDR表示法中的前缀（包括单个地址）或范围（0.7.23）。 </p>
<blockquote>
<p>  从版本1.3.10和1.2.7开始支持IPv6前缀。 </p>
</blockquote>
<p>  还支持以下特殊参数： </p>
<blockquote>
<p>  从版本1.3.0和1.2.1开始支持受信任的IPv6地址。 </p>
</blockquote>
<p>  例： </p>
<pre class="notranslate">geo $country {
    default        ZZ;
    include        conf/geo.conf;
    delete         127.0.0.0/16;
    proxy          192.168.100.0/24;
    proxy          2001:0db8::/32;

    127.0.0.0/24   US;
    127.0.0.1/32   RU;
    10.1.0.0/16    RU;
    192.168.1.0/24 UK;
}
</pre>



<p>   <code>conf/geo.conf</code>文件可以包含以下行： </p>
<pre class="notranslate">10.2.0.0/16    RU;
192.168.2.0/24 RU;
</pre>



<p>  使用最具体匹配的值。  例如，对于127.0.0.1地址，将选择值“ <code>RU</code> ”，而不是“ <code>US</code> ”。 </p>
<p>  范围示例： </p>
<pre class="notranslate">geo $country {
    ranges;
    default                   ZZ;
    127.0.0.0-127.0.0.0       US;
    127.0.0.1-127.0.0.1       RU;
    127.0.0.1-127.0.0.255     US;
    10.1.0.0-10.1.255.255     RU;
    192.168.1.0-192.168.1.255 UK;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geoip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geoip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geoip-module"><a href="#Module-ngx-http-geoip-module" class="headerlink" title="Module ngx_http_geoip_module"></a>Module ngx_http_geoip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geoip_country">geoip_country</a> <br>     <a href="#geoip_city">geoip_city</a> <br>     <a href="#geoip_org">geoip_org</a> <br>     <a href="#geoip_proxy">geoip_proxy</a> <br>     <a href="#geoip_proxy_recursive">geoip_proxy_recursive</a> <br></td>

<p>   <code>ngx_http_geoip_module</code>模块（0.8.6+）使用预编译的<a href="http://www.maxmind.com" target="_blank" rel="noopener">MaxMind</a>数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p>  使用支持IPv6的数据库（1.3.12,1.2.7）时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_geoip_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.maxmind.com/app/c" target="_blank" rel="noopener">MaxMind GeoIP</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    geoip_country         GeoIP.dat;
    geoip_city            GeoLiteCity.dat;
    geoip_proxy           192.168.100.0/24;
    geoip_proxy           2001:0db8::/32;
    geoip_proxy_recursive on;
    ...
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_country*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家/地区的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_city*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。  使用此数据库时，以下变量可用： </p>
<blockquote>
<p>  此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_org*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.0.3版本中。 </p>
<p>  指定用于根据客户端IP地址确定组织的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_proxy*address*</code> | <code>*CIDR*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  定义可信地址。  当请求来自可信地址时，将使用来自“X-Forwarded-For”请求头字段的地址。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_proxy_recursiveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">geoip_proxy_recursive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  如果禁用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用“X-Forwarded-For”中发送的最后一个地址。  如果启用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用在“X-Forwarded-For”中发送的最后一个不可信地址。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_flv_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_flv_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_flv_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-flv-module"><a href="#Module-ngx-http-flv-module" class="headerlink" title="Module ngx_http_flv_module"></a>Module ngx_http_flv_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#flv">flv</a> <br></td>

<p>   <code>ngx_http_flv_module</code>模块为Flash Video（FLV）文件提供伪流服务器端支持。 </p>
<p>  它特别通过请求URI的查询字符串中的<code>start</code>参数处理请求，方法是从请求的字节偏移量和前置FLV头开始发回文件的内容。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_flv_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location ~ \.flv$ {
    flv;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**flv** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_fastcgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_fastcgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_fastcgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-fastcgi-module"><a href="#Module-ngx-http-fastcgi-module" class="headerlink" title="Module ngx_http_fastcgi_module"></a>Module ngx_http_fastcgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#fastcgi_bind">fastcgi_bind</a> <br>     <a href="#fastcgi_buffer_size">fastcgi_buffer_size</a> <br>     <a href="#fastcgi_buffering">fastcgi_buffering</a> <br>     <a href="#fastcgi_buffers">fastcgi_buffers</a> <br>     <a href="#fastcgi_busy_buffers_size">fastcgi_busy_buffers_size</a> <br>     <a href="#fastcgi_cache">fastcgi_cache</a> <br>     <a href="#fastcgi_cache_background_update">fastcgi_cache_background_update</a> <br>     <a href="#fastcgi_cache_bypass">fastcgi_cache_bypass</a> <br>     <a href="#fastcgi_cache_key">fastcgi_cache_key</a> <br>     <a href="#fastcgi_cache_lock">fastcgi_cache_lock</a> <br>     <a href="#fastcgi_cache_lock_age">fastcgi_cache_lock_age</a> <br>     <a href="#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a> <br>     <a href="#fastcgi_cache_max_range_offset">fastcgi_cache_max_range_offset</a> <br>     <a href="#fastcgi_cache_methods">fastcgi_cache_methods</a> <br>     <a href="#fastcgi_cache_min_uses">fastcgi_cache_min_uses</a> <br>     <a href="#fastcgi_cache_path">fastcgi_cache_path</a> <br>     <a href="#fastcgi_cache_purge">fastcgi_cache_purge</a> <br>     <a href="#fastcgi_cache_revalidate">fastcgi_cache_revalidate</a> <br>     <a href="#fastcgi_cache_use_stale">fastcgi_cache_use_stale</a> <br>     <a href="#fastcgi_cache_valid">fastcgi_cache_valid</a> <br>     <a href="#fastcgi_catch_stderr">fastcgi_catch_stderr</a> <br>     <a href="#fastcgi_connect_timeout">fastcgi_connect_timeout</a> <br>     <a href="#fastcgi_force_ranges">fastcgi_force_ranges</a> <br>     <a href="#fastcgi_hide_header">fastcgi_hide_header</a> <br>     <a href="#fastcgi_ignore_client_abort">fastcgi_ignore_client_abort</a> <br>     <a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a> <br>     <a href="#fastcgi_index">fastcgi_index</a> <br>     <a href="#fastcgi_intercept_errors">fastcgi_intercept_errors</a> <br>     <a href="#fastcgi_keep_conn">fastcgi_keep_conn</a> <br>     <a href="#fastcgi_limit_rate">fastcgi_limit_rate</a> <br>     <a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a> <br>     <a href="#fastcgi_next_upstream">fastcgi_next_upstream</a> <br>     <a href="#fastcgi_next_upstream_timeout">fastcgi_next_upstream_timeout</a> <br>     <a href="#fastcgi_next_upstream_tries">fastcgi_next_upstream_tries</a> <br>     <a href="#fastcgi_no_cache">fastcgi_no_cache</a> <br>     <a href="#fastcgi_param">fastcgi_param</a> <br>     <a href="#fastcgi_pass">fastcgi_pass</a> <br>     <a href="#fastcgi_pass_header">fastcgi_pass_header</a> <br>     <a href="#fastcgi_pass_request_body">fastcgi_pass_request_body</a> <br>     <a href="#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a> <br>     <a href="#fastcgi_read_timeout">fastcgi_read_timeout</a> <br>     <a href="#fastcgi_request_buffering">fastcgi_request_buffering</a> <br>     <a href="#fastcgi_send_lowat">fastcgi_send_lowat</a> <br>     <a href="#fastcgi_send_timeout">fastcgi_send_timeout</a> <br>     <a href="#fastcgi_socket_keepalive">fastcgi_socket_keepalive</a> <br>     <a href="#fastcgi_split_path_info">fastcgi_split_path_info</a> <br>     <a href="#fastcgi_store">fastcgi_store</a> <br>     <a href="#fastcgi_store_access">fastcgi_store_access</a> <br>     <a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a> <br>     <a href="#fastcgi_temp_path">fastcgi_temp_path</a> <br> <a href="#parameters">Parameters Passed to a FastCGI Server</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_fastcgi_module</code>模块允许将请求传递给FastCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    fastcgi_pass  localhost:9000;
    fastcgi_index index.php;

    fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
    fastcgi_param QUERY_STRING    $query_string;
    fastcgi_param REQUEST_METHOD  $request_method;
    fastcgi_param CONTENT_TYPE    $content_type;
    fastcgi_param CONTENT_LENGTH  $content_length;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_bind**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到FastCGI服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>fastcgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到FastCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">fastcgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自FastCGI服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从FastCGI服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  启用或禁用缓冲来自FastCGI服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从FastCGI服务器接收响应，并将其保存到<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#fastcgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a>和<a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从FastCGI服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从FastCGI服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从FastCGI服务器<a href="#fastcgi_buffering">缓冲</a>响应时，限制可能忙于向响应客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#fastcgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">fastcgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
fastcgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#fastcgi_no_cache">fastcgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">fastcgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给FastCGI服务器，一次只允许一个请求填充根据<a href="#fastcgi_cache_key">fastcgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给FastCGI服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给FastCGI服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  为<a href="#fastcgi_cache_lock">fastcgi_cache_lock</a>设置超时。  当<code>*time*</code>到期时，请求将被传递给FastCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给FastCGI服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_methods**     &lt;code class=&quot;notranslate&quot;&gt;GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.59版本中。 </p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#fastcgi_no_cache">fastcgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的密钥和文件名都是将MD5功能应用于代理URL的结果。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">fastcgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#fastcgi_temp_path">fastcgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#fastcgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#fastcgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#fastcgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">fastcgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        fastcgi_pass        backend;
        fastcgi_cache       cache_zone;
        fastcgi_cache_key   $uri;
        fastcgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_use_stale**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与FastCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。  该指令的参数与<a href="#fastcgi_next_upstream">fastcgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择要处理请求的FastCGI服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这样可以在更新缓存数据时最大限度地减少对FastCGI服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对FastCGI服务器的访问次数，可以使用<a href="#fastcgi_cache_lock">fastcgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_valid** [ &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">fastcgi_cache_valid 200 302 10m;
fastcgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">fastcgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">fastcgi_cache_valid 200 302 10m;
fastcgi_cache_valid 301      1h;
fastcgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_catch_stderr*string*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>设置要在从FastCGI服务器接收的响应的错误流中搜索的字符串。  如果找到该<code>*string*</code> ，则认为FastCGI服务器返回了<a href="#fastcgi_next_upstream">无效响应</a> 。  这允许在nginx中处理应用程序错误，例如： </p>
</li>
</ul>
<pre class="notranslate">location /php/ {
    fastcgi_pass backend:9000;
    ...
    fastcgi_catch_stderr "PHP Fatal error";
    fastcgi_next_upstream error timeout invalid_header;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与FastCGI服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论来自这些响应中的“Accept-Ranges”字段如何，都可以对来自FastCGI服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会将FastCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。   <code>fastcgi_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#fastcgi_pass_header">fastcgi_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_ignore_client_abort off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定客户端在不等待响应的情况下关闭连接时是否应关闭与FastCGI服务器的连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从FastCGI服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#fastcgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#fastcgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_index*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在<code>$fastcgi_script_name</code>变量的值中设置将在以斜杠结尾的URI之后附加的文件名。  例如，使用这些设置 </p>
<pre class="notranslate">fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
</pre>

<p>  和“ <code>/page.php</code> ”请求， <code>SCRIPT_FILENAME</code>参数将等于“ <code>/home/www/scripts/php/page.php</code> ”，并且使用“ <code>/</code> ”请求它将等于“ <code>/home/www/scripts/php/index.php</code> “。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的FastCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_keep_connon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_keep_conn off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  默认情况下，FastCGI服务器将在发送响应后立即关闭连接。  但是，当此伪指令设置为<code>on</code> ，nginx将指示FastCGI服务器保持连接打开。  特别是，这对于FastCGI服务器的<a href="ngx_http_upstream_module.html#keepalive">keepalive</a>连接起作用是必要的。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从FastCGI服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到FastCFI服务器的连接，则总速率将是指定限制的两倍。  仅当启用了对来自FastCGI服务器的响应的<a href="#fastcgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自FastCGI服务器的响应<a href="#fastcgi_buffering">缓冲</a> ，并且整个响应不适合<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#fastcgi_cache">缓存</a>或<a href="#fastcgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream**     &lt;code class=&quot;notranslate&quot;&gt;error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#fastcgi_next_upstream_tries">尝试次数</a>和<a href="#fastcgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#fastcgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#fastcgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">fastcgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
fastcgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#fastcgi_cache_bypass">fastcgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_param**     &lt;code class=&quot;notranslate&quot;&gt;*parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给FastCGI服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>fastcgi_param</code>指令时，这些指令才从前一级继承。 </p>
<p>  以下示例显示了PHP的最低必需设置： </p>
<pre class="notranslate">fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
fastcgi_param QUERY_STRING    $query_string;
</pre>



<p>   <code>SCRIPT_FILENAME</code>参数在PHP中用于确定脚本名称， <code>QUERY_STRING</code>参数用于传递请求参数。 </p>
<p>  对于处理<code>POST</code>请求的脚本，还需要以下三个参数： </p>
<pre class="notranslate">fastcgi_param REQUEST_METHOD  $request_method;
fastcgi_param CONTENT_TYPE    $content_type;
fastcgi_param CONTENT_LENGTH  $content_length;
</pre>



<p>  如果PHP是使用<code>--enable-force-cgi-redirect</code>配置参数构建的，则还应使用值“200”传递<code>REDIRECT_STATUS</code>参数： </p>
<pre class="notranslate">fastcgi_param REDIRECT_STATUS 200;
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">fastcgi_param HTTPS           $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置FastCGI服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">fastcgi_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">fastcgi_pass unix:/tmp/fastcgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将FastCGI服务器上<a href="#fastcgi_hide_header">禁用的</a>标头字段传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给FastCGI服务器。  另请参见<a href="#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给FastCGI服务器。  另请参见<a href="#fastcgi_pass_request_body">fastcgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从FastCGI服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果FastCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到FastCGI服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到FastCGI服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#fastcgi_next_upstream">下一个服务器</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_send_lowat*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_send_lowat 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令设置为非零值，则nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或具有指定<code>*size*</code>的<code>SO_SNDLOWAT</code>套接字选项来最小化到FastCGI服务器的传出连接上的发送操作数。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到FastCGI服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果FastCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到FastCGI服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_split_path_info*regex*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义捕获<code>$fastcgi_path_info</code>变量值的正则表达式。  正则表达式应该有两个捕获：第一个变为<code>$fastcgi_script_name</code>变量的值，第二个变为<code>$fastcgi_path_info</code>变量的值。  例如，使用这些设置 </p>
<pre class="notranslate">location ~ ^(.+\.php)(.*)$ {
    fastcgi_split_path_info       ^(.+\.php)(.*)$;
    fastcgi_param SCRIPT_FILENAME /path/to/php$fastcgi_script_name;
    fastcgi_param PATH_INFO       $fastcgi_path_info;
</pre>

<p>  和“ <code>/show.php/article/0001</code> ”请求， <code>SCRIPT_FILENAME</code>参数将等于“ <code>/path/to/php/show.php</code>参数将等于“ <code>/article/0001</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_store**     &lt;code class=&quot;notranslate&quot;&gt;on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">fastcgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#fastcgi_temp_path">fastcgi_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root                 /data/www;
    error_page           404 = /fetch$uri;
}

location /fetch/ {
    internal;

    fastcgi_pass         backend:9000;
    ...

    fastcgi_store        on;
    fastcgi_store_access user:rw group:rw all:r;
    fastcgi_temp_path    /data/temp;

    alias                /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">fastcgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">fastcgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从FastCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_temp_path**     &lt;code class=&quot;notranslate&quot;&gt;*path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_temp_path fastcgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从FastCGI服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">fastcgi_temp_path /spool/nginx/fastcgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/fastcgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#fastcgi_cache_path">fastcgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
<h4 id="传递给FastCGI服务器的参数"><a href="#传递给FastCGI服务器的参数" class="headerlink" title="传递给FastCGI服务器的参数"></a>传递给FastCGI服务器的参数</h4><p>   HTTP请求标头字段作为参数传递给FastCGI服务器。  在作为FastCGI服务器运行的应用程序和脚本中，这些参数通常可用作环境变量。  例如，“User-Agent”标头字段作为<code>HTTP_USER_AGENT</code>参数传递。  除HTTP请求头字段外，还可以使用<a href="#fastcgi_param">fastcgi_param</a>指令传递任意参数。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_fastcgi_module</code>模块支持可用于使用<a href="#fastcgi_param">fastcgi_param</a>指令设置参数的嵌入变量： </p>
<pre class="notranslate">fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
</pre>

<p>  使用<a href="#fastcgi_split_path_info">fastcgi_split_path_info</a>指令时， <code>$fastcgi_script_name</code>变量等于指令设置的第一个捕获的值。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_f4f_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_f4f_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_f4f_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-f4f-module"><a href="#Module-ngx-http-f4f-module" class="headerlink" title="Module ngx_http_f4f_module"></a>Module ngx_http_f4f_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#f4f">f4f</a> <br>     <a href="#f4f_buffer_size">f4f_buffer_size</a> <br></td>

<p>   <code>ngx_http_f4f_module</code>模块为Adobe HTTP动态流（HDS）提供服务器端支持。 </p>
<p>  该模块以“ <code>/videoSeg1-Frag1</code> ”形式实现HTTP动态流式处理请求的处理 - 使用<code>videoSeg1.f4x</code>索引文件从<code>videoSeg1.f4f</code>文件中提取所需的片段。  该模块是Apache的Adobe f4f模块（HTTP Origin Module）的替代品。 </p>
<p>  需要使用Adobe的f4fpackager进行常规预处理，有关详细信息，请参阅相关文档。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /video/ {
    f4f;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**f4f** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**f4f_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">f4f_buffer_size 512k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取<code>.f4x</code>索引文件的缓冲区的<code>*size*</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_empty_gif_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_empty_gif_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_empty_gif_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-empty-gif-module"><a href="#Module-ngx-http-empty-gif-module" class="headerlink" title="Module ngx_http_empty_gif_module"></a>Module ngx_http_empty_gif_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#empty_gif">empty_gif</a> <br></td>

<p>   <code>ngx_http_empty_gif_module</code>模块发出单像素透明GIF。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location = /_.gif {
    empty_gif;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**empty_gif** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_dav_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_dav_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_dav_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-dav-module"><a href="#Module-ngx-http-dav-module" class="headerlink" title="Module ngx_http_dav_module"></a>Module ngx_http_dav_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#create_full_put_path">create_full_put_path</a> <br>     <a href="#dav_access">dav_access</a> <br>     <a href="#dav_methods">dav_methods</a> <br>     <a href="#min_delete_depth">min_delete_depth</a> <br></td>

<p>   <code>ngx_http_dav_module</code>模块用于通过WebDAV协议进行文件管理自动化。  该模块处理HTTP和WebDAV方法PUT，DELETE，MKCOL，COPY和MOVE。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_dav_module</code>配置参数启用它。 </p>
<blockquote>
<p>  需要其他WebDAV方法才能运行的WebDAV客户端不适用于此模块。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    root                  /data/www;

    client_body_temp_path /data/client_temp;

    dav_methods PUT DELETE MKCOL COPY MOVE;

    create_full_put_path  on;
    dav_access            group:rw  all:r;

    limit_except GET {
        allow 192.168.1.0/32;
        deny  all;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**create_full_put_pathon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">create_full_put_path off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>   WebDAV规范仅允许在现有目录中创建文件。  该指令允许创建所有需要的中间目录。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**dav_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">dav_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">dav_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">dav_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**dav_methods**     &lt;code class=&quot;notranslate&quot;&gt;off</code> | <code>*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">dav_methods off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许指定的HTTP和WebDAV方法。  参数<code>off</code>拒绝此模块处理的所有方法。  支持以下方法： <code>PUT</code> ， <code>DELETE</code> ， <code>MKCOL</code> ， <code>COPY</code>和<code>MOVE</code> 。 </p>
<p>  使用PUT方法上载的文件首先写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="ngx_http_core_module.html#client_body_temp_path">client_body_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  使用PUT方法创建文件时，可以通过在“Date”标题字段中传递修改日期来指定修改日期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**min_delete_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">min_delete_depth 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许DELETE方法删除文件，前提是请求路径中的元素数不小于指定的数。  例如，指令 </p>
<pre class="notranslate">min_delete_depth 4;
</pre>

<p>  允许删除请求中的文件 </p>
<pre class="notranslate">/users/00/00/name
/users/00/00/name/pic.jpg
/users/00/00/page.html
</pre>

<p>  并否认删除 </p>
<pre class="notranslate">/users/00/00
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_core_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_core_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-core-module"><a href="#Module-ngx-http-core-module" class="headerlink" title="Module ngx_http_core_module"></a>Module ngx_http_core_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#absolute_redirect">absolute_redirect</a> <br>     <a href="#aio">aio</a> <br>     <a href="#aio_write">aio_write</a> <br>     <a href="#alias">alias</a> <br>     <a href="#chunked_transfer_encoding">chunked_transfer_encoding</a> <br>     <a href="#client_body_buffer_size">client_body_buffer_size</a> <br>     <a href="#client_body_in_file_only">client_body_in_file_only</a> <br>     <a href="#client_body_in_single_buffer">client_body_in_single_buffer</a> <br>     <a href="#client_body_temp_path">client_body_temp_path</a> <br>     <a href="#client_body_timeout">client_body_timeout</a> <br>     <a href="#client_header_buffer_size">client_header_buffer_size</a> <br>     <a href="#client_header_timeout">client_header_timeout</a> <br>     <a href="#client_max_body_size">client_max_body_size</a> <br>     <a href="#connection_pool_size">connection_pool_size</a> <br>     <a href="#default_type">default_type</a> <br>     <a href="#directio">directio</a> <br>     <a href="#directio_alignment">directio_alignment</a> <br>     <a href="#disable_symlinks">disable_symlinks</a> <br>     <a href="#error_page">error_page</a> <br>     <a href="#etag">etag</a> <br>     <a href="#http">http</a> <br>     <a href="#if_modified_since">if_modified_since</a> <br>     <a href="#ignore_invalid_headers">ignore_invalid_headers</a> <br>     <a href="#internal">internal</a> <br>     <a href="#keepalive_disable">keepalive_disable</a> <br>     <a href="#keepalive_requests">keepalive_requests</a> <br>     <a href="#keepalive_timeout">keepalive_timeout</a> <br>     <a href="#large_client_header_buffers">large_client_header_buffers</a> <br>     <a href="#limit_except">limit_except</a> <br>     <a href="#limit_rate">limit_rate</a> <br>     <a href="#limit_rate_after">limit_rate_after</a> <br>     <a href="#lingering_close">lingering_close</a> <br>     <a href="#lingering_time">lingering_time</a> <br>     <a href="#lingering_timeout">lingering_timeout</a> <br>     <a href="#listen">listen</a> <br>     <a href="#location">location</a> <br>     <a href="#log_not_found">log_not_found</a> <br>     <a href="#log_subrequest">log_subrequest</a> <br>     <a href="#max_ranges">max_ranges</a> <br>     <a href="#merge_slashes">merge_slashes</a> <br>     <a href="#msie_padding">msie_padding</a> <br>     <a href="#msie_refresh">msie_refresh</a> <br>     <a href="#open_file_cache">open_file_cache</a> <br>     <a href="#open_file_cache_errors">open_file_cache_errors</a> <br>     <a href="#open_file_cache_min_uses">open_file_cache_min_uses</a> <br>     <a href="#open_file_cache_valid">open_file_cache_valid</a> <br>     <a href="#output_buffers">output_buffers</a> <br>     <a href="#port_in_redirect">port_in_redirect</a> <br>     <a href="#postpone_output">postpone_output</a> <br>     <a href="#read_ahead">read_ahead</a> <br>     <a href="#recursive_error_pages">recursive_error_pages</a> <br>     <a href="#request_pool_size">request_pool_size</a> <br>     <a href="#reset_timedout_connection">reset_timedout_connection</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#root">root</a> <br>     <a href="#satisfy">satisfy</a> <br>     <a href="#send_lowat">send_lowat</a> <br>     <a href="#send_timeout">send_timeout</a> <br>     <a href="#sendfile">sendfile</a> <br>     <a href="#sendfile_max_chunk">sendfile_max_chunk</a> <br>     <a href="#server">server</a> <br>     <a href="#server_name">server_name</a> <br>     <a href="#server_name_in_redirect">server_name_in_redirect</a> <br>     <a href="#server_names_hash_bucket_size">server_names_hash_bucket_size</a> <br>     <a href="#server_names_hash_max_size">server_names_hash_max_size</a> <br>     <a href="#server_tokens">server_tokens</a> <br>     <a href="#subrequest_output_buffer_size">subrequest_output_buffer_size</a> <br>     <a href="#tcp_nodelay">tcp_nodelay</a> <br>     <a href="#tcp_nopush">tcp_nopush</a> <br>     <a href="#try_files">try_files</a> <br>     <a href="#types">types</a> <br>     <a href="#types_hash_bucket_size">types_hash_bucket_size</a> <br>     <a href="#types_hash_max_size">types_hash_max_size</a> <br>     <a href="#underscores_in_headers">underscores_in_headers</a> <br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a> <br>     <a href="#variables_hash_max_size">variables_hash_max_size</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**absolute_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">absolute_redirect on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  如果禁用，nginx发出的重定向将是相对的。 </p>
<p>  另请参见<a href="#server_name_in_redirect">server_name_in_redirect</a>和<a href="#port_in_redirect">port_in_redirect</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**aio** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>off</code> |<br>    <code>threads</code> [ <code>=</code> <code>*pool*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">aio off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.11版本中。 </p>
<p>  启用或禁用在FreeBSD和Linux上使用异步文件I / O（AIO）： </p>
<pre class="notranslate">location /video/ {
    aio            on;
    output_buffers 1 64k;
}
</pre>



<p>  在FreeBSD上，可以从FreeBSD 4.3开始使用AIO。  在FreeBSD 11.0之前，AIO可以静态链接到内核： </p>
<pre class="notranslate">options VFS_AIO
</pre>

<p>  或作为内核可加载模块动态加载： </p>
<pre class="notranslate">kldload aio
</pre>



<p>  在Linux上，可以从内核版本2.6.22开始使用AIO。  此外，有必要启用<a href="#directio">directio</a> ，否则读取将被阻止： </p>
<pre class="notranslate">location /video/ {
    aio            on;
    directio       512;
    output_buffers 1 128k;
}
</pre>



<p>  在Linux上， <a href="#directio">directio</a>只能用于读取在512字节边界（或XFS为4K）上对齐的块。  在阻塞模式下读取文件的未对齐结束。  对于字节范围请求和不是从文件开头的FLV请求也是如此：在文件开头和结尾读取未对齐数据将被阻塞。 </p>
<p>  当在Linux上启用AIO和<a href="#sendfile">sendfile时</a> ，AIO用于大于或等于<a href="#directio">directio</a>指令中指定大小的文件，而<a href="#sendfile">sendfile</a>用于较小大小的文件或禁用<a href="#directio">directio</a>时。 </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    aio            on;
    directio       8m;
}
</pre>



<p>  最后，可以使用多线程（1.7.11）读取和<a href="#sendfile">发送</a>文件，而不会阻止工作进程： </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    aio            threads;
}
</pre>

<p>  读取和发送文件操作被卸载到指定<a href="ngx_core_module.html#thread_pool">池的</a>线程。  如果省略池名称，则使用名称为“ <code>default</code> ”的池。  池名称也可以使用变量设置： </p>
<pre class="notranslate">aio threads=pool$disk;
</pre>

<p>  默认情况下，禁用多线程，应使用<code>--with-threads</code>配置参数启用它。  目前，多线程仅与<a href="events.html#epoll">epoll</a> ， <a href="events.html#kqueue">kqueue</a>和<a href="events.html#eventport">eventport</a>方法兼容。  只在Linux上支持多线程文件发送。 </p>
<p>  另请参见<a href="#sendfile">sendfile</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**aio_writeon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">aio_write off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.9.13版本中。 </p>
<p>  如果启用了<a href="#aio">aio</a> ，则指定是否用于写入文件。  目前，这仅在使用<code>aio threads</code> ，并且仅限于使用从代理服务器接收的数据编写临时文件。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**alias*path*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  定义指定位置的替换。  例如，使用以下配置 </p>
<pre class="notranslate">location /i/ {
    alias /data/w3/images/;
}
</pre>

<p>  根据“ <code>/i/top.gif</code> ”的请求，将发送文件<code>/data/w3/images/top.gif</code> 。 </p>
<p>   <code>*path*</code>值可以包含变量， <code>$document_root</code>和<code>$realpath_root</code>除外。 </p>
<p>  如果在使用正则表达式定义的位置内使用<code>alias</code>则此类正则表达式应包含捕获，而<code>alias</code>应引用这些捕获（0.7.40），例如： </p>
<pre class="notranslate">location ~ ^/users/(.+\.(?:gif|jpe?g|png))$ {
    alias /data/w3/images/$1;
}
</pre>



<p>  当location匹配指令值的最后一部分时： </p>
<pre class="notranslate">location /images/ {
    alias /data/w3/images/;
}
</pre>

<p>  最好使用<a href="#root">root</a>指令： </p>
<pre class="notranslate">location /images/ {
    root /data/w3;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**chunked_transfer_encodingon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">chunked_transfer_encoding on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  允许在HTTP / 1.1中禁用分块传输编码。  尽管符合标准要求，但在使用软件无法支持分块编码时，它可能会派上用场。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_buffer_size 8k|16k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置读取客户端请求正文的缓冲区大小。  如果请求主体大于缓冲区，则整个主体或仅其部分被写入<a href="#client_body_temp_path">临时文件</a> 。  默认情况下，缓冲区大小等于两个内存页。  这是x86上的8K，其他32位平台和x86-64。  在其他64位平台上通常为16K。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_in_file_only** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>clean</code> |<br>    <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_in_file_only off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  确定nginx是否应将整个客户端请求主体保存到文件中。  该指令可以在调试期间使用，或者在使用<code>$request_body_file</code>变量或模块<a href="ngx_http_perl_module.html">ngx_http_perl_module</a>的<a href="ngx_http_perl_module.html#methods">$ r-&gt; request_body_file</a>方法时使用。 </p>
<p>  设置为打开值<code>on</code> ，请求处理后不会删除临时文件。 </p>
<p>  值<code>clean</code>将导致删除请求处理后留下的临时文件。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_in_single_bufferon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_in_single_buffer off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  确定nginx是否应将整个客户端请求主体保存在单个缓冲区中。  使用<code>$request_body</code>变量时，建议使用该指令，以保存所涉及的复制操作数。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_temp_path** 
    &lt;code class=&quot;notranslate&quot;&gt;*path*</code><br>    [ <code>*level1*</code><br>    [ <code>*level2*</code><br>    [ <code>*level3*</code> ]]]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_temp_path client_body_temp;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义用于存储包含客户端请求主体的临时文件的目录。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">client_body_temp_path /spool/nginx/client_temp 1 2;
</pre>

<p>  临时文件的路径可能如下所示： </p>
<pre class="notranslate">/spool/nginx/client_temp/7/45/00000123457
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义读取客户端请求正文的超时。  超时仅设置为两个连续读取操作之间的时间段，而不是整个请求主体的传输。  如果客户端在此时间内未传输任何内容，请求将以408（请求超时）错误终止。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_header_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_header_buffer_size 1k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  设置缓冲区大小以读取客户端请求标头。  对于大多数请求，1K字节的缓冲区就足够了。  但是，如果请求包含长cookie或来自WAP客户端，则可能不适合1K。  如果请求行或请求头字段不适合此缓冲区，则分配由<a href="#large_client_header_buffers">large_client_header_buffers</a>指令配置的较大缓冲区。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_header_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_header_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  定义读取客户端请求标头的超时。  如果客户端在此时间内未传输整个标头，请求将以408（请求超时）错误终止。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_max_body_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_max_body_size 1m;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置客户端请求正文的最大允许大小，在“Content-Length”请求标头字段中指定。  如果请求中的大小超过配置的值，则会将413（请求实体太大）错误返回给客户端。  请注意，浏览器无法正确显示此错误。  将<code>*size*</code>设置为0将禁用检查客户端请求正文大小。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**connection_pool_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">connection_pool_size 256|512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  允许精确调整每个连接的内存分配。  该指令对性能的影响最小，通常不应使用。  默认情况下，大小在32位平台上等于256字节，在64位平台上等于512字节。 </p>
<blockquote>
<p>  在1.9.8版之前，所有平台上的默认值均为256。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**default_type*mime-type*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">default_type text/plain;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义响应的默认MIME类型。  可以使用<a href="#types">types</a>指令设置文件扩展名到MIME类型的映射。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**directio*size*</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">directio off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.7.7版本中。 </p>
<p>  在读取大于或等于指定<code>*size*</code>文件时，允许使用<code>O_DIRECT</code>标志（FreeBSD，Linux）， <code>F_NOCACHE</code>标志（macOS）或<code>directio()</code>函数（Solaris）。  该指令自动禁用（0.7.15）对给定请求使用<a href="#sendfile">sendfile</a> 。  它对于提供大型文件非常有用： </p>
<pre class="notranslate">directio 4m;
</pre>

<p>  或者在Linux上使用<a href="#aio">aio</a>时。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**directio_alignment*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">directio_alignment 512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.11版本中。 </p>
<p>  设置<a href="#directio">directio</a>的对齐方式。  在大多数情况下，512字节对齐就足够了。  但是，在Linux下使用XFS时，需要将其增加到4K。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**disable_symlinksoff</code> ; <br> <code>**disable_symlinks** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>if_not_owner</code><br>    [ <code>from</code> = <code>*part*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">disable_symlinks off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.15版中。 </p>
<p>  确定打开文件时应如何处理符号链接： </p>
<p>  例： </p>
<pre class="notranslate">disable_symlinks on from=$document_root;
</pre>



<p>  该指令仅适用于具有<code>openat()</code>和<code>fstatat()</code>接口的系统。  这些系统包括FreeBSD，Linux和Solaris的现代版本。 </p>
<p>  参数<code>on</code>和<code>if_not_owner</code>添加了处理开销。 </p>
<blockquote>
<p>  在不支持仅为搜索打开目录的系统上，要使用这些参数，需要工作进程对所有正在检查的目录具有读取权限。 </p>
<p>   <a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a> ， <a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>和<a href="ngx_http_dav_module.html">ngx_http_dav_module</a>模块当前忽略此指令。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**error_page** 
    &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …<br>    [ <code>=</code> [ <code>*response*</code> ]]<br>    <code>*uri*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  定义将为指定错误显示的URI。   <code>*uri*</code>值可以包含变量。 </p>
<p>  例： </p>
<pre class="notranslate">error_page 404             /404.html;
error_page 500 502 503 504 /50x.html;
</pre>



<p>  这导致内部重定向到指定的<code>*uri*</code> ，客户端请求方法更改为“ <code>GET</code> ”（对于“ <code>GET</code> ”和“ <code>HEAD</code> ”以外的所有方法）。 </p>
<p>  此外，可以使用“ <code>=</code> <code>*response*</code> ”语法将响应代码更改为另一个，例如： </p>
<pre class="notranslate">error_page 404 =200 /empty.gif;
</pre>



<p>  如果代理服务器或FastCGI / uwsgi / SCGI / gRPC服务器处理错误响应，并且服务器可能返回不同的响应代码（例如，200,302,401或404），则可以使用代码进行响应收益： </p>
<pre class="notranslate">error_page 404 = /404.php;
</pre>



<p>  如果在内部重定向期间无需更改URI和方法，则可以将错误处理传递到命名位置： </p>
<pre class="notranslate">location / {
    error_page 404 = @fallback;
}

location @fallback {
    proxy_pass http://backend;
}
</pre>





<blockquote>
<p>  如果<code>*uri*</code>处理导致错误，则将上次发生的错误的状态代码返回给客户端。 </p>
</blockquote>
<p>  也可以使用URL重定向进行错误处理： </p>
<pre class="notranslate">error_page 403      http://example.com/forbidden.html;
error_page 404 =301 http://example.com/notfound.html;
</pre>

<p>  在这种情况下，默认情况下，响应代码302返回给客户端。  它只能更改为重定向状态代码之一（301,302,303,307和308）。 </p>
<blockquote>
<p>  在版本1.1.16和1.0.13之前，代码307不被视为重定向。 </p>
<p>  在版本1.13.0之前，代码308不被视为重定向。 </p>
</blockquote>
<p>  当且仅当在当前级别上没有定义<code>error_page</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**etagon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">etag on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.3.3版本中。 </p>
<p>  启用或禁用自动生成静态资源的“ETag”响应头字段。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**http** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>main</code> <br><br>                </td></p>
<p>  提供指定HTTP服务器指令的配置文件上下文。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**if_modified_since** 
    &lt;code class=&quot;notranslate&quot;&gt;off</code> |<br>    <code>exact</code> |<br>    <code>before</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">if_modified_since exact;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.7.24版本中。 </p>
<p>  指定如何将响应的修改时间与“If-Modified-Since”请求标头字段中的时间进行比较： </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**ignore_invalid_headerson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">ignore_invalid_headers on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  控制是否应忽略具有无效名称的标头字段。  有效名称由英文字母，数字，连字符和可能的下划线组成（由<a href="#underscores_in_headers">underscores_in_headers</a>指令控制）。 </p>
<p>  如果在<a href="#server">服务器</a>级别指定了该指令，则仅在服务器是默认服务器时使用其值。  指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**internal** ;</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  指定给定位置只能用于内部请求。  对于外部请求，返回客户端错误404（未找到）。  内部请求如下： </p>
<ul>
<li>由<a href="#error_page">error_page</a> ， <a href="ngx_http_index_module.html#index">index</a> ， <a href="ngx_http_random_index_module.html#random_index">random_index</a>和<a href="#try_files">try_files</a>指令重定向的请求; -   来自上游服务器的“X-Accel-Redirect”响应头字段重定向的请求; -   由<a href="ngx_http_ssi_module.html">ngx_http_ssi_module</a>模块的“ <code>include virtual</code> ”命令， <a href="ngx_http_addition_module.html">ngx_http_addition_module</a>模块指令以及<a href="ngx_http_auth_request_module.html#auth_request">auth_request</a>和<a href="ngx_http_mirror_module.html#mirror">mirror</a>指令形成的子请求; -   请求由<a href="ngx_http_rewrite_module.html#rewrite">重写</a>指令更改。 </li>
</ul>
<p>  例： </p>
<pre class="notranslate">error_page 404 /404.html;

location = /404.html {
    internal;
}
</pre>



<blockquote>
<p>  每个请求最多有10个内部重定向，以防止在错误配置中发生的请求处理周期。  如果达到此限制，则返回错误500（内部服务器错误）。  在这种情况下，可以在错误日志中看到“重写或内部重定向周期”消息。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_disablenone</code> | <code>*browser*</code> …; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_disable msie6;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  禁用与行为不当的浏览器保持连接状态。   <code>*browser*</code>参数指定将受影响的浏览器。  一旦收到POST请求，值<code>msie6</code>将禁用与旧版本MSIE的保持活动连接。  值<code>safari</code>禁用与macOS和类似macOS的操作系统上的Safari和类似Safari的浏览器的保持活动连接。  值<code>none</code>与所有浏览器保持连接。 </p>
<blockquote>
<p>  在版本1.1.18之前，值<code>safari</code>与所有操作系统上的所有Safari和类似Safari的浏览器相匹配，默认情况下禁用与它们保持连接的连接。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_requests*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_requests 100;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.0版本中。 </p>
<p>  设置可通过一个保持活动连接提供的最大请求数。  在发出最大请求数后，将关闭连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_timeout** 
    &lt;code class=&quot;notranslate&quot;&gt;*timeout*</code><br>    [ <code>*header_timeout*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_timeout 75s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  第一个参数设置一个超时，在此期间保持活动的客户端连接将在服务器端保持打开状态。  零值禁用保持活动的客户端连接。  可选的第二个参数在“Keep-Alive：timeout = <code>*time*</code> ”响应头字段中设置一个值。  两个参数可能不同。 </p>
<p>   Mozilla和Konqueror识别“Keep-Alive：timeout = <code>*time*</code> ”标题字段。   MSIE在大约60秒内自行关闭保持连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**large_client_header_buffers*number*</code> <code>*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">large_client_header_buffers 4 8k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  设置用于读取大客户机请求标头的缓冲区的最大<code>*number*</code>和<code>*size*</code> 。  请求行不能超过一个缓冲区的大小，否则会将414（Request-URI Too Large）错误返回给客户端。  请求头字段也不能超过一个缓冲区的大小，或者400（错误请求）错误返回给客户端。  缓冲区仅按需分配。  默认情况下，缓冲区大小等于8K字节。  如果在请求处理结束后连接转换为保持活动状态，则释放这些缓冲区。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_except*method*</code> … { … } <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  限制允许位置内的HTTP方法。   <code>*method*</code>参数可以是以下之一： <code>GET</code> ， <code>HEAD</code> ， <code>POST</code> ， <code>PUT</code> ， <code>DELETE</code> ， <code>MKCOL</code> ， <code>COPY</code> ， <code>MOVE</code> ， <code>OPTIONS</code> ， <code>PROPFIND</code> ， <code>PROPPATCH</code> ， <code>LOCK</code> ， <code>UNLOCK</code>或<code>PATCH</code> 。  允许<code>GET</code>方法也允许使用<code>HEAD</code>方法。  使用<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> （1.13.10）模块指令可以限制对其他方法的访问： </p>
<pre class="notranslate">limit_except GET {
    allow 192.168.1.0/32;
    deny  all;
}
</pre>

<p>  请注意，这将限制对<strong>除</strong> GET和HEAD <strong>之外的</strong>所有方法的访问。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_rate*rate*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">limit_rate 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  限制向客户端传输的响应速率。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<p>  也可以在<code>$limit_rate</code>变量中设置速率限制。  在根据特定条件限制费率的情况下，它可能很有用： </p>
<pre class="notranslate">server {

    if ($slow) {
        set $limit_rate 4k;
    }

    ...
}
</pre>



<p>  还可以在代理服务器响应的“X-Accel-Limit-Rate”头字段中设置速率限制。  可以使用<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a>和<a href="ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_rate_after*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">limit_rate_after 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.0版本中。 </p>
<p>  设置初始量，在此之后，对客户端的响应的进一步传输将受到速率限制。 </p>
<p>  例： </p>
<pre class="notranslate">location /flv/ {
    flv;
    limit_rate_after 500k;
    limit_rate       50k;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_close** 
    &lt;code class=&quot;notranslate&quot;&gt;off</code> |<br>    <code>on</code> |<br>    <code>always</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_close on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  控制nginx如何关闭客户端连接。 </p>
<p>  默认值“ <code>on</code> ”指示nginx在完全关闭连接之前<a href="#lingering_timeout">等待</a>并<a href="#lingering_time">处理</a>来自客户端的其他数据，但仅当启发式表明客户端可能正在发送更多数据时。 </p>
<p>  值“ <code>always</code> ”将导致nginx无条件地等待并处理其他客户端数据。 </p>
<p>  值“ <code>off</code> ”告诉nginx永远不要等待更多数据并立即关闭连接。  此行为会破坏协议，不应在正常情况下使用。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_time*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_time 30s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  当<a href="#lingering_close">lingering_close</a>生效时，此指令指定nginx处理（读取和忽略）来自客户端的其他数据的最长时间。  之后，即使有更多数据，连接也将关闭。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_timeout 5s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  当<a href="#lingering_close">lingering_close</a>生效时，此指令指定更多客户端数据到达的最长等待时间。  如果在此期间未收到数据，则关闭连接。  否则，将读取并忽略数据，并且nginx会再次开始等待更多数据。  重复“wait-read-ignore”循环，但不会超过<a href="#lingering_time">lingering_time</a>指令指定的循环。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;*address*</code> [: <code>*port*</code> ]<br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>setfib</code> = <code>*number*</code> ]<br>    [ <code>fastopen</code> = <code>*number*</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]<br>    [ <code>reuseport</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br> <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;*port*</code><br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>setfib</code> = <code>*number*</code> ]<br>    [ <code>fastopen</code> = <code>*number*</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]<br>    [ <code>reuseport</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br> <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;unix:</code> <code>*path*</code><br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">listen <em>:80 | </em>:8000;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  设置IP的<code>*address*</code>和<code>*port*</code> ，或服务器将接受请求的UNIX域套接字的<code>*path*</code> 。  可以指定<code>*address*</code>和<code>*port*</code> ，或仅指定<code>*address*</code>或仅<code>*port*</code> 。   <code>*address*</code>也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:8000;
listen 127.0.0.1;
listen 8000;
listen *:8000;
listen localhost:8000;
</pre>

<p>   IPv6地址（0.7.36）在方括号中指定： </p>
<pre class="notranslate">listen [::]:8000;
listen [::1];
</pre>

<p>   UNIX域套接字（0.8.21）使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>  如果仅给出<code>*address*</code> ，则使用端口80。 </p>
<p>  如果指令不存在，那么如果nginx以超级用户权限运行，则使用<code>*:80</code> ，否则使用<code>*:8000</code> 。 </p>
<p>   <code>default_server</code>参数（如果存在）将使服务器成为指定<code>*address*</code> ： <code>*port*</code>对的默认服务器。  如果没有任何指令具有<code>default_server</code>参数，则具有<code>*address*</code> ： <code>*port*</code>对的第一个服务器将成为该对的默认服务器。 </p>
<blockquote>
<p>  在0.8.21之前的版本中，此参数仅命名为<code>default</code> 。 </p>
</blockquote>
<p>   <code>ssl</code>参数（0.7.14）允许指定此端口上接受的所有连接都应在SSL模式下工作。  这样可以为处理HTTP和HTTPS请求的服务器提供更紧凑的<a href="configuring_https_servers.html#single_http_https_server">配置</a> 。 </p>
<p>   <code>http2</code>参数（1.9.5）将端口配置为接受<a href="ngx_http_v2_module.html">HTTP / 2</a>连接。  通常，为了使其工作，也应该指定<code>ssl</code>参数，但是也可以将nginx配置为接受没有SSL的HTTP / 2连接。 </p>
<p>   <code>spdy</code>参数（1.3.15-1.9.4）允许接受此端口上的<a href="ngx_http_spdy_module.html">SPDY</a>连接。  通常，为了使其工作，还应指定<code>ssl</code>参数，但也可以将nginx配置为接受不带SSL的SPDY连接。 </p>
<p>   <code>proxy_protocol</code>参数（1.5.12）允许指定此端口上接受的所有连接都应使用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a> 。 </p>
<blockquote>
<p>  自版本1.13.11起支持PROXY协议版本2。 </p>
</blockquote>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。  这些参数可以在任何<code>listen</code>指令中指定，但对于给定的<code>*address*</code>只能指定一次： <code>*port*</code>对。 </p>
<blockquote>
<p>  在0.8.21之前的版本中，它们只能在<code>listen</code>指令中与<code>default</code>参数一起指定。 </p>
<p>  除非服务器可以处理多次<a href="https://tools.ietf.org/html/rfc7413#section-6.1" target="_blank" rel="noopener">使用数据</a>的<a href="https://tools.ietf.org/html/rfc7413#section-6.1" target="_blank" rel="noopener">同一SYN数据包，</a>否则不要启用此功能。 </p>
<p>  在1.3.4版之前，如果省略此参数，则操作系统的设置对套接字有效。 </p>
<p>  不恰当地使用此选项可能会产生安全<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">隐患</a> 。 </p>
</blockquote>
<pre class="notranslate">so_keepalive=30m::10</pre>



<p>  例： </p>
<pre class="notranslate">listen 127.0.0.1 default_server accept_filter=dataready backlog=1024;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**location** [
    &lt;code class=&quot;notranslate&quot;&gt;=</code> |<br>    <code>~</code> |<br>    <code>~*</code> |<br>    <code>^~</code><br>    ] <code>*uri*</code> { … } <br> <code>**location@</code> <code>*name*</code> { … } <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  根据请求URI设置配置。 </p>
<p>  在解码以“ <code>%XX</code> ”形式编码的文本，解析对相对路径分量的引用之后，针对规范化的URI执行匹配<code>.</code>   “和” <code>..</code> “，并且可能<a href="#merge_slashes">将</a>两个或多个相邻斜线<a href="#merge_slashes">压缩</a>成单个斜线。 </p>
<p>  位置可以由前缀字符串或正则表达式定义。  正则表达式使用前面的“ <code>~*</code> ”修饰符（用于不区分大小写的匹配）或“ <code>~</code> ”修饰符（用于区分大小写的匹配）指定。  为了找到与给定请求匹配的位置，nginx首先检查使用前缀字符串（前缀位置）定义的位置。  其中，选择并记住具有最长匹配前缀的位置。  然后按照它们在配置文件中的出现顺序检查正则表达式。  正则表达式的搜索在第一个匹配时终止，并使用相应的配置。  如果未找到与正则表达式的匹配，则使用先前记住的前缀位置的配置。 </p>
<p>  可以嵌套<code>location</code>块，但下面提到了一些例外情况。 </p>
<p>  对于不区分大小写的操作系统（如macOS和Cygwin），与前缀字符串匹配会忽略大小写（0.7.7）。  但是，比较仅限于一个字节的区域设置。 </p>
<p>  正则表达式可以包含稍后可以在其他指令中使用的捕获（0.7.40）。 </p>
<p>  如果最长匹配前缀位置具有“ <code>^~</code> ”修饰符，则不检查正则表达式。 </p>
<p>  此外，使用“ <code>=</code> ”修饰符可以定义URI和位置的精确匹配。  如果找到完全匹配，则搜索终止。  例如，如果频繁发生“ <code>/</code> ”请求，则定义“ <code>location = /</code> ”将加速这些请求的处理，因为搜索在第一次比较之后立即终止。  这样的位置显然不能包含嵌套位置。 </p>
<blockquote>
<p>  在0.7.1到0.8.41的版本中，如果请求与前缀位置匹配而没有“ <code>=</code> ”和“ <code>^~</code> ”修饰符，则搜索也会终止，并且不会检查正则表达式。 </p>
</blockquote>
<p>  让我们通过一个例子来说明以上内容： </p>
<pre class="notranslate">location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
</pre>

<p>   “ <code>/</code> ”请求将匹配配置A，“/ <code>/index.html</code> ”请求将匹配配置B，“/ <code>/documents/document.html</code> ”请求将匹配配置C，“/ <code>/images/1.gif</code> ”请求将匹配配置D，“/ <code>/documents/1.jpg</code> ”请求将匹配配置E. </p>
<p>   “ <code>@</code> ”前缀定义了命名位置。  这样的位置不用于常规请求处理，而是用于请求重定向。  它们不能嵌套，也不能包含嵌套位置。 </p>
<p>  如果位置由以斜杠字符结尾的前缀字符串定义，并且请求由<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>或<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass之一</a>处理，则执行特殊处理。  为了响应URI等于此字符串但没有尾部斜杠的请求，带有代码301的永久重定向将返回到请求的URI，并附加斜杠。  如果不需要，可以像下面这样定义URI和位置的完全匹配： </p>
<pre class="notranslate">location /user/ {
    proxy_pass http://user.example.com;
}

location = /user {
    proxy_pass http://login.example.com;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**log_not_foundon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">log_not_found on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用将未找到的文件的错误记录到<a href="ngx_core_module.html#error_log">error_log中</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**log_subrequeston</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">log_subrequest off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用将子请求记录到<a href="ngx_http_log_module.html#access_log">access_log中</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**max_ranges*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.2版中。 </p>
<p>  限制字节范围请求中允许的最大范围数。  超出限制的请求将被处理，就像没有指定字节范围一样。  默认情况下，范围数量不受限制。  零值完全禁用字节范围支持。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**merge_slasheson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">merge_slashes on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  启用或禁用将URI中的两个或多个相邻斜杠压缩为单个斜杠。 </p>
<p>  请注意，压缩对于正确匹配前缀字符串和正则表达式位置至关重要。  没有它，“ <code>//scripts/one.php</code> ”请求将不匹配 </p>
<pre class="notranslate">location /scripts/ {
    ...
}
</pre>

<p>  并且可能被处理为静态文件。  所以它被转换为“ <code>/scripts/one.php</code> ”。 </p>
<p>  如果URI包含base64编码的名称，则必须<code>off</code>压缩，因为base64在内部使用“ <code>/</code> ”字符。  但是，出于安全考虑，最好避免关闭压缩。 </p>
<p>  如果在<a href="#server">服务器</a>级别指定了该指令，则仅在服务器是默认服务器时使用其值。  指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**msie_paddingon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">msie_padding on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用向状态大于400的MSIE客户端的响应添加注释，以将响应大小增加到512字节。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**msie_refreshon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">msie_refresh off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用发布刷新而不是MSIE客户端的重定向。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cacheoff</code> ; <br> <code>**open_file_cache** 
&lt;code class=&quot;notranslate&quot;&gt;max</code> = <code>*N*</code><br>[ <code>inactive</code> = <code>*time*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  配置可以存储的缓存： </p>
<ul>
<li>打开文件描述符，它们的大小和修改时间; -   关于目录存在的信息; -   文件查找错误，例如“找不到文件”，“没有读取权限”等。 <blockquote class="note">  应该通过<a href="#open_file_cache_errors">open_file_cache_errors</a>指令单独启用缓存错误。 </blockquote></li>
</ul>
<p>  该指令具有以下参数： </p>
<p>  例： </p>
<pre class="notranslate">open_file_cache          max=1000 inactive=20s;
open_file_cache_valid    30s;
open_file_cache_min_uses 2;
open_file_cache_errors   on;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_errorson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_errors off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  通过<a href="#open_file_cache">open_file_cache</a>启用或禁用文件查找错误的缓存。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_min_uses*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_min_uses 1;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置在<a href="#open_file_cache">open_file_cache</a>指令的<code>inactive</code>参数配置的时间段内文件访问的最小<code>*number*</code> ，这是文件描述符在缓存中保持打开所必需的。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_valid*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_valid 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置应验证<a href="#open_file_cache">open_file_cache</a>元素的时间。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**output_buffers*number*</code> <code>*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">output_buffers 2 32k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置用于从磁盘读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。 </p>
<blockquote>
<p>  在1.9.5版之前，默认值为1 32k。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**port_in_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">port_in_redirect on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用在nginx发出的<a href="#absolute_redirect">绝对</a>重定向中指定端口。 </p>
<p>  在重定向中使用主服务器名称由<a href="#server_name_in_redirect">server_name_in_redirect</a>指令控制。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**postpone_output*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">postpone_output 1460;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果可能，客户端数据的传输将被推迟，直到nginx至少要发送<code>*size*</code>字节的数据。  零值禁用推迟数据传输。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**read_ahead*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">read_ahead 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置使用文件时内核的预读取量。 </p>
<p>  在Linux上，使用<code>posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)</code>系统调用，因此忽略<code>*size*</code>参数。 </p>
<p>  在FreeBSD上，使用了自FreeBSD 9.0-CURRENT以来支持的<code>fcntl(O_READAHEAD,</code> <code>*size*</code> <code>)</code>系统调用。   FreeBSD 7必须<a href="http://sysoev.ru/freebsd/patch.readahead.txt" target="_blank" rel="noopener">打补丁</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**recursive_error_pageson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">recursive_error_pages off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  使用<a href="#error_page">error_page</a>指令启用或禁用多个重定向。  此类重定向的数量<a href="#internal">有限</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**request_pool_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">request_pool_size 4k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  允许精确调整每个请求的内存分配。  该指令对性能的影响最小，通常不应使用。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**reset_timedout_connectionon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">reset_timedout_connection off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用重置超时连接。  重置如下进行。  在关闭套接字之前，在其上设置<code>SO_LINGER</code>选项，超时值为0.当套接字关闭时，TCP RST将发送到客户端，并释放此套接字占用的所有内存。  这有助于避免将已填充缓冲区的已关闭套接字保持在FIN_WAIT1状态很长时间。 </p>
<p>  应该注意，超时保持连接正常关闭。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**resolver** 
    &lt;code class=&quot;notranslate&quot;&gt;*address*</code> …<br>    [ <code>valid</code> = <code>*time*</code> ]<br>    [ <code>ipv6</code> = <code>on</code> | <code>off</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<blockquote>
<p>  在1.1.7版之前，只能配置一个名称服务器。  从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。 </p>
</blockquote>
<p>  默认情况下，nginx将在解析时查找IPv4和IPv6地址。  如果不需要查找IPv6地址，可以指定<code>ipv6=off</code>参数。 </p>
<blockquote>
<p>  从版本1.5.8开始支持将名称解析为IPv6地址。 </p>
</blockquote>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。 </p>
<p>  为防止DNS欺骗，建议在正确安全的受信任本地网络中配置DNS服务器。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**resolver_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">resolver_timeout 30s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置名称解析的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**root*path*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">root html;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  设置请求的根目录。  例如，使用以下配置 </p>
<pre class="notranslate">location /i/ {
    root /data/w3;
}
</pre>

<p>  将发送<code>/data/w3/i/top.gif</code>文件以响应“ <code>/i/top.gif</code> ”请求。 </p>
<p>   <code>*path*</code>值可以包含变量， <code>$document_root</code>和<code>$realpath_root</code>除外。 </p>
<p>  仅通过向<code>root</code>指令的值添加URI来构造文件的路径。  如果必须修改URI，则应使用<a href="#alias">别名</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**satisfyall</code> | <code>any</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">satisfy all;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果所有（ <code>all</code> ）或至少一个（ <code>any</code> ） <a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> ， <a href="ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>或<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a>模块允许访问，则允许访问。 </p>
<p>  例： </p>
<pre class="notranslate">location / {
    satisfy any;

    allow 192.168.1.0/32;
    deny  all;

    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**send_lowat*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">send_lowat 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果指令设置为非零值，nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或<code>SO_SNDLOWAT</code>套接字选项来最小化客户端套接字上的发送操作数。  在这两种情况下都使用指定的<code>*size*</code> 。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**send_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">send_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置将响应传输到客户端的超时。  仅在两次连续写操作之间设置超时，而不是整个响应的传输。  如果客户端在此时间内未收到任何内容，则会关闭连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**sendfileon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">sendfile off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  启用或禁用<code>sendfile()</code>的使用。 </p>
<p>  从nginx 0.8.12和FreeBSD 5.2.1开始， <a href="#aio">aio</a>可用于预加载<code>sendfile()</code>数据： </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    tcp_nopush     on;
    aio            on;
}
</pre>

<p>  在此配置中，使用<code>SF_NODISKIO</code>标志调用<code>sendfile()</code> ，这会导致它不阻塞磁盘I / O，而是报告数据不在内存中。  然后，nginx通过读取一个字节来启动异步数据加载。  在第一次读取时，FreeBSD内核将文件的前128K字节加载到内存中，尽管下一次读取只会以16K块的形式加载数据。  可以使用<a href="#read_ahead">read_ahead</a>指令更改此<a href="#read_ahead">设置</a> 。 </p>
<blockquote>
<p>  在1.7.11版之前，可以使用<code>aio sendfile;</code>启用预加载<code>aio sendfile;</code>   。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**sendfile_max_chunk*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">sendfile_max_chunk 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置为非零值时，限制可在单个<code>sendfile()</code>调用中传输的数据量。  没有限制，一个快速连接可能完全占用工作进程。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置虚拟服务器的配置。  基于IP（基于IP地址）和基于名称（基于“主机”请求标头字段）的虚拟服务器之间没有明确的区别。  相反， <a href="#listen">listen</a>指令描述了应该接受服务器连接的所有地址和端口， <a href="#server_name">server_name</a>指令列出了所有服务器名称。   “ <a href="request_processing.html">如何nginx处理请求</a> ”文档中提供了示例配置。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_name*name*</code> …; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_name “”;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  设置虚拟服务器的名称，例如： </p>
<pre class="notranslate">server {
    server_name example.com www.example.com;
}
</pre>



<p>  第一个名称成为主服务器名称。 </p>
<p>  服务器名称可以包含替换名称的第一个或最后一个部分的星号（“ <code>*</code> ”）： </p>
<pre class="notranslate">server {
    server_name example.com *.example.com www.example.*;
}
</pre>

<p>  这些名称称为通配符名称。 </p>
<p>  上面提到的前两个名称可以合二为一： </p>
<pre class="notranslate">server {
    server_name .example.com;
}
</pre>



<p>  也可以在服务器名称中使用正则表达式，在名称前面加上波浪号（“ <code>~</code> ”）： </p>
<pre class="notranslate">server {
    server_name www.example.com ~^www\d+\.example\.com$;
}
</pre>



<p>  正则表达式可以包含以后可以在其他指令中使用的捕获（0.7.40）： </p>
<pre class="notranslate">server {
    server_name ~^(www\.)?(.+)$;

    location / {
        root /sites/$2;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre>



<p>  正则表达式中的命名捕获创建变量（0.8.25），以后可以在其他指令中使用它们： </p>
<pre class="notranslate">server {
    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;

    location / {
        root /sites/$domain;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre>



<p>  如果指令的参数设置为“ <code>$hostname</code> ”（0.9.4），则插入机器的主机名。 </p>
<p>  也可以指定一个空的服务器名称（0.7.11）： </p>
<pre class="notranslate">server {
    server_name www.example.com "";
}
</pre>

<p>  它允许此服务器处理请求而不使用“Host”头字段 - 而不是默认服务器 - 用于给定地址：端口对。  这是默认设置。 </p>
<blockquote>
<p>  在0.8.48之前，默认使用机器的主机名。 </p>
</blockquote>
<p>  在按名称搜索虚拟服务器期间，如果名称与多个指定的变体匹配（例如，通配符名称和正则表达式匹配），将按以下优先级顺序选择第一个匹配的变体： </p>
<ol>
<li>确切的名字 1.   以星号开头的最长通配符名称，例如“ <code>*.example.com</code> ” 1.   最长的通配符名称以星号结尾，例如“ <code>mail.*</code> ” 1.   第一个匹配的正则表达式（按配置文件中的出现顺序） </li>
</ol>
<p>  服务器名称的详细描述在单独的<a href="server_names.html">服务器名称</a>文档中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_name_in_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_name_in_redirect off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  在nginx发出的<a href="#absolute_redirect">绝对</a>重定向中启用或禁用<a href="#server_name">server_name</a>指令指定的主服务器名称。  禁用主服务器名称时，将使用“主机”请求标头字段中的名称。  如果此字段不存在，则使用服务器的IP地址。 </p>
<p>  在重定向中使用端口由<a href="#port_in_redirect">port_in_redirect</a>指令控制。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_names_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_names_hash_bucket_size 32|64|128;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置服务器名称哈希表的存储桶大小。  默认值取决于处理器缓存行的大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_names_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_names_hash_max_size 512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置服务器名称哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_tokens** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>off</code> |<br>    <code>build</code> |<br>    <code>*string*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_tokens on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用在错误页面和“服务器”响应头字段中发出nginx版本。 </p>
<p>   <code>build</code>参数（1.11.10）允许发出<a href="configure.html#build">构建名称</a>和nginx版本。 </p>
<p>  此外，作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，从版本1.9.13开始，错误页面上的签名和“服务器”响应头字段值可以使用带变量的<code>*string*</code>显式设置。  空字符串禁用“服务器”字段的发射。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**subrequest_output_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">subrequest_output_buffer_size 4k|8k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.13.10版本中。 </p>
<p> Sets the <code>*size*</code> of the buffer used for storing the response body of a subrequest.  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p> The directive is applicable only for subrequests with response bodies saved into memory. For example, such subrequests are created by <a href="ngx_http_ssi_module.html#ssi_include_set">SSI</a> . </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**tcp_nodelayon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">tcp_nodelay on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用<code>TCP_NODELAY</code>选项的使用。 The option is enabled when a connection is transitioned into the keep-alive state. Additionally, it is enabled on SSL connections, for unbuffered proxying, and for <a href="websocket.html">WebSocket</a> proxying. </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**tcp_nopushon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">tcp_nopush off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Enables or disables the use of the <code>TCP_NOPUSH</code> socket option on FreeBSD or the <code>TCP_CORK</code> socket option on Linux. The options are enabled only when <a href="#sendfile">sendfile</a> is used. Enabling the option allows </p>
<ul>
<li>sending the response header and the beginning of a file in one packet, on Linux and FreeBSD 4.*; -  sending a file in full packets. </li>
</ul>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**try_files*file*</code> … <code>*uri*</code> ; <br> <code>**try_files*file*</code> … = <code>*code*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the <code>*file*</code> parameter according to the <a href="#root">root</a> and <a href="#alias">alias</a> directives. It is possible to check directory’s existence by specifying a slash at the end of a name, eg “ <code>$uri/</code> ”. If none of the files were found, an internal redirect to the <code>*uri*</code> specified in the last parameter is made.  例如： </p>
<pre class="notranslate">location /images/ {
    try_files $uri /images/default.gif;
}

location = /images/default.gif {
    expires 30s;
}
</pre>

<p> The last parameter can also point to a named location, as shown in examples below. Starting from version 0.7.51, the last parameter can also be a <code>*code*</code> : </p>
<pre class="notranslate">location / {
    try_files $uri $uri/index.html $uri.html =404;
}
</pre>



<p> Example in proxying Mongrel: </p>
<pre class="notranslate">location / {
    try_files /system/maintenance.html
              $uri $uri/index.html $uri.html
              @mongrel;
}

location @mongrel {
    proxy_pass http://mongrel;
}
</pre>



<p> Example for Drupal/FastCGI: </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @drupal;
}

location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
    fastcgi_param QUERY_STRING    $args;

    ... other fastcgi_param's
}

location @drupal {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    fastcgi_param SCRIPT_NAME     /index.php;
    fastcgi_param QUERY_STRING    q=$uri&amp;$args;

    ... other fastcgi_param's
}
</pre>

<p> In the following example, </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @drupal;
}
</pre>

<p> the <code>try_files</code> directive is equivalent to </p>
<pre class="notranslate">location / {
    error_page 404 = @drupal;
    log_not_found off;
}
</pre>

<p> And here, </p>
<pre class="notranslate">location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

    ...
}
</pre>

<p> <code>try_files</code> checks the existence of the PHP file before passing the request to the FastCGI server. </p>
<p> Example for Wordpress and Joomla: </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @wordpress;
}

location ~ \.php$ {
    try_files $uri @wordpress;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    ... other fastcgi_param's
}

location @wordpress {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    ... other fastcgi_param's
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types {<br>    text/html  html;<br>    image/gif  gif;<br>    image/jpeg jpg;<br>}</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Maps file name extensions to MIME types of responses. Extensions are case-insensitive. Several extensions can be mapped to one type, for example: </p>
<pre class="notranslate">types {
    application/octet-stream bin exe dll;
    application/octet-stream deb;
    application/octet-stream dmg;
}
</pre>



<p> A sufficiently full mapping table is distributed with nginx in the <code>conf/mime.types</code> file. </p>
<p> To make a particular location emit the “ <code>application/octet-stream</code> ” MIME type for all requests, the following configuration can be used: </p>
<pre class="notranslate">location /download/ {
    types        { }
    default_type application/octet-stream;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types_hash_bucket_size 64;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Sets the bucket size for the types hash tables.  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<blockquote>
<p> Prior to version 1.5.13, the default value depended on the size of the processor’s cache line. </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types_hash_max_size 1024;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Sets the maximum <code>*size*</code> of the types hash tables.  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**underscores_in_headerson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">underscores_in_headers off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p> Enables or disables the use of underscores in client request header fields. When the use of underscores is disabled, request header fields whose names contain underscores are marked as invalid and become subject to the <a href="#ignore_invalid_headers">ignore_invalid_headers</a> directive. </p>
<p> If the directive is specified on the <a href="#server">server</a> level, its value is only used if a server is a default one. The value specified also applies to all virtual servers listening on the same address and port. </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**variables_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">variables_hash_bucket_size 64;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置变量哈希表的桶大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**variables_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">variables_hash_max_size 1024;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<blockquote>
<p> Prior to version 1.5.13, the default value was 512. </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> The <code>ngx_http_core_module</code> module supports embedded variables with names matching the Apache Server variables. First of all, these are variables representing client request header fields, such as <code>$http_user_agent</code> , <code>$http_cookie</code> , and so on. Also there are other variables: </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p> The variable’s value is made available in locations processed by the <a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> , <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> , <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> , and <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> directives when the request body was read to a <a href="#client_body_buffer_size">memory buffer</a> . </p>
<p> At the end of processing, the file needs to be removed. To always write the request body to a file, <a href="#client_body_in_file_only">client_body_in_file_only</a> needs to be enabled. When the name of a temporary file is passed in a proxied request or in a request to a FastCGI/uwsgi/SCGI server, passing the request body should be disabled by the <a href="ngx_http_proxy_module.html#proxy_pass_request_body">proxy_pass_request_body off</a> , <a href="ngx_http_fastcgi_module.html#fastcgi_pass_request_body">fastcgi_pass_request_body off</a> , <a href="ngx_http_uwsgi_module.html#uwsgi_pass_request_body">uwsgi_pass_request_body off</a> , or <a href="ngx_http_scgi_module.html#scgi_pass_request_body">scgi_pass_request_body off</a> directives, respectively. </p>
<p>  计算此变量的值通常需要一次系统调用。  为避免系统调用， <a href="#listen">listen</a>指令必须指定地址并使用<code>bind</code>参数。 </p>
<p> The value of <code>$uri</code> may change during request processing, eg when doing internal redirects, or when using index files. </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_charset_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_charset_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_charset_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-charset-module"><a href="#Module-ngx-http-charset-module" class="headerlink" title="Module ngx_http_charset_module"></a>Module ngx_http_charset_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#charset">charset</a> <br>     <a href="#charset_map">charset_map</a> <br>     <a href="#charset_types">charset_types</a> <br>     <a href="#override_charset">override_charset</a> <br>     <a href="#source_charset">source_charset</a> <br></td>

<p>   <code>ngx_http_charset_module</code>模块将指定的字符集添加到“Content-Type”响应头字段。  此外，该模块可以将数据从一个字符集转换为另一个字符集，但有一些限制： </p>
<ul>
<li>转换是以一种方式执行的 - 从服务器到客户端， -   只能转换单字节字符集 -   或者来自UTF-8的单字节字符集。 </li>
</ul>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">include        conf/koi-win;

charset        windows-1251;
source_charset koi8-r;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset*charset*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">charset off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  将指定的charset添加到“Content-Type”响应头字段。  如果此charset与<a href="#source_charset">source_charset</a>指令中指定的charset不同，则执行转换。 </p>
<p>  参数<code>off</code>取消将charset添加到“Content-Type”响应头字段。 </p>
<p>  可以使用变量定义charset： </p>
<pre class="notranslate">charset $charset;
</pre>

<p>  在这种情况下，变量的所有可能值需要以<a href="#charset_map">charset_map</a> ， <a href="#charset">charset</a>或<a href="#source_charset">source_charset</a>指令的形式存在于配置中至少一次。  对于<code>utf-8</code> ， <code>windows-1251</code>和<code>koi8-r</code> charsets，将文件<code>conf/koi-win</code> ， <code>conf/koi-utf</code>和<code>conf/win-utf</code>包含在<code>conf/koi-win</code>就足够了。  对于其他字符集，只需制作虚构的转换表即可，例如： </p>
<pre class="notranslate">charset_map iso-8859-5 _ { }
</pre>



<p>  此外，可以在“X-Accel-Charset”响应头字段中设置字符集。  可以使用<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a> ， <a href="ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a>和<a href="ngx_http_grpc_module.html#grpc_ignore_headers">grpc_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset_map*charset1*</code> <code>*charset2*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  描述从一个字符集到另一个字符集的转换表。  使用相同的数据构建反向转换表。  字符代码以十六进制给出。   80-FF范围内的缺失字符被替换为“ <code>?</code>   ”。  从UTF-8转换时，单字节字符集中缺少的字符将替换为“ <code>&amp;amp;#XXXX;</code>   ”。 </p>
<p>  例： </p>
<pre class="notranslate">charset_map koi8-r windows-1251 {
    C0 FE ; # small yu
    C1 E0 ; # small a
    C2 E1 ; # small b
    C3 F6 ; # small ts
    ...
}
</pre>



<p>  在将转换表描述为UTF-8时，应在第二列中给出UTF-8字符集的代码，例如： </p>
<pre class="notranslate">charset_map koi8-r utf-8 {
    C0 D18E ; # small yu
    C1 D0B0 ; # small a
    C2 D0B1 ; # small b
    C3 D186 ; # small ts
    ...
}
</pre>



<p>  在分配文件<code>conf/koi-win</code> ， <code>conf/koi-utf</code>和<code>conf/win-utf</code>中提供了从<code>koi8-r</code>到<code>windows-1251</code> ，从<code>koi8-r</code>和<code>windows-1251</code>到<code>utf-8</code>完整转换表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">charset_types text/html text/xml text/plain text/vnd.wap.wmlapplication/javascript application/rss+xml;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.9版本中。 </p>
<p>  除了“ <code>text/html</code> ”之外，还可以在具有指定MIME类型的响应中启用模块处理。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
<blockquote>
<p>  在版本1.5.4之前，“ <code>application/x-javascript</code> ”被用作默认MIME类型而不是“ <code>application/javascript</code> ”。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**override_charseton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">override_charset off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  确定当答案已在“Content-Type”响应头字段中携带字符集时，是否应对从代理或FastCGI / uwsgi / SCGI / gRPC服务器接收的答案执行转换。  如果启用了转换，则将接收到的响应中指定的字符集用作源字符集。 </p>
<blockquote>
<p>  应当注意，如果在子请求中接收到响应，则始终执行从响应字符集到主请求字符集的转换，而不管<code>override_charset</code>指令设置如何。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**source_charset*charset*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  定义响应的源字符集。  如果此charset与<a href="#charset">charset</a>指令中指定的<a href="#charset">charset</a>不同，则执行转换。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_browser_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_browser_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_browser_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-browser-module"><a href="#Module-ngx-http-browser-module" class="headerlink" title="Module ngx_http_browser_module"></a>Module ngx_http_browser_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ancient_browser">ancient_browser</a> <br>     <a href="#ancient_browser_value">ancient_browser_value</a> <br>     <a href="#modern_browser">modern_browser</a> <br>     <a href="#modern_browser_value">modern_browser_value</a> <br></td>

<p>   <code>ngx_http_browser_module</code>模块创建的变量的值取决于“User-Agent”请求标头字段的值： </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  选择索引文件： </p>
<pre class="notranslate">modern_browser_value "modern.";

modern_browser msie      5.5;
modern_browser gecko     1.0.0;
modern_browser opera     9.0;
modern_browser safari    413;
modern_browser konqueror 3.0;

index index.${modern_browser}html index.html;
</pre>



<p>  旧浏览器的重定向： </p>
<pre class="notranslate">modern_browser msie      5.0;
modern_browser gecko     0.9.1;
modern_browser opera     8.0;
modern_browser safari    413;
modern_browser konqueror 3.0;

modern_browser unlisted;

ancient_browser Links Lynx netscape4;

if ($ancient_browser) {
    rewrite ^ /ancient.html;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ancient_browser*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果在“User-Agent”请求标头字段中找到任何指定的子字符串，则浏览器将被视为古代。  特殊字符串“ <code>netscape4</code> ”对应于正则表达式“ <code>^Mozilla/[1-4]</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ancient_browser_value*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ancient_browser_value 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<code>$ancient_browser</code>变量的值。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**modern_browser*browser*</code> <code>*version*</code> ; <br> <code>**modern_browserunlisted</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定从中将浏览器视为现代的版本。  浏览器可以是以下任何一种： <code>msie</code> ， <code>gecko</code> （基于Mozilla的浏览器）， <code>opera</code> ， <code>safari</code>或<code>konqueror</code> 。 </p>
<p>  可以使用以下格式指定版本：X，XX，XXX或XXXX每种格式的最大值分别为4000,4000.99,4000.99.99和4000.99.99.99。 </p>
<p>   <code>unlisted</code>的特殊值指定将浏览器视为现代浏览器，如果它未被<code>modern_browser</code>和<a href="#ancient_browser">ancient_browser</a>指令列出。  否则这样的浏览器被认为是古老的。  如果请求未在标头中提供“User-Agent”字段，则将浏览器视为未列出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**modern_browser_value*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">modern_browser_value 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<code>$modern_browser</code>变量的值。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_autoindex_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_autoindex_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_autoindex_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-autoindex-module"><a href="#Module-ngx-http-autoindex-module" class="headerlink" title="Module ngx_http_autoindex_module"></a>Module ngx_http_autoindex_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#autoindex">autoindex</a> <br>     <a href="#autoindex_exact_size">autoindex_exact_size</a> <br>     <a href="#autoindex_format">autoindex_format</a> <br>     <a href="#autoindex_localtime">autoindex_localtime</a> <br></td>

<p>   <code>ngx_http_autoindex_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求，并生成目录列表。  当<a href="ngx_http_index_module.html">ngx_http_index_module</a>模块找不到索引文件时，通常<code>ngx_http_autoindex_module</code>请求传递给<code>ngx_http_autoindex_module</code>模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    autoindex on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用目录列表输出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_exact_sizeon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_exact_size on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  对于HTML <a href="#autoindex_format">格式</a> ，指定是否应在目录列表中输出确切的文件大小，或者更确切地舍入为千字节，兆字节和千兆字节。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_format**     &lt;code class=&quot;notranslate&quot;&gt;html</code> |    <code>xml</code> |    <code>json</code> |    <code>jsonp</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_format html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.9版本中。 </p>
<p>  设置目录列表的格式。 </p>
<p>  使用JSONP格式时，使用<code>callback</code>请求参数设置回调函数的名称。  如果参数缺失或具有空值，则使用JSON格式。 </p>
<p>  可以使用<a href="ngx_http_xslt_module.html">ngx_http_xslt_module</a>模块转换XML输出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_localtimeon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_localtime off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  对于HTML <a href="#autoindex_format">格式</a> ，指定目录列表中的时间是应以本地时区还是UTC输出。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_request_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_request_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_request_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-request-module"><a href="#Module-ngx-http-auth-request-module" class="headerlink" title="Module ngx_http_auth_request_module"></a>Module ngx_http_auth_request_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_request">auth_request</a> <br>     <a href="#auth_request_set">auth_request_set</a> <br></td>

<p>   <code>ngx_http_auth_request_module</code>模块（1.5.4+）基于子请求的结果实现客户端授权。  如果子请求返回2xx响应代码，则允许访问。  如果它返回401或403，则拒绝访问，并显示相应的错误代码。  子请求返回的任何其他响应代码都被视为错误。 </p>
<p>  对于401错误，客户端还从子请求响应中接收“WWW-Authenticate”头。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_auth_request_module</code>配置参数启用它。 </p>
<p>  该模块可以通过<a href="ngx_http_core_module.html#satisfy">满足</a>指令与其他访问模块组合，例如<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> 。 </p>
<blockquote>
<p>  在1.7.3版之前，无法缓存对授权子请求的响应（使用<a href="ngx_http_proxy_module.html#proxy_cache">proxy_cache</a> ， <a href="ngx_http_proxy_module.html#proxy_store">proxy_store</a>等）。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /private/ {
    auth_request /auth;
    ...
}

location = /auth {
    proxy_pass ...
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_request*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_request off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  根据子请求的结果启用授权，并设置子请求将发送到的URI。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_request_set*$variable*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  授权请求完成后，将请求<code>*variable*</code>设置为给定<code>*value*</code> 。  该值可能包含授权请求中的变量，例如<code>$upstream_http_*</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_jwt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_jwt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_jwt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-jwt-module"><a href="#Module-ngx-http-auth-jwt-module" class="headerlink" title="Module ngx_http_auth_jwt_module"></a>Module ngx_http_auth_jwt_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_jwt">auth_jwt</a> <br>     <a href="#auth_jwt_claim_set">auth_jwt_claim_set</a> <br>     <a href="#auth_jwt_header_set">auth_jwt_header_set</a> <br>     <a href="#auth_jwt_key_file">auth_jwt_key_file</a> <br>     <a href="#auth_jwt_key_request">auth_jwt_key_request</a> <br>     <a href="#auth_jwt_leeway">auth_jwt_leeway</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_auth_jwt_module</code>模块（1.11.3）通过使用指定的密钥验证提供的<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web令牌</a> （JWT）来实现客户端授权。   JWT声明必须以<a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web签名</a> （JWS）结构进行编码。  该模块可用于<a href="http://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="noopener">OpenID Connect</a>身份验证。 </p>
<p>  该模块可以通过<a href="ngx_http_core_module.html#satisfy">满足</a>指令与其他访问模块组合，例如<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> 。 </p>
<p>  该模块支持以下加密<a href="https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms" target="_blank" rel="noopener">算法</a> ： </p>
<ul>
<li>HS256，HS384，HS512 -    RS256，RS384，RS512 -    ES256，ES384，ES512 -    EdDSA（Ed25519和Ed448签名）（1.15.7）<br>在1.13.7版之前，仅支持HS256，RS256，ES256算法。 </li>
</ul>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    auth_jwt          "closed site";
    auth_jwt_key_file conf/keys.json;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt**     &lt;code class=&quot;notranslate&quot;&gt;*string*</code>    [ <code>token=</code> <code>*$variable*</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_jwt off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  启用JSON Web Token的验证。  指定的<code>*string*</code>用作域。  参数值可以包含变量。 </p>
<p>  可选的<code>token</code>参数指定包含JSON Web Token的变量。  默认情况下，JWT作为<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">承载令牌</a>在“授权”标头中传递。   JWT也可以作为cookie或查询字符串的一部分传递： </p>
<pre class="notranslate">auth_jwt "closed site" token=$cookie_auth_token;
</pre>



<p>  特殊值<code>off</code>取消了从先前配置级别继承的<code>auth_jwt</code>伪指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_claim_set*$variable*</code> <code>*name*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  将<code>*variable*</code>设置为由键名标识的JWT声明参数。  名称匹配从JSON树的顶级开始。  对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<pre class="notranslate">location / {
    auth_jwt           "closed site";
    auth_jwt_key_file  conf/keys.json;
    auth_jwt_claim_set $email info e-mail;
    auth_jwt_claim_set $job info "job title";
}
</pre>



<blockquote>
<p>  在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_header_set*$variable*</code> <code>*name*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  将<code>*variable*</code>设置为由键名标识的JOSE标头参数。  名称匹配从JSON树的顶级开始。  对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<blockquote>
<p>  在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_key_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  指定<a href="https://tools.ietf.org/html/rfc7517#section-5" target="_blank" rel="noopener">JSON Web Key Set</a>格式的<code>*file*</code> ，用于验证JWT签名。  参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_key_request*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  允许从子请求中检索<a href="https://tools.ietf.org/html/rfc7517#section-5" target="_blank" rel="noopener">JSON Web Key Set</a>文件以验证JWT签名，并设置子请求将发送到的URI。  为避免验证开销，建议缓存密钥文件： </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache levels=1 keys_zone=foo:10m;

server {
    ...

    location / {
        auth_jwt             "closed site";
        auth_jwt_key_request /jwks_uri;
    }

    location = /jwks_uri {
        internal;
        proxy_cache foo;
        proxy_pass  http://idp.example.com/keys;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_leeway*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_jwt_leeway 0s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.10版本中。 </p>
<p>  设置最大允许余地，以在验证<a href="https://tools.ietf.org/html/rfc7519#section-4.1.4" target="_blank" rel="noopener">exp</a>和<a href="https://tools.ietf.org/html/rfc7519#section-4.1.5" target="_blank" rel="noopener">nbf</a> JWT声明时补偿时钟偏差。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_auth_jwt_module</code>模块支持嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_basic_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_basic_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_basic_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-basic-module"><a href="#Module-ngx-http-auth-basic-module" class="headerlink" title="Module ngx_http_auth_basic_module"></a>Module ngx_http_auth_basic_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_basic">auth_basic</a> <br>     <a href="#auth_basic_user_file">auth_basic_user_file</a> <br></td>

<p>   <code>ngx_http_auth_basic_module</code>模块允许通过使用“HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。 </p>
<p>  访问也可以通过<a href="ngx_http_access_module.html">地址</a> ， <a href="ngx_http_auth_request_module.html">子请求</a>的<a href="ngx_http_auth_request_module.html">结果</a>或<a href="ngx_http_auth_jwt_module.html">JWT来限制</a> 。  通过地址和密码同时限制访问由<a href="ngx_http_core_module.html#satisfy">satisf</a>指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_basic*string*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_basic off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  使用“HTTP基本身份验证”协议启用用户名和密码验证。  指定的参数用作域。  参数值可以包含变量（1.3.10,1.2.7）。  特殊值<code>off</code>允许取消从先前配置级别继承的<code>auth_basic</code>伪指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_basic_user_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  指定保存用户名和密码的文件，格式如下： </p>
<pre class="notranslate"># comment
name1:password1
name2:password2:comment
name3:password3
</pre>

<p>   <code>*file*</code>名可以包含变量。 </p>
<p>  支持以下密码类型： </p>
<ul>
<li>用<code>crypt()</code>函数加密;  可以使用Apache HTTP Server分发中的“ <code>htpasswd</code> ”实用程序或“ <code>openssl passwd</code> ”命令生成; -   使用基于MD5的密码算法（apr1）的Apache变体进行散列;  可以使用相同的工具生成; -   由<a href="https://tools.ietf.org/html/rfc2307#section-5.3" target="_blank" rel="noopener">RFC 2307中</a>描述的“ <code>{</code> <code>*scheme*</code> <code>}</code> <code>*data*</code> ”语法（1.0.3+）指定;  目前实现的方案包括<code>PLAIN</code> （不应使用示例一）， <code>SHA</code> （1.3.13）（不应使用普通SHA-1哈希）和<code>SSHA</code> （盐渍SHA-1哈希，一些软件包使用，特别是OpenLDAP和Dovecot）。 <blockquote class="note">  仅添加了对<code>SHA</code>方案的支持，以帮助从其他Web服务器迁移。  它不应该用于新密码，因为它使用的无盐SHA-1散列很容易受到<a href="http://en.wikipedia.org/wiki/Rainbow_attack" target="_blank" rel="noopener">彩虹表</a>攻击。 </blockquote></li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_api_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_api_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_api_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-api-module"><a href="#Module-ngx-http-api-module" class="headerlink" title="Module ngx_http_api_module"></a>Module ngx_http_api_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#api">api</a> <br>     <a href="#status_zone">status_zone</a> <br> <a href="#compatibility">Compatibility</a> <br> <a href="#endpoints">Endpoints</a> <br>     <a href="#root">/</a> <br>     <a href="#nginx">/nginx</a> <br>     <a href="#processes">/processes</a> <br>     <a href="#connections">/connections</a> <br>     <a href="#ssl">/ssl</a> <br>     <a href="#slabs_">/slabs/</a> <br>     <a href="#slabs_slab_zone_name">/slabs/{slabZoneName}</a> <br>     <a href="#http_">/http/</a> <br>     <a href="#http_requests">/http/requests</a> <br>     <a href="#http_server_zones_">/http/server_zones/</a> <br>     <a href="#http_server_zones_http_server_zone_name">/http/server_zones/{httpServerZoneName}</a> <br>     <a href="#http_caches_">/http/caches/</a> <br>     <a href="#http_caches_http_cache_zone_name">/http/caches/{httpCacheZoneName}</a> <br>     <a href="#http_upstreams_">/http/upstreams/</a> <br>     <a href="#http_upstreams_http_upstream_name_">/http/upstreams/{httpUpstreamName}/</a> <br>     <a href="#http_upstreams_http_upstream_name_servers_">/http/upstreams/{httpUpstreamName}/servers/</a> <br>     <a href="#http_upstreams_http_upstream_name_servers_http_upstream_server_id">/http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}</a> <br>     <a href="#http_keyvals_">/http/keyvals/</a> <br>     <a href="#http_keyvals_http_keyval_zone_name">/http/keyvals/{httpKeyvalZoneName}</a> <br>     <a href="#stream_">/stream/</a> <br>     <a href="#stream_server_zones_">/stream/server_zones/</a> <br>     <a href="#stream_server_zones_stream_server_zone_name">/stream/server_zones/{streamServerZoneName}</a> <br>     <a href="#stream_upstreams_">/stream/upstreams/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_">/stream/upstreams/{streamUpstreamName}/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_servers_">/stream/upstreams/{streamUpstreamName}/servers/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_servers_stream_upstream_server_id">/stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}</a> <br>     <a href="#stream_keyvals_">/stream/keyvals/</a> <br>     <a href="#stream_keyvals_stream_keyval_zone_name">/stream/keyvals/{streamKeyvalZoneName}</a> <br>     <a href="#stream_zone_sync_">/stream/zone_sync/</a> <br> <a href="#definitions">Response Objects</a> <br></td>

<p>   <code>ngx_http_api_module</code>模块（1.13.3）提供REST API，用于访问各种状态信息，即时配置上游服务器组以及管理<a href="ngx_http_keyval_module.html">键值对，</a>而无需重新配置nginx。 </p>
<blockquote>
<p>  该模块取代了<a href="ngx_http_status_module.html">ngx_http_status_module</a>和<a href="ngx_http_upstream_conf_module.html">ngx_http_upstream_conf_module</a>模块。 </p>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    upstream backend {
        zone http_backend 64k;

        server backend1.example.com weight=5;
        server backend2.example.com;
    }

    proxy_cache_path /data/nginx/cache_backend keys_zone=cache_backend:10m;

    server {
        server_name backend.example.com;

        location / {
            proxy_pass  http://backend;
            proxy_cache cache_backend;

            health_check;
        }

        status_zone server_backend;
    }

    keyval_zone zone=one:32k state=one.keyval;
    keyval $arg_text $text zone=one;

    server {
        listen 127.0.0.1;

        location /api {
            **api** write=on;
            allow 127.0.0.1;
            deny all;
        }
    }
}

stream {
    upstream backend {
        zone stream_backend 64k;

        server backend1.example.com:12345 weight=5;
        server backend2.example.com:12345;
    }

    server {
        listen      127.0.0.1:12345;
        proxy_pass  backend;
        status_zone server_backend;
        health_check;
    }
}
</pre>

<p>  所有API请求都包含URI中支持的API <a href="#api_version">版本</a> 。  使用此配置的API请求示例： </p>
<pre class="notranslate">http://127.0.0.1/api/3/
http://127.0.0.1/api/3/nginx
http://127.0.0.1/api/3/connections
http://127.0.0.1/api/3/http/requests
http://127.0.0.1/api/3/http/server_zones/server_backend
http://127.0.0.1/api/3/http/caches/cache_backend
http://127.0.0.1/api/3/http/upstreams/backend
http://127.0.0.1/api/3/http/upstreams/backend/servers/
http://127.0.0.1/api/3/http/upstreams/backend/servers/1
http://127.0.0.1/api/3/http/keyvals/one?key=arg1
http://127.0.0.1/api/3/stream/
http://127.0.0.1/api/3/stream/server_zones/server_backend
http://127.0.0.1/api/3/stream/upstreams/
http://127.0.0.1/api/3/stream/upstreams/backend
http://127.0.0.1/api/3/stream/upstreams/backend/servers/1
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**api** 
[ &lt;code class=&quot;notranslate&quot;&gt;write</code> = <code>on</code> | <code>off</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  打开周围位置的REST API接口。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p>   <code>write</code>参数确定API是只读还是读写。  默认情况下，API是只读的。 </p>
<p>  所有API请求都应在URI中包含受支持的API版本。  如果请求URI等于位置前缀，则返回支持的API版本列表。  当前的API版本为“ <code>3</code> ”。 </p>
<p>  请求行中的可选“ <code>fields</code> ”参数指定将输出所请求对象的哪些字段： </p>
<pre class="notranslate">http://127.0.0.1/api/3/nginx?fields=version,build
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**status_zone*zone*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  该指令出现在1.13.12版中。 </p>
<p>  允许在指定<code>*zone*</code>收集虚拟<a href="ngx_http_core_module.html#server">http</a>或<a href="stream/ngx_stream_core_module.html#server">流</a>服务器状态信息。  多个服务器可能共享同一个区域。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li><a href="#stream_zone_sync_">/ stream / zone_sync /</a> data在<a href="#api_version">版本</a> 3中添加。 -    <a href="#api_version">版本</a> 2中添加了<a href="#def_nginx_http_upstream_conf_server">drain</a>参数。 -    <a href="#stream_keyvals_">/ stream / keyvals /</a> data在<a href="#api_version">版本</a> 2中添加。 </li>
</ul>
<h4 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h4><p>  支持的方法： </p>
<ul>
<li><code>GET</code> - 返回根端点列表   返回根端点列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><code>GET</code> - 返回nginx运行实例的状态   返回nginx版本，构建名称，地址，配置重新加载次数，主进程和工作进程的ID。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出运行实例的nginx字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_object">nginx</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回nginx进程状态   返回异常终止和重生的子进程的数量。   可能的回应： <ul class="compact"><li>   200  - 成功，退货<a href="#def_nginx_processes">流程</a><br>重置异常终止和重生的子进程的计数器。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><p><code>GET</code> - 返回客户端连接统计信息   返回客户端连接的统计信息   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出连接统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_connections">连接</a><br>重置已接受和已删除客户端连接的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><p><code>GET</code> - 返回SSL统计信息   返回SSL统计信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出SSL统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_ssl_object">SSL</a><br>重置SSL握手和会话重用的计数器。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><code>GET</code> - 所有楼板的返回状态   使用slab分配器返回每个共享内存区域的slab状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出板区域的哪些区域。  如果“ <code>fields</code> ”值为空，则仅输出区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有楼板的“ <a href="#def_nginx_slab_zone">带有slab分配器的共享内存区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回板的状态   使用slab分配器返回特定共享内存区域的slab状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出板区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_slab_zone">带有slab分配器的共享内存区域</a> -    404  - 未找到平板（ <code>SlabNotFound</code> ），返回<a href="#def_nginx_error">错误</a><br>重置每个内存插槽的“ <code>reqs</code> ”和“ <code>reqs</code> ”指标。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到平板（ <code>SlabNotFound</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回与HTTP相关的端点列表   返回第一级HTTP端点的列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP请求统计信息   返回客户端HTTP请求的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出客户端HTTP请求统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_requests">HTTP请求</a><br>重置客户端HTTP请求总数。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有HTTP服务器区域的状态   返回每个HTTP <a href="https://nginx.org/en/http/ngx_http_api_module.html#status_zone" target="_blank" rel="noopener">服务器区域的</a>状态信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出服务器区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http服务器区域的“ <a href="#def_nginx_http_server_zone">HTTP服务器区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP服务器区域的状态   返回特定HTTP服务器区域的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_server_zone">HTTP服务器区域</a> -    404  - 找不到服务器区域（ <code>ServerZoneNotFound</code> ），返回<a href="#def_nginx_error">错误</a><br>重置特定HTTP服务器区域中接受和丢弃的请求，响应，接收和发送字节的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 找不到服务器区域（ <code>ServerZoneNotFound</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有缓存的状态   返回由<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_path" target="_blank" rel="noopener">proxy_cache_path</a>和其他“ <code>*_cache_path</code> ”指令配置的每个缓存的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出缓存区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出缓存区的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http缓存的“ <a href="#def_nginx_http_cache">HTTP缓存</a> ”对象集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回缓存的状态   返回特定缓存的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出缓存区的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_cache">HTTP缓存</a> -    404  - 未找到缓存（ <code>CacheNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>重置特定缓存区域中缓存命中/未命中的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到缓存（ <code>CacheNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有HTTP上游服务器组的状态   返回每个HTTP上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出上游的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  -  Success，返回所有http上游的“ <a href="#def_nginx_http_upstream">HTTP Upstream</a> ”对象集合<br>支持的方法： </li>
<li><p><code>GET</code> -  HTTP上游服务器组的返回状态   返回特定HTTP上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream">HTTP上游</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>重置上游服务器组中每个上游服务器的统计信息和队列统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP上游服务器组中所有服务器的配置   返回特定HTTP上游服务器组中每个服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a>阵列 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>将新服务器添加到HTTP上游服务器组。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li>201  - 创建，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），缺少“ <code>server</code> ”参数（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时<code>error</code> “ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”可能没有端口（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”需要域名（ <code>UpstreamBadAddress</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），路径太长（ <code>UpstreamBadRoute</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），没有解析定义解析（ <code>UpstreamConfNoResolver</code> ），上游“ <code>*name*</code> ”没有备份（ <code>UpstreamNoBackup</code> ），上游“ <code>*name*</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code>   <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP上游服务器组中服务器的配置   返回HTTP上游服务器组中特定服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>修改HTTP上游服务器组中特定服务器的设置。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时的“ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），无效的“ <code>server</code> ”参数（ <code>UpstreamBadAddress</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），无效的“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效的“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效的“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效的“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效的“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），路由太长（ <code>UpstreamBadRoute</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），服务器“ <code>*ID*</code> ”地址是不可变的（ <code>UpstreamServerImmutable</code> ），服务器“ <code>ID</code> ”权重是不可变的（ <code>UpstreamServerWeightImmutable</code> ），上游“ <code>name</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从HTTP上游服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
<li>200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a>阵列 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），服务器“ <code>*id*</code> ”不可移动（ <code>UpstreamServerImmutable</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 从所有HTTP keyval区域返回键值对   返回每个HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>的键值对。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  如果“ <code>fields</code> ”值为空，则仅输出HTTP keyval区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http密钥的“ <a href="#def_nginx_http_keyval_zone">HTTP Keyval共享内存区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 从HTTP键区域返回键值对   返回存储在特定HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>中的键值对。   请求参数： <dl class="compact"><dt>   <code>key</code> （ <code>string</code> ，可选） </dt><dd>  从HTTP keyval区域获取特定的键值对。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_keyval_zone">HTTP Keyval共享内存区域</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>向HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>添加新的键值对。  如果HTTP keyval共享内存区域为空，则可以输入多个键值对。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>201  - 创建 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能添加一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    409  - 密钥已存在（ <code>KeyvalKeyExists</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>更改键值对中所选键的值，或通过将键值设置为<code>null</code>来删除键。 </p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>204  - 成功 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能更新一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域中</a>删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回与流相关的端点列表   返回第一级流端点的列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><code>GET</code> - 返回所有流服务器区域的状态   返回每个流<a href="https://nginx.org/en/http/ngx_http_api_module.html#status_zone" target="_blank" rel="noopener">服务器区域的</a>状态信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出服务器区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有流服务器区域的“ <a href="#def_nginx_stream_server_zone">Stream Server Zone</a> ”对象集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流服务器区域的状态   返回特定流服务器区域的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_server_zone">Stream Server Zone</a> -    404  - 未找到服务器区域（ <code>ServerZoneNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a><br>重置特定流服务器区域中接受和丢弃的连接，会话，接收和发送字节的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到服务器区域（ <code>ServerZoneNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有流上游服务器组的状态   返回每个流上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出上游的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，为所有流上游返回“ <a href="#def_nginx_stream_upstream">Stream Upstream</a> ”对象的集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组的状态   返回特定流上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_upstream">Stream Upstream</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>重置上游服务器组中每个上游服务器的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组中所有服务器的配置   返回特定流上游服务器组中每个服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一组<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Servers</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>将新服务器添加到流上游服务器组。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li>201  - 创建，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），缺少“ <code>server</code> ”参数（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时<code>error</code> “ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），服务器“ <code>host</code> ”（ <code>UpstreamBadAddress</code> ）中没有端口，服务上游“ <code>host</code> ”可能没有端口（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”需要域名（ <code>UpstreamBadAddress</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> “（ <code>UpstreamBadMaxConns</code> ），无效” <code>max_fails</code> “（ <code>UpstreamBadMaxFails</code> ），无效” <code>fail_timeout</code> “（ <code>UpstreamBadFailTimeout</code> ），无效” <code>slow_start</code> “（ <code>UpstreamBadSlowStart</code> ），” <code>service</code> “为空（ <code>UpstreamBadService</code> ），无法解析解析器（ <code>UpstreamConfNoResolver</code> ），上游” <code>*name*</code> “没有备份（ <code>UpstreamNoBackup</code> ），上游” <code>*name*</code> “内存耗尽（ <code>UpstreamOutOfMemory</code>   <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组中服务器的配置   返回流上游服务器组中特定服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），返回<a href="#def_nginx_error">Error</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>修改流上游服务器组中特定服务器的设置。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>200  - 成功，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时的“ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），无效的“ <code>server</code> ”参数（ <code>UpstreamBadAddress</code> ），服务器“ <code>host</code> ”（ <code>UpstreamBadAddress</code> ）中没有端口，服务器ID无效（ <code>UpstreamBadServerId</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），服务器“ <code>*ID*</code> ”地址为不可变（ <code>UpstreamServerImmutable</code> ），服务器“ <code>*ID*</code> ”权重为不可变（ <code>UpstreamServerWeightImmutable</code> ），上游“ <code>name</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从流服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
<li>200  - 成功，返回一组<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Servers</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），服务器“ <code>*id*</code> ”不可移动（ <code>UpstreamServerImmutable</code> ），返回<a href="#def_nginx_error">Error</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 从所有流键区域返回键值对   返回每个流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>的键值对。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  如果“ <code>fields</code> ”值为空，则仅输出流密钥区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有流关键字的“ <a href="#def_nginx_stream_keyval_zone">Stream Keyval Shared Memory Zone</a> ”对象的集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 从流键区域返回键 - 值对   返回存储在特定流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>中的键值对。   请求参数： <dl class="compact"><dt>   <code>key</code> （ <code>string</code> ，可选） </dt><dd>  从流密钥区域获取特定键值对。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_keyval_zone">Stream Keyval共享内存区域</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>将新键值对添加到流键值共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a> 。  如果流键值共享内存区域为空，则可以输入多个键值对。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>201  - 创建 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能添加一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    409  - 密钥已存在（ <code>KeyvalKeyExists</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>更改键值对中所选键的值，或通过将键值设置为<code>null</code>来删除键。 </p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>204  - 成功 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能更新一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域中</a>删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回节点的同步状态   返回群集节点的同步状态。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_zone_sync">Stream Zone Sync节点</a> -    404  - 未配置区域同步（ <code>ZoneSyncNotConfigured</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a> </li>
</ul>
<h4 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h4><p><li id="def_nginx_object">   nginx的：   有关nginx的一般信息： <dl class="compact"><dt>   <code>version</code> （ <code>string</code> ） </dt><dd>   nginx的版本。 </dd><dt>   <code>build</code> （ <code>string</code> ） </dt><dd>   nginx构建的名称。 </dd><dt>   <code>address</code> （ <code>string</code> ） </dt><dd>  接受状态请求的服务器的地址。 </dd><dt>   <code>generation</code> （ <code>integer</code> ） </dt><dd>  配置<a href="https://nginx.org/en/control.html#reconfiguration" target="_blank" rel="noopener">重新加载</a>的总数。 </dd><dt>   <code>load_timestamp</code> （ <code>string</code> ） </dt><dd>  上次重新加载配置的时间，采用ISO 8601格式，分辨率为毫秒。 </dd><dt>   <code>timestamp</code> （ <code>string</code> ） </dt><dd>   ISO 8601格式的当前时间，分辨率为毫秒。 </dd><dt>   <code>pid</code> （ <code>integer</code> ） </dt><dd>  处理状态请求的工作进程的ID。 </dd><dt>   <code>ppid</code> （ <code>integer</code> ） </dt><dd>  启动<a href="https://nginx.org/en/http/ngx_http_status_module.html#pid" target="_blank" rel="noopener">工作进程</a>的主进程的ID。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “nginx” : {<br>    “version” : “1.15.2”,<br>    “build” : “nginx-plus-r16”,<br>    “address” : “206.251.255.64”,<br>    “generation” : 6,<br>    “load_timestamp” : “2018-10-08T09:05:48.776Z”,<br>    “timestamp” : “2018-10-08T15:23:17.056Z”,<br>    “pid” : 32212,<br>    “ppid” : 32210<br>  }<br>}</pre></blockquote></li><li id="def_nginx_processes">  流程： <dl class="compact"><dt>   <code>respawned</code> （ <code>integer</code> ） </dt><dd>  异常终止和重生的子进程的总数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “respawned” : 0<br>}</pre></blockquote></li><li id="def_nginx_connections">  连接：   已接受，已删除，活动和空闲连接的数量。 <dl class="compact"><dt>   <code>accepted</code> （ <code>integer</code> ） </dt><dd>  已接受的客户端连接总数。 </dd><dt>   <code>dropped</code> （ <code>integer</code> ） </dt><dd>  已删除的客户端连接总数。 </dd><dt>   <code>active</code> （ <code>integer</code> ） </dt><dd>  当前活动客户端连接数。 </dd><dt>   <code>idle</code> （ <code>integer</code> ） </dt><dd>  当前空闲客户端连接数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “accepted” : 4968119,<br>  “dropped” : 0,<br>  “active” : 5,<br>  “idle” : 117<br>}</pre></blockquote></li><li id="def_nginx_ssl_object">   SSL： <dl class="compact"><dt>   <code>handshakes</code> （ <code>integer</code> ） </dt><dd>  成功的SSL握手总数。 </dd><dt>   <code>handshakes_failed</code> （ <code>integer</code> ） </dt><dd>  失败的SSL握手总数。 </dd><dt>   <code>session_reuses</code> （ <code>integer</code> ） </dt><dd>   SSL握手期间会话​​重用的总次数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “handshakes” : 79572,<br>  “handshakes_failed” : 21025,<br>  “session_reuses” : 15762<br>}</pre></blockquote></li><li id="def_nginx_slab_zone">  带有slab分配器的共享内存区域： <dl class="compact"><dt> <code>pages</code> </dt> <dd>  空闲和已用内存页面的数量。 <dl class="compact"><dt>   <code>used</code> （ <code>integer</code> ） </dt><dd>  当前使用的内存页数。 </dd><dt>   <code>free</code> （ <code>integer</code> ） </dt><dd>  当前可用内存页数。 </dd></dl></dd><dt> <code>slots</code> </dt> <dd>  内存插槽的状态数据（8,16,32,64,128等）    “ <a href="#def_nginx_slab_zone_slot">Memory Slot</a> ”对象的集合 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “pages” : {<br>    “used” : 1143,<br>    “free” : 2928<br>  },<br>  “slots” : {<br>    “8” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “16” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “32” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “64” : {<br>      “used” : 1,<br>      “free” : 63,<br>      “reqs” : 1,<br>      “fails” : 0<br>    },<br>    “128” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “256” : {<br>      “used” : 18078,<br>      “free” : 178,<br>      “reqs” : 1635736,<br>      “fails” : 0<br>    }<br>  }<br>}</pre></blockquote></li>-   内存插槽： <dl class="compact"><dt>   <code>used</code> （ <code>integer</code> ） </dt><dd>  当前使用的内存插槽数。 </dd><dt>   <code>free</code> （ <code>integer</code> ） </dt><dd>  当前可用内存插槽的数量。 </dd><dt>   <code>reqs</code> （ <code>integer</code> ） </dt><dd>  分配指定大小内存的总尝试次数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  分配指定大小内存的尝试失败次数。 </dd></dl><li id="def_nginx_http_requests">   HTTP请求： <dl class="compact"><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  客户端请求的总数。 </dd><dt>   <code>current</code> （ <code>integer</code> ） </dt><dd>  当前的客户端请求数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “total” : 10624511,<br>  “current” : 4<br>}</pre></blockquote></li><li id="def_nginx_http_server_zone">   HTTP服务器区域： <dl class="compact"><dt>   <code>processing</code> （ <code>integer</code> ） </dt><dd>  当前正在处理的客户端请求数。 </dd><dt>   <code>requests</code> （ <code>integer</code> ） </dt><dd>  从客户端收到的客户端请求总数。 </dd><dt> <code>responses</code> </dt> <dd>  发送给客户端的响应总数和状态代码为“ <code>1xx</code> ”，“ <code>2xx</code> ”，“ <code>3xx</code> ”，“ <code>4xx</code> ”和“ <code>5xx</code> ”的响应数。 <dl class="compact"><dt>   <code>1xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>1xx</code> ”状态代码的响应数。 </dd><dt>   <code>2xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>2xx</code> ”状态代码的响应数。 </dd><dt>   <code>3xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>3xx</code> ”状态代码的响应数。 </dd><dt>   <code>4xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>4xx</code> ”状态代码的响应数。 </dd><dt>   <code>5xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>5xx</code> ”状态代码的响应数。 </dd><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  发送给客户端的响应总数。 </dd></dl></dd><dt>   <code>discarded</code> （ <code>integer</code> ） </dt><dd>  未发送响应而完成的请求总数。 </dd><dt>   <code>received</code> （ <code>integer</code> ） </dt><dd>  从客户端收到的总字节数。 </dd><dt>   <code>sent</code> （ <code>integer</code> ） </dt><dd>  发送给客户端的总字节数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “processing” : 1,<br>  “requests” : 706690,<br>  “responses” : {<br>    “1xx” : 0,<br>    “2xx” : 699482,<br>    “3xx” : 4522,<br>    “4xx” : 907,<br>    “5xx” : 266,<br>    “total” : 705177<br>  },<br>  “discarded” : 1513,<br>  “received” : 172711587,<br>  “sent” : 19415530115<br>}</pre></blockquote></li><li id="def_nginx_http_cache">   HTTP缓存： <dl class="compact"><dt>   <code>size</code> （ <code>integer</code> ） </dt><dd>  缓存的当前大小。 </dd><dt>   <code>max_size</code> （ <code>integer</code> ） </dt><dd>  配置中指定的高速缓存的最大大小限制。 </dd><dt>   <code>cold</code> （ <code>boolean</code> ） </dt><dd>  一个布尔值，指示“缓存加载器”进程是否仍在将数据从磁盘加载到缓存中。 </dd><dt> <code>hit</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_valid" target="_blank" rel="noopener">有效</a>响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>stale</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的过期响应总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_use_stale" target="_blank" rel="noopener">proxy_cache_use_stale</a>和其他“ <code>*_cache_use_stale</code> ”指令）。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>updating</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  在响应更新时从缓存读取的过期响应总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_use_stale_updating" target="_blank" rel="noopener">proxy_cache_use_stale</a>和其他“ <code>*_cache_use_stale</code> ”指令）。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>revalidated</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的过期和重新验证响应的总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_revalidate" target="_blank" rel="noopener">proxy_cache_revalidate</a>和其他“ <code>*_cache_revalidate</code> <a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_revalidate" target="_blank" rel="noopener">_cache_revalidate</a> ”指令。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>miss</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  在缓存中找不到的响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd><dt> <code>expired</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  未从缓存中获取的过期响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd><dt> <code>bypass</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  由于<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_bypass" target="_blank" rel="noopener">proxy_cache_bypass</a>和其他“ <code>*_cache_bypass</code> ”指令，缓存中未查找的响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “size” : 530915328,<br>  “max_size” : 536870912,<br>  “cold” : false,<br>  “hit” : {<br>    “responses” : 254032,<br>    “bytes” : 6685627875<br>  },<br>  “stale” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “updating” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “revalidated” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “miss” : {<br>    “responses” : 1619201,<br>    “bytes” : 53841943822<br>  },<br>  “expired” : {<br>    “responses” : 45859,<br>    “bytes” : 1656847080,<br>    “responses_written” : 44992,<br>    “bytes_written” : 1641825173<br>  },<br>  “bypass” : {<br>    “responses” : 200187,<br>    “bytes” : 5510647548,<br>    “responses_written” : 200173,<br>    “bytes_written” : 44992<br>  }<br>}</pre></blockquote></li><li id="def_nginx_http_upstream">   HTTP上游： <dl class="compact"><dt> <code>peers</code> </dt> <dd>  一系列的： <dl class="compact"><dt>   <code>id</code> （ <code>integer</code> ） </dt><dd>  服务器的ID。 </dd><dt>   <code>server</code> （ <code>string</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">地址</a> 。 </dd><dt>   <code>service</code> （ <code>string</code> ） </dt><dd>   <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#service" target="_blank" rel="noopener">服务</a>参数值。 </dd><dt>   <code>name</code> （ <code>string</code> ） </dt><dd>   <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令中指定的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">服务器</a>名称。 </dd><dt>   <code>backup</code> （ <code>boolean</code> ） </dt><dd>  一个布尔值，指示服务器是否为<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#backup" target="_blank" rel="noopener">备份</a>服务器。 </dd><dt>   <code>weight</code> （ <code>integer</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#weight" target="_blank" rel="noopener">重量</a> 。 </dd><dt>   <code>state</code> （ <code>string</code> ） </dt><dd>  当前状态，可以是“ <code>up</code> ”，“ <code>draining</code> ”，“ <code>down</code> ”，“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”之一。 </dd><dt>   <code>active</code> （ <code>integer</code> ） </dt><dd>  当前活动连接数。 </dd><dt>   <code>max_conns</code> （ <code>integer</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a>限制。 </dd><dt>   <code>requests</code> （ <code>integer</code> ） </dt><dd>  转发到此服务器的客户端请求总数。 </dd><dt> <code>responses</code> </dt> <dd><dl class="compact"><dt>   <code>1xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>1xx</code> ”状态代码的响应数。 </dd><dt>   <code>2xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>2xx</code> ”状态代码的响应数。 </dd><dt>   <code>3xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>3xx</code> ”状态代码的响应数。 </dd><dt>   <code>4xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>4xx</code> ”状态代码的响应数。 </dd><dt>   <code>5xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>5xx</code> ”状态代码的响应数。 </dd><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  从此服务器获取的响应总数。 </dd></dl></dd><dt>   <code>sent</code> （ <code>integer</code> ） </dt><dd>  发送到此服务器的总字节数。 </dd><dt>   <code>received</code> （ <code>integer</code> ） </dt><dd>  从此服务器接收的总字节数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  与服务器通信失败的总次数。 </dd><dt>   <code>unavail</code> （ <code>integer</code> ） </dt><dd>  由于尝试达到<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a>阈值的次数不成功，服务器因客户端请求（状态为“ <code>unavail</code> ”）而变为不可用的次数。 </dd><dt> <code>health_checks</code> </dt> <dd><dl class="compact"><dt>   <code>checks</code> （ <code>integer</code> ） </dt><dd>  进行的<a href="https://nginx.org/en/http/ngx_http_upstream_hc_module.html#health_check" target="_blank" rel="noopener">健康检查</a>请求总数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  健康检查失败的次数。 </dd><dt>   <code>unhealthy</code> （ <code>integer</code> ） </dt><dd>  服务器变得不健康的次数（状态“ <code>unhealthy</code> ”）。 </dd><dt>   <code>last_passed</code> （ <code>boolean</code> ） </dt><dd>  布尔值，指示上次运行状况检查请求是否成功并通过了<a href="https://nginx.org/en/http/ngx_http_upstream_hc_module.html#match" target="_blank" rel="noopener">测试</a> 。 </dd></dl></dd><dt>   <code>downtime</code> （ <code>integer</code> ） </dt><dd>  服务器处于“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”状态的总时间。 </dd><dt>   <code>downstart</code> （ <code>string</code> ） </dt><dd>  服务器变为“ <code>unavail</code> ”，“ <code>checking</code> ”或“ <code>unhealthy</code> ”的时间，采用ISO 8601格式，分辨率为毫秒。 </dd><dt> <code>selected</code> ( <code>string</code> ) </dt><dd> The time when the server was last selected to process a request, in the ISO 8601 format with millisecond resolution. </dd><dt> <code>header_time</code> ( <code>integer</code> ) </dt><dd> The average time to get the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#var_upstream_header_time" target="_blank" rel="noopener">response header</a> from the server. </dd><dt> <code>response_time</code> ( <code>integer</code> ) </dt><dd> The average time to get the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#var_upstream_response_time" target="_blank" rel="noopener">full response</a> from the server. </dd></dl></dd><dt> <code>keepalive</code> ( <code>integer</code> ) </dt><dd>  当前空闲<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a>连接数。 </dd><dt> <code>zombies</code> ( <code>integer</code> ) </dt><dd>  从组中删除但仍处理活动客户端请求的当前服务器数。 </dd><dt> <code>zone</code> ( <code>string</code> ) </dt><dd>  保持组配置和运行时状态的共享内存<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#zone" target="_blank" rel="noopener">区域</a>的名称。 </dd><dt> <code>queue</code> </dt> <dd>  对于请求<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#queue" target="_blank" rel="noopener">队列</a> ，提供以下数据： <dl class="compact"><dt> <code>size</code> ( <code>integer</code> ) </dt><dd>  队列中当前的请求数。 </dd><dt> <code>max_size</code> ( <code>integer</code> ) </dt><dd>  可以同时在队列中的最大请求数。 </dd><dt> <code>overflows</code> ( <code>integer</code> ) </dt><dd>  由于队列溢出而拒绝的请求总数。 </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “upstream_backend” : {<br>    “peers” : [<br>      {<br>        “id” : 0,<br>        “server” : “10.0.0.1:8088”,<br>        “name” : “10.0.0.1:8088”,<br>        “backup” : false,<br>        “weight” : 5,<br>        “state” : “up”,<br>        “active” : 0,<br>        “max_conns” : 20,<br>        “requests” : 667231,<br>        “header_time” : 20,<br>        “response_time” : 36,<br>        “responses” : {<br>          “1xx” : 0,<br>          “2xx” : 666310,<br>          “3xx” : 0,<br>          “4xx” : 915,<br>          “5xx” : 6,<br>          “total” : 667231<br>        },<br>        “sent” : 251946292,<br>        “received” : 19222475454,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26214,<br>          “fails” : 0,<br>          “unhealthy” : 0,<br>          “last_passed” : true<br>        },<br>        “downtime” : 0,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      },<br>      {<br>        “id” : 1,<br>        “server” : “10.0.0.1:8089”,<br>        “name” : “10.0.0.1:8089”,<br>        “backup” : true,<br>        “weight” : 1,<br>        “state” : “unhealthy”,<br>        “active” : 0,<br>        “max_conns” : 20,<br>        “requests” : 0,<br>        “responses” : {<br>          “1xx” : 0,<br>          “2xx” : 0,<br>          “3xx” : 0,<br>          “4xx” : 0,<br>          “5xx” : 0,<br>          “total” : 0<br>        },<br>        “sent” : 0,<br>        “received” : 0,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26284,<br>          “fails” : 26284,<br>          “unhealthy” : 1,<br>          “last_passed” : false<br>        },<br>        “downtime” : 262925617,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      }<br>    ],<br>    “keepalive” : 0,<br>    “zombies” : 0,<br>    “zone” : “upstream_backend”<br>  }<br>}</pre></blockquote></li><li id="def_nginx_http_upstream_conf_server"> HTTP Upstream Server:  Dynamically configurable parameters of an HTTP upstream <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a> : <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd> The ID of the HTTP upstream server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#address" target="_blank" rel="noopener">address</a> parameter of the HTTP upstream server.  添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the <a href="https://nginx.org/en/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a> directive in the “ <code>http</code> ” block. See also the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#resolve" target="_blank" rel="noopener">resolve</a> parameter of the HTTP upstream server. </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#service" target="_blank" rel="noopener">service</a> parameter of the HTTP upstream server. This parameter cannot be changed. </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#weight" target="_blank" rel="noopener">weight</a> parameter of the HTTP upstream server. </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a> parameter of the HTTP upstream server. </dd><dt> <code>max_fails</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a> parameter of the HTTP upstream server. </dd><dt> <code>fail_timeout</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#fail_timeout" target="_blank" rel="noopener">fail_timeout</a> parameter of the HTTP upstream server. </dd><dt> <code>slow_start</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#slow_start" target="_blank" rel="noopener">slow_start</a> parameter of the HTTP upstream server. </dd><dt> <code>route</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#route" target="_blank" rel="noopener">route</a> parameter of the HTTP upstream server. </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd> When <code>true</code> , adds a <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#backup" target="_blank" rel="noopener">backup</a> server. This parameter cannot be changed. </dd><dt> <code>down</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#down" target="_blank" rel="noopener">down</a> parameter of the HTTP upstream server. </dd><dt> <code>drain</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#drain" target="_blank" rel="noopener">drain</a> parameter of the HTTP upstream server. </dd><dt> <code>parent</code> ( <code>string</code> ) </dt><dd> Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>host</code> ( <code>string</code> ) </dt><dd> Hostname of the resolved server. The hostname is assigned automatically and cannot be changed. </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “id” : 1,<br>  “server” : “10.0.0.1:8089”,<br>  “weight” : 4,<br>  “max_conns” : 0,<br>  “max_fails” : 0,<br>  “fail_timeout” : “10s”,<br>  “slow_start” : “10s”,<br>  “route” : “”,<br>  “backup” : true,<br>  “down” : true<br>}</pre></blockquote></li><li id="def_nginx_http_keyval_zone"> HTTP Keyval Shared Memory Zone:  Contents of an HTTP keyval shared memory zone.   例： <blockquote class="example"><pre class="notranslate">{<br>  “key1” : “value1”,<br>  “key2” : “value2”,<br>  “key3” : “value3”<br>}</pre></blockquote></li><li id="def_nginx_stream_server_zone"> Stream Server Zone: <dl class="compact"><dt> <code>processing</code> ( <code>integer</code> ) </dt><dd>  当前正在处理的客户端连接数。 </dd><dt> <code>connections</code> ( <code>integer</code> ) </dt><dd>  从客户端接受的连接总数。 </dd><dt> <code>sessions</code> </dt> <dd> The total number of completed sessions, and the number of sessions completed with status codes “ <code>2xx</code> ”, “ <code>4xx</code> ”, or “ <code>5xx</code> ”. <dl class="compact"><dt> <code>2xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>2xx</code> ”. </dd><dt> <code>4xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>4xx</code> ”. </dd><dt> <code>5xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>5xx</code> ”. </dd><dt> <code>total</code> ( <code>integer</code> ) </dt><dd>  已完成的客户会话总数。 </dd></dl></dd><dt> <code>discarded</code> ( <code>integer</code> ) </dt><dd>  在不创建会话的情况下完成的连接总数。 </dd><dt> <code>received</code> ( <code>integer</code> ) </dt><dd>  从客户端收到的总字节数。 </dd><dt> <code>sent</code> ( <code>integer</code> ) </dt><dd>  发送给客户端的总字节数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “dns” : {<br>    “processing” : 1,<br>    “connections” : 155569,<br>    “sessions” : {<br>      “2xx” : 155564,<br>      “4xx” : 0,<br>      “5xx” : 0,<br>      “total” : 155569<br>    },<br>    “discarded” : 0,<br>    “received” : 4200363,<br>    “sent” : 20489184<br>  }<br>}</pre></blockquote></li><li id="def_nginx_stream_upstream"> Stream Upstream: <dl class="compact"><dt> <code>peers</code> </dt> <dd> An array of: <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd>  服务器的ID。 </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">地址</a> 。 </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd>   <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#service" target="_blank" rel="noopener">服务</a>参数值。 </dd><dt> <code>name</code> ( <code>string</code> ) </dt><dd>   <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令中指定的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">服务器</a>名称。 </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd>  一个布尔值，指示服务器是否为<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#backup" target="_blank" rel="noopener">备份</a>服务器。 </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#weight" target="_blank" rel="noopener">重量</a> 。 </dd><dt> <code>state</code> ( <code>string</code> ) </dt><dd>  当前状态，可以是“ <code>up</code> ”，“ <code>down</code> ”，“ <code>unavail</code> ”，“ <code>checking</code> ”或“ <code>unhealthy</code> ”之一。 </dd><dt> <code>active</code> ( <code>integer</code> ) </dt><dd>  当前的连接数。 </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a>限制。 </dd><dt> <code>connections</code> ( <code>integer</code> ) </dt><dd>  转发到此服务器的客户端连接总数。 </dd><dt> <code>connect_time</code> ( <code>integer</code> ) </dt><dd>  连接上游服务器的平均时间。 </dd><dt> <code>first_byte_time</code> ( <code>integer</code> ) </dt><dd>  接收第一个数据字节的平均时间。 </dd><dt> <code>response_time</code> ( <code>integer</code> ) </dt><dd>  接收最后一个数据字节的平均时间。 </dd><dt> <code>sent</code> ( <code>integer</code> ) </dt><dd>  发送到此服务器的总字节数。 </dd><dt> <code>received</code> ( <code>integer</code> ) </dt><dd>  从此服务器接收的总字节数。 </dd><dt> <code>fails</code> ( <code>integer</code> ) </dt><dd>  与服务器通信失败的总次数。 </dd><dt> <code>unavail</code> ( <code>integer</code> ) </dt><dd>  由于尝试达到<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a>阈值的次数不成功，服务器无法进行客户端连接（状态为“ <code>unavail</code> ”）的次数。 </dd><dt> <code>health_checks</code> </dt> <dd><dl class="compact"><dt> <code>checks</code> ( <code>integer</code> ) </dt><dd>  进行的<a href="https://nginx.org/en/stream/ngx_stream_upstream_hc_module.html#health_check" target="_blank" rel="noopener">健康检查</a>请求总数。 </dd><dt> <code>fails</code> ( <code>integer</code> ) </dt><dd>  健康检查失败的次数。 </dd><dt> <code>unhealthy</code> ( <code>integer</code> ) </dt><dd>  服务器变得不健康的次数（状态“ <code>unhealthy</code> ”）。 </dd><dt> <code>last_passed</code> ( <code>boolean</code> ) </dt><dd> Boolean indicating whether the last health check request was successful and passed <a href="https://nginx.org/en/stream/ngx_stream_upstream_hc_module.html#match" target="_blank" rel="noopener">tests</a> . </dd></dl></dd><dt> <code>downtime</code> ( <code>integer</code> ) </dt><dd>  服务器处于“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”状态的总时间。 </dd><dt> <code>downstart</code> ( <code>string</code> ) </dt><dd> The time when the server became “ <code>unavail</code> ”, “ <code>checking</code> ”, or “ <code>unhealthy</code> ”, in the ISO 8601 format with millisecond resolution. </dd><dt> <code>selected</code> ( <code>string</code> ) </dt><dd> The time when the server was last selected to process a connection, in the ISO 8601 format with millisecond resolution. </dd></dl></dd><dt> <code>zombies</code> ( <code>integer</code> ) </dt><dd>  当前从组中删除但仍处理活动客户端连接的服务器数。 </dd><dt> <code>zone</code> ( <code>string</code> ) </dt><dd>  保持组配置和运行时状态的共享内存<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#zone" target="_blank" rel="noopener">区域</a>的名称。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “dns” : {<br>    “peers” : [<br>      {<br>        “id” : 0,<br>        “server” : “10.0.0.1:12347”,<br>        “name” : “10.0.0.1:12347”,<br>        “backup” : false,<br>        “weight” : 5,<br>        “state” : “up”,<br>        “active” : 0,<br>        “max_conns” : 50,<br>        “connections” : 667231,<br>        “sent” : 251946292,<br>        “received” : 19222475454,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26214,<br>          “fails” : 0,<br>          “unhealthy” : 0,<br>          “last_passed” : true<br>        },<br>        “downtime” : 0,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      },<br>      {<br>        “id” : 1,<br>        “server” : “10.0.0.1:12348”,<br>        “name” : “10.0.0.1:12348”,<br>        “backup” : true,<br>        “weight” : 1,<br>        “state” : “unhealthy”,<br>        “active” : 0,<br>        “max_conns” : 50,<br>        “connections” : 0,<br>        “sent” : 0,<br>        “received” : 0,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26284,<br>          “fails” : 26284,<br>          “unhealthy” : 1,<br>          “last_passed” : false<br>        },<br>        “downtime” : 262925617,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      }<br>    ],<br>    “zombies” : 0,<br>    “zone” : “dns”<br>  }<br>}</pre></blockquote></li><li id="def_nginx_stream_upstream_conf_server"> Stream Upstream Server:  Dynamically configurable parameters of a stream upstream <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a> : <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd> The ID of the stream upstream server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">address</a> parameter of the stream upstream server.  添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#resolver" target="_blank" rel="noopener">resolver</a> directive in the “ <code>stream</code> ” block. See also the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#resolve" target="_blank" rel="noopener">resolve</a> parameter of the stream upstream server. </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#service" target="_blank" rel="noopener">service</a> parameter of the stream upstream server. This parameter cannot be changed. </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#weight" target="_blank" rel="noopener">weight</a> parameter of the stream upstream server. </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a> parameter of the stream upstream server. </dd><dt> <code>max_fails</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a> parameter of the stream upstream server. </dd><dt> <code>fail_timeout</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#fail_timeout" target="_blank" rel="noopener">fail_timeout</a> parameter of the stream upstream server. </dd><dt> <code>slow_start</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#slow_start" target="_blank" rel="noopener">slow_start</a> parameter of the stream upstream server. </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd> When <code>true</code> , adds a <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#backup" target="_blank" rel="noopener">backup</a> server. This parameter cannot be changed. </dd><dt> <code>down</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#down" target="_blank" rel="noopener">down</a> parameter of the stream upstream server. </dd><dt> <code>parent</code> ( <code>string</code> ) </dt><dd> Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>host</code> ( <code>string</code> ) </dt><dd> Hostname of the resolved server. The hostname is assigned automatically and cannot be changed. </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “id” : 0,<br>  “server” : “10.0.0.1:12348”,<br>  “weight” : 1,<br>  “max_conns” : 0,<br>  “max_fails” : 1,<br>  “fail_timeout” : “10s”,<br>  “slow_start” : 0,<br>  “backup” : false,<br>  “down” : false<br>}</pre></blockquote></li><li id="def_nginx_stream_keyval_zone"> Stream Keyval Shared Memory Zone:  Contents of a stream keyval shared memory zone.   例： <blockquote class="example"><pre class="notranslate">{<br>  “key1” : “value1”,<br>  “key2” : “value2”,<br>  “key3” : “value3”<br>}</pre></blockquote></li><li id="def_nginx_stream_zone_sync"> Stream Zone Sync Node: <dl class="compact"><dt> <code>zones</code> </dt> <dd> Synchronization information per each shared memory zone.  A collection of “ <a href="#def_nginx_stream_zone_sync_zone">Sync Zone</a> “ objects </dd><dt> <code>status</code> </dt> <dd> Synchronization information per node in a cluster. <dl class="compact"><dt> <code>bytes_in</code> ( <code>integer</code> ) </dt><dd> The number of bytes received by this node. </dd><dt> <code>msgs_in</code> ( <code>integer</code> ) </dt><dd> The number of messages received by this node. </dd><dt> <code>msgs_out</code> ( <code>integer</code> ) </dt><dd> The number of messages sent by this node. </dd><dt> <code>bytes_out</code> ( <code>integer</code> ) </dt><dd> The number of bytes sent by this node. </dd><dt> <code>nodes_online</code> ( <code>integer</code> ) </dt><dd> The number of peers this node is connected to. </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “zones” : {<br>    “zone1” : {<br>      “records_pending” : 2061,<br>      “records_total” : 260575<br>    },<br>    “zone2” : {<br>      “records_pending” : 0,<br>      “records_total” : 14749<br>    }<br>  },<br>  “status” : {<br>    “bytes_in” : 1364923761,<br>    “msgs_in” : 337236,<br>    “msgs_out” : 346717,<br>    “bytes_out” : 1402765472,<br>    “nodes_online” : 15<br>  }<br>}</pre></blockquote></li>-  Sync Zone:  Synchronization status of a shared memory zone. <dl class="compact"><dt> <code>records_pending</code> ( <code>integer</code> ) </dt><dd> The number of records that need to be sent to the cluster. </dd><dt> <code>records_total</code> ( <code>integer</code> ) </dt><dd> The total number of records stored in the shared memory zone. </dd></dl>-   错误：  nginx error object. <dl class="compact"><dt> <code>path</code> ( <code>string</code> ) </dt><dd> API path. </dd><dt> <code>method</code> ( <code>string</code> ) </dt><dd> HTTP method. </dd><dt> <code>error</code> </dt> <dd><dl class="compact"><dt> <code>status</code> ( <code>integer</code> ) </dt><dd> HTTP error code. </dd><dt> <code>text</code> ( <code>string</code> ) </dt><dd> Error description. </dd><dt> <code>code</code> ( <code>string</code> ) </dt><dd> Internal nginx error code. </dd></dl></dd><dt> <code>request_id</code> ( <code>string</code> ) </dt><dd> The ID of the request, equals the value of the <a href="https://nginx.org/en/http/ngx_http_core_module.html#var_request_id" target="_blank" rel="noopener">$request_id</a> variable. </dd><dt> <code>href</code> ( <code>string</code> ) </dt><dd> Link to reference documentation. </dd></dl></p>
<pre class="notranslate">{
  "respawned" : 0
}</pre>

<pre class="notranslate">{
  "handshakes" : 79572,
  "handshakes_failed" : 21025,
  "session_reuses" : 15762
}</pre>

<pre class="notranslate">{
  "total" : 10624511,
  "current" : 4
}</pre>

<pre class="notranslate">{
  "size" : 530915328,
  "max_size" : 536870912,
  "cold" : false,
  "hit" : {
    "responses" : 254032,
    "bytes" : 6685627875
  },
  "stale" : {
    "responses" : 0,
    "bytes" : 0
  },
  "updating" : {
    "responses" : 0,
    "bytes" : 0
  },
  "revalidated" : {
    "responses" : 0,
    "bytes" : 0
  },
  "miss" : {
    "responses" : 1619201,
    "bytes" : 53841943822
  },
  "expired" : {
    "responses" : 45859,
    "bytes" : 1656847080,
    "responses_written" : 44992,
    "bytes_written" : 1641825173
  },
  "bypass" : {
    "responses" : 200187,
    "bytes" : 5510647548,
    "responses_written" : 200173,
    "bytes_written" : 44992
  }
}</pre>

<pre class="notranslate">{
  "id" : 1,
  "server" : "10.0.0.1:8089",
  "weight" : 4,
  "max_conns" : 0,
  "max_fails" : 0,
  "fail_timeout" : "10s",
  "slow_start" : "10s",
  "route" : "",
  "backup" : true,
  "down" : true
}</pre>

<pre class="notranslate">{
  "dns" : {
    "processing" : 1,
    "connections" : 155569,
    "sessions" : {
      "2xx" : 155564,
      "4xx" : 0,
      "5xx" : 0,
      "total" : 155569
    },
    "discarded" : 0,
    "received" : 4200363,
    "sent" : 20489184
  }
}</pre>

<pre class="notranslate">{
  "id" : 0,
  "server" : "10.0.0.1:12348",
  "weight" : 1,
  "max_conns" : 0,
  "max_fails" : 1,
  "fail_timeout" : "10s",
  "slow_start" : 0,
  "backup" : false,
  "down" : false
}</pre>

<pre class="notranslate">{
  "zones" : {
    "zone1" : {
      "records_pending" : 2061,
      "records_total" : 260575
    },
    "zone2" : {
      "records_pending" : 0,
      "records_total" : 14749
    }
  },
  "status" : {
    "bytes_in" : 1364923761,
    "msgs_in" : 337236,
    "msgs_out" : 346717,
    "bytes_out" : 1402765472,
    "nodes_online" : 15
  }
}</pre>





</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_addition_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_addition_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_addition_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-addition-module"><a href="#Module-ngx-http-addition-module" class="headerlink" title="Module ngx_http_addition_module"></a>Module ngx_http_addition_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#add_before_body">add_before_body</a> <br>     <a href="#add_after_body">add_after_body</a> <br>     <a href="#addition_types">addition_types</a> <br></td>

<p>   <code>ngx_http_addition_module</code>模块是一个过滤器，用于在响应之前和之后添加文本。  默认情况下不构建此模块，应使用<code>--with-http_addition_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    add_before_body /before_action;
    add_after_body  /after_action;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_before_body*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  添加由于在响应主体之前处理给定子请求而返回的文本。  作为参数的空字符串（ <code>&quot;&quot;</code> ）取消从先前配置级别继承的添加。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_after_body*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  添加由于在响应主体之后处理给定子请求而返回的文本。  作为参数的空字符串（ <code>&quot;&quot;</code> ）取消从先前配置级别继承的添加。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**addition_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">addition_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.9版本中。 </p>
<p>  除了“ <code>text/html</code> ”之外，还允许在具有指定MIME类型的响应中添加文本。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_access_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_access_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-access-module"><a href="#Module-ngx-http-access-module" class="headerlink" title="Module ngx_http_access_module"></a>Module ngx_http_access_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#allow">allow</a> <br>     <a href="#deny">deny</a> <br></td>

<p>   <code>ngx_http_access_module</code>模块允许限制对某些客户端地址的访问。 </p>
<p>  访问也可以通过<a href="ngx_http_auth_basic_module.html">密码</a> ， <a href="ngx_http_auth_request_module.html">子请求</a>的<a href="ngx_http_auth_request_module.html">结果</a>或<a href="ngx_http_auth_jwt_module.html">JWT来限制</a> 。  通过地址和密码同时限制访问由<a href="ngx_http_core_module.html#satisfy">satisf</a>指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    deny  192.168.1.1;
    allow 192.168.1.0/24;
    allow 10.1.1.0/16;
    allow 2001:0db8::/32;
    deny  all;
}
</pre>



<p>  按顺序检查规则，直到找到第一个匹配项。  在此示例中，仅允许IPv4网络<code>10.1.1.0/16</code>和<code>192.168.1.0/24</code>不包括地址<code>192.168.1.1</code> ）和IPv6网络<code>2001:0db8::/32</code> 。  如果有很多规则，最好使用<a href="ngx_http_geo_module.html">ngx_http_geo_module</a>模块变量。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**allow**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  允许访问指定的网络或地址。  如果指定了特殊值<code>unix:</code> （1.5.1），则允许访问所有UNIX域套接字。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**deny**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  拒绝访问指定的网络或地址。  如果指定了特殊值<code>unix:</code> （1.5.1），则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/load_balancing-nginx中文手册]]></title>
      <url>/ngx/http/load_balancing.html</url>
      <content type="html"><![CDATA[<p>http,load_balancing<br><a id="more"></a></p>
<h2 id="使用nginx作为HTTP负载均衡器"><a href="#使用nginx作为HTTP负载均衡器" class="headerlink" title="使用nginx作为HTTP负载均衡器"></a>使用nginx作为HTTP负载均衡器</h2><td align="left" class="notranslate"> <a href="#nginx_load_balancing_methods">Load balancing methods</a> <br> <a href="#nginx_load_balancing_configuration">Default load balancing configuration</a> <br> <a href="#nginx_load_balancing_with_least_connected">Least connected load balancing</a> <br> <a href="#nginx_load_balancing_with_ip_hash">Session persistence</a> <br> <a href="#nginx_weighted_load_balancing">Weighted load balancing</a> <br> <a href="#nginx_load_balancing_health_checks">Health checks</a> <br> <a href="#nginx_load_balancing_additional_information">Further reading</a> <br></td>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>  跨多个应用程序实例的负载平衡是一种常用技术，用于优化资源利用率，最大化吞吐量，减少延迟并确保容错配置。 </p>
<p>  可以使用nginx作为非常有效的HTTP负载平衡器，将流量分配到多个应用程序服务器，并使用nginx提高Web应用程序的性能，可伸缩性和可靠性。 </p>
<h4 id="负载均衡方法"><a href="#负载均衡方法" class="headerlink" title="负载均衡方法"></a>负载均衡方法</h4><p>   nginx支持以下负载平衡机制（或​​方法）： </p>
<ul>
<li>循环 - 对应用程序服务器的请求以循环方式分发， -   最少连接 - 下一个请求被分配给活动连接数最少的服务器， -    ip-hash  - 哈希函数用于确定应为下一个请求选择哪个服务器（基于客户端的IP地址）。 </li>
</ul>
<h4 id="默认负载均衡配置"><a href="#默认负载均衡配置" class="headerlink" title="默认负载均衡配置"></a>默认负载均衡配置</h4><p>  使用nginx进行负载平衡的最简单配置可能如下所示： </p>
<pre class="notranslate">http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}
</pre>



<p>  在上面的示例中，在srv1-srv3上运行了3个相同应用程序的实例。  如果未特别配置负载平衡方法，则默认为循环。  所有请求都<a href="ngx_http_proxy_module.html#proxy_pass">代理</a>到服务器组myapp1，nginx应用HTTP负载平衡来分发请求。 </p>
<p>   nginx中的反向代理实现包括HTTP，HTTPS，FastCGI，uwsgi，SCGI，memcached和gRPC的负载平衡。 </p>
<p>  要为HTTPS而不是HTTP配置负载平衡，只需使用“https”作为协议。 </p>
<p>  为FastCGI，uwsgi，SCGI，memcached或gRPC设置负载平衡时，分别使用<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>和<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>指令。 </p>
<h4 id="最小连接负载平衡"><a href="#最小连接负载平衡" class="headerlink" title="最小连接负载平衡"></a>最小连接负载平衡</h4><p>  另一个负载平衡规则是最少连接的。  在某些请求需要更长时间才能完成的情况下，最小连接允许更公平地控制应用程序实例上的负载。 </p>
<p>  使用最少连接的负载平衡，nginx将尽量不会使繁忙的应用程序服务器过载请求，而是将新请求分发给不太繁忙的服务器。 </p>
<p>  当<a href="ngx_http_upstream_module.html#least_conn">least_conn</a>指令用作服务器组配置的一部分时，将激活nginx中的最小连接负载平衡： </p>
<pre class="notranslate">    upstream myapp1 {
        least_conn;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }
</pre>



<h4 id="会话持久性"><a href="#会话持久性" class="headerlink" title="会话持久性"></a>会话持久性</h4><p>  请注意，通过循环或最少连接的负载平衡，每个后续客户端的请求可能会分发到不同的服务器。  无法保证同一客户端始终指向同一服务器。 </p>
<p>  如果需要将客户端绑定到特定的应用程序服务器 - 换句话说，就始终尝试选择特定服务器而言，使客户端的会话“粘滞”或“持久” -  ip-hash负载平衡机制可以是用过的。 </p>
<p>  使用ip-hash，客户端的IP地址将用作散列密钥，以确定应为客户端的请求选择服务器组中的哪个服务器。  此方法可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。 </p>
<p>  要配置ip-hash负载平衡，只需将<a href="ngx_http_upstream_module.html#ip_hash">ip_hash</a>指令添加到服务器（上游）组配置： </p>
<pre class="notranslate">upstream myapp1 {
    ip_hash;
    server srv1.example.com;
    server srv2.example.com;
    server srv3.example.com;
}
</pre>



<h4 id="加权负载平衡"><a href="#加权负载平衡" class="headerlink" title="加权负载平衡"></a>加权负载平衡</h4><p>  通过使用服务器权重，甚至可以进一步影响nginx负载平衡算法。 </p>
<p>  在上面的示例中，未配置服务器权重，这意味着所有指定的服务器都被视为对特定负载平衡方法具有同等资格。 </p>
<p>  特别是对于循环，它还意味着在服务器上或多或少地平等分配请求 - 只要有足够的请求，并且以统一的方式处理请求并且足够快地完成。 </p>
<p>  当为服务器指定<a href="ngx_http_upstream_module.html#server">权重</a>参数时， <a href="ngx_http_upstream_module.html#server">权</a>重被计入负载平衡决策的一部分。 </p>
<pre class="notranslate">    upstream myapp1 {
        server srv1.example.com weight=3;
        server srv2.example.com;
        server srv3.example.com;
    }
</pre>



<p>  使用此配置，每5个新请求将分布在应用程序实例中，如下所示：3个请求将定向到srv1，一个请求将转到srv2，另一个请求转到srv3。 </p>
<p>  同样可以在最近的nginx版本中使用具有最少连接和ip-hash负载平衡的权重。 </p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p>   nginx中的反向代理实现包括带内（或被动）服务器运行状况检查。  如果来自特定服务器的响应失败并显示错误，则nginx会将此服务器标记为失败，并将尝试避免为后续入站请求选择此服务器一段时间。 </p>
<p>   <a href="ngx_http_upstream_module.html#server">max_fails</a>指令设置在<a href="ngx_http_upstream_module.html#server">fail_timeout</a>期间应该发生的与服务器通信的连续不成功尝试次数。  默认情况下， <a href="ngx_http_upstream_module.html#server">max_fails</a>设置为1.当设置为0时，将禁用此服务器的运行状况检查。   <a href="ngx_http_upstream_module.html#server">fail_timeout</a>参数还定义服务器将标记为失败的时间。  在服务器发生故障后的<a href="ngx_http_upstream_module.html#server">fail_timeout</a>时间间隔后，nginx将开始使用实时客户端的请求正常探测服务器。  如果探测成功，则将服务器标记为实时。 </p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p>  此外，还有更多指令和参数可以控制nginx中的服务器负载平衡，例如<a href="ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> ， <a href="ngx_http_upstream_module.html#server">backup</a> ， <a href="ngx_http_upstream_module.html#server">down</a>和<a href="ngx_http_upstream_module.html#keepalive">keepalive</a> 。  有关更多信息，请查看我们的<a href="..">参考文档</a> 。 </p>
<p>  最后但同样重要的是， <a href="https://www.nginx.com/products/application-load-balancing/" target="_blank" rel="noopener">应用程序负载平衡</a> ， <a href="https://www.nginx.com/products/application-health-checks/" target="_blank" rel="noopener">应用程序运行状况检查</a> ， <a href="https://www.nginx.com/products/live-activity-monitoring/" target="_blank" rel="noopener">活动监视</a>和服务器组的动态<a href="https://www.nginx.com/products/on-the-fly-reconfiguration/" target="_blank" rel="noopener">重新配置</a>是我们付费NGINX Plus订阅的一部分。 </p>
<p>  以下文章更详细地描述了与NGINX Plus的负载平衡： </p>
<ul>
<li><a href="https://www.nginx.com/blog/load-balancing-with-nginx-plus/" target="_blank" rel="noopener">使用NGINX和NGINX Plus进行负载均衡</a> -    <a href="https://www.nginx.com/blog/load-balancing-with-nginx-plus-part2/" target="_blank" rel="noopener">使用NGINX和NGINX Plus第2部分进行负载平衡</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/converting_rewrite_rules-nginx中文手册]]></title>
      <url>/ngx/http/converting_rewrite_rules.html</url>
      <content type="html"><![CDATA[<p>http,converting_rewrite_rules<br><a id="more"></a></p>
<h2 id="转换重写规则"><a href="#转换重写规则" class="headerlink" title="转换重写规则"></a>转换重写规则</h2><td align="left" class="notranslate"> <a href="#converting_mongrel_rules">Converting Mongrel rules</a> <br></td>

<h4 id="重定向到主站点"><a href="#重定向到主站点" class="headerlink" title="重定向到主站点"></a>重定向到主站点</h4><p>  在共享托管生活期间用于<em>仅</em>使用Apache的.htaccess文件配置<em>所有内容</em>的人通常会翻译以下规则： </p>
<pre class="notranslate">RewriteCond  %{HTTP_HOST}  example.org
RewriteRule  (.*)          http://www.example.org$1
</pre>

<p>  这样的事情： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  www.example.org  example.org;
    if ($http_host = example.org) {
        rewrite  (.*)  http://www.example.org$1;
    }
    ...
}
</pre>



<p>  这是一种错误，繁琐且无效的方式。  正确的方法是为<code>example.org</code>定义一个单独的服务器： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org;
    return       301 http://www.example.org$request_uri;
}

server {
    listen       80;
    server_name  www.example.org;
    ...
}
</pre>



<blockquote>
<p>  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ <a href="http://www.example.org$request_uri?" target="_blank" rel="noopener">http://www.example.org$request_uri?</a>;<br></pre></blockquote></p>
</blockquote>
<p>  另一个例子。  而不是“倒置”逻辑“所有不是<code>example.com</code>而不是<code>www.example.com</code> ”： </p>
<pre class="notranslate">RewriteCond  %{HTTP_HOST}  !example.com
RewriteCond  %{HTTP_HOST}  !www.example.com
RewriteRule  (.*)          http://www.example.com$1
</pre>

<p>  一个人应该简单地定义<code>example.com</code> ， <code>www.example.com</code>和“其他一切”： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.com www.example.com;
    ...
}

server {
    listen       80 default_server;
    server_name  _;
    return       301 http://example.com$request_uri;
}
</pre>



<blockquote>
<p>  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ <a href="http://example.com$request_uri?" target="_blank" rel="noopener">http://example.com$request_uri?</a>;<br></pre></blockquote></p>
</blockquote>
<h4 id="转换Mongrel规则"><a href="#转换Mongrel规则" class="headerlink" title="转换Mongrel规则"></a>转换Mongrel规则</h4><p>  典型的Mongrel规则： </p>
<pre class="notranslate">DocumentRoot /var/www/myapp.com/current/public

RewriteCond %{DOCUMENT_ROOT}/system/maintenance.html -f
RewriteCond %{SCRIPT_FILENAME} !maintenance.html
RewriteRule ^.*$ %{DOCUMENT_ROOT}/system/maintenance.html [L]

RewriteCond %{REQUEST_FILENAME} -f
RewriteRule ^(.*)$ $1 [QSA,L]

RewriteCond %{REQUEST_FILENAME}/index.html -f
RewriteRule ^(.*)$ $1/index.html [QSA,L]

RewriteCond %{REQUEST_FILENAME}.html -f
RewriteRule ^(.*)$ $1.html [QSA,L]

RewriteRule ^/(.*)$ balancer://mongrel_cluster%{REQUEST_URI} [P,QSA,L]
</pre>

<p>  应转换为 </p>
<pre class="notranslate">location / {
    root       /var/www/myapp.com/current/public;

    try_files  /system/maintenance.html
               $uri  $uri/index.html $uri.html
               @mongrel;
}

location @mongrel {
    proxy_pass  http://mongrel;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/configuring_https_servers-nginx中文手册]]></title>
      <url>/ngx/http/configuring_https_servers.html</url>
      <content type="html"><![CDATA[<p>http,configuring_https_servers<br><a id="more"></a></p>
<h2 id="配置HTTPS服务器"><a href="#配置HTTPS服务器" class="headerlink" title="配置HTTPS服务器"></a>配置HTTPS服务器</h2><td align="left" class="notranslate"> <a href="#optimization">HTTPS server optimization</a> <br> <a href="#chains">SSL certificate chains</a> <br> <a href="#single_http_https_server">A single HTTP/HTTPS server</a> <br> <a href="#name_based_https_servers">Name-based HTTPS servers</a> <br>     <a href="#certificate_with_several_names">An SSL certificate with several names</a> <br>     <a href="#sni">Server Name Indication</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>  要配置HTTPS服务器，必须在<a href="ngx_http_core_module.html#server">服务器</a>块中的<a href="ngx_http_core_module.html#listen">侦听套接字</a>上启用<code>ssl</code>参数，并且应指定<a href="ngx_http_ssl_module.html#ssl_certificate">服务器证书</a>和<a href="ngx_http_ssl_module.html#ssl_certificate_key">私钥</a>文件的位置： </p>
<pre class="notranslate">server {
    listen              443 **ssl** ;
    server_name         www.example.com;
    ssl_certificate     **www.example.com.crt** ;
    ssl_certificate_key **www.example.com.key** ;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
</pre>

<p>  服务器证书是公共实体。  它被发送到连接到服务器的每个客户端。  私钥是一个安全的实体，应该存储在具有受限访问权限的文件中，但是，它必须是nginx的主进程可读的。  私钥可以替代地存储在与证书相同的文件中： </p>
<pre class="notranslate">    ssl_certificate     www.example.com.cert;
    ssl_certificate_key www.example.com.cert;
</pre>

<p>  在这种情况下，还应限制文件访问权限。  虽然证书和密钥存储在一个文件中，但只有证书才会发送到客户端。 </p>
<p>  指令<a href="ngx_http_ssl_module.html#ssl_protocols">ssl_protocols</a>和<a href="ngx_http_ssl_module.html#ssl_ciphers">ssl_ciphers</a>可用于限制连接以仅包括SSL / TLS的强版本和密码。  默认情况下，nginx使用“ <code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2</code> ”和“ <code>ssl_ciphers HIGH:!aNULL:!MD5</code> ”，因此通常不需要明确配置它们。  请注意，这些指令的默认值已多次<a href="#compatibility">更改</a> 。 </p>
<h4 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h4><p>   SSL操作会消耗额外的CPU资源。  在多处理器系统上，应运行多个<a href="ngx_core_module.html#worker_processes">工作进程</a> ，不少于可用CPU核心数。   CPU占用最多的操作是SSL握手。  有两种方法可以最大限度地减少每个客户端的这些操作数量：第一种方法是通过启用<a href="ngx_http_core_module.html#keepalive_timeout">keepalive</a>连接来通过一个连接发送多个请求，第二种方法是重用SSL会话参数以避免SSL并行连接和后续连接。  会话存储在工作<a href="ngx_http_ssl_module.html#ssl_session_cache">线程</a>之间共享的SSL会话高速缓存中，并由<a href="ngx_http_ssl_module.html#ssl_session_cache">ssl_session_cache</a>指令配置。  一兆字节的缓存包含大约4000个会话。  默认缓存超时为5分钟。  可以使用<a href="ngx_http_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a>指令增加它。  以下是针对具有10兆字节共享会话缓存的多核系统优化的示例配置： </p>
<pre class="notranslate"> **worker_processes auto** ;

http {
    **ssl_session_cache   shared:SSL:10m** ;
    **ssl_session_timeout 10m** ;

    server {
        listen              443 ssl;
        server_name         www.example.com;
        **keepalive_timeout   70** ;

        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
</pre>



<h4 id="SSL证书链"><a href="#SSL证书链" class="headerlink" title="SSL证书链"></a>SSL证书链</h4><p>  某些浏览器可能会抱怨由知名证书颁发机构签名的证书，而其他浏览器可能会毫无问题地接受证书。  发生这种情况是因为颁发机构使用中间证书对服务器证书进行了签名，该中间证书不存在于与特定浏览器一起分发的知名可信证书颁发机构的证书库中。  在这种情况下，授权机构提供一组链式证书，这些证书应连接到签名的服务器证书。  服务器证书必须出现在组合文件中的链接证书之前： </p>
<pre class="notranslate">$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt
</pre>

<p>  生成的文件应该在<a href="ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a>指令中使用： </p>
<pre class="notranslate">server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.chained.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
</pre>

<p>  如果服务器证书和软件包已按错误的顺序连接，则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">SSL_CTX_use_PrivateKey_file(" ... /www.example.com.key") failed
   (SSL: error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch)
</pre>

<p>  因为nginx试图将私钥与bundle的第一个证书而不是服务器证书一起使用。 </p>
<p>  浏览器通常存储他们收到的中间证书，并由受信任的权威机构签名，因此主动使用的浏览器可能已经拥有所需的中间证书，并且可能不会抱怨没有链接束发送的证书。  要确保服务器发送完整的证书链，可以使用<code>openssl</code>命令行实用程序，例如： </p>
<pre class="notranslate">$ openssl s_client -connect www.godaddy.com:443
...
Certificate chain
 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US
     /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc
     /OU=MIS Department/ **CN=www.GoDaddy.com**
     /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b)
   i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
   i:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
 2 s:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
   i:/L=ValiCert Validation Network/O= **ValiCert, Inc.**
     /OU=ValiCert Class 2 Policy Validation Authority
     /CN=http://www.valicert.com//emailAddress=info@valicert.com
...
</pre>



<blockquote>
<p>  在使用<a href="#sni">SNI</a>测试配置时，指定<code>-servername</code>选项很重要，因为默认情况下<code>openssl</code>不使用SNI。 </p>
</blockquote>
<p>  在该示例中， <code>www.GoDaddy.com</code>服务器证书＃0的主题（“ <em>s</em> ”）由发行者（“ <em>i</em> ”）签名，发行者本身是证书＃1的主题，其由发行者本身签署。是证书＃2的主题，由知名发行人<em>ValiCert，Inc。签署，</em>其证书存储在浏览器的内置证书库（位于Jack建造的房屋中）中。 </p>
<p>  如果尚未添加证书包，则仅显示服务器证书＃0。 </p>
<h4 id="单个HTTP-HTTPS服务器"><a href="#单个HTTP-HTTPS服务器" class="headerlink" title="单个HTTP / HTTPS服务器"></a>单个HTTP / HTTPS服务器</h4><p>  可以配置处理HTTP和HTTPS请求的单个服务器： </p>
<pre class="notranslate">server {
    listen              80;
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
</pre>



<blockquote>
<p>  在0.7.14之前，无法为个别侦听套接字选择性地启用SSL，如上所示。  只能使用<a href="ngx_http_ssl_module.html#ssl">ssl</a>指令为整个服务器启用<a href="ngx_http_ssl_module.html#ssl">SSL</a> ，从而无法设置单个HTTP / HTTPS服务器。  添加了<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数来解决此问题。  因此不鼓励在现代版本中使用<a href="ngx_http_ssl_module.html#ssl">ssl</a>指令。 </p>
</blockquote>
<h4 id="基于名称的HTTPS服务器"><a href="#基于名称的HTTPS服务器" class="headerlink" title="基于名称的HTTPS服务器"></a>基于名称的HTTPS服务器</h4><p>  配置两个或多个侦听单个IP地址的HTTPS服务器时会出现一个常见问题： </p>
<pre class="notranslate">server {
    listen          443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
</pre>

<p>  使用此配置，浏览器接收默认服务器的证书，即<code>www.example.com</code>无论请求的服务器名称如何。  这是由SSL协议行为引起的。  在浏览器发送HTTP请求之前建立SSL连接，并且nginx不知道所请求服务器的名称。  因此，它可能只提供默认服务器的证书。 </p>
<p>  解决此问题的最古老，最强大的方法是为每个HTTPS服务器分配一个单独的IP地址： </p>
<pre class="notranslate">server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
</pre>



<h4 id="具有多个名称的SSL证书"><a href="#具有多个名称的SSL证书" class="headerlink" title="具有多个名称的SSL证书"></a>具有多个名称的SSL证书</h4><p>  还有其他方法允许在多个HTTPS服务器之间共享单个IP地址。  但是，所有这些都有它们的缺点。  一种方法是在SubjectAltName证书字段中使用具有多个名称的证书，例如<code>www.example.com</code>和<code>www.example.org</code> 。  但是，SubjectAltName字段长度是有限的。 </p>
<p>  另一种方法是使用带有通配符名称的证书，例如<code>*.example.org</code> 。  通配符证书可保护指定域的所有子域，但仅限于一个级别。  此证书与<code>www.example.org</code>匹配，但与<code>example.org</code>和<code>www.sub.example.org</code>不匹配。  这两种方法也可以组合使用。  证书可以在SubjectAltName字段中包含完全和通配符名称，例如<code>example.org</code>和<code>*.example.org</code> 。 </p>
<p>  最好将具有多个名称的证书文件及其私钥文件放在配置的<em>http</em>级别，以在所有服务器中继承其单个内存副本： </p>
<pre class="notranslate">ssl_certificate     common.crt;
ssl_certificate_key common.key;

server {
    listen          443 ssl;
    server_name     www.example.com;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ...
}
</pre>



<h4 id="服务器名称指示"><a href="#服务器名称指示" class="headerlink" title="服务器名称指示"></a>服务器名称指示</h4><p>  在单个IP地址上运行多个HTTPS服务器的更通用的解决方案是<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066），它允许浏览器在SSL握手期间传递请求的服务器名称，因此服务器将知道哪个它应该用于连接的证书。  目前大多数现代浏览器都<a href="http://en.wikipedia.org/wiki/Server_Name_Indication#Support" target="_blank" rel="noopener">支持</a> SNI，但某些老客户或特殊客户可能无法使用。 </p>
<blockquote>
<p>  只有域名可以在SNI中传递，但是如果请求包含文字IP地址，某些浏览器可能会错误地传递服务器的IP地址作为其名称。  人们不应该依赖于此。 </p>
</blockquote>
<p>  为了在nginx中使用SNI，必须在构建nginx二进制文件的OpenSSL库以及在运行时动态链接到的库中支持它。  如果使用配置选项<nobr>“–enable-tlsext”</nobr>构建，OpenSSL支持自0.9.8f版本以来的SNI <nobr>。</nobr>  自OpenSSL 0.9.8j以来，默认情况下启用此选项。  如果nginx是使用SNI支持构建的，那么nginx将在使用“-V”开关运行时显示： </p>
<pre class="notranslate">$ nginx -V
...
TLS SNI support enabled
...
</pre>

<p>  但是，如果启用SNI的nginx动态链接到没有SNI支持的OpenSSL库，nginx会显示警告： </p>
<pre class="notranslate">nginx was built with SNI support, however, now it is linked
dynamically to an OpenSSL library which has no tlsext support,
therefore SNI is not available
</pre>



<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>自0.8.21和0.7.62以来，“-V”开关显示SNI支持状态。 -   自0.7.14起，支持<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。  在0.8.21之前，它只能与<code>default</code>参数一起指定。 -   自0.5.23以来，SNI一直受到支持。 -   自0.5.6以来一直支持共享SSL会话缓存。 </li>
</ul>
<ul>
<li>版本1.9.1及更高版本：默认的SSL协议是TLSv1，TLSv1.1和TLSv1.2（如果OpenSSL库支持）。 -   版本0.7.65,0.8.19及更高版本：默认的SSL协议是SSLv3，TLSv1，TLSv1.1和TLSv1.2（如果受OpenSSL库支持）。 -   版本0.7.64,0.8.18及更早版本：默认的SSL协议是SSLv2，SSLv3和TLSv1。 </li>
</ul>
<ul>
<li>版本1.0.5及更高版本：默认的SSL密码为“ <code>HIGH:!aNULL:!MD5</code> ”。 -   版本0.7.65,0.8.20及更高版本：默认SSL密码为“ <code>HIGH:!ADH:!MD5</code> ”。 -   版本0.8.19：默认SSL密码为“ <code>ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM</code> ”。 -   版本0.7.64,0.8.18及更早版本：默认的SSL密码是 <br>   “ <code>ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</code> ”。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dev/development_guide-nginx中文手册]]></title>
      <url>/ngx/dev/development_guide.html</url>
      <content type="html"><![CDATA[<p>dev,development_guide<br><a id="more"></a></p>
<h2 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h2><td align="left" class="notranslate"> <a href="#introduction">Introduction</a> <br>     <a href="#code_layout">Code layout</a> <br>     <a href="#include_files">Include files</a> <br>     <a href="#integers">Integers</a> <br>     <a href="#common_return_codes">Common return codes</a> <br>     <a href="#error_handling">Error handling</a> <br> <a href="#strings">Strings</a> <br>     <a href="#overview">Overview</a> <br>     <a href="#formatting">Formatting</a> <br>     <a href="#numeric_conversion">Numeric conversion</a> <br>     <a href="#regex">Regular expressions</a> <br> <a href="#time">Time</a> <br> <a href="#containers">Containers</a> <br>     <a href="#array">Array</a> <br>     <a href="#list">List</a> <br>     <a href="#queue">Queue</a> <br>     <a href="#red_black_tree">Red-Black tree</a> <br>     <a href="#hash">Hash</a> <br> <a href="#memory_management">Memory management</a> <br>     <a href="#heap">Heap</a> <br>     <a href="#pool">Pool</a> <br>     <a href="#shared_memory">Shared memory</a> <br> <a href="#logging">Logging</a> <br> <a href="#cycle">Cycle</a> <br> <a href="#buffer">Buffer</a> <br> <a href="#networking">Networking</a> <br>     <a href="#connection">Connection</a> <br> <a href="#events">Events</a> <br>     <a href="#event">Event</a> <br>     <a href="#i_o_events">I/O events</a> <br>     <a href="#timer_events">Timer events</a> <br>     <a href="#posted_events">Posted events</a> <br>     <a href="#event_loop">Event loop</a> <br> <a href="#processes">Processes</a> <br> <a href="#threads">Threads</a> <br> <a href="#Modules">Modules</a> <br>     <a href="#adding_new_modules">Adding new modules</a> <br>     <a href="#core_modules">Core Modules</a> <br>     <a href="#config_directives">Configuration Directives</a> <br> <a href="#http">HTTP</a> <br>     <a href="#http_connection">Connection</a> <br>     <a href="#http_request">Request</a> <br>     <a href="#http_conf">Configuration</a> <br>     <a href="#http_phases">Phases</a> <br>     <a href="#http_variables">Variables</a> <br>     <a href="#http_complex_values">Complex values</a> <br>     <a href="#http_request_redirection">Request redirection</a> <br>     <a href="#http_subrequests">Subrequests</a> <br>     <a href="#http_request_finalization">Request finalization</a> <br>     <a href="#http_request_body">Request body</a> <br>     <a href="#http_response">Response</a> <br>     <a href="#http_response_body">Response body</a> <br>     <a href="#http_body_filters">Body filters</a> <br>     <a href="#http_building_filter_modules">Building filter modules</a> <br>     <a href="#http_body_buffers_reuse">Buffer reuse</a> <br>     <a href="#http_load_balancing">Load balancing</a> <br> <a href="#examples">Examples</a> <br> <a href="#code_style">Code style</a> <br>     <a href="#code_style_general_rules">General rules</a> <br>     <a href="#code_style_files">Files</a> <br>     <a href="#code_style_comments">Comments</a> <br>     <a href="#code_style_preprocessor">Preprocessor</a> <br>     <a href="#code_style_types">Types</a> <br>     <a href="#code_style_variables">Variables</a> <br>     <a href="#code_style_functions">Functions</a> <br>     <a href="#code_style_expressions">Expressions</a> <br>     <a href="#code_style_conditionals_and_loops">Conditionals and Loops</a> <br>     <a href="#code_style_labels">Labels</a> <br></td>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h4 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h4><ul>
<li><p><code>auto</code> - 构建脚本 -  <code>src</code> <ul class="compact"> <li>   <code>core</code> - 基本类型和函数 - 字符串，数组，日志，池等。 -    <code>event</code> - 事件核心 <ul class="compact"><li>   <code>modules</code> - 事件通知模块： <code>epoll</code> ， <code>kqueue</code> ， <code>select</code>等。 -    <code>modules</code> - 其他HTTP模块 -    <code>v2</code> -  HTTP / 2 -  <code>unix</code>  -  <code>win32</code>  </li></ul></li></ul></p>
<h4 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h4><p>以下两个<code>#include</code>语句必须出现在每个nginx文件的开头： </p>
</li>
</ul>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
</pre>

<p>  除此之外，HTTP代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_http.h&gt;
</pre>

<p>  邮件代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_mail.h&gt;
</pre>

<p>  流代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_stream.h&gt;
</pre>

<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>  出于一般目的，nginx代码使用两种整数类型， <code>ngx_int_t</code>和<code>ngx_uint_t</code> ，它们分别是<code>intptr_t</code>和<code>uintptr_t</code> typedef。 </p>
<h4 id="常见的返回码"><a href="#常见的返回码" class="headerlink" title="常见的返回码"></a>常见的返回码</h4><p>   nginx中的大多数函数返回以下代码： </p>
<ul>
<li><p><code>NGX_OK</code> - 操作成功。 -    <code>NGX_ERROR</code> - 操作失败。 -    <code>NGX_AGAIN</code> - 操作不完整;  再次调用该函数。 -    <code>NGX_DECLINED</code> - 例如，操作被拒绝，因为它在配置中被禁用。  这绝不是一个错误。 -    <code>NGX_BUSY</code> - 资源不可用。 -    <code>NGX_DONE</code> - 操作完成或在其他地方继续。  也用作替代成功代码。 -    <code>NGX_ABORT</code> - 功能已中止。  也用作替代错误代码。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p><code>ngx_errno</code>宏返回上一个系统错误代码。  它映射到POSIX平台上的<code>errno</code>和Windows中的<code>GetLastError()</code>调用。   <code>ngx_socket_errno</code>宏返回最后一个套接字错误号。  与<code>ngx_errno</code>宏一样，它映射到POSIX平台上的<code>errno</code> 。  它映射到Windows上的<code>WSAGetLastError()</code>调用。   <code>ngx_socket_errno</code>多次访问<code>ngx_errno</code>或<code>ngx_socket_errno</code>的值可能会导致性能问题。  如果可能多次使用错误值，请将其存储在<code>ngx_err_t</code>类型的本地变量中。  要设置错误，请使用<code>ngx_set_errno(errno)</code>和<code>ngx_set_socket_errno(errno)</code>宏。 </p>
<p><code>ngx_errno</code>和<code>ngx_socket_errno</code>的值可以传递给日志函数<code>ngx_log_error()</code>和<code>ngx_log_debugX()</code> ，在这种情况下，系统错误文本将添加到日志消息中。 </p>
<p>使用<code>ngx_errno</code>示例： </p>
</li>
</ul>
<pre class="notranslate">void
ngx_my_kill(ngx_pid_t pid, ngx_log_t *log, int signo)
{
    ngx_err_t  err;

    if (kill(pid, signo) == -1) {
        err = ngx_errno;

        ngx_log_error(NGX_LOG_ALERT, log, err, "kill(%P, %d) failed", pid, signo);

        if (err == NGX_ESRCH) {
            return 2;
        }

        return 1;
    }

    return 0;
}
</pre>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p>  对于C字符串，nginx使用无符号字符类型指针<code>u_char *</code> 。 </p>
<p>   nginx字符串类型<code>ngx_str_t</code>定义如下： </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p>   <code>len</code>字段保存字符串长度， <code>data</code>保存字符串数据。  保存在<code>ngx_str_t</code>中的<code>ngx_str_t</code>在<code>len</code>字节之后可能会或可能不会以空值终止。  在大多数情况下，事实并非如此。  但是，在代码的某些部分（例如，在解析配置时），已知<code>ngx_str_t</code>对象以空值终止，这简化了字符串比较并使字符串更容易传递给系统调用。 </p>
<p>   nginx中的字符串操作在<code>src/core/ngx_string.h</code>中声明。其中一些是围绕标准C函数的包装器： </p>
<ul>
<li><code>ngx_strcmp()</code>  -  <code>ngx_strncmp()</code>  -  <code>ngx_strstr()</code>  -  <code>ngx_strlen()</code>  -  <code>ngx_strchr()</code>  -  <code>ngx_memcmp()</code>  -  <code>ngx_memset()</code>  -  <code>ngx_memcpy()</code>  -  <code>ngx_memmove()</code>  </li>
</ul>
<p>  其他字符串函数是特定于nginx的 </p>
<ul>
<li><code>ngx_memzero()</code> - 用零填充内存。 -    <code>ngx_explicit_memzero()</code> - 与<code>ngx_memzero()</code>相同，但编译器的死存储消除优化永远不会删除此调用。  此功能可用于清除密码和密钥等敏感数据。 -    <code>ngx_cpymem()</code> - 与<code>ngx_memcpy()</code>相同，但返回最终目标地址这个可以方便地连续添加多个字符串。 -    <code>ngx_movemem()</code> - 与<code>ngx_memmove()</code>相同，但返回最终目标地址。 -    <code>ngx_strlchr()</code> - 搜索字符串中的字符，由两个指针分隔。 </li>
</ul>
<p>  以下函数执行大小写转换和比较： </p>
<ul>
<li><code>ngx_tolower()</code>  -  <code>ngx_toupper()</code>  -  <code>ngx_strlow()</code>  -  <code>ngx_strcasecmp()</code>  -  <code>ngx_strncasecmp()</code>  </li>
</ul>
<p>  以下宏简化了字符串初始化： </p>
<ul>
<li><p><code>ngx_string(text)</code> - 来自C字符串文字<code>text</code>的<code>ngx_str_t</code>类型的静态初始值设定项 -    <code>ngx_null_string</code> - <code>ngx_str_t</code>类型的静态空字符串初始值设定项 -    <code>ngx_str_set(str, text)</code> - 使用C字符串文字<code>text</code>初始化<code>ngx_str_t *</code> type的字符串<code>str</code> -    <code>ngx_str_null(str)</code> - 使用空字符串初始化<code>ngx_str_t *</code> type的字符串<code>str</code> </p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>以下格式化函数支持特定于nginx的类型： </p>
</li>
</ul>
<ul>
<li><code>ngx_sprintf(buf, fmt, ...)</code>  -  <code>ngx_snprintf(buf, max, fmt, ...)</code>  -  <code>ngx_slprintf(buf, last, fmt, ...)</code>  -  <code>ngx_vslprintf(buf, last, fmt, args)</code>  -  <code>ngx_vsnprintf(buf, max, fmt, args)</code>  </li>
</ul>
<p>  这些函数支持的格式化选项的完整列表位于<code>src/core/ngx_string.c</code> 。  他们之中有一些是： </p>
<ul>
<li><p><code>%O</code> - <code>off_t</code> -    <code>%T</code> - <code>time_t</code> -    <code>%z</code> - <code>ssize_t</code> -    <code>%i</code> - <code>ngx_int_t</code> -    <code>%p</code> - <code>void *</code> -    <code>%V</code> - <code>ngx_str_t *</code> -    <code>%s</code> - <code>u_char *</code> （以null结尾） -    <code>%*s</code> - <code>size_t + u_char *</code><br>您可以在大多数类型上添加前缀以使其无符号。  要将输出转换为十六进制，请使用<code>X</code>或<code>x</code> 。 </p>
<p>例如： </p>
</li>
</ul>
<pre class="notranslate">u_char      buf[NGX_INT_T_LEN];
size_t      len;
ngx_uint_t  n;

/* set n here */

len = ngx_sprintf(buf, "%ui", n) — buf;
</pre>



<h4 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h4><p>  在nginx中实现了几个用于数值转换的函数。  前四个每个都将给定长度的字符串转换为指定类型的正整数。  它们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atoi(line, n)</code> - <code>ngx_int_t</code> -    <code>ngx_atosz(line, n)</code> - <code>ssize_t</code> -    <code>ngx_atoof(line, n)</code> - <code>off_t</code> -    <code>ngx_atotm(line, n)</code> - <code>time_t</code> </li>
</ul>
<p>  还有两个额外的数字转换函数。  与前四个一样，他们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atofp(line, n, point)</code> - 将给定长度的固定点浮点数转换为<code>ngx_int_t</code>类型的正整数。  结果左移小数点位置。  数字的字符串表示形式预计不会超过小数位数。  例如， <code>ngx_atofp(&quot;10.5&quot;, 4, 2)</code>返回<code>1050</code> 。 -    <code>ngx_hextoi(line, n)</code> - 将正整数的十六进制表示形式转换为<code>ngx_int_t</code> 。 </li>
</ul>
<h4 id="常用表达"><a href="#常用表达" class="headerlink" title="常用表达"></a>常用表达</h4><p>   nginx中的正则表达式接口是<a href="http://www.pcre.org" target="_blank" rel="noopener">PCRE</a>库的包装器。  相应的头文件是<code>src/core/ngx_regex.h</code> 。 </p>
<p>  要使用正则表达式进行字符串匹配，首先需要编译它，这通常在配置阶段完成。  请注意，由于PCRE支持是可选的，因此使用该接口的所有代码都必须受到周围<code>NGX_PCRE</code>宏的保护： </p>
<pre class="notranslate">#if (NGX_PCRE)
ngx_regex_t          *re;
ngx_regex_compile_t   rc;

u_char                errstr[NGX_MAX_CONF_ERRSTR];

ngx_str_t  value = ngx_string("message (\\d\\d\\d).*Codeword is '(?&lt;cw&gt;\\w+)'");

ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t));

rc.pattern = value;
rc.pool = cf-&gt;pool;
rc.err.len = NGX_MAX_CONF_ERRSTR;
rc.err.data = errstr;
/* rc.options are passed as is to pcre_compile() */

if (ngx_regex_compile(&amp;rc) != NGX_OK) {
    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &amp;rc.err);
    return NGX_CONF_ERROR;
}

re = rc.regex;
#endif
</pre>

<p>  编译成功后， <code>ngx_regex_compile_t</code>结构中的<code>ngx_regex_compile_t</code>和<code>named_captures</code>字段<code>ngx_regex_compile_t</code>包含正则表达式中的所有捕获和命名捕获的计数。 </p>
<p>  然后可以使用编译的正则表达式来匹配字符串： </p>
<pre class="notranslate">ngx_int_t  n;
int        captures[(1 + rc.captures) * 3];

ngx_str_t input = ngx_string("This is message 123. Codeword is 'foobar'.");

n = ngx_regex_exec(re, &amp;input, captures, (1 + rc.captures) * 3);
if (n &gt;= 0) {
    /* string matches expression */

} else if (n == NGX_REGEX_NO_MATCHED) {
    /* no match was found */

} else {
    /* some error */
    ngx_log_error(NGX_LOG_ALERT, log, 0, ngx_regex_exec_n " failed: %i", n);
}
</pre>

<p>   <code>ngx_regex_exec()</code>的参数是编译的正则表达式<code>re</code> ，匹配<code>s</code>的字符串，用于保存找到的任何<code>captures</code>的可选整数数组以及数组的<code>size</code> 。  根据<a href="http://www.pcre.org/original/doc/html/pcreapi.html" target="_blank" rel="noopener">PCRE API的</a>要求， <code>captures</code>数组的大小必须是三的倍数。  在该示例中，大小是根据匹配的字符串本身的总捕获数加<code>1</code> 。 </p>
<p>  如果有匹配，则可以按如下方式访问捕获： </p>
<pre class="notranslate">u_char     *p;
size_t      size;
ngx_str_t   name, value;

/* all captures */
for (i = 0; i &lt; n * 2; i += 2) {
    value.data = input.data + captures[i];
    value.len = captures[i + 1] — captures[i];
}

/* accessing named captures */

size = rc.name_size;
p = rc.names;

for (i = 0; i &lt; rc.named_captures; i++, p += size) {

    /* capture name */
    name.data = &amp;p[2];
    name.len = ngx_strlen(name.data);

    n = 2 * ((p[0] &lt;&lt; 8) + p[1]);

    /* captured value */
    value.data = &amp;input.data[captures[n]];
    value.len = captures[n + 1] — captures[n];
}
</pre>



<p>   <code>ngx_regex_exec_array()</code>函数接受<code>ngx_regex_elt_t</code>元素的数组（它们只是具有关联名称的已编译正则表达式），要匹配的字符串和日志。  该函数将表达式从数组应用到字符串，直到找到匹配或不再有表达式为止。  当匹配时返回值为<code>NGX_OK</code> ，否则<code>NGX_ERROR</code> ，如果出错则返回值为<code>NGX_OK</code> 。 </p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>   <code>ngx_time_t</code>结构表示具有三种不同类型的时间，包括秒，毫秒和GMT偏移量： </p>
<pre class="notranslate">typedef struct {
    time_t      sec;
    ngx_uint_t  msec;
    ngx_int_t   gmtoff;
} ngx_time_t;
</pre>

<p>   <code>ngx_tm_t</code>结构是UNIX平台上的<code>struct tm</code>和Windows上的<code>SYSTEMTIME</code>的别名。 </p>
<p>  要获得当前时间，通常可以访问其中一个可用的全局变量，表示所需格式的缓存时间值。 </p>
<p>  可用的字符串表示形式为： </p>
<ul>
<li><code>ngx_cached_err_log_time</code> - 用于错误日志条目： <code>&quot;1970/09/28 12:00:00&quot;</code> -    <code>ngx_cached_http_log_time</code> - 用于HTTP访问日志条目： <code>&quot;28/Sep/1970:12:00:00 +0600&quot;</code> -    <code>ngx_cached_syslog_time</code> - 用于syslog条目： <code>&quot;Sep 28 12:00:00&quot;</code> -    <code>ngx_cached_http_time</code> - 用于HTTP标头： <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> -    <code>ngx_cached_http_log_iso8601</code> -  ISO 8601标准格式： <code>&quot;1970-09-28T12:00:00+06:00&quot;</code> </li>
</ul>
<p>   <code>ngx_time()</code>和<code>ngx_timeofday()</code>宏以秒为单位返回当前时间值，是访问缓存时间值的首选方法。 </p>
<p>  要显式获取时间，请使用<code>ngx_gettimeofday()</code> ，它更新其参数（指向<code>struct timeval</code>指针）。  当nginx从系统调用返回到事件循环时，时间总是更新。  要立即更新时间，请在信号处理程序上下文中更新时间时调用<code>ngx_time_update()</code>或<code>ngx_time_sigsafe_update()</code> 。 </p>
<p>  以下函数将<code>time_t</code>转换为指示的细分时间表示。  每对中的第一个函数将<code>time_t</code>转换为<code>ngx_tm_t</code> ，将第二个函数（使用<code>_libc_</code> infix）转换为<code>struct tm</code> ： </p>
<ul>
<li><code>ngx_gmtime(), ngx_libc_gmtime()</code> - 以UTC表示的时间 -    <code>ngx_localtime(), ngx_libc_localtime()</code> - 相对于本地时区表示的时间<br><code>ngx_http_time(buf, time)</code>函数返回适合在HTTP头中使用的字符串表示（例如， <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> ）。   <code>ngx_http_cookie_time(buf, time)</code>返回一个字符串表示函数，返回一个适合HTTP cookie的字符串表示（ <code>&quot;Thu, 31-Dec-37 23:55:55 GMT&quot;</code> ）。 </li>
</ul>
<h4 id="集装箱"><a href="#集装箱" class="headerlink" title="集装箱"></a>集装箱</h4><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>   nginx数组类型<code>ngx_array_t</code>定义如下 </p>
<pre class="notranslate">typedef struct {
    void        *elts;
    ngx_uint_t   nelts;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *pool;
} ngx_array_t;
</pre>

<p>   <code>elts</code>字段中提供了数组的元素。   <code>nelts</code>字段包含元素的数量。   <code>size</code>字段保存单个元素的大小，并在初始化数组时设置。 </p>
<p>  使用<code>ngx_array_create(pool, n, size)</code>调用在池中创建数组，并使用<code>ngx_array_init(array, pool, n, size)</code>调用来初始化已分配的数组对象。 </p>
<pre class="notranslate">ngx_array_t  *a, b;

/* create an array of strings with preallocated memory for 10 elements */
a = ngx_array_create(pool, 10, sizeof(ngx_str_t));

/* initialize string array for 10 elements */
ngx_array_init(&amp;b, pool, 10, sizeof(ngx_str_t));
</pre>

<p>  使用以下函数将元素添加到数组： </p>
<ul>
<li><code>ngx_array_push(a)</code>添加一个尾部元素并返回指向它的指针 -    <code>ngx_array_push_n(a, n)</code>添加<code>n</code>尾部元素并返回指向第一个元素的指针 </li>
</ul>
<p>  如果当前分配的内存量不足以容纳新元素，则分配新的内存块并将现有元素复制到其中。  新内存块通常是现有内存块的两倍。 </p>
<pre class="notranslate">s = ngx_array_push(a);
ss = ngx_array_push_n(&amp;b, 3);
</pre>

<h4 id="名单"><a href="#名单" class="headerlink" title="名单"></a>名单</h4><p>  在nginx中，列表是一系列数组，针对插入可能大量的项进行了优化。   <code>ngx_list_t</code>列表类型定义如下： </p>
<pre class="notranslate">typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p>  实际项目存储在列表部分中，其定义如下： </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};
</pre>

<p>  在使用之前，必须通过调用<code>ngx_list_init(list, pool, n, size)</code>或通过调用<code>ngx_list_create(pool, n, size)</code>创建列表来初始化<code>ngx_list_init(list, pool, n, size)</code> 。  这两个函数都将单个项的大小和每个列表部分的项数作为参数。  要将项添加到列表，请使用<code>ngx_list_push(list)</code>函数。  要迭代这些项，请直接访问列表字段，如示例所示： </p>
<pre class="notranslate">ngx_str_t        *v;
ngx_uint_t        i;
ngx_list_t       *list;
ngx_list_part_t  *part;

list = ngx_list_create(pool, 100, sizeof(ngx_str_t));
if (list == NULL) { /* error */ }

/* add items to the list */

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "foo");

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "bar");

/* iterate over the list */

part = &amp;list-&gt;part;
v = part-&gt;elts;

for (i = 0; /* void */; i++) {

    if (i &gt;= part-&gt;nelts) {
        if (part-&gt;next == NULL) {
            break;
        }

        part = part-&gt;next;
        v = part-&gt;elts;
        i = 0;
    }

    ngx_do_smth(&amp;v[i]);
}
</pre>

<p>  列表主要用于HTTP输入和输出标头。 </p>
<p>  列表不支持删除项目。  但是，在需要时，项目可以在内部被标记为缺失，而不会实际从列表中删除。  例如，要将HTTP输出标头（存储为<code>ngx_table_elt_t</code>对象）标记为缺失，请将<code>ngx_table_elt_t</code>的<code>hash</code>字段设置为零。  迭代标题时，显式跳过以这种方式标记的项目。 </p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>  在nginx中，队列是一个侵入式双向链表，每个节点定义如下： </p>
<pre class="notranslate">typedef struct ngx_queue_s  ngx_queue_t;

struct ngx_queue_s {
    ngx_queue_t  *prev;
    ngx_queue_t  *next;
};
</pre>

<p>  头队列节点未与任何数据链接。  使用前，请使用<code>ngx_queue_init(q)</code>调用初始化列表头。  队列支持以下操作： </p>
<ul>
<li><code>ngx_queue_insert_head(h, x)</code> ， <code>ngx_queue_insert_tail(h, x)</code> - 插入新节点 -    <code>ngx_queue_remove(x)</code> - 删除队列节点 -    <code>ngx_queue_split(h, q, n)</code> - 在一个节点上拆分队列，将队列尾部返回到一个单独的队列中 -    <code>ngx_queue_add(h, n)</code> - 将第二个队列添加到第一个队列 -    <code>ngx_queue_head(h)</code> ， <code>ngx_queue_last(h)</code> - 获取第一个或最后一个队列节点 -    <code>ngx_queue_sentinel(h)</code> - 获取队列sentinel对象以结束迭代 -    <code>ngx_queue_data(q, type, link)</code> - 获取对队列节点数据结构开头的引用，考虑其中的队列字段偏移量 </li>
</ul>
<p>  一个例子： </p>
<pre class="notranslate">typedef struct {
    ngx_str_t    value;
    ngx_queue_t  queue;
} ngx_foo_t;

ngx_foo_t    *f;
ngx_queue_t   values, *q;

ngx_queue_init(&amp;values);

f = ngx_palloc(pool, sizeof(ngx_foo_t));
if (f == NULL) { /* error */ }
ngx_str_set(&amp;f-&gt;value, "foo");

ngx_queue_insert_tail(&amp;values, &amp;f-&gt;queue);

/* insert more nodes here */

for (q = ngx_queue_head(&amp;values);
     q != ngx_queue_sentinel(&amp;values);
     q = ngx_queue_next(q))
{
    f = ngx_queue_data(q, ngx_foo_t, queue);

    ngx_do_smth(&amp;f-&gt;value);
}
</pre>

<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>   <code>src/core/ngx_rbtree.h</code>头文件提供了对红黑树的有效实现的访问。 </p>
<pre class="notranslate">typedef struct {
    ngx_rbtree_t       rbtree;
    ngx_rbtree_node_t  sentinel;

    /* custom per-tree data here */
} my_tree_t;

typedef struct {
    ngx_rbtree_node_t  rbnode;

    /* custom per-node data */
    foo_t              val;
} my_node_t;
</pre>

<p>  要处理整个树，需要两个节点：root和sentinel。  通常，它们会添加到自定义结构中，允许您将数据组织到树中，其中树叶包含指向或嵌入数据的链接。 </p>
<p>  要初始化树： </p>
<pre class="notranslate">my_tree_t  root;

ngx_rbtree_init(&amp;root.rbtree, &amp;root.sentinel, insert_value_function);
</pre>

<p>  要遍历树并插入新值，请使用“ <code>insert_value</code> ”函数。  例如， <code>ngx_str_rbtree_insert_value</code>函数处理<code>ngx_str_t</code>类型。  它的参数是指向插入的根节点，要添加的新创建的节点以及树的标记的指针。 </p>
<pre class="notranslate">void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp,
                                 ngx_rbtree_node_t *node,
                                 ngx_rbtree_node_t *sentinel)
</pre>

<p>  遍历非常简单，可以使用以下查找函数模式进行演示： </p>
<pre class="notranslate">my_node_t *
my_rbtree_lookup(ngx_rbtree_t *rbtree, foo_t *val, uint32_t hash)
{
    ngx_int_t           rc;
    my_node_t          *n;
    ngx_rbtree_node_t  *node, *sentinel;

    node = rbtree-&gt;root;
    sentinel = rbtree-&gt;sentinel;

    while (node != sentinel) {

        n = (my_node_t *) node;

        if (hash != node-&gt;key) {
            node = (hash &lt; node-&gt;key) ? node-&gt;left : node-&gt;right;
            continue;
        }

        rc = compare(val, node-&gt;val);

        if (rc &lt; 0) {
            node = node-&gt;left;
            continue;
        }

        if (rc &gt; 0) {
            node = node-&gt;right;
            continue;
        }

        return n;
    }

    return NULL;
}
</pre>

<p>   <code>compare()</code>函数是一个经典的比较器函数，它返回一个小于，等于或大于零的值。  为了加速查找并避免比较可能很大的用户对象，使用整数哈希字段。 </p>
<p>  要将节点添加到树，请分配新节点，对其进行初始化并调用<code>ngx_rbtree_insert()</code> ： </p>
<pre class="notranslate">    my_node_t          *my_node;
    ngx_rbtree_node_t  *node;

    my_node = ngx_palloc(...);
    init_custom_data(&amp;my_node-&gt;val);

    node = &amp;my_node-&gt;rbnode;
    node-&gt;key = create_key(my_node-&gt;val);

    ngx_rbtree_insert(&amp;root-&gt;rbtree, node);
</pre>

<p>  要删除节点，请调用<code>ngx_rbtree_delete()</code>函数： </p>
<pre class="notranslate">ngx_rbtree_delete(&amp;root-&gt;rbtree, node);
</pre>

<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>  散列表函数在<code>src/core/ngx_hash.h</code> 。  支持精确匹配和通配符匹配。  后者需要额外的设置，并在下面的单独部分中描述。 </p>
<p>  在初始化哈希之前，您需要知道它将保留的元素数量，以便nginx可以最佳地构建它。  需要配置的两个参数是<code>max_size</code>和<code>bucket_size</code> ，详见单独的<a href="hash.html">文档</a> 。  它们通常可由用户配置。  散列初始化设置与<code>ngx_hash_init_t</code>类型一起存储，散列本身为<code>ngx_hash_t</code> ： </p>
<pre class="notranslate">ngx_hash_t       foo_hash;
ngx_hash_init_t  hash;

hash.hash = &amp;foo_hash;
hash.key = ngx_hash_key;
hash.max_size = 512;
hash.bucket_size = ngx_align(64, ngx_cacheline_size);
hash.name = "foo_hash";
hash.pool = cf-&gt;pool;
hash.temp_pool = cf-&gt;temp_pool;
</pre>

<p>   <code>key</code>是指向函数的指针，该函数从字符串创建哈希整数键。  有两个通用的密钥创建函数： <code>ngx_hash_key(data, len)</code>和<code>ngx_hash_key_lc(data, len)</code> 。  后者将字符串转换为全部小写字符，因此传递的字符串必须是可写的。  如果不是这样，将<code>NGX_HASH_READONLY_KEY</code>标志传递给函数，初始化密钥数组（见下文）。 </p>
<p>  散列键存储在<code>ngx_hash_keys_arrays_t</code> ，并使用<code>ngx_hash_keys_array_init(arr, type)</code>初始化：第二个参数（ <code>type</code> ）控制为散列预分配的资源量，可以是<code>NGX_HASH_SMALL</code>或<code>NGX_HASH_LARGE</code> 。  如果您希望散列包含数千个元素，则后者是合适的。 </p>
<pre class="notranslate">ngx_hash_keys_arrays_t  foo_keys;

foo_keys.pool = cf-&gt;pool;
foo_keys.temp_pool = cf-&gt;temp_pool;

ngx_hash_keys_array_init(&amp;foo_keys, NGX_HASH_SMALL);
</pre>



<p>  要将键插入哈希键数组，请使用<code>ngx_hash_add_key(keys_array, key, value, flags)</code>函数： </p>
<pre class="notranslate">ngx_str_t k1 = ngx_string("key1");
ngx_str_t k2 = ngx_string("key2");

ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;my_data_ptr_1, NGX_HASH_READONLY_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;my_data_ptr_2, NGX_HASH_READONLY_KEY);
</pre>



<p>  要构建哈希表，请调用<code>ngx_hash_init(hinit, key_names, nelts)</code>函数： </p>
<pre class="notranslate">ngx_hash_init(&amp;hash, foo_keys.keys.elts, foo_keys.keys.nelts);
</pre>

<p>  如果<code>max_size</code>或<code>bucket_size</code>参数不够大，则该函数失败。 </p>
<p>  构建哈希时，使用<code>ngx_hash_find(hash, key, name, len)</code>函数查找元素： </p>
<pre class="notranslate">my_data_t   *data;
ngx_uint_t   key;

key = ngx_hash_key(k1.data, k1.len);

data = ngx_hash_find(&amp;foo_hash, key, k1.data, k1.len);
if (data == NULL) {
    /* key not found */
}
</pre>



<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><p>  要创建使用通配符的哈希，请使用<code>ngx_hash_combined_t</code>类型。  它包括上面描述的散列类型，并有两个额外的键数组： <code>dns_wc_head</code>和<code>dns_wc_tail</code> 。  基本属性的初始化类似于常规哈希： </p>
<pre class="notranslate">ngx_hash_init_t      hash
ngx_hash_combined_t  foo_hash;

hash.hash = &amp;foo_hash.hash;
hash.key = ...;
</pre>



<p>  可以使用<code>NGX_HASH_WILDCARD_KEY</code>标志添加通配符键： </p>
<pre class="notranslate">/* k1 = ".example.org"; */
/* k2 = "foo.*";        */
ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;data1, NGX_HASH_WILDCARD_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;data2, NGX_HASH_WILDCARD_KEY);
</pre>

<p>  该函数识别通配符并将键添加到相应的数组中。  有关通配符语法和匹配算法的说明，请参阅<a href="http/ngx_http_map_module.html#map">映射</a>模块文档。 </p>
<p>  根据添加的键的内容，您可能需要初始化最多三个键阵列：一个用于精确匹配（如上所述），另外两个用于从字符串的头部或尾部开始匹配： </p>
<pre class="notranslate">if (foo_keys.dns_wc_head.nelts) {

    ngx_qsort(foo_keys.dns_wc_head.elts,
              (size_t) foo_keys.dns_wc_head.nelts,
              sizeof(ngx_hash_key_t),
              cmp_dns_wildcards);

    hash.hash = NULL;
    hash.temp_pool = pool;

    if (ngx_hash_wildcard_init(&amp;hash, foo_keys.dns_wc_head.elts,
                               foo_keys.dns_wc_head.nelts)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    foo_hash.wc_head = (ngx_hash_wildcard_t *) hash.hash;
}
</pre>

<p>  需要对keys数组进行排序，并且必须将初始化结果添加到组合哈希中。   <code>dns_wc_tail</code>数组的初始化类似地完成。 </p>
<p>  组合哈希中的查找由<code>ngx_hash_find_combined(chash, key, name, len)</code> ： </p>
<pre class="notranslate">/* key = "bar.example.org"; — will match ".example.org" */
/* key = "foo.example.com"; — will match "foo.*"        */

hkey = ngx_hash_key(key.data, key.len);
res = ngx_hash_find_combined(&amp;foo_hash, hkey, key.data, key.len);
</pre>



<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>  要从系统堆分配内存，请使用以下函数： </p>
<ul>
<li><code>ngx_alloc(size, log)</code> - 从系统堆分配内存。  这是<code>malloc()</code>的包装，具有日志记录支持。  分配错误和调试信息将记录到<code>log</code> 。 -    <code>ngx_calloc(size, log)</code> - 从系统堆分配内存，如<code>ngx_alloc()</code> ，但在分配后用零填充内存。 -    <code>ngx_memalign(alignment, size, log)</code> - 从系统堆中分配对齐的内存。  这是提供该功能的那些平台上<code>posix_memalign()</code>的包装器。  否则，实现将回<code>ngx_alloc()</code> ，它提供了最大的对齐。 -    <code>ngx_free(p)</code> - 免费分配的内存。  这是<code>free()</code>的包装器 </li>
</ul>
<h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>  大多数nginx分配都是在池中完成的。  当池被销毁时，nginx池中分配的内存将自动释放。  这提供了良好的分配性能并使内存控制变得容易。 </p>
<p>  池内部在连续的内存块中分配对象。  块已满后，将分配一个新块并将其添加到池内存块列表中。  当请求的分配太大而无法容纳到块中时，请求将被转发到系统分配器，并且返回的指针将存储在池中以进一步解除分配。 </p>
<p>   nginx池的类型是<code>ngx_pool_t</code> 。  支持以下操作： </p>
<ul>
<li><code>ngx_create_pool(size, log)</code> - 创建具有指定块大小的池。  返回的池对象也在池中分配。   <code>size</code>至少应为<code>NGX_MIN_POOL_SIZE</code>和<code>NGX_MIN_POOL_SIZE</code>的倍数。 -    <code>ngx_destroy_pool(pool)</code> - 释放所有池内存，包括池对象本身。 -    <code>ngx_palloc(pool, size)</code> - 从指定的池中分配对齐的内存。 -    <code>ngx_pcalloc(pool, size)</code> - 从指定的池中分配对齐的内存并用零填充它。 -    <code>ngx_pnalloc(pool, size)</code> - 从指定的池中分配未对齐的内存。  主要用于分配字符串。 -    <code>ngx_pfree(pool, p)</code> - 以前在指定池中分配的<code>ngx_pfree(pool, p)</code>内存。  只能释放由转发到系统分配器的请求产生的分配。 </li>
</ul>
<pre class="notranslate">u_char      *p;
ngx_str_t   *s;
ngx_pool_t  *pool;

pool = ngx_create_pool(1024, log);
if (pool == NULL) { /* error */ }

s = ngx_palloc(pool, sizeof(ngx_str_t));
if (s == NULL) { /* error */ }
ngx_str_set(s, "foo");

p = ngx_pnalloc(pool, 3);
if (p == NULL) { /* error */ }
ngx_memcpy(p, "foo", 3);
</pre>

<p>  链接（ <code>ngx_chain_t</code> ）在nginx中被主动使用，因此nginx池实现提供了重用它们的方法。   <code>ngx_pool_t</code>的<code>chain</code>字段保留了先前分配的链接列表，可以重用。  要在池中有效分配链路链接，请使用<code>ngx_alloc_chain_link(pool)</code>功能。  此函数在池列表中查找自由链链接，并在池列表为空时分配新的链链接。  要释放链接，请调用<code>ngx_free_chain(pool, cl)</code>函数。 </p>
<p>  清理处理程序可以在池中注册。  清理处理程序是一个带有参数的回调函数，该函数在销毁池时调用。  池通常绑定到特定的nginx对象（如HTTP请求），并在对象到达其生命周期结束时被销毁。  注册池清理是释放资源，关闭文件描述符或对与主对象关联的共享数据进行最终调整的便捷方式。 </p>
<p>  要注册池清理，请调用<code>ngx_pool_cleanup_add(pool, size)</code> ，它返回一个要由调用者填写的<code>ngx_pool_cleanup_t</code>指针。  使用<code>size</code>参数为清理处理程序分配上下文。 </p>
<pre class="notranslate">ngx_pool_cleanup_t  *cln;

cln = ngx_pool_cleanup_add(pool, 0);
if (cln == NULL) { /* error */ }

cln-&gt;handler = ngx_my_cleanup;
cln-&gt;data = "foo";

...

static void
ngx_my_cleanup(void *data)
{
    u_char  *msg = data;

    ngx_do_smth(msg);
}
</pre>

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>   nginx使用共享内存在进程之间共享公共数据。   <code>ngx_shared_memory_add(cf, name, size, tag)</code>函数将新的共享内存条目<code>ngx_shm_zone_t</code>到循环中。  该函数接收区域的<code>name</code>和<code>size</code> 。  每个共享区域必须具有唯一名称。  如果已存在具有提供的<code>name</code>和<code>tag</code>的共享区域条目，则重用现有区域条目。  如果具有相同名称的现有条目具有不同的标记，则该函数将失败并显示错误。  通常，模块结构的地址作为<code>tag</code>传递，从而可以在一个nginx模块中按名称重用共享区域。 </p>
<p>  共享内存条目结构<code>ngx_shm_zone_t</code>具有以下字段： </p>
<ul>
<li><code>init</code> - 初始化回调，在共享区域映射到实际内存后调用 -    <code>data</code> - 数据上下文，用于将任意数据传递给<code>init</code>回调 -    <code>noreuse</code> - 禁用旧循环重用共享区域的标志 -    <code>tag</code> - 共享区域标记 -    <code>shm</code> - 类型为<code>ngx_shm_t</code>的特定于平台的对象，至少包含以下字段： <ul class="compact"><li>   <code>addr</code> - 映射共享内存地址，最初为NULL -    <code>size</code> - 共享内存大小 -    <code>name</code> - 共享内存名称 -    <code>log</code> - 共享内存日志 -    <code>exists</code> - 表示共享内存的标志是从主进程继承的（特定于Windows） </li>
</ul>
<p>  解析配置后，共享区域条目将映射到<code>ngx_init_cycle()</code>实际内存。  在POSIX系统上， <code>mmap()</code> syscall用于创建共享匿名映射。  在Windows上，使用<code>CreateFileMapping()</code> / <code>MapViewOfFileEx()</code>对。 </p>
<p>  对于在共享内存中分配，nginx提供slab池<code>ngx_slab_pool_t</code>类型。  在每个nginx共享区域中自动创建用于分配内存的slab池。  该池位于共享区域的开头，可以通过表达式<code>(ngx_slab_pool_t *) shm_zone-&amp;gt;shm.addr</code> 。  要在共享区域中分配内存，请调用<code>ngx_slab_alloc(pool, size)</code>或<code>ngx_slab_calloc(pool, size)</code> 。  要释放内存，请调用<code>ngx_slab_free(pool, p)</code> 。 </p>
<p>   Slab池将所有共享区域划分为页面。  每个页面用于分配相同大小的对象。  指定的大小必须是2的幂，并且大于8字节的最小大小。  不合格的值被四舍五入。  每个页面的位掩码跟踪正在使用哪些块以及哪些块可以自由分配。  对于大于半页（通常为2048字节）的大小，一次分配整个页面 </p>
<p>  要保护共享内存中的数据不受并发访问影响，请使用<code>ngx_slab_pool_t</code>的<code>mutex</code>字段中提供的<code>mutex</code> 。  在分配和释放内存时，板块池最常使用互斥锁，但它可用于保护共享区域中分配的任何其他用户数据结构。  要锁定或解锁互斥锁，请分别调用<code>ngx_shmtx_lock(&amp;amp;shpool-&amp;gt;mutex)</code>或<code>ngx_shmtx_unlock(&amp;amp;shpool-&amp;gt;mutex)</code> 。 </p>
<pre class="notranslate">ngx_str_t        name;
ngx_foo_ctx_t   *ctx;
ngx_shm_zone_t  *shm_zone;

ngx_str_set(&amp;name, "foo");

/* allocate shared zone context */
ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_foo_ctx_t));
if (ctx == NULL) {
    /* error */
}

/* add an entry for 64k shared zone */
shm_zone = ngx_shared_memory_add(cf, &amp;name, 65536, &amp;ngx_foo_module);
if (shm_zone == NULL) {
    /* error */
}

/* register init callback and context */
shm_zone-&gt;init = ngx_foo_init_zone;
shm_zone-&gt;data = ctx;


...


static ngx_int_t
ngx_foo_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_foo_ctx_t  *octx = data;

    size_t            len;
    ngx_foo_ctx_t    *ctx;
    ngx_slab_pool_t  *shpool;

    value = shm_zone-&gt;data;

    if (octx) {
        /* reusing a shared zone from old cycle */
        ctx-&gt;value = octx-&gt;value;
        return NGX_OK;
    }

    shpool = (ngx_slab_pool_t *) shm_zone-&gt;shm.addr;

    if (shm_zone-&gt;shm.exists) {
        /* initialize shared zone context in Windows nginx worker */
        ctx-&gt;value = shpool-&gt;data;
        return NGX_OK;
    }

    /* initialize shared zone */

    ctx-&gt;value = ngx_slab_alloc(shpool, sizeof(ngx_uint_t));
    if (ctx-&gt;value == NULL) {
        return NGX_ERROR;
    }

    shpool-&gt;data = ctx-&gt;value;

    return NGX_OK;
}
</pre>

<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>  对于日志记录，nginx使用<code>ngx_log_t</code>对象。   nginx记录器支持几种类型的输出： </p>
<ul>
<li>stderr  - 记录到标准错误（stderr） -    file  - 记录到文件 -    syslog  - 记录到syslog -    memory  - 记录到内部存储器以用于开发目的;  稍后可以使用调试器访问内存 </li>
</ul>
<p>  记录器实例可以是记录器链，使用<code>next</code>字段相互链接。  在这种情况下，每条消息都写入链中的所有记录器。 </p>
<p>  对于每个记录器，严重性级别控制将哪些消息写入日志（仅记录分配了该级别或更高级别的事件）。  支持以下严重性级别： </p>
<ul>
<li><code>NGX_LOG_EMERG</code>  -  <code>NGX_LOG_ALERT</code>  -  <code>NGX_LOG_CRIT</code>  -  <code>NGX_LOG_ERR</code>  -  <code>NGX_LOG_WARN</code>  -  <code>NGX_LOG_NOTICE</code>  -  <code>NGX_LOG_INFO</code>  -  <code>NGX_LOG_DEBUG</code>  </li>
</ul>
<p>  对于调试日志记录，还会检查调试掩码。  调试掩码是： </p>
<ul>
<li><code>NGX_LOG_DEBUG_CORE</code>  -  <code>NGX_LOG_DEBUG_ALLOC</code>  -  <code>NGX_LOG_DEBUG_MUTEX</code>  -  <code>NGX_LOG_DEBUG_EVENT</code>  -  <code>NGX_LOG_DEBUG_HTTP</code>  -  <code>NGX_LOG_DEBUG_MAIL</code>  -  <code>NGX_LOG_DEBUG_STREAM</code>  </li>
</ul>
<p>  通常，记录器是由<code>error_log</code>指令中的现有nginx代码创建的，几乎在循环，配置，客户端连接和其他对象的每个处理阶段都可用。 </p>
<p>   Nginx提供以下日志记录宏： </p>
<ul>
<li><code>ngx_log_error(level, log, err, fmt, ...)</code> - 错误记录 -    <code>ngx_log_debug0(level, log, err, fmt)</code> ， <code>ngx_log_debug1(level, log, err, fmt, arg1)</code>等 - 使用最多八个支持的格式化参数调试日志记录 </li>
</ul>
<p>  日志消息在堆栈中的大小为<code>NGX_MAX_ERROR_STR</code> （当前为2048字节）的缓冲区中格式化。  该消息前面附有严重性级别，进程ID（PID），连接ID（存储在<code>log-&amp;gt;connection</code> ）和系统错误文本。  对于非调试消息，还调用<code>log-&amp;gt;handler</code>以将更多特定信息添加到日志消息中。   HTTP模块将<code>ngx_http_log_error()</code>函数设置为日志处理程序，以记录客户端和服务器地址，当前操作（存储在<code>log-&amp;gt;action</code> ），客户端请求行，服务器名称等。 </p>
<pre class="notranslate">/* specify what is currently done */
log-&gt;action = "sending mp4 to client";

/* error and debug log */
ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0, "client prematurely
              closed connection");

ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4-&gt;file.log, 0,
               "mp4 start:%ui, length:%ui", mp4-&gt;start, mp4-&gt;length);
</pre>

<p>  上面的示例导致日志条目如下： </p>
<pre class="notranslate">2016/09/16 22:08:52 [info] 17445#0: *1 client prematurely closed connection while
sending mp4 to client, client: 127.0.0.1, server: , request: "GET /file.mp4 HTTP/1.1"
2016/09/16 23:28:33 [debug] 22140#0: *1 mp4 start:0, length:10000
</pre>

<h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>  循环对象存储从特定配置创建的nginx运行时上下文。  它的类型是<code>ngx_cycle_t</code> 。  当前循环由<code>ngx_cycle</code>全局变量引用，并在nginx worker启动时继承。  每次重新加载nginx配置时，都会从新的nginx配置创建一个新的循环;  成功创建新循环后，通常会删除旧循环。 </p>
<p>  循环由<code>ngx_init_cycle()</code>函数创建，该函数将前一个循环作为其参数。  该函数定位上一个循环的配置文件，并从前一个循环继承尽可能多的资源。  称为“初始循环”的占位符循环创建为nginx启动，然后由从配置构建的实际循环替换。 </p>
<p>  该周期的成员包括： </p>
<ul>
<li><code>pool</code> - 自行车游泳池  为每个新周期创建。 -    <code>log</code> - 循环日志。  最初从旧循环继承，在读取配置后将其设置为指向<code>new_log</code> 。 -    <code>new_log</code> - 由配置创建的循环日志。  它受根范围<code>error_log</code>指令的影响。 -    <code>connections</code> ， <code>connection_n</code> - 类型为<code>ngx_connection_t</code>的连接数组，由事件模块在初始化每个nginx worker时创建。   nginx配置中的<code>worker_connections</code>指令设置连接数<code>connection_n</code> 。 -    <code>free_connections</code> ， <code>free_connection_n</code> - 当前可用连接的列表和数量。  如果没有可用的连接，则nginx工作程序拒绝接受新客户端或连接到上游服务器。 -    <code>files</code> ， <code>files_n</code> - 用于将文件描述符映射到nginx连接的数组。  该映射由具有<code>NGX_USE_FD_EVENT</code>标志的事件模块使用（当前，它是<code>poll</code>和<code>devpoll</code> ）。 -    <code>conf_ctx</code> - 核心模块配置数组。  在读取nginx配置文件期间创建并填充配置。 -    <code>modules</code> ， <code>modules_n</code> - 由当前配置加载的<code>ngx_module_t</code>类型的模块数组，包括静态和动态模块。 -    <code>listening</code> - <code>ngx_listening_t</code>类型的侦听对象数组。  通常通过调用<code>ngx_create_listening()</code>函数的不同模块的<code>listen</code>指令添加侦听对象。  侦听套接字是基于侦听对象创建的。 -    <code>paths</code> - <code>ngx_path_t</code>类型的路径数组。  通过从将在某些目录上运行的模块调用函数<code>ngx_add_path()</code>来添加路径。  这些目录是在读取配置后由nginx创建的，如果缺少的话。  此外，可以为每个路径添加两个处理程序： <ul class="compact"><li>   path loader  - 在启动或重新加载nginx后，仅在60秒内执行一次。  通常，加载程序读取目录并将数据存储在nginx共享内存中。  从专用的nginx进程“nginx缓存加载器”调用该处理程序。 -   路径管理器 - 定期执行。  通常，管理器从目录中删除旧文件并更新nginx内存以反映更改。  处理程序从专用的“nginx缓存管理器”进程调用。 </li>
</ul>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>  对于输入/输出操作，nginx提供缓冲区类型<code>ngx_buf_t</code> 。  通常，它用于保存要写入目标或从源读取的数据。  缓冲区可以引用内存或文件中的数据，从技术上讲，缓冲区可以同时引用这两个数据。  缓冲区的内存是单独分配的，与缓冲区结构<code>ngx_buf_t</code> 。 </p>
<p>   <code>ngx_buf_t</code>结构包含以下字段： </p>
<ul>
<li><code>start</code> ， <code>end</code> - 为缓冲区分配的内存块的边界。 -    <code>pos</code> ， <code>last</code> - 内存缓冲区的边界;  通常是一个<code>start</code>的子范围.. <code>end</code> 。 -    <code>file_pos</code> ， <code>file_last</code> - 文件缓冲区的边界，表示为从文件开头的偏移量。 -    <code>tag</code> - 用于区分缓冲区的唯一值;  由不同的nginx模块创建，通常用于缓冲区重用。 -    <code>file</code> - 文件对象。 -    <code>temporary</code> - 指示缓冲区引用可写内存的标志。 -    <code>memory</code> - 指示缓冲区引用只读<code>memory</code>标志。 -    <code>in_file</code> - 指示缓冲区引用文件中数据的标志。 -    <code>flush</code> - 表示需要刷新缓冲区之前的所有数据的标志。 -    <code>recycled</code> - 表示缓冲区可以重用并需要尽快使用的标志。 -    <code>sync</code> - 表示缓冲区不携带数据或<code>flush</code>或<code>last_buf</code>等特殊信号的<code>last_buf</code> 。  默认情况下，nginx认为这样的缓冲区是一个错误条件，但是这个标志告诉nginx跳过错误检查。 -    <code>last_buf</code> - 表示缓冲区是输出中的最后一个的标志。 -    <code>last_in_chain</code> - 表示请求或子请求中不再有数据缓冲区的标志。 -    <code>shadow</code> - 引用与当前缓冲区相关的另一个（“shadow”）缓冲区，通常是缓冲区使用阴影中的数据。  消耗缓冲区时，通常还将阴影缓冲区标记为已消耗。 -    <code>last_shadow</code> - 指示缓冲区是引用特定影子缓冲区的最后一个缓冲区的标志。 -    <code>temp_file</code> - 指示缓冲区位于临时文件中的标志。 </li>
</ul>
<p>  对于输入和输出操作，缓冲区链接在一起。  链是<code>ngx_chain_t</code>类型的链序列，定义如下： </p>
<pre class="notranslate">typedef struct ngx_chain_s  ngx_chain_t;

struct ngx_chain_s {
    ngx_buf_t    *buf;
    ngx_chain_t  *next;
};
</pre>

<p>  每个链节都保持对其缓冲区的引用和对下一个链节的引用。 </p>
<p>  使用缓冲区和链的示例： </p>
<pre class="notranslate">ngx_chain_t *
ngx_get_my_chain(ngx_pool_t *pool)
{
    ngx_buf_t    *b;
    ngx_chain_t  *out, *cl, **ll;

    /* first buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_calloc_buf(pool);
    if (b == NULL) { /* error */ }

    b-&gt;start = (u_char *) "foo";
    b-&gt;pos = b-&gt;start;
    b-&gt;end = b-&gt;start + 3;
    b-&gt;last = b-&gt;end;
    b-&gt;memory = 1; /* read-only memory */

    cl-&gt;buf = b;
    out = cl;
    ll = &amp;cl-&gt;next;

    /* second buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_create_temp_buf(pool, 3);
    if (b == NULL) { /* error */ }

    b-&gt;last = ngx_cpymem(b-&gt;last, "foo", 3);

    cl-&gt;buf = b;
    cl-&gt;next = NULL;
    *ll = cl;

    return out;
}
</pre>

<h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>  连接类型<code>ngx_connection_t</code>是套接字描述符的包装器。  它包括以下字段： </p>
<ul>
<li><code>fd</code> - 套接字描述符 -    <code>data</code> - 任意连接上下文。  通常，它是指向在连接之上构建的更高级别对象的指针，例如HTTP请求或Stream会话。 -    <code>read</code> ， <code>write</code> - 读取和写入连接事件。 -    <code>recv</code> ， <code>send</code> ， <code>recv_chain</code> ， <code>send_chain</code> - 连接的I / O操作。 -    <code>pool</code> - 连接池。 -    <code>log</code> - 连接日志。 -    <code>sockaddr</code> ， <code>socklen</code> ， <code>addr_text</code> - 二进制和文本形式的远程套接字地址。 -    <code>local_sockaddr</code> ， <code>local_socklen</code> - 二进制形式的本地套接字地址。  最初，这些字段为空。  使用<code>ngx_connection_local_sockaddr()</code>函数获取本地套接字地址。 -    <code>proxy_protocol_addr</code> ， <code>proxy_protocol_port</code> -  PROXY协议客户端地址和端口，如果为连接启用了PROXY协议。 -    <code>ssl</code> - 连接的SSL上下文。 -    <code>reusable</code> - 指示连接处于允许重用的状态的标志。 -    <code>close</code> - 表示正在重用连接并需要<code>close</code>标志。 </li>
</ul>
<p>   nginx连接可以透明地封装SSL层。  在这种情况下，连接的<code>ssl</code>字段包含指向<code>ngx_ssl_connection_t</code>结构的指针，保留连接的所有SSL相关数据，包括<code>SSL_CTX</code>和<code>SSL</code> 。   <code>recv</code> ， <code>send</code> ， <code>recv_chain</code>和<code>send_chain</code>处理程序也设置为启用SSL的函数。 </p>
<p>   nginx配置中的<code>worker_connections</code>指令限制了每个nginx worker的连接数。  当工人启动并存储在循环对象的<code>connections</code>字段中时，所有连接结构都是预先创建的。  要检索连接结构，请使用<code>ngx_get_connection(s, log)</code>函数。  它需要一个套接字描述符作为其参数，它需要包装在一个连接结构中。 </p>
<p> Because the number of connections per worker is limited, nginx provides a way to grab connections that are currently in use. To enable or disable reuse of a connection, call the <code>ngx_reusable_connection(c, reusable)</code> function. Calling <code>ngx_reusable_connection(c, 1)</code> sets the <code>reuse</code> flag in the connection structure and inserts the connection into the <code>reusable_connections_queue</code> of the cycle. Whenever <code>ngx_get_connection()</code> finds out there are no available connections in the cycle’s <code>free_connections</code> list, it calls <code>ngx_drain_connections()</code> to release a specific number of reusable connections. For each such connection, the <code>close</code> flag is set and its read handler is called which is supposed to free the connection by calling <code>ngx_close_connection(c)</code> and make it available for reuse. To exit the state when a connection can be reused <code>ngx_reusable_connection(c, 0)</code> is called. HTTP client connections are an example of reusable connections in nginx; they are marked as reusable until the first request byte is received from the client. </p>
<h4 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p> Event object <code>ngx_event_t</code> in nginx provides a mechanism for notification that a specific event has occurred. </p>
<p> Fields in <code>ngx_event_t</code> include: </p>
<ul>
<li><code>data</code> — Arbitrary event context used in event handlers, usually as pointer to a connection related to the event. -  <code>handler</code> — Callback function to be invoked when the event happens. -  <code>write</code> — Flag indicating a write event. Absence of the flag indicates a read event. -  <code>active</code> — Flag indicating that the event is registered for receiving I/O notifications, normally from notification mechanisms like <code>epoll</code> , <code>kqueue</code> , <code>poll</code> . -  <code>ready</code> — Flag indicating that the event has received an I/O notification. -  <code>delayed</code> — Flag indicating that I/O is delayed due to rate limiting. -  <code>timer</code> — Red-black tree node for inserting the event into the timer tree. -  <code>timer_set</code> — Flag indicating that the event timer is set and not yet expired. -  <code>timedout</code> — Flag indicating that the event timer has expired. -  <code>eof</code> — Flag indicating that EOF occurred while reading data. -  <code>pending_eof</code> — Flag indicating that EOF is pending on the socket, even though there may be some data available before it. The flag is delivered via the <code>EPOLLRDHUP</code> <code>epoll</code> event or <code>EV_EOF</code> <code>kqueue</code> flag. -  <code>error</code> — Flag indicating that an error occurred during reading (for a read event) or writing (for a write event). -  <code>cancelable</code> — Timer event flag indicating that the event should be ignored while shutting down the worker. Graceful worker shutdown is delayed until there are no non-cancelable timer events scheduled. -  <code>posted</code> — Flag indicating that the event is posted to a queue. -  <code>queue</code> — Queue node for posting the event to a queue. </li>
</ul>
<h4 id="I-O-events"><a href="#I-O-events" class="headerlink" title="I/O events"></a>I/O events</h4><p> Each connection obtained by calling the <code>ngx_get_connection()</code> function has two attached events, <code>c-&amp;gt;read</code> and <code>c-&amp;gt;write</code> , which are used for receiving notification that the socket is ready for reading or writing. All such events operate in Edge-Triggered mode, meaning that they only trigger notifications when the state of the socket changes. For example, doing a partial read on a socket does not make nginx deliver a repeated read notification until more data arrives on the socket. Even when the underlying I/O notification mechanism is essentially Level-Triggered ( <code>poll</code> , <code>select</code> etc), nginx converts the notifications to Edge-Triggered. To make nginx event notifications consistent across all notifications systems on different platforms, the functions <code>ngx_handle_read_event(rev, flags)</code> and <code>ngx_handle_write_event(wev, lowat)</code> must be called after handling an I/O socket notification or calling any I/O functions on that socket. Normally, the functions are called once at the end of each read or write event handler. </p>
<h4 id="Timer-events"><a href="#Timer-events" class="headerlink" title="Timer events"></a>Timer events</h4><p> An event can be set to send a notification when a timeout expires. The timer used by events counts milliseconds since some unspecified point in the past truncated to <code>ngx_msec_t</code> type. Its current value can be obtained from the <code>ngx_current_msec</code> variable. </p>
<p> The function <code>ngx_add_timer(ev, timer)</code> sets a timeout for an event, <code>ngx_del_timer(ev)</code> deletes a previously set timeout. The global timeout red-black tree <code>ngx_event_timer_rbtree</code> stores all timeouts currently set. The key in the tree is of type <code>ngx_msec_t</code> and is the time when the event occurs. The tree structure enables fast insertion and deletion operations, as well as access to the nearest timeouts, which nginx uses to find out how long to wait for I/O events and for expiring timeout events. </p>
<h4 id="Posted-events"><a href="#Posted-events" class="headerlink" title="Posted events"></a>Posted events</h4><p> An event can be posted which means that its handler will be called at some point later within the current event loop iteration. Posting events is a good practice for simplifying code and escaping stack overflows. Posted events are held in a post queue. The <code>ngx_post_event(ev, q)</code> mscro posts the event <code>ev</code> to the post queue <code>q</code> . The <code>ngx_delete_posted_event(ev)</code> macro deletes the event <code>ev</code> from the queue it’s currently posted in. Normally, events are posted to the <code>ngx_posted_events</code> queue, which is processed late in the event loop — after all I/O and timer events are already handled. The function <code>ngx_event_process_posted()</code> is called to process an event queue. It calls event handlers until the queue is not empty. This means that a posted event handler can post more events to be processed within the current event loop iteration. </p>
<p>  一个例子： </p>
<pre class="notranslate">void
ngx_my_connection_read(ngx_connection_t *c)
{
    ngx_event_t  *rev;

    rev = c-&gt;read;

    ngx_add_timer(rev, 1000);

    rev-&gt;handler = ngx_my_read_handler;

    ngx_my_read(rev);
}


void
ngx_my_read_handler(ngx_event_t *rev)
{
    ssize_t            n;
    ngx_connection_t  *c;
    u_char             buf[256];

    if (rev-&gt;timedout) { /* timeout expired */ }

    c = rev-&gt;data;

    while (rev-&gt;ready) {
        n = c-&gt;recv(c, buf, sizeof(buf));

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR) { /* error */ }

        /* process buf */
    }

    if (ngx_handle_read_event(rev, 0) != NGX_OK) { /* error */ }
}
</pre>

<h4 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h4><p> Except for the nginx master process, all nginx processes do I/O and so have an event loop. (The nginx master process instead spends most of its time in the <code>sigsuspend()</code> call waiting for signals to arrive.) The nginx event loop is implemented in the <code>ngx_process_events_and_timers()</code> function, which is called repeatedly until the process exits. </p>
<p> The event loop has the following stages: </p>
<ul>
<li>Find the timeout that is closest to expiring, by calling <code>ngx_event_find_timer()</code> . This function finds the leftmost node in the timer tree and returns the number of milliseconds until the node expires. -  Process I/O events by calling a handler, specific to the event notification mechanism, chosen by nginx configuration. This handler waits for at least one I/O event to happen, but only until the next timeout expires. When a read or write event occurs, the <code>ready</code> flag is set and the event’s handler is called. For Linux, the <code>ngx_epoll_process_events()</code> handler is normally used, which calls <code>epoll_wait()</code> to wait for I/O events. -  Expire timers by calling <code>ngx_event_expire_timers()</code> . The timer tree is iterated from the leftmost element to the right until an unexpired timeout is found. For each expired node the <code>timedout</code> event flag is set, the <code>timer_set</code> flag is reset, and the event handler is called -  Process posted events by calling <code>ngx_event_process_posted()</code> . The function repeatedly removes the first element from the posted events queue and calls the element’s handler, until the queue is empty. </li>
</ul>
<p> All nginx processes handle signals as well. Signal handlers only set global variables which are checked after the <code>ngx_process_events_and_timers()</code> call. </p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p> There are several types of processes in nginx. The type of a process is kept in the <code>ngx_process</code> global variable, and is one of the following: </p>
<ul>
<li><code>NGX_PROCESS_MASTER</code> — The master process, which reads the NGINX configuration, creates cycles, and starts and controls child processes. It does not perform any I/O and responds only to signals. Its cycle function is <code>ngx_master_process_cycle()</code> . -  <code>NGX_PROCESS_WORKER</code> — The worker process, which handles client connections. It is started by the master process and responds to its signals and channel commands as well. Its cycle function is <code>ngx_worker_process_cycle()</code> . There can be multiple worker processes, as configured by the <code>worker_processes</code> directive. -  <code>NGX_PROCESS_SINGLE</code> — The single process, which exists only in <code>master_process off</code> mode, and is the only process running in that mode. It creates cycles (like the master process does) and handles client connections (like the worker process does). Its cycle function is <code>ngx_single_process_cycle()</code> . -  <code>NGX_PROCESS_HELPER</code> — The helper process, of which currently there are two types: cache manager and cache loader. The cycle function for both is <code>ngx_cache_manager_process_cycle()</code> .<br>The nginx processes handle the following signals: </li>
<li><code>NGX_SHUTDOWN_SIGNAL</code> ( <code>SIGQUIT</code> on most systems) — Gracefully shutdown. Upon receiving this signal, the master process sends a shutdown signal to all child processes. When no child processes are left, the master destroys the cycle pool and exits. When a worker process receives this signal, it closes all listening sockets and waits until there are no non-cancelable events scheduled, then destroys the cycle pool and exits. When the cache manager or the cache loader process receives this signal, it exits immediately. The <code>ngx_quit</code> variable is set to <code>1</code> when a process receives this signal, and is immediately reset after being processed. The <code>ngx_exiting</code> variable is set to <code>1</code> while a worker process is in the shutdown state. -  <code>NGX_TERMINATE_SIGNAL</code> ( <code>SIGTERM</code> on most systems) — Terminate. Upon receiving this signal, the master process sends a terminate signal to all child processes. If a child process does not exit within 1 second, the master process sends the <code>SIGKILL</code> signal to kill it. When no child processes are left, the master process destroys the cycle pool and exits. When a worker process, the cache manager process or the cache loader process receives this signal, it destroys the cycle pool and exits. The variable <code>ngx_terminate</code> is set to <code>1</code> when this signal is received. -  <code>NGX_NOACCEPT_SIGNAL</code> ( <code>SIGWINCH</code> on most systems) - Shut down all worker and helper processes. Upon receiving this signal, the master process shuts down its child processes. If a previously started new nginx binary exits, the child processes of the old master are started again. When a worker process receives this signal, it shuts down in debug mode set by the <code>debug_points</code> directive. -  <code>NGX_RECONFIGURE_SIGNAL</code> ( <code>SIGHUP</code> on most systems) - Reconfigure. Upon receiving this signal, the master process re-reads the configuration and creates a new cycle based on it. If the new cycle is created successfully, the old cycle is deleted and new child processes are started. Meanwhile, the old child processes receive the <code>NGX_SHUTDOWN_SIGNAL</code> signal. In single-process mode, nginx creates a new cycle, but keeps the old one until there are no longer clients with active connections tied to it. The worker and helper processes ignore this signal. -  <code>NGX_REOPEN_SIGNAL</code> ( <code>SIGUSR1</code> on most systems) — Reopen files. The master process sends this signal to workers, which reopen all <code>open_files</code> related to the cycle. -  <code>NGX_CHANGEBIN_SIGNAL</code> ( <code>SIGUSR2</code> on most systems) — Change the nginx binary. The master process starts a new nginx binary and passes in a list of all listen sockets. The text-format list, passed in the <code>“NGINX”</code> environment variable, consists of descriptor numbers separated with semicolons. The new nginx binary reads the <code>“NGINX”</code> variable and adds the sockets to its init cycle. Other processes ignore this signal.<br>While all nginx worker processes are able to receive and properly handle POSIX signals, the master process does not use the standard <code>kill()</code> syscall to pass signals to workers and helpers. Instead, nginx uses inter-process socket pairs which allow sending messages between all nginx processes. Currently, however, messages are only sent from the master to its children. The messages carry the standard signals. </li>
</ul>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p> It is possible to offload into a separate thread tasks that would otherwise block the nginx worker process. For example, nginx can be configured to use threads to perform <a href="http/ngx_http_core_module.html#aio">file I/O</a> . Another use case is a library that doesn’t have asynchronous interface and thus cannot be normally used with nginx. Keep in mind that the threads interface is a helper for the existing asynchronous approach to processing client connections, and by no means intended as a replacement. </p>
<p> To deal with synchronization, the following wrappers over <code>pthreads</code> primitives are available: </p>
<ul>
<li><code>typedef pthread_mutex_t ngx_thread_mutex_t;</code> <ul class="compact"> <li> <code>ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>   -  <code>ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  </li>
</ul>
<p> Instead of creating a new thread for each task, nginx implements a <a href="ngx_core_module.html#thread_pool">thread_pool</a> strategy. Multiple thread pools may be configured for different purposes (for example, performing I/O on different sets of disks). Each thread pool is created at startup and contains a limited number of threads that process a queue of tasks. When a task is completed, a predefined completion handler is called. </p>
<p> The <code>src/core/ngx_thread_pool.h</code> header file contains relevant definitions: </p>
<pre class="notranslate">struct ngx_thread_task_s {
    ngx_thread_task_t   *next;
    ngx_uint_t           id;
    void                *ctx;
    void               (*handler)(void *data, ngx_log_t *log);
    ngx_event_t          event;
};

typedef struct ngx_thread_pool_s  ngx_thread_pool_t;

ngx_thread_pool_t *ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name);
ngx_thread_pool_t *ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name);

ngx_thread_task_t *ngx_thread_task_alloc(ngx_pool_t *pool, size_t size);
ngx_int_t ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task);

</pre>

<p> At configuration time, a module willing to use threads has to obtain a reference to a thread pool by calling <code>ngx_thread_pool_add(cf, name)</code> , which either creates a new thread pool with the given <code>name</code> or returns a reference to the pool with that name if it already exists. </p>
<p> To add a <code>task</code> into a queue of a specified thread pool <code>tp</code> at runtime, use the <code>ngx_thread_task_post(tp, task)</code> function. To execute a function in a thread, pass parameters and setup a completion handler using the <code>ngx_thread_task_t</code> structure: </p>
<pre class="notranslate">typedef struct {
    int    foo;
} my_thread_ctx_t;


static void
my_thread_func(void *data, ngx_log_t *log)
{
    my_thread_ctx_t *ctx = data;

    /* this function is executed in a separate thread */
}


static void
my_thread_completion(ngx_event_t *ev)
{
    my_thread_ctx_t *ctx = ev-&gt;data;

    /* executed in nginx event loop */
}


ngx_int_t
my_task_offload(my_conf_t *conf)
{
    my_thread_ctx_t    *ctx;
    ngx_thread_task_t  *task;

    task = ngx_thread_task_alloc(conf-&gt;pool, sizeof(my_thread_ctx_t));
    if (task == NULL) {
        return NGX_ERROR;
    }

    ctx = task-&gt;ctx;

    ctx-&gt;foo = 42;

    task-&gt;handler = my_thread_func;
    task-&gt;event.handler = my_thread_completion;
    task-&gt;event.data = ctx;

    if (ngx_thread_task_post(conf-&gt;thread_pool, task) != NGX_OK) {
        return NGX_ERROR;
    }

    return NGX_OK;
}
</pre>



<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><h4 id="Adding-new-modules"><a href="#Adding-new-modules" class="headerlink" title="Adding new modules"></a>Adding new modules</h4><p> Each standalone nginx module resides in a separate directory that contains at least two files: <code>config</code> and a file with the module source code. The <code>config</code> file contains all information needed for nginx to integrate the module, for example: </p>
<pre class="notranslate">ngx_module_type=CORE
ngx_module_name=ngx_foo_module
ngx_module_srcs="$ngx_addon_dir/ngx_foo_module.c"

. auto/module

ngx_addon_name=$ngx_module_name
</pre>

<p> The <code>config</code> file is a POSIX shell script that can set and access the following variables: </p>
<ul>
<li><code>ngx_module_type</code> — Type of module to build. Possible values are <code>CORE</code> , <code>HTTP</code> , <code>HTTP_FILTER</code> , <code>HTTP_INIT_FILTER</code> , <code>HTTP_AUX_FILTER</code> , <code>MAIL</code> , <code>STREAM</code> , or <code>MISC</code> . -  <code>ngx_module_name</code> — Module names. To build multiple modules from a set of source files, specify a whitespace-separated list of names. The first name indicates the name of the output binary for the dynamic module. The names in the list must match the names used in the source code. -  <code>ngx_addon_name</code> — Name of the module as it appears in output on the console from the configure script. -  <code>ngx_module_srcs</code> — Whitespace-separated list of source files used to compile the module. The <code>$ngx_addon_dir</code> variable can be used to represent the path to the module directory. -  <code>ngx_module_incs</code> — Include paths required to build the module -  <code>ngx_module_deps</code> — Whitespace-separated list of the module’s dependencies. Usually, it is the list of header files. -  <code>ngx_module_libs</code> — Whitespace-separated list of libraries to link with the module. For example, use <code>ngx_module_libs=-lpthread</code> to link <code>libpthread</code> library. The following macros can be used to link against the same libraries as nginx: <code>LIBXSLT</code> , <code>LIBGD</code> , <code>GEOIP</code> , <code>PCRE</code> , <code>OPENSSL</code> , <code>MD5</code> , <code>SHA1</code> , <code>ZLIB</code> , and <code>PERL</code> . -  <code>ngx_module_link</code> — Variable set by the build system to <code>DYNAMIC</code> for a dynamic module or <code>ADDON</code> for a static module and used to determine different actions to perform depending on linking type. -  <code>ngx_module_order</code> — Load order for the module; useful for the <code>HTTP_FILTER</code> and <code>HTTP_AUX_FILTER</code> module types. The format for this option is a whitespace-separated list of modules. All modules in the list following the current module’s name end up after it in the global list of modules, which sets up the order for modules initialization. For filter modules later initialization means earlier execution.  The following modules are typically used as references. The <code>ngx_http_copy_filter_module</code> reads the data for other filter modules and is placed near the bottom of the list so that it is one of the first to be executed. The <code>ngx_http_write_filter_module</code> writes the data to the client socket and is placed near the top of the list, and is the last to be executed.  By default, filter modules are placed before the <code>ngx_http_copy_filter</code> in the module list so that the filter handler is executed after the copy filter handler. For other module types the default is the empty string.<br>To compile a module into nginx statically, use the <code>--add-module=/path/to/module</code> argument to the configure script. To compile a module for later dynamic loading into nginx, use the <code>--add-dynamic-module=/path/to/module</code> argument. </li>
</ul>
<h4 id="Core-Modules"><a href="#Core-Modules" class="headerlink" title="Core Modules"></a>Core Modules</h4><p> Modules are the building blocks of nginx, and most of its functionality is implemented as modules. The module source file must contain a global variable of type <code>ngx_module_t</code> , which is defined as follows: </p>
<pre class="notranslate">struct ngx_module_s {

    /* private part is omitted */

    void                 *ctx;
    ngx_command_t        *commands;
    ngx_uint_t            type;

    ngx_int_t           (*init_master)(ngx_log_t *log);

    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
    void                (*exit_thread)(ngx_cycle_t *cycle);
    void                (*exit_process)(ngx_cycle_t *cycle);

    void                (*exit_master)(ngx_cycle_t *cycle);

    /* stubs for future extensions are omitted */
};
</pre>

<p> The omitted private part includes the module version and a signature and is filled using the predefined macro <code>NGX_MODULE_V1</code> . </p>
<p> Each module keeps its private data in the <code>ctx</code> field, recognizes the configuration directives, specified in the <code>commands</code> array, and can be invoked at certain stages of nginx lifecycle. The module lifecycle consists of the following events: </p>
<ul>
<li><p>Configuration directive handlers are called as they appear in configuration files in the context of the master process. -  After the configuration is parsed successfully, <code>init_module</code> handler is called in the context of the master process. The <code>init_module</code> handler is called in the master process each time a configuration is loaded. -  The master process creates one or more worker processes and the <code>init_process</code> handler is called in each of them. -  When a worker process receives the shutdown or terminate command from the master, it invokes the <code>exit_process</code> handler. -  The master process calls the <code>exit_master</code> handler before exiting.<br>Because threads are used in nginx only as a supplementary I/O facility with its own API, <code>init_thread</code> and <code>exit_thread</code> handlers are not currently called. There is also no <code>init_master</code> handler, because it would be unnecessary overhead. </p>
<p>The module <code>type</code> defines exactly what is stored in the <code>ctx</code> field. Its value is one of the following types: </p>
</li>
<li><p><code>NGX_CORE_MODULE</code>  -  <code>NGX_EVENT_MODULE</code>  -  <code>NGX_HTTP_MODULE</code>  -  <code>NGX_MAIL_MODULE</code>  -  <code>NGX_STREAM_MODULE</code><br>The <code>NGX_CORE_MODULE</code> is the most basic and thus the most generic and most low-level type of module. The other module types are implemented on top of it and provide a more convenient way to deal with corresponding domains, like handling events or HTTP requests. </p>
<p>The set of core modules includes <code>ngx_core_module</code> , <code>ngx_errlog_module</code> , <code>ngx_regex_module</code> , <code>ngx_thread_pool_module</code> and <code>ngx_openssl_module</code> modules. The HTTP module, the stream module, the mail module and event modules are core modules too. The context of a core module is defined as: </p>
</li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_str_t             name;
    void               *(*create_conf)(ngx_cycle_t *cycle);
    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;
</pre>

<p> where the <code>name</code> is a module name string, <code>create_conf</code> and <code>init_conf</code> are pointers to functions that create and initialize module configuration respectively. For core modules, nginx calls <code>create_conf</code> before parsing a new configuration and <code>init_conf</code> after all configuration is parsed successfully. The typical <code>create_conf</code> function allocates memory for the configuration and sets default values. </p>
<p> For example, a simplistic module called <code>ngx_foo_module</code> might look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author.
 */


#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;


typedef struct {
    ngx_flag_t  enable;
} ngx_foo_conf_t;


static void *ngx_foo_create_conf(ngx_cycle_t *cycle);
static char *ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf);

static char *ngx_foo_enable(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_enable_post = { ngx_foo_enable };


static ngx_command_t  ngx_foo_commands[] = {

    { ngx_string("foo_enabled"),
      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      0,
      offsetof(ngx_foo_conf_t, enable),
      &amp;ngx_foo_enable_post },

      ngx_null_command
};


static ngx_core_module_t  ngx_foo_module_ctx = {
    ngx_string("foo"),
    ngx_foo_create_conf,
    ngx_foo_init_conf
};


ngx_module_t  ngx_foo_module = {
    NGX_MODULE_V1,
    &amp;ngx_foo_module_ctx,                   /* module context */
    ngx_foo_commands,                      /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static void *
ngx_foo_create_conf(ngx_cycle_t *cycle)
{
    ngx_foo_conf_t  *fcf;

    fcf = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_foo_conf_t));
    if (fcf == NULL) {
        return NULL;
    }

    fcf-&gt;enable = NGX_CONF_UNSET;

    return fcf;
}


static char *
ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_foo_conf_t *fcf = conf;

    ngx_conf_init_value(fcf-&gt;enable, 0);

    return NGX_CONF_OK;
}


static char *
ngx_foo_enable(ngx_conf_t *cf, void *post, void *data)
{
    ngx_flag_t  *fp = data;

    if (*fp == 0) {
        return NGX_CONF_OK;
    }

    ngx_log_error(NGX_LOG_NOTICE, cf-&gt;log, 0, "Foo Module is enabled");

    return NGX_CONF_OK;
}
</pre>



<h4 id="Configuration-Directives"><a href="#Configuration-Directives" class="headerlink" title="Configuration Directives"></a>Configuration Directives</h4><p> The <code>ngx_command_t</code> type defines a single configuration directive. Each module that supports configuration provides an array of such structures that describe how to process arguments and what handlers to call: </p>
<pre class="notranslate">typedef struct ngx_command_s  ngx_command_t;

struct ngx_command_s {
    ngx_str_t             name;
    ngx_uint_t            type;
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    ngx_uint_t            conf;
    ngx_uint_t            offset;
    void                 *post;
};
</pre>

<p> Terminate the array with the special value <code>ngx_null_command</code> . The <code>name</code> is the name of a directive as it appears in the configuration file, for example “worker_processes” or “listen”. The <code>type</code> is a bit-field of flags that specify the number of arguments the directive takes, its type, and the context in which it appears. The flags are: </p>
<ul>
<li><code>NGX_CONF_NOARGS</code> — Directive takes no arguments. -  <code>NGX_CONF_1MORE</code> — Directive takes one or more arguments. -  <code>NGX_CONF_2MORE</code> — Directive takes two or more arguments. -  <code>NGX_CONF_TAKE1</code> .. <code>NGX_CONF_TAKE7</code> — Directive takes exactly the indicated number of arguments. -  <code>NGX_CONF_TAKE12</code> , <code>NGX_CONF_TAKE13</code> , <code>NGX_CONF_TAKE23</code> , <code>NGX_CONF_TAKE123</code> , <code>NGX_CONF_TAKE1234</code> — Directive may take different number of arguments. Options are limited to the given numbers. For example, <code>NGX_CONF_TAKE12</code> means it takes one or two arguments.<br>The flags for directive types are: </li>
<li><code>NGX_CONF_BLOCK</code> — Directive is a block, that is, it can contain other directives within its opening and closing braces, or even implement its own parser to handle contents inside. -  <code>NGX_CONF_FLAG</code> — Directive takes a boolean value, either <code>on</code> or <code>off</code> .<br>A directive’s context defines where it may appear in the configuration: </li>
<li><p><code>NGX_MAIN_CONF</code> — In the top level context. -  <code>NGX_HTTP_MAIN_CONF</code> — In the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF</code> — In a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF</code> — In a <code>location</code> block within the <code>http</code> block. -  <code>NGX_HTTP_UPS_CONF</code> — In an <code>upstream</code> block within the <code>http</code> block. -  <code>NGX_HTTP_SIF_CONF</code> — In an <code>if</code> block within a <code>server</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LIF_CONF</code> — In an <code>if</code> block within a <code>location</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LMT_CONF</code> — In a <code>limit_except</code> block within the <code>http</code> block. -  <code>NGX_STREAM_MAIN_CONF</code> — In the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF</code> — In a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_STREAM_UPS_CONF</code> — In an <code>upstream</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF</code> — In the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF</code> — In a <code>server</code> block within the <code>mail</code> block. -  <code>NGX_EVENT_CONF</code> — In the <code>event</code> block. -  <code>NGX_DIRECT_CONF</code> — Used by modules that don’t create a hierarchy of contexts and only have one global configuration. This configuration is passed to the handler as the <code>conf</code> argument.<br>The configuration parser uses these flags to throw an error in case of a misplaced directive and calls directive handlers supplied with a proper configuration pointer, so that the same directives in different locations can store their values in distinct places. </p>
<p>The <code>set</code> field defines a handler that processes a directive and stores parsed values into the corresponding configuration. There’s a number of functions that perform common conversions: </p>
</li>
<li><code>ngx_conf_set_flag_slot</code> — Converts the literal strings <code>on</code> and <code>off</code> into an <code>ngx_flag_t</code> value with values 1 or 0, respectively. -  <code>ngx_conf_set_str_slot</code> — Stores a string as a value of the <code>ngx_str_t</code> type. -  <code>ngx_conf_set_str_array_slot</code> — Appends a value to an array <code>ngx_array_t</code> of strings <code>ngx_str_t</code> . The array is created if does not already exist. -  <code>ngx_conf_set_keyval_slot</code> — Appends a key-value pair to an array <code>ngx_array_t</code> of key-value pairs <code>ngx_keyval_t</code> . The first string becomes the key and the second the value. The array is created if it does not already exist. -  <code>ngx_conf_set_num_slot</code> — Converts a directive’s argument to an <code>ngx_int_t</code> value. -  <code>ngx_conf_set_size_slot</code> — Converts a <a href="syntax.html">size</a> to a <code>size_t</code> value expressed in bytes. -  <code>ngx_conf_set_off_slot</code> — Converts an <a href="syntax.html">offset</a> to an <code>off_t</code> value expressed in bytes. -  <code>ngx_conf_set_msec_slot</code> — Converts a <a href="syntax.html">time</a> to an <code>ngx_msec_t</code> value expressed in milliseconds. -  <code>ngx_conf_set_sec_slot</code> — Converts a <a href="syntax.html">time</a> to a <code>time_t</code> value expressed in in seconds. -  <code>ngx_conf_set_bufs_slot</code> — Converts the two supplied arguments into an <code>ngx_bufs_t</code> object that holds the number and <a href="syntax.html">size</a> of buffers. -  <code>ngx_conf_set_enum_slot</code> — Converts the supplied argument into an <code>ngx_uint_t</code> value. The null-terminated array of <code>ngx_conf_enum_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding integer values. -  <code>ngx_conf_set_bitmask_slot</code> — Converts the supplied arguments into an <code>ngx_uint_t</code> value. The mask values for each argument are ORed producing the result. The null-terminated array of <code>ngx_conf_bitmask_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding mask values. -  <code>set_path_slot</code> — Converts the supplied arguments to an <code>ngx_path_t</code> value and performs all required initializations. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_temp_path">proxy_temp_path</a> directive. -  <code>set_access_slot</code> — Converts the supplied arguments to a file permissions mask. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_store_access">proxy_store_access</a> directive. </li>
</ul>
<p> The <code>conf</code> field defines which configuration structure is passed to the directory handler. Core modules only have the global configuration and set <code>NGX_DIRECT_CONF</code> flag to access it. Modules like HTTP, Stream or Mail create hierarchies of configurations. For example, a module’s configuration is created for <code>server</code> , <code>location</code> and <code>if</code> scopes. </p>
<ul>
<li><code>NGX_HTTP_MAIN_CONF_OFFSET</code> — Configuration for the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF_OFFSET</code> — Configuration for a <code>location</code> block within the <code>http</code> . -  <code>NGX_STREAM_MAIN_CONF_OFFSET</code> — Configuration for the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF_OFFSET</code> — Configuration for the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>mail</code> block. </li>
</ul>
<p> The <code>offset</code> defines the offset of a field in a module configuration structure that holds values for this particular directive. The typical use is to employ the <code>offsetof()</code> macro. </p>
<p> The <code>post</code> field has two purposes: it may be used to define a handler to be called after the main handler has completed, or to pass additional data to the main handler. In the first case, the <code>ngx_conf_post_t</code> structure needs to be initialized with a pointer to the handler, for example: </p>
<pre class="notranslate">static char *ngx_do_foo(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_post = { ngx_do_foo };
</pre>

<p> The <code>post</code> argument is the <code>ngx_conf_post_t</code> object itself, and the <code>data</code> is a pointer to the value, converted from arguments by the main handler with the appropriate type. </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h4 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h4><p> Each HTTP client connection runs through the following stages: </p>
<ul>
<li><p><code>ngx_event_accept()</code> accepts a client TCP connection. This handler is called in response to a read notification on a listen socket. A new <code>ngx_connecton_t</code> object is created at this stage to wrap the newly accepted client socket. Each nginx listener provides a handler to pass the new connection object to. For HTTP connections it’s <code>ngx_http_init_connection(c)</code> . -  <code>ngx_http_init_connection()</code> performs early initialization of the HTTP connection. At this stage an <code>ngx_http_connection_t</code> object is created for the connection and its reference is stored in the connection’s <code>data</code> field. Later it will be replaced by an HTTP request object. A PROXY protocol parser and the SSL handshake are started at this stage as well. -  <code>ngx_http_wait_request_handler()</code> read event handler is called when data is available on the client socket. At this stage an HTTP request object <code>ngx_http_request_t</code> is created and set to the connection’s <code>data</code> field. -  <code>ngx_http_process_request_line()</code> read event handler reads client request line. The handler is set by <code>ngx_http_wait_request_handler()</code> . The data is read into connection’s <code>buffer</code> . The size of the buffer is initially set by the directive <a href="http/ngx_http_core_module.html#client_header_buffer_size">client_header_buffer_size</a> . The entire client header is supposed to fit in the buffer. If the initial size is not sufficient, a bigger buffer is allocated, with the capacity set by the <code>large_client_header_buffers</code> directive. -  <code>ngx_http_process_request_headers()</code> read event handler, is set after <code>ngx_http_process_request_line()</code> to read the client request header. -  <code>ngx_http_core_run_phases()</code> is called when the request header is completely read and parsed. This function runs request phases from <code>NGX_HTTP_POST_READ_PHASE</code> to <code>NGX_HTTP_CONTENT_PHASE</code> . The last phase is intended to generate a response and pass it along the filter chain. The response is not necessarily sent to the client at this phase. It might remain buffered and be sent at the finalization stage. -  <code>ngx_http_finalize_request()</code> is usually called when the request has generated all the output or produced an error. In the latter case an appropriate error page is looked up and used as the response. If the response is not completely sent to the client by this point, an HTTP writer <code>ngx_http_writer()</code> is activated to finish sending outstanding data. -  <code>ngx_http_finalize_connection()</code> is called when the complete response has been sent to the client and the request can be destroyed. If the client connection keepalive feature is enabled, <code>ngx_http_set_keepalive()</code> is called, which destroys the current request and waits for the next request on the connection. Otherwise, <code>ngx_http_close_request()</code> destroys both the request and the connection. </p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>For each client HTTP request the <code>ngx_http_request_t</code> object is created. Some of the fields of this object are: </p>
</li>
<li><p><code>connection</code> — Pointer to a <code>ngx_connection_t</code> client connection object. Several requests can reference the same connection object at the same time - one main request and its subrequests. After a request is deleted, a new request can be created on the same connection.  Note that for HTTP connections <code>ngx_connection_t</code> ‘s <code>data</code> field points back to the request. Such requests are called active, as opposed to the other requests tied to the connection. An active request is used to handle client connection events and is allowed to output its response to the client. Normally, each request becomes active at some point so that it can send its output. -  <code>ctx</code> — Array of HTTP module contexts. Each module of type <code>NGX_HTTP_MODULE</code> can store any value (normally, a pointer to a structure) in the request. The value is stored in the <code>ctx</code> array at the module’s <code>ctx_index</code> position. The following macros provide a convenient way to get and set request contexts: <ul class="compact"><li> <code>ngx_http_get_module_ctx(r, module)</code> — Returns the <code>module</code> ‘s context -  <code>ngx_http_set_ctx(r, c, module)</code> — Sets <code>c</code> as the <code>module</code> ‘s context<br><code>posted_requests</code> — List of requests to be started or resumed, which is done by calling the request’s <code>write_event_handler</code> . Normally, this handler holds the request main function, which at first runs request phases and then produces the output. </li></ul></p>
<p>A request is usually posted by the <code>ngx_http_post_request(r, NULL)</code> call. It is always posted to the main request <code>posted_requests</code> list. The function <code>ngx_http_run_posted_requests(c)</code> runs all requests that are posted in the main request of the passed connection’s active request. All event handlers call <code>ngx_http_run_posted_requests</code> , which can lead to new posted requests. Normally, it is called after invoking a request’s read or write handler. </p>
<p><code>keepalive</code> — Flag indicating whether client connection keepalive is supported. The value is inferred from the HTTP version and the value of the “Connection” header. </p>
</li>
</ul>
<h4 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h4><p> Each HTTP module can have three types of configuration: </p>
<ul>
<li>Main configuration — Applies to the entire <code>http</code> block. Functions as global settings for a module. -  Server configuration — Applies to a single <code>server</code> block. Functions as server-specific settings for a module. -  Location configuration — Applies to a single <code>location</code> , <code>if</code> or <code>limit_except</code> block. Functions as location-specific settings for a module.<br>Configuration structures are created at the nginx configuration stage by calling functions, which allocate the structures, initialize them and merge them. The following example shows how to create a simple location configuration for a module. The configuration has one setting, <code>foo</code> , of type unsigned integer. </li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_uint_t  foo;
} ngx_http_foo_loc_conf_t;


static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    NULL,                                  /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    ngx_http_foo_create_loc_conf,          /* create location configuration */
    ngx_http_foo_merge_loc_conf            /* merge location configuration */
};


static void *
ngx_http_foo_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_foo_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_foo_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf-&gt;foo = NGX_CONF_UNSET_UINT;

    return conf;
}


static char *
ngx_http_foo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_foo_loc_conf_t *prev = parent;
    ngx_http_foo_loc_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf-&gt;foo, prev-&gt;foo, 1);
}
</pre>

<p> As seen in the example, the <code>ngx_http_foo_create_loc_conf()</code> function creates a new configuration structure, and <code>ngx_http_foo_merge_loc_conf()</code> merges a configuration with configuration from a higher level. In fact, server and location configuration do not exist only at the server and location levels, but are also created for all levels above them. Specifically, a server configuration is also created at the main level and location configurations are created at the main, server, and location levels. These configurations make it possible to specify server- and location-specific settings at any level of an nginx configuration file. Eventually configurations are merged down. A number of macros like <code>NGX_CONF_UNSET</code> and <code>NGX_CONF_UNSET_UINT</code> are provided for indicating a missing setting and ignoring it while merging. Standard nginx merge macros like <code>ngx_conf_merge_value()</code> and <code>ngx_conf_merge_uint_value()</code> provide a convenient way to merge a setting and set the default value if none of the configurations provided an explicit value. For complete list of macros for different types, see <code>src/core/ngx_conf_file.h</code> . </p>
<p> The following macros are available. for accessing configuration for HTTP modules at configuration time. They all take <code>ngx_conf_t</code> reference as the first argument. </p>
<ul>
<li><code>ngx_http_conf_get_module_main_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_srv_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_loc_conf(cf, module)</code><br>The following example gets a pointer to a location configuration of standard nginx core module <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> and replaces the location content handler kept in the <code>handler</code> field of the structure. </li>
</ul>
<pre class="notranslate">static ngx_int_t ngx_http_foo_handler(ngx_http_request_t *r);


static ngx_command_t  ngx_http_foo_commands[] = {

    { ngx_string("foo"),
      NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
      ngx_http_foo,
      0,
      0,
      NULL },

      ngx_null_command
};


static char *
ngx_http_foo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_bar_handler;

    return NGX_CONF_OK;
}
</pre>

<p> The following macros are available for accessing configuration for HTTP modules at runtime. </p>
<ul>
<li><code>ngx_http_get_module_main_conf(r, module)</code>  -  <code>ngx_http_get_module_srv_conf(r, module)</code>  -  <code>ngx_http_get_module_loc_conf(r, module)</code><br>These macros receive a reference to an HTTP request <code>ngx_http_request_t</code> . The main configuration of a request never changes. Server configuration can change from the default after the virtual server for the request is chosen. Location configuration selected for processing a request can change multiple times as a result of a rewrite operation or internal redirect. The following example shows how to access a module’s HTTP configuration at runtime. </li>
</ul>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_http_foo_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_foo_module);

    ...
}
</pre>

<h4 id="相"><a href="#相" class="headerlink" title="相"></a>相</h4><p> Each HTTP request passes through a sequence of phases. In each phase a distinct type of processing is performed on the request. Module-specific handlers can be registered in most phases, and many standard nginx modules register their phase handlers as a way to get called at a specific stage of request processing. Phases are processed successively and the phase handlers are called once the request reaches the phase. Following is the list of nginx HTTP phases. </p>
<ul>
<li><code>NGX_HTTP_POST_READ_PHASE</code> — First phase. The <a href="http/ngx_http_realip_module.html">ngx_http_realip_module</a> registers its handler at this phase to enable substitution of client addresses before any other module is invoked. -  <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> — Phase where rewrite directives defined in a <code>server</code> block (but outside a <code>location</code> block) are processed. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> installs its handler at this phase. -  <code>NGX_HTTP_FIND_CONFIG_PHASE</code> — Special phase where a location is chosen based on the request URI. Before this phase, the default location for the relevant virtual server is assigned to the request, and any module requesting a location configuration receives the configuration for the default server location. This phase a assigns a new location to the request. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_REWRITE_PHASE</code> — Same as <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> , but for rewrite rules defined in the location, chosen in the previous phase. -  <code>NGX_HTTP_POST_REWRITE_PHASE</code> — Special phase where the request is redirected to a new location if its URI changed during a rewrite. This is implemented by the request going through the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> again. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PREACCESS_PHASE</code> — A common phase for different types of handlers, not associated with access control. The standard nginx modules <a href="http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a> and <a href="http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a> register their handlers at this phase. -  <code>NGX_HTTP_ACCESS_PHASE</code> — Phase where it is verified that the client is authorized to make the request. Standard nginx modules such as <a href="http/ngx_http_access_module.html">ngx_http_access_module</a> and <a href="http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> register their handlers at this phase. By default the client must pass the authorization check of all handlers registered at this phase for the request to continue to the next phase. The <a href="http/ngx_http_core_module.html#satisfy">satisfy</a> directive, can be used to permit processing to continue if any of the phase handlers authorizes the client. -  <code>NGX_HTTP_POST_ACCESS_PHASE</code> — Special phase where the <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> directive is processed. If some access phase handlers denied access and none explicitly allowed it, the request is finalized. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PRECONTENT_PHASE</code> — Phase for handlers to be called prior to generating content. Standard modules such as <a href="http/ngx_http_core_module.html#try_files">ngx_http_try_files_module</a> and <a href="http/ngx_http_mirror_module.html">ngx_http_mirror_module</a> register their handlers at this phase. -  <code>NGX_HTTP_CONTENT_PHASE</code> — Phase where the response is normally generated. Multiple nginx standard modules register their handlers at this phase, including <a href="http/ngx_http_index_module.html">ngx_http_index_module</a> or <code>ngx_http_static_module</code> . They are called sequentially until one of them produces the output. It’s also possible to set content handlers on a per-location basis. If the <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> ‘s location configuration has <code>handler</code> set, it is called as the content handler and the handlers installed at this phase are ignored. -  <code>NGX_HTTP_LOG_PHASE</code> — Phase where request logging is performed. Currently, only the <a href="http/ngx_http_log_module.html">ngx_http_log_module</a> registers its handler at this stage for access logging. Log phase handlers are called at the very end of request processing, right before freeing the request.<br>Following is the example of a preaccess phase handler. </li>
</ul>
<pre class="notranslate">static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    ngx_http_foo_init,                     /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_str_t  *ua;

    ua = r-&gt;headers_in-&gt;user_agent;

    if (ua == NULL) {
        return NGX_DECLINED;
    }

    /* reject requests with "User-Agent: foo" */
    if (ua-&gt;value.len == 3 &amp;&amp; ngx_strncmp(ua-&gt;value.data, "foo", 3) == 0) {
        return NGX_HTTP_FORBIDDEN;
    }

    return NGX_DECLINED;
}


static ngx_int_t
ngx_http_foo_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_foo_handler;

    return NGX_OK;
}
</pre>

<p> Phase handlers are expected to return specific codes: </p>
<ul>
<li><code>NGX_OK</code> — Proceed to the next phase. -  <code>NGX_DECLINED</code> — Proceed to the next handler of the current phase. If the current handler is the last in the current phase, move to the next phase. -  <code>NGX_AGAIN</code> , <code>NGX_DONE</code> — Suspend phase handling until some future event which can be an asynchronous I/O operation or just a delay, for example. It is assumed, that phase handling will be resumed later by calling <code>ngx_http_core_run_phases()</code> . -  Any other value returned by the phase handler is treated as a request finalization code, in particular, an HTTP response code. The request is finalized with the code provided.<br>For some phases, return codes are treated in a slightly different way. At the content phase, any return code other that <code>NGX_DECLINED</code> is considered a finalization code. Any return code from the location content handlers is considered a finalization code. At the access phase, in <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> mode, any return code other than <code>NGX_OK</code> , <code>NGX_DECLINED</code> , <code>NGX_AGAIN</code> , <code>NGX_DONE</code> is considered a denial. If no subsequent access handlers allow or deny access with a different code, the denial code will become the finalization code. </li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h4 id="Accessing-existing-variables"><a href="#Accessing-existing-variables" class="headerlink" title="Accessing existing variables"></a>Accessing existing variables</h4><p> Variables can be referenced by index (this is the most common method) or name (see <a href="#http_creating_variables">below</a> ). The index is created at configuration stage, when a variable is added to the configuration. To obtain the variable index, use <code>ngx_http_get_variable_index()</code> : </p>
<pre class="notranslate">ngx_str_t  name;  /* ngx_string("foo") */
ngx_int_t  index;

index = ngx_http_get_variable_index(cf, &amp;name);
</pre>

<p> Here, <code>cf</code> is a pointer to nginx configuration and <code>name</code> points to a string containing the variable name. The function returns <code>NGX_ERROR</code> on error or a valid index otherwise, which is typically stored somewhere in the module’s configuration for future use. </p>
<p> All HTTP variables are evaluated in the context of a given HTTP request, and results are specific to and cached in that HTTP request. All functions that evaluate variables return the <code>ngx_http_variable_value_t</code> type, representing the variable value: </p>
<pre class="notranslate">typedef ngx_variable_value_t  ngx_http_variable_value_t;

typedef struct {
    unsigned    len:28;

    unsigned    valid:1;
    unsigned    no_cacheable:1;
    unsigned    not_found:1;
    unsigned    escape:1;

    u_char     *data;
} ngx_variable_value_t;
</pre>

<p>  哪里： </p>
<ul>
<li><code>len</code> — The length of the value -  <code>data</code> — The value itself -  <code>valid</code> — The value is valid -  <code>not_found</code> — The variable was not found and thus the <code>data</code> and <code>len</code> fields are irrelevant; this can happen, for example, with variables like <code>$arg_foo</code> when a corresponding argument was not passed in a request -  <code>no_cacheable</code> — Do not cache result -  <code>escape</code> — Used internally by the logging module to mark values that require escaping on output. </li>
</ul>
<p> The <code>ngx_http_get_flushed_variable()</code> and <code>ngx_http_get_indexed_variable()</code> functions are used to obtain the value of a variable. They have the same interface - accepting an HTTP request <code>r</code> as a context for evaluating the variable and an <code>index</code> that identifies it. An example of typical usage: </p>
<pre class="notranslate">ngx_http_variable_value_t  *v;

v = ngx_http_get_flushed_variable(r, index);

if (v == NULL || v-&gt;not_found) {
    /* we failed to get value or there is no such variable, handle it */
    return NGX_ERROR;
}

/* some meaningful value is found */
</pre>

<p> The difference between functions is that the <code>ngx_http_get_indexed_variable()</code> returns a cached value and <code>ngx_http_get_flushed_variable()</code> flushes the cache for non-cacheable variables. </p>
<p> Some modules, such as SSI and Perl, need to deal with variables for which the name is not known at configuration time. An index therefore cannot be used to access them, but the <code>ngx_http_get_variable(r, name, key)</code> function is available. It searches for a variable with a given <code>name</code> and its hash <code>key</code> derived from the name. </p>
<h4 id="Creating-variables"><a href="#Creating-variables" class="headerlink" title="Creating variables"></a>Creating variables</h4><p> To create a variable, use the <code>ngx_http_add_variable()</code> function. It takes as arguments a configuration (where the variable is registered), the variable name and flags that control the function’s behaviour: </p>
<ul>
<li><code>NGX_HTTP_VAR_CHANGEABLE</code> — Enables redefinition of the variable: there is no conflict if another module defines a variable with the same name. This allows the <a href="http/ngx_http_rewrite_module.html#set">set</a> directive to override variables. -  <code>NGX_HTTP_VAR_NOCACHEABLE</code> — Disables caching, which is useful for variables such as <code>$time_local</code> . -  <code>NGX_HTTP_VAR_NOHASH</code> — Indicates that this variable is only accessible by index, not by name. This is a small optimization for use when it is known that the variable is not needed in modules like SSI or Perl. -  <code>NGX_HTTP_VAR_PREFIX</code> — The name of the variable is a prefix. In this case, a handler must implement additional logic to obtain the value of a specific variable. For example, all “ <code>arg_</code> ” variables are processed by the same handler, which performs lookup in request arguments and returns the value of a specific argument.<br>The function returns NULL in case of error or a pointer to <code>ngx_http_variable_t</code> otherwise: </li>
</ul>
<pre class="notranslate">struct ngx_http_variable_s {
    ngx_str_t                     name;
    ngx_http_set_variable_pt      set_handler;
    ngx_http_get_variable_pt      get_handler;
    uintptr_t                     data;
    ngx_uint_t                    flags;
    ngx_uint_t                    index;
};
</pre>

<p> The <code>get</code> and <code>set</code> handlers are called to obtain or set the variable value, <code>data</code> is passed to variable handlers, and <code>index</code> holds assigned variable index used to reference the variable. </p>
<p> Usually, a null-terminated static array of <code>ngx_http_variable_t</code> structures is created by a module and processed at the preconfiguration stage to add variables into the configuration, for example: </p>
<pre class="notranslate">static ngx_http_variable_t  ngx_http_foo_vars[] = {

    { ngx_string("foo_v1"), NULL, ngx_http_foo_v1_variable, 0, 0, 0 },

      ngx_http_null_variable
};

static ngx_int_t
ngx_http_foo_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_foo_vars; v-&gt;name.len; v++) {
        var = ngx_http_add_variable(cf, &amp;v-&gt;name, v-&gt;flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var-&gt;get_handler = v-&gt;get_handler;
        var-&gt;data = v-&gt;data;
    }

    return NGX_OK;
}
</pre>

<p> This function in the example is used to initialize the <code>preconfiguration</code> field of the HTTP module context and is called before the parsing of HTTP configuration, so that the parser can refer to these variables. </p>
<p> The <code>get</code> handler is responsible for evaluating a variable in the context of a specific request, for example: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_variable_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r-&gt;pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;len = ngx_sprintf(p, "%uA", r-&gt;connection-&gt;number) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;
    v-&gt;data = p;

    return NGX_OK;
}
</pre>

<p> It returns <code>NGX_ERROR</code> in case of internal error (for example, failed memory allocation) or <code>NGX_OK</code> otherwise. To learn the status of variable evaluation, inspect the flags in <code>ngx_http_variable_value_t</code> (see the description <a href="#http_existing_variables">above</a> ). </p>
<p> The <code>set</code> handler allows setting the property referenced by the variable. For example, the set handler of the <code>$limit_rate</code> variable modifies the request’s <code>limit_rate</code> field: </p>
<pre class="notranslate">...
{ ngx_string("limit_rate"), ngx_http_variable_request_set_size,
  ngx_http_variable_request_get_size,
  offsetof(ngx_http_request_t, limit_rate),
  NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE, 0 },
...

static void
ngx_http_variable_request_set_size(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ssize_t    s, *sp;
    ngx_str_t  val;

    val.len = v-&gt;len;
    val.data = v-&gt;data;

    s = ngx_parse_size(&amp;val);

    if (s == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                      "invalid size \"%V\"", &amp;val);
        return;
    }

    sp = (ssize_t *) ((char *) r + data);

    *sp = s;

    return;
}
</pre>



<h4 id="Complex-values"><a href="#Complex-values" class="headerlink" title="Complex values"></a>Complex values</h4><p> A complex value, despite its name, provides an easy way to evaluate expressions which can contain text, variables, and their combination. </p>
<p> The complex value description in <code>ngx_http_compile_complex_value</code> is compiled at the configuration stage into <code>ngx_http_complex_value_t</code> which is used at runtime to obtain results of expression evaluation. </p>
<pre class="notranslate">ngx_str_t                         *value;
ngx_http_complex_value_t           cv;
ngx_http_compile_complex_value_t   ccv;

value = cf-&gt;args-&gt;elts; /* directive arguments */

ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

ccv.cf = cf;
ccv.value = &amp;value[1];
ccv.complex_value = &amp;cv;
ccv.zero = 1;
ccv.conf_prefix = 1;

if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
    return NGX_CONF_ERROR;
}
</pre>

<p> Here, <code>ccv</code> holds all parameters that are required to initialize the complex value <code>cv</code> : </p>
<ul>
<li><p><code>cf</code> — Configuration pointer -  <code>value</code> — String to be parsed (input) -  <code>complex_value</code> — Compiled value (output) -  <code>zero</code> — Flag that enables zero-terminating value -  <code>conf_prefix</code> — Prefixes the result with the configuration prefix (the directory where nginx is currently looking for configuration) -  <code>root_prefix</code> — Prefixes the result with the root prefix (the normal nginx installation prefix)<br>The <code>zero</code> flag is useful when results are to be passed to libraries that require zero-terminated strings, and prefixes are handy when dealing with filenames. </p>
<p>Upon successful compilation, <code>cv.lengths</code> contains information about the presence of variables in the expression. The NULL value means that the expression contained static text only, and so can be stored in a simple string rather than as a complex value. </p>
<p>The <code>ngx_http_set_complex_value_slot()</code> is a convenient function used to initialize a complex value completely in the directive declaration itself. </p>
<p>At runtime, a complex value can be calculated using the <code>ngx_http_complex_value()</code> function: </p>
</li>
</ul>
<pre class="notranslate">ngx_str_t  res;

if (ngx_http_complex_value(r, &amp;cv, &amp;res) != NGX_OK) {
    return NGX_ERROR;
}
</pre>

<p> Given the request <code>r</code> and previously compiled value <code>cv</code> , the function evaluates the expression and writes the result to <code>res</code> . </p>
<h4 id="Request-redirection"><a href="#Request-redirection" class="headerlink" title="Request redirection"></a>Request redirection</h4><p> An HTTP request is always connected to a location via the <code>loc_conf</code> field of the <code>ngx_http_request_t</code> structure. This means that at any point the location configuration of any module can be retrieved from the request by calling <code>ngx_http_get_module_loc_conf(r, module)</code> . Request location can change several times during the request’s lifetime. Initially, a default server location of the default server is assigned to a request. If the request switches to a different server (chosen by the HTTP “Host” header or SSL SNI extension), the request switches to the default location of that server as well. The next change of the location takes place at the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> request phase. At this phase a location is chosen by request URI among all non-named locations configured for the server. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> can change the request URI at the <code>NGX_HTTP_REWRITE_PHASE</code> request phase as a result of the <a href="http/ngx_http_rewrite_module.html#rewrite">rewrite</a> directive and send the request back to the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> phase for selection of a new location based on the new URI. </p>
<p> It is also possible to redirect a request to a new location at any point by calling one of <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> . </p>
<p> The <code>ngx_http_internal_redirect(r, uri, args)</code> function changes the request URI and returns the request to the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. The request proceeds with a server default location. Later at <code>NGX_HTTP_FIND_CONFIG_PHASE</code> a new location is chosen based on the new request URI. </p>
<p> The following example performs an internal redirect with the new request arguments. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_redirect(ngx_http_request_t *r)
{
    ngx_str_t  uri, args;

    ngx_str_set(&amp;uri, "/foo");
    ngx_str_set(&amp;args, "bar=1");

    return ngx_http_internal_redirect(r, &amp;uri, &amp;args);
}
</pre>

<p> The function <code>ngx_http_named_location(r, name)</code> redirects a request to a named location. The name of the location is passed as the argument. The location is looked up among all named locations of the current server, after which the requests switches to the <code>NGX_HTTP_REWRITE_PHASE</code> phase. </p>
<p> The following example performs a redirect to a named location @foo. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_named_redirect(ngx_http_request_t *r)
{
    ngx_str_t  name;

    ngx_str_set(&amp;name, "foo");

    return ngx_http_named_location(r, &amp;name);
}
</pre>

<p> Both functions - <code>ngx_http_internal_redirect(r, uri, args)</code> and <code>ngx_http_named_location(r, name)</code> can be called when nginx modules have already stored some contexts in a request’s <code>ctx</code> field. It’s possible for these contexts to become inconsistent with the new location configuration. To prevent inconsistency, all request contexts are erased by both redirect functions. </p>
<p> Calling <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> increases the request <code>count</code> . For consistent request reference counting, call <code>ngx_http_finalize_request(r, NGX_DONE)</code> after redirecting the request. This will finalize current request code path and decrease the counter. </p>
<p> Redirected and rewritten requests become internal and can access the <a href="http/ngx_http_core_module.html#internal">internal</a> locations. Internal requests have the <code>internal</code> flag set. </p>
<h4 id="Subrequests"><a href="#Subrequests" class="headerlink" title="Subrequests"></a>Subrequests</h4><p> Subrequests are primarily used to insert output of one request into another, possibly mixed with other data. A subrequest looks like a normal request, but shares some data with its parent. In particular, all fields related to client input are shared because a subrequest does not receive any other input from the client. The request field <code>parent</code> for a subrequest contains a link to its parent request and is NULL for the main request. The field <code>main</code> contains a link to the main request in a group of requests. </p>
<p> A subrequest starts in the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. It passes through the same subsequent phases as a normal request and is assigned a location based on its own URI. </p>
<p> The output header in a subrequest is always ignored. The <code>ngx_http_postpone_filter</code> places the subrequest’s output body in the right position relative to other data produced by the parent request. </p>
<p> Subrequests are related to the concept of active requests. A request <code>r</code> is considered active if <code>c-&amp;gt;data == r</code> , where <code>c</code> is the client connection object. At any given point, only the active request in a request group is allowed to output its buffers to the client. An inactive request can still send its output to the filter chain, but it does not pass beyond the <code>ngx_http_postpone_filter</code> and remains buffered by that filter until the request becomes active. Here are some rules of request activation: </p>
<ul>
<li>Initially, the main request is active. -  The first subrequest of an active request becomes active right after creation. -  The <code>ngx_http_postpone_filter</code> activates the next request in the active request’s subrequest list, once all data prior to that request are sent. -  When a request is finalized, its parent is activated.<br>Create a subrequest by calling the function <code>ngx_http_subrequest(r, uri, args, psr, ps, flags)</code> , where <code>r</code> is the parent request, <code>uri</code> and <code>args</code> are the URI and arguments of the subrequest, <code>psr</code> is the output parameter, which receives the newly created subrequest reference, <code>ps</code> is a callback object for notifying the parent request that the subrequest is being finalized, and <code>flags</code> is bitmask of flags. The following flags are available: </li>
<li><code>NGX_HTTP_SUBREQUEST_IN_MEMORY</code> - Output is not sent to the client, but rather stored in memory. The flag only affects subrequests which are processed by one of the proxying modules. After a subrequest is finalized its output is available in a <code>r-&amp;gt;upstream-&amp;gt;buffer</code> of type <code>ngx_buf_t</code> . -  <code>NGX_HTTP_SUBREQUEST_WAITED</code> - The subrequest’s <code>done</code> flag is set even if the subrequest is not active when it is finalized. This subrequest flag is used by the SSI filter. -  <code>NGX_HTTP_SUBREQUEST_CLONE</code> - The subrequest is created as a clone of its parent. It is started at the same location and proceeds from the same phase as the parent request.<br>The following example creates a subrequest with the URI of <code>/foo</code> . </li>
</ul>
<pre class="notranslate">ngx_int_t            rc;
ngx_str_t            uri;
ngx_http_request_t  *sr;

...

ngx_str_set(&amp;uri, "/foo");

rc = ngx_http_subrequest(r, &amp;uri, NULL, &amp;sr, NULL, 0);
if (rc == NGX_ERROR) {
    /* error */
}
</pre>

<p> This example clones the current request and sets a finalization callback for the subrequest. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_clone(ngx_http_request_t *r)
{
    ngx_http_request_t          *sr;
    ngx_http_post_subrequest_t  *ps;

    ps = ngx_palloc(r-&gt;pool, sizeof(ngx_http_post_subrequest_t));
    if (ps == NULL) {
        return NGX_ERROR;
    }

    ps-&gt;handler = ngx_http_foo_subrequest_done;
    ps-&gt;data = "foo";

    return ngx_http_subrequest(r, &amp;r-&gt;uri, &amp;r-&gt;args, &amp;sr, ps,
                               NGX_HTTP_SUBREQUEST_CLONE);
}


ngx_int_t
ngx_http_foo_subrequest_done(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    char  *msg = (char *) data;

    ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  "done subrequest r:%p msg:%s rc:%i", r, msg, rc);

    return rc;
}
</pre>

<p> Subrequests are normally created in a body filter, in which case their output can be treated like the output from any explicit request. This means that eventually the output of a subrequest is sent to the client, after all explicit buffers that are passed before subrequest creation and before any buffers that are passed after creation. This ordering is preserved even for large hierarchies of subrequests. The following example inserts output from a subrequest after all request data buffers, but before the final buffer with the <code>last_buf</code> flag. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_uint_t                  last;
    ngx_chain_t                *cl, out;
    ngx_http_request_t         *sr;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    last = 0;

    for (cl = in; cl; cl = cl-&gt;next) {
        if (cl-&gt;buf-&gt;last_buf) {
            cl-&gt;buf-&gt;last_buf = 0;
            cl-&gt;buf-&gt;last_in_chain = 1;
            cl-&gt;buf-&gt;sync = 1;
            last = 1;
        }
    }

    /* Output explicit output buffers */

    rc = ngx_http_next_body_filter(r, in);

    if (rc == NGX_ERROR || !last) {
        return rc;
    }

    /*
     * Create the subrequest.  The output of the subrequest
     * will automatically be sent after all preceding buffers,
     * but before the last_buf buffer passed later in this function.
     */

    if (ngx_http_subrequest(r, ctx-&gt;uri, NULL, &amp;sr, NULL, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, NULL, ngx_http_foo_filter_module);

    /* Output the final buffer with the last_buf flag */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = 1;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<p> A subrequest can also be created for other purposes than data output. For example, the <a href="http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> module creates a subrequest at the <code>NGX_HTTP_ACCESS_PHASE</code> phase. To disable output at this point, the <code>header_only</code> flag is set on the subrequest. This prevents the subrequest body from being sent to the client. Note that the subrequest’s header is never sent to the client. The result of the subrequest can be analyzed in the callback handler. </p>
<h4 id="Request-finalization"><a href="#Request-finalization" class="headerlink" title="Request finalization"></a>Request finalization</h4><p> An HTTP request is finalized by calling the function <code>ngx_http_finalize_request(r, rc)</code> . It is usually finalized by the content handler after all output buffers are sent to the filter chain. At this point all of the output might not be sent to the client, with some of it remaining buffered somewhere along the filter chain. If it is, the <code>ngx_http_finalize_request(r, rc)</code> function automatically installs a special handler <code>ngx_http_writer(r)</code> to finish sending the output. A request is also finalized in case of an error or if a standard HTTP response code needs to be returned to the client. </p>
<p> The function <code>ngx_http_finalize_request(r, rc)</code> expects the following <code>rc</code> values: </p>
<ul>
<li><p><code>NGX_DONE</code> - Fast finalization. Decrement the request <code>count</code> and destroy the request if it reaches zero. The client connection can be used for more requests after the current request is destroyed. -  <code>NGX_ERROR</code> , <code>NGX_HTTP_REQUEST_TIME_OUT</code> ( <code>408</code> ), <code>NGX_HTTP_CLIENT_CLOSED_REQUEST</code> ( <code>499</code> ) - Error finalization. Terminate the request as soon as possible and close the client connection. -  <code>NGX_HTTP_CREATED</code> ( <code>201</code> ), <code>NGX_HTTP_NO_CONTENT</code> ( <code>204</code> ), codes greater than or equal to <code>NGX_HTTP_SPECIAL_RESPONSE</code> ( <code>300</code> ) - Special response finalization. For these values nginx either sends to the client a default response page for the code or performs the internal redirect to an <a href="http/ngx_http_core_module.html#error_page">error_page</a> location if that is configured for the code. -  Other codes are considered successful finalization codes and might activate the request writer to finish sending the response body. Once the body is completely sent, the request <code>count</code> is decremented. If it reaches zero, the request is destroyed, but the client connection can still be used for other requests. If <code>count</code> is positive, there are unfinished activities within the request, which will be finalized at a later point. </p>
<h4 id="Request-body"><a href="#Request-body" class="headerlink" title="Request body"></a>Request body</h4><p>For dealing with the body of a client request, nginx provides the <code>ngx_http_read_client_request_body(r, post_handler)</code> and <code>ngx_http_discard_request_body(r)</code> functions. The first function reads the request body and makes it available via the <code>request_body</code> request field. The second function instructs nginx to discard (read and ignore) the request body. One of these functions must be called for every request. Normally, the content handler makes the call. </p>
<p>Reading or discarding the client request body from a subrequest is not allowed. It must always be done in the main request. When a subrequest is created, it inherits the parent’s <code>request_body</code> object which can be used by the subrequest if the main request has previously read the request body. </p>
<p>The function <code>ngx_http_read_client_request_body(r, post_handler)</code> starts the process of reading the request body. When the body is completely read, the <code>post_handler</code> callback is called to continue processing the request. If the request body is missing or has already been read, the callback is called immediately. The function <code>ngx_http_read_client_request_body(r, post_handler)</code> allocates the <code>request_body</code> request field of type <code>ngx_http_request_body_t</code> . The field <code>bufs</code> of this object keeps the result as a buffer chain. The body can be saved in memory buffers or file buffers, if the capacity specified by the <a href="http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a> directive is not enough to fit the entire body in memory. </p>
<p>The following example reads a client request body and returns its size. </p>
</li>
</ul>
<pre class="notranslate">ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t  rc;

    rc = ngx_http_read_client_request_body(r, ngx_http_foo_init);

    if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) {
        /* error */
        return rc;
    }

    return NGX_DONE;
}


void
ngx_http_foo_init(ngx_http_request_t *r)
{
    off_t         len;
    ngx_buf_t    *b;
    ngx_int_t     rc;
    ngx_chain_t  *in, out;

    if (r-&gt;request_body == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    len = 0;

    for (in = r-&gt;request_body-&gt;bufs; in; in = in-&gt;next) {
        len += ngx_buf_size(in-&gt;buf);
    }

    b = ngx_create_temp_buf(r-&gt;pool, NGX_OFF_T_LEN);
    if (b == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    b-&gt;last = ngx_sprintf(b-&gt;pos, "%O", len);
    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = b-&gt;last - b-&gt;pos;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        ngx_http_finalize_request(r, rc);
        return;
    }

    out.buf = b;
    out.next = NULL;

    rc = ngx_http_output_filter(r, &amp;out);

    ngx_http_finalize_request(r, rc);
}
</pre>

<p> The following fields of the request determine how the request body is read: </p>
<ul>
<li><code>request_body_in_single_buf</code> - Read the body to a single memory buffer. -  <code>request_body_in_file_only</code> - Always read the body to a file, even if fits in the memory buffer. -  <code>request_body_in_persistent_file</code> - Do not unlink the file immediately after creation. A file with this flag can be moved to another directory. -  <code>request_body_in_clean_file</code> - Unlink the file when the request is finalized. This can be useful when a file was supposed to be moved to another directory but was not moved for some reason. -  <code>request_body_file_group_access</code> - Enable group access to the file by replacing the default 0600 access mask with 0660. -  <code>request_body_file_log_level</code> - Severity level at which to log file errors. -  <code>request_body_no_buffering</code> - Read the request body without buffering.<br>The <code>request_body_no_buffering</code> flag enables the unbuffered mode of reading a request body. In this mode, after calling <code>ngx_http_read_client_request_body()</code> , the <code>bufs</code> chain might keep only a part of the body. To read the next part, call the <code>ngx_http_read_unbuffered_request_body(r)</code> function. The return value <code>NGX_AGAIN</code> and the request flag <code>reading_body</code> indicate that more data is available. If <code>bufs</code> is NULL after calling this function, there is nothing to read at the moment. The request callback <code>read_event_handler</code> will be called when the next part of request body is available. </li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p> In nginx an HTTP response is produced by sending the response header followed by the optional response body. Both header and body are passed through a chain of filters and eventually get written to the client socket. An nginx module can install its handler into the header or body filter chain and process the output coming from the previous handler. </p>
<h4 id="Response-header"><a href="#Response-header" class="headerlink" title="Response header"></a>Response header</h4><p> The <code>ngx_http_send_header(r)</code> function sends the output header. Do not call this function until <code>r-&amp;gt;headers_out</code> contains all of the data required to produce the HTTP response header. The <code>status</code> field in <code>r-&amp;gt;headers_out</code> must always be set. If the response status indicates that a response body follows the header, <code>content_length_n</code> can be set as well. The default value for this field is <code>-1</code> , which means that the body size is unknown. In this case, chunked transfer encoding is used. To output an arbitrary header, append the <code>headers</code> list. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t         rc;
    ngx_table_elt_t  *h;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    /* X-Foo: foo */

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    ...
}
</pre>

<h4 id="Header-filters"><a href="#Header-filters" class="headerlink" title="Header filters"></a>Header filters</h4><p> The <code>ngx_http_send_header(r)</code> function invokes the header filter chain by calling the first header filter handler stored in the <code>ngx_http_top_header_filter</code> variable. It’s assumed that every header handler calls the next handler in the chain until the final handler <code>ngx_http_header_filter(r)</code> is called. The final header handler constructs the HTTP response based on <code>r-&amp;gt;headers_out</code> and passes it to the <code>ngx_http_writer_filter</code> for output. </p>
<p> To add a handler to the header filter chain, store its address in the global variable <code>ngx_http_top_header_filter</code> at configuration time. The previous handler address is normally stored in a static variable in a module and is called by the newly added handler before exiting. </p>
<p> The following example of a header filter module adds the HTTP header “ <code>X-Foo: foo</code> “ to every response with status <code>200</code> . </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


static ngx_int_t ngx_http_foo_header_filter(ngx_http_request_t *r);
static ngx_int_t ngx_http_foo_header_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_foo_header_filter_module_ctx = {
    NULL,                                   /* preconfiguration */
    ngx_http_foo_header_filter_init,        /* postconfiguration */

    NULL,                                   /* create main configuration */
    NULL,                                   /* init main configuration */

    NULL,                                   /* create server configuration */
    NULL,                                   /* merge server configuration */

    NULL,                                   /* create location configuration */
    NULL                                    /* merge location configuration */
};


ngx_module_t  ngx_http_foo_header_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_foo_header_filter_module_ctx, /* module context */
    NULL,                                   /* module directives */
    NGX_HTTP_MODULE,                        /* module type */
    NULL,                                   /* init master */
    NULL,                                   /* init module */
    NULL,                                   /* init process */
    NULL,                                   /* init thread */
    NULL,                                   /* exit thread */
    NULL,                                   /* exit process */
    NULL,                                   /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;


static ngx_int_t
ngx_http_foo_header_filter(ngx_http_request_t *r)
{
    ngx_table_elt_t  *h;

    /*
     * The filter handler adds "X-Foo: foo" header
     * to every HTTP 200 response
     */

    if (r-&gt;headers_out.status != NGX_HTTP_OK) {
        return ngx_http_next_header_filter(r);
    }

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    return ngx_http_next_header_filter(r);
}


static ngx_int_t
ngx_http_foo_header_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_foo_header_filter;

    return NGX_OK;
}
</pre>

<h4 id="Response-body"><a href="#Response-body" class="headerlink" title="Response body"></a>Response body</h4><p> To send the response body, call the <code>ngx_http_output_filter(r, cl)</code> function. The function can be called multiple times. Each time, it sends a part of the response body in the form of a buffer chain. Set the <code>last_buf</code> flag in the last body buffer. </p>
<p> The following example produces a complete HTTP response with “foo” as its body. For the example to work as subrequest as well as a main request, the <code>last_in_chain</code> flag is set in the last buffer of the output. The <code>last_buf</code> flag is set only for the main request because the last buffer for a subrequest does not end the entire output. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_bar_content_handler(ngx_http_request_t *r)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    b-&gt;memory = 1;

    b-&gt;pos = (u_char *) "foo";
    b-&gt;last = b-&gt;pos + 3;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<h4 id="Body-filters"><a href="#Body-filters" class="headerlink" title="Body filters"></a>Body filters</h4><p> The function <code>ngx_http_output_filter(r, cl)</code> invokes the body filter chain by calling the first body filter handler stored in the <code>ngx_http_top_body_filter</code> variable. It’s assumed that every body handler calls the next handler in the chain until the final handler <code>ngx_http_write_filter(r, cl)</code> is called. </p>
<p> A body filter handler receives a chain of buffers. The handler is supposed to process the buffers and pass a possibly new chain to the next handler. It’s worth noting that the chain links <code>ngx_chain_t</code> of the incoming chain belong to the caller, and must not be reused or changed. Right after the handler completes, the caller can use its output chain links to keep track of the buffers it has sent. To save the buffer chain or to substitute some buffers before passing to the next filter, a handler needs to allocate its own chain links. </p>
<p> Following is an example of a simple body filter that counts the number of bytes in the body. The result is available as the <code>$counter</code> variable which can be used in the access log. </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


typedef struct {
    off_t  count;
} ngx_http_counter_filter_ctx_t;


static ngx_int_t ngx_http_counter_body_filter(ngx_http_request_t *r,
    ngx_chain_t *in);
static ngx_int_t ngx_http_counter_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);
static ngx_int_t ngx_http_counter_add_variables(ngx_conf_t *cf);
static ngx_int_t ngx_http_counter_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_counter_filter_module_ctx = {
    ngx_http_counter_add_variables,        /* preconfiguration */
    ngx_http_counter_filter_init,          /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


ngx_module_t  ngx_http_counter_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_counter_filter_module_ctx,   /* module context */
    NULL,                                  /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_body_filter_pt  ngx_http_next_body_filter;

static ngx_str_t  ngx_http_counter_name = ngx_string("counter");


static ngx_int_t
ngx_http_counter_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_chain_t                    *cl;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_counter_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_counter_filter_module);
    }

    for (cl = in; cl; cl = cl-&gt;next) {
        ctx-&gt;count += ngx_buf_size(cl-&gt;buf);
    }

    return ngx_http_next_body_filter(r, in);
}


static ngx_int_t
ngx_http_counter_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char                         *p;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        v-&gt;not_found = 1;
        return NGX_OK;
    }

    p = ngx_pnalloc(r-&gt;pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;data = p;
    v-&gt;len = ngx_sprintf(p, "%O", ctx-&gt;count) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &amp;ngx_http_counter_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var-&gt;get_handler = ngx_http_counter_variable;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_counter_body_filter;

    return NGX_OK;
}
</pre>

<h4 id="Building-filter-modules"><a href="#Building-filter-modules" class="headerlink" title="Building filter modules"></a>Building filter modules</h4><p> When writing a body or header filter, pay special attention to the filter’s position in the filter order. There’s a number of header and body filters registered by nginx standard modules. The nginx standard modules register a number of head and body filters and it’s important to register a new filter module in the right place with respect to them. Normally, modules register filters in their postconfiguration handlers. The order in which filters are called during processing is obviously the reverse of the order in which they are registered. </p>
<p> For third-party filter modules nginx provides a special slot <code>HTTP_AUX_FILTER_MODULES</code> . To register a filter module in this slot, set the <code>ngx_module_type</code> variable to <code>HTTP_AUX_FILTER</code> in the module’s configuration. </p>
<p> The following example shows a filter module config file assuming for a module with just one source file, <code>ngx_http_foo_filter_module.c</code> . </p>
<pre class="notranslate">ngx_module_type=HTTP_AUX_FILTER
ngx_module_name=ngx_http_foo_filter_module
ngx_module_srcs="$ngx_addon_dir/ngx_http_foo_filter_module.c"

. auto/module
</pre>

<h4 id="Buffer-reuse"><a href="#Buffer-reuse" class="headerlink" title="Buffer reuse"></a>Buffer reuse</h4><p> When issuing or altering a stream of buffers, it’s often desirable to reuse the allocated buffers. A standard and widely adopted approach in nginx code is to keep two buffer chains for this purpose: <code>free</code> and <code>busy</code> . The <code>free</code> chain keeps all free buffers, which can be reused. The <code>busy</code> chain keeps all buffers sent by the current module that are still in use by some other filter handler. A buffer is considered in use if its size is greater than zero. Normally, when a buffer is consumed by a filter, its <code>pos</code> (or <code>file_pos</code> for a file buffer) is moved towards <code>last</code> ( <code>file_last</code> for a file buffer). Once a buffer is completely consumed, it’s ready to be reused. To add newly freed buffers to the <code>free</code> chain it’s enough to iterate over the <code>busy</code> chain and move the zero size buffers at the head of it to <code>free</code> . This operation is so common that there is a special function for it, <code>ngx_chain_update_chains(free, busy, out, tag)</code> . The function appends the output chain <code>out</code> to <code>busy</code> and moves free buffers from the top of <code>busy</code> to <code>free</code> . Only the buffers with the specified <code>tag</code> are reused. This lets a module reuse only the buffers that it allocated itself. </p>
<p> The following example is a body filter that inserts the string “foo” before each incoming buffer. The new buffers allocated by the module are reused if possible. Note that for this example to work properly, setting up a <a href="#http_header_filters">header filter</a> and resetting <code>content_length_n</code> to <code>-1</code> is also required, but the relevant code is not provided here. </p>
<pre class="notranslate">typedef struct {
    ngx_chain_t  *free;
    ngx_chain_t  *busy;
}  ngx_http_foo_filter_ctx_t;


ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_chain_t                *cl, *tl, *out, **ll;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_foo_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_foo_filter_module);
    }

    /* create a new chain "out" from "in" with all the changes */

    ll = &amp;out;

    for (cl = in; cl; cl = cl-&gt;next) {

        /* append "foo" in a reused buffer if possible */

        tl = ngx_chain_get_free_buf(r-&gt;pool, &amp;ctx-&gt;free);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        b = tl-&gt;buf;
        b-&gt;tag = (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module;
        b-&gt;memory = 1;
        b-&gt;pos = (u_char *) "foo";
        b-&gt;last = b-&gt;pos + 3;

        *ll = tl;
        ll = &amp;tl-&gt;next;

        /* append the next incoming buffer */

        tl = ngx_alloc_chain_link(r-&gt;pool);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        tl-&gt;buf = cl-&gt;buf;
        *ll = tl;
        ll = &amp;tl-&gt;next;
    }

    *ll = NULL;

    /* send the new chain */

    rc = ngx_http_next_body_filter(r, out);

    /* update "busy" and "free" chains for reuse */

    ngx_chain_update_chains(r-&gt;pool, &amp;ctx-&gt;free, &amp;ctx-&gt;busy, &amp;out,
                            (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module);

    return rc;
}
</pre>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> provides the basic functionality needed to pass requests to remote servers. Modules that implement specific protocols, such as HTTP or FastCGI, use this functionality. The module also provides an interface for creating custom load-balancing modules and implements a default round-robin method. </p>
<p> The <a href="http/ngx_http_upstream_module.html#least_conn">least_conn</a> and <a href="http/ngx_http_upstream_module.html#hash">hash</a> modules implement alternative load-balancing methods, but are actually implemented as extensions of the upstream round-robin module and share a lot of code with it, such as the representation of a server group. The <a href="http/ngx_http_upstream_module.html#keepalive">keepalive</a> module is an independent module that extends upstream functionality. </p>
<p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> can be configured explicitly by placing the corresponding <a href="http/ngx_http_upstream_module.html#upstream">upstream</a> block into the configuration file, or implicitly by using directives such as <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> that accept a URL that gets evaluated at some point into a list of servers. The alternative load-balancing methods are available only with an explicit upstream configuration. The upstream module configuration has its own directive context <code>NGX_HTTP_UPS_CONF</code> . The structure is defined as follows: </p>
<pre class="notranslate">struct ngx_http_upstream_srv_conf_s {
    ngx_http_upstream_peer_t         peer;
    void                           **srv_conf;

    ngx_array_t                     *servers;  /* ngx_http_upstream_server_t */

    ngx_uint_t                       flags;
    ngx_str_t                        host;
    u_char                          *file_name;
    ngx_uint_t                       line;
    in_port_t                        port;
    ngx_uint_t                       no_port;  /* unsigned no_port:1 */

#if (NGX_HTTP_UPSTREAM_ZONE)
    ngx_shm_zone_t                  *shm_zone;
#endif
};
</pre>


<ul>
<li><code>srv_conf</code> — Configuration context of upstream modules. -  <code>servers</code> — Array of <code>ngx_http_upstream_server_t</code> , the result of parsing a set of <a href="http/ngx_http_upstream_module.html#server">server</a> directives in the <code>upstream</code> block. -  <code>flags</code> — Flags that mostly mark which features are supported by the load-balancing method. The features are configured as parameters of the <a href="http/ngx_http_upstream_module.html#server">server</a> directive: <ul class="compact"><li> <code>NGX_HTTP_UPSTREAM_CREATE</code> — Distinguishes explicitly defined upstreams from those that are automatically created by the <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> directive and “friends” (FastCGI, SCGI, etc.) -  <code>NGX_HTTP_UPSTREAM_WEIGHT</code> — The “ <code>weight</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_FAILS</code> — The “ <code>max_fails</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_FAIL_TIMEOUT</code> — The “ <code>fail_timeout</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_DOWN</code> — The “ <code>down</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_BACKUP</code> — The “ <code>backup</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_CONNS</code> — The “ <code>max_conns</code> ” parameter is supported <pre class="notranslate">typedef struct {
 ngx_http_upstream_init_pt        init_upstream;
 ngx_http_upstream_init_peer_pt   init;
 void                            *data;
} ngx_http_upstream_peer_t;
</pre></li>
<li><code>init_upstream(cf, us)</code> — Configuration-time method responsible for initializing a group of servers and initializing the <code>init()</code> method in case of success. A typical load-balancing module uses a list of servers in the <code>upstream</code> block to create an efficient data structure that it uses and saves its own configuration to the <code>data</code> field. -  <code>init(r, us)</code> — Initializes a per-request <code>ngx_http_upstream_peer_t.peer</code> structure that is used for load balancing (not to be confused with the <code>ngx_http_upstream_srv_conf_t.peer</code> described above which is per-upstream). It is passed as the <code>data</code> argument to all callbacks that deal with server selection. </li>
</ul>
<p> When nginx has to pass a request to another host for processing, it uses the configured load-balancing method to obtain an address to connect to. The method is obtained from the <code>ngx_http_upstream_t.peer</code> object of type <code>ngx_peer_connection_t</code> : </p>
<pre class="notranslate">struct ngx_peer_connection_s {
    ...

    struct sockaddr                 *sockaddr;
    socklen_t                        socklen;
    ngx_str_t                       *name;

    ngx_uint_t                       tries;

    ngx_event_get_peer_pt            get;
    ngx_event_free_peer_pt           free;
    ngx_event_notify_peer_pt         notify;
    void                            *data;

#if (NGX_SSL || NGX_COMPAT)
    ngx_event_set_peer_session_pt    set_session;
    ngx_event_save_peer_session_pt   save_session;
#endif

    ...
};
</pre>

<p> The structure has the following fields: </p>
<ul>
<li><code>sockaddr</code> , <code>socklen</code> , <code>name</code> — Address of the upstream server to connect to; this is the output parameter of a load-balancing method. -  <code>data</code> — The per-request data of a load-balancing method; keeps the state of the selection algorithm and usually includes the link to the upstream configuration. It is passed as an argument to all methods that deal with server selection (see <a href="#lb_method_get">below</a> ). -  <code>tries</code> — Allowed <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_tries">number</a> of attempts to connect to an upstream server. -  <code>get</code> , <code>free</code> , <code>notify</code> , <code>set_session</code> , and <code>save_session</code> - Methods of the load-balancing module, described below. </li>
</ul>
<p> All methods accept at least two arguments: a peer connection object <code>pc</code> and the <code>data</code> created by <code>ngx_http_upstream_srv_conf_t.peer.init()</code> . Note that it might differ from <code>pc.data</code> due to “chaining” of load-balancing modules. </p>
<ul>
<li><code>get(pc, data)</code> — The method called when the upstream module is ready to pass a request to an upstream server and needs to know its address. The method has to fill the <code>sockaddr</code> , <code>socklen</code> , and <code>name</code> fields of <code>ngx_peer_connection_t</code> structure. The return is one of: <ul class="compact"><li> <code>NGX_OK</code> — Server was selected. -  <code>NGX_ERROR</code> — Internal error occurred. -  <code>NGX_BUSY</code> — no servers are currently available. This can happen due to many reasons, including: the dynamic server group is empty, all servers in the group are in the failed state, or all servers in the group are already handling the maximum number of connections. -  <code>NGX_DONE</code> — the underlying connection was reused and there is no need to create a new connection to the upstream server. This value is set by the <code>keepalive</code> module. -  <code>NGX_PEER_FAILED</code> — Attempt was <a href="http/ngx_http_upstream_module.html#max_fails">unsuccessful</a> -  <code>NGX_PEER_NEXT</code> — A special case when upstream server returns codes <code>403</code> or <code>404</code> , which are not considered a <a href="http/ngx_http_upstream_module.html#max_fails">failure</a> . -  <code>NGX_PEER_KEEPALIVE</code> — Currently unused </li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p> The <a href="http://hg.nginx.org/nginx-dev-examples" target="_blank" rel="noopener">nginx-dev-examples</a> repository provides nginx module examples. </p>
<h4 id="Code-style"><a href="#Code-style" class="headerlink" title="Code style"></a>Code style</h4><h4 id="General-rules"><a href="#General-rules" class="headerlink" title="General rules"></a>General rules</h4><ul>
<li>maximum text width is 80 characters -  indentation is 4 spaces -  no tabs, no trailing spaces -  list elements on the same line are separated with spaces -  hexadecimal literals are lowercase -  file names, function and type names, and global variables have the <code>ngx_</code> or more specific prefix such as <code>ngx_http_</code> and <code>ngx_mail_</code> </li>
</ul>
<pre class="notranslate">size_t
ngx_utf8_length(u_char *p, size_t n)
{
    u_char  c, *last;
    size_t  len;

    last = p + n;

    for (len = 0; p &lt; last; len++) {

        c = *p;

        if (c &lt; 0x80) {
            p++;
            continue;
        }

        if (ngx_utf8_decode(&amp;p, n) &gt; 0x10ffff) {
            /* invalid UTF-8 */
            return n;
        }
    }

    return len;
}
</pre>



<h4 id="档"><a href="#档" class="headerlink" title="档"></a>档</h4><p> A typical source file may contain the following sections separated by two empty lines: </p>
<ul>
<li>copyright statements -   包括 -  preprocessor definitions -  type definitions -  function prototypes -  variable definitions -  function definitions </li>
</ul>
<p> Copyright statements look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author Name
 * Copyright (C) Organization, Inc.
 */
</pre>

<p> If the file is modified significantly, the list of authors should be updated, the new author is added to the top. </p>
<p> The <code>ngx_config.h</code> and <code>ngx_core.h</code> files are always included first, followed by one of <code>ngx_http.h</code> , <code>ngx_stream.h</code> , or <code>ngx_mail.h</code> . Then follow optional external header files: </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;

#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;
#include &lt;libxslt/xslt.h&gt;

#if (NGX_HAVE_EXSLT)
#include &lt;libexslt/exslt.h&gt;
#endif
</pre>



<p> Header files should include the so called “header protection”: </p>
<pre class="notranslate">#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_
#define _NGX_PROCESS_CYCLE_H_INCLUDED_
...
#endif /* _NGX_PROCESS_CYCLE_H_INCLUDED_ */
</pre>



<h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><ul>
<li>“ <code>//</code> ” comments are not used -  text is written in English, American spelling is preferred </li><li> multi-line comments are formatted like this: <blockquote class="example"><pre class="notranslate">/*<ul>
<li>The red-black tree code is based on the algorithm described in</li>
<li>the “Introduction to Algorithms” by Cormen, Leiserson and Rivest.<br><em>/<br></em></li></ul></pre></blockquote><blockquote class="example"><pre class="notranslate">/ find the server configuration for the address:port */<br></pre></blockquote></li><pre class="notranslate">/* find the server configuration for the address:port */
</pre>



</ul></li>
</ul>
</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p> Macro names start from <code>ngx_</code> or <code>NGX_</code> (or more specific) prefix. Macro names for constants are uppercase. Parameterized macros and macros for initializers are lowercase. The macro name and value are separated by at least two spaces: </p>
<pre class="notranslate">#define NGX_CONF_BUFFER  4096

#define ngx_buf_in_memory(b)  (b-&gt;temporary || b-&gt;memory || b-&gt;mmap)

#define ngx_buf_size(b)                                                      \
    (ngx_buf_in_memory(b) ? (off_t) (b-&gt;last - b-&gt;pos):                      \
                            (b-&gt;file_last - b-&gt;file_pos))

#define ngx_null_string  { 0, NULL }
</pre>

<p> Conditions are inside parentheses, negation is outside: </p>
<pre class="notranslate">#if (NGX_HAVE_KQUEUE)
...
#elif ((NGX_HAVE_DEVPOLL &amp;&amp; !(NGX_TEST_BUILD_DEVPOLL)) \
       || (NGX_HAVE_EVENTPORT &amp;&amp; !(NGX_TEST_BUILD_EVENTPORT)))
...
#elif (NGX_HAVE_EPOLL &amp;&amp; !(NGX_TEST_BUILD_EPOLL))
...
#elif (NGX_HAVE_POLL)
...
#else /* select */
...
#endif /* NGX_HAVE_KQUEUE */
</pre>



<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p> Type names end with the “ <code>_t</code> ” suffix. A defined type name is separated by at least two spaces: </p>
<pre class="notranslate">typedef ngx_uint_t  ngx_rbtree_key_t;
</pre>



<p> Structure types are defined using <code>typedef</code> . Inside structures, member types and names are aligned: </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p> Keep alignment identical among different structures in the file. A structure that points to itself has the name, ending with “ <code>_s</code> ”. Adjacent structure definitions are separated with two empty lines: </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};


typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p> Each structure member is declared on its own line: </p>
<pre class="notranslate">typedef struct {
    ngx_uint_t        hash;
    ngx_str_t         key;
    ngx_str_t         value;
    u_char           *lowcase_key;
} ngx_table_elt_t;
</pre>



<p> Function pointers inside structures have defined types ending with “ <code>_pt</code> ”: </p>
<pre class="notranslate">typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);
typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);

typedef struct {
    ngx_recv_pt        recv;
    ngx_recv_chain_pt  recv_chain;
    ngx_recv_pt        udp_recv;
    ngx_send_pt        send;
    ngx_send_pt        udp_send;
    ngx_send_chain_pt  udp_send_chain;
    ngx_send_chain_pt  send_chain;
    ngx_uint_t         flags;
} ngx_os_io_t;
</pre>



<p> Enumerations have types ending with “ <code>_e</code> ”: </p>
<pre class="notranslate">typedef enum {
    ngx_http_fastcgi_st_version = 0,
    ngx_http_fastcgi_st_type,
    ...
    ngx_http_fastcgi_st_padding
} ngx_http_fastcgi_state_e;
</pre>



<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p> Variables are declared sorted by length of a base type, then alphabetically. Type names and variable names are aligned. The type and name “columns” are separated with two spaces. Large arrays are put at the end of a declaration block: </p>
<pre class="notranslate">u_char                      |  | *rv, *p;
ngx_conf_t                  |  | *cf;
ngx_uint_t                  |  |  i, j, k;
unsigned int                |  |  len;
struct sockaddr             |  | *sa;
const unsigned char         |  | *data;
ngx_peer_connection_t       |  | *pc;
ngx_http_core_srv_conf_t    |  |**cscfp;
ngx_http_upstream_srv_conf_t|  | *us, *uscf;
u_char                      |  |  text[NGX_SOCKADDR_STRLEN];
</pre>



<p> Static and global variables may be initialized on declaration: </p>
<pre class="notranslate">static ngx_str_t  ngx_http_memcached_key = ngx_string("memcached_key");
</pre>



<pre class="notranslate">static ngx_uint_t  mday[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</pre>



<pre class="notranslate">static uint32_t  ngx_crc32_table16[] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    ...
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};
</pre>



<p> There is a bunch of commonly used type/name combinations: </p>
<pre class="notranslate">u_char                        *rv;
ngx_int_t                      rc;
ngx_conf_t                    *cf;
ngx_connection_t              *c;
ngx_http_request_t            *r;
ngx_peer_connection_t         *pc;
ngx_http_upstream_srv_conf_t  *us, *uscf;
</pre>



<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p> All functions (even static ones) should have prototypes. Prototypes include argument names. Long prototypes are wrapped with a single indentation on continuation lines: </p>
<pre class="notranslate">static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);

static char *ngx_http_merge_servers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_http_module_t *module,
    ngx_uint_t ctx_index);
</pre>

<p> The function name in a definition starts with a new line. The function body opening and closing braces are on separate lines. The body of a function is indented. There are two empty lines between functions: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_find_virtual_server(ngx_http_request_t *r, u_char *host, size_t len)
{
    ...
}


static ngx_int_t
ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ...
}
</pre>

<p> There is no space after the function name and opening parenthesis. Long function calls are wrapped such that continuation lines start from the position of the first function argument. If this is impossible, format the first continuation line such that it ends at position 79: </p>
<pre class="notranslate">ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
               "http header: \"%V: %V\"",
               &amp;h-&gt;key, &amp;h-&gt;value);

hc-&gt;busy = ngx_palloc(r-&gt;connection-&gt;pool,
                  cscf-&gt;large_client_header_buffers.num * sizeof(ngx_buf_t *));
</pre>

<p> The <code>ngx_inline</code> macro should be used instead of <code>inline</code> : </p>
<pre class="notranslate">static ngx_inline void ngx_cpuid(uint32_t i, uint32_t *buf);
</pre>



<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p> Binary operators except “ <code>.</code> ” and “ <code>−&amp;gt;</code> ” should be separated from their operands by one space. Unary operators and subscripts are not separated from their operands by spaces: </p>
<pre class="notranslate">width = width * 10 + (*fmt++ - '0');
</pre>



<pre class="notranslate">ch = (u_char) ((decoded &lt;&lt; 4) + (ch - '0'));
</pre>



<pre class="notranslate">r-&gt;exten.data = &amp;r-&gt;uri.data[i + 1];
</pre>



<p> Type casts are separated by one space from casted expressions. An asterisk inside type cast is separated with space from type name: </p>
<pre class="notranslate">len = ngx_sock_ntop((struct sockaddr *) sin6, p, len, 1);
</pre>



<p> If an expression does not fit into single line, it is wrapped. The preferred point to break a line is a binary operator. The continuation line is lined up with the start of expression: </p>
<pre class="notranslate">if (status == NGX_HTTP_MOVED_PERMANENTLY
    || status == NGX_HTTP_MOVED_TEMPORARILY
    || status == NGX_HTTP_SEE_OTHER
    || status == NGX_HTTP_TEMPORARY_REDIRECT
    || status == NGX_HTTP_PERMANENT_REDIRECT)
{
    ...
}
</pre>



<pre class="notranslate">p-&gt;temp_file-&gt;warn = "an upstream response is buffered "
                     "to a temporary file";
</pre>

<p> As a last resort, it is possible to wrap an expression so that the continuation line ends at position 79: </p>
<pre class="notranslate">hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, sizeof(ngx_hash_wildcard_t)
                                     + size * sizeof(ngx_hash_elt_t *));
</pre>

<p> The above rules also apply to sub-expressions, where each sub-expression has its own indentation level: </p>
<pre class="notranslate">if (((u-&gt;conf-&gt;cache_use_stale &amp; NGX_HTTP_UPSTREAM_FT_UPDATING)
     || c-&gt;stale_updating) &amp;&amp; !r-&gt;background
    &amp;&amp; u-&gt;conf-&gt;cache_background_update)
{
    ...
}
</pre>

<p> Sometimes, it is convenient to wrap an expression after a cast. In this case, the continuation line is indented: </p>
<pre class="notranslate">node = (ngx_rbtree_node_t *)
           ((u_char *) lr - offsetof(ngx_rbtree_node_t, color));
</pre>



<p> Pointers are explicitly compared to <code>NULL</code> (not <code>0</code> ): </p>
<pre class="notranslate">if (ptr != NULL) {
    ...
}
</pre>



<h4 id="Conditionals-and-Loops"><a href="#Conditionals-and-Loops" class="headerlink" title="Conditionals and Loops"></a>Conditionals and Loops</h4><p> The “ <code>if</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line, or on a dedicated line if the condition takes several lines. Closing brace is located on a dedicated line, optionally followed by “ <code>else if</code> / <code>else</code> ”. Usually, there is an empty line before the “ <code>else if</code> / <code>else</code> ” part: </p>
<pre class="notranslate">if (node-&gt;left == sentinel) {
    temp = node-&gt;right;
    subst = node;

} else if (node-&gt;right == sentinel) {
    temp = node-&gt;left;
    subst = node;

} else {
    subst = ngx_rbtree_min(node-&gt;right, sentinel);

    if (subst-&gt;left != sentinel) {
        temp = subst-&gt;left;

    } else {
        temp = subst-&gt;right;
    }
}
</pre>



<p> Similar formatting rules are applied to “ <code>do</code> ” and “ <code>while</code> ” loops: </p>
<pre class="notranslate">while (p &lt; last &amp;&amp; *p == ' ') {
    p++;
}
</pre>



<pre class="notranslate">do {
    ctx-&gt;node = rn;
    ctx = ctx-&gt;next;
} while (ctx);
</pre>



<p> The “ <code>switch</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line. Closing brace is located on a dedicated line. The “ <code>case</code> ” keywords are lined up with “ <code>switch</code> ”: </p>
<pre class="notranslate">switch (ch) {
case '!':
    looked = 2;
    state = ssi_comment0_state;
    break;

case '&lt;':
    copy_end = p;
    break;

default:
    copy_end = p;
    looked = 0;
    state = ssi_start_state;
    break;
}
</pre>



<p> Most “ <code>for</code> ” loops are formatted like this: </p>
<pre class="notranslate">for (i = 0; i &lt; ccf-&gt;env.nelts; i++) {
    ...
}
</pre>



<pre class="notranslate">for (q = ngx_queue_head(locations);
     q != ngx_queue_sentinel(locations);
     q = ngx_queue_next(q))
{
    ...
}
</pre>

<p> If some part of the “ <code>for</code> ” statement is omitted, this is indicated by the “ <code>/* void */</code> ” comment: </p>
<pre class="notranslate">for (i = 0; /* void */ ; i++) {
    ...
}
</pre>

<p> A loop with an empty body is also indicated by the “ <code>/* void */</code> ” comment which may be put on the same line: </p>
<pre class="notranslate">for (cl = *busy; cl-&gt;next; cl = cl-&gt;next) { /* void */ }
</pre>

<p> An endless loop looks like this: </p>
<pre class="notranslate">for ( ;; ) {
    ...
}
</pre>



<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p> Labels are surrounded with empty lines and are indented at the previous level: </p>
<pre class="notranslate">    if (i == 0) {
        u-&gt;err = "host not found";
        goto failed;
    }

    u-&gt;addrs = ngx_pcalloc(pool, i * sizeof(ngx_addr_t));
    if (u-&gt;addrs == NULL) {
        goto failed;
    }

    u-&gt;naddrs = i;

    ...

    return NGX_OK;

failed:

    freeaddrinfo(res);
    return NGX_ERROR;
</pre>





</li></ul></li></ul></li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows-nginx中文手册]]></title>
      <url>/ngx/windows.html</url>
      <content type="html"><![CDATA[<p>windows<br><a id="more"></a></p>
<h2 id="适用于Windows的nginx"><a href="#适用于Windows的nginx" class="headerlink" title="适用于Windows的nginx"></a>适用于Windows的nginx</h2><td align="left" class="notranslate"> <a href="#known_issues">Known issues</a> <br> <a href="#possible_future_enhancements">Possible future enhancements</a> <br></td>

<p>  适用于Windows的nginx版本使用本机Win32 API（而不是Cygwin仿真层）。  目前仅使用<code>select()</code>连接处理方法，因此不应期望高性能和可伸缩性。  由于这个以及一些其他已知问题，nginx for Windows的版本被认为是<em>测试</em>版。  目前，除了XSLT过滤器，图像过滤器，GeoIP模块和嵌入式Perl语言之外，它提供的功能几乎与UNIX版本的nginx相同。 </p>
<p>  要安装nginx / Windows，请<a href="download.html">下载</a>最新的主线版本发行版（1.15.7），因为nginx的主线分支包含所有已知的修复程序。  然后解压缩发行版，转到nginx-1.15.7目录，然后运行<code>nginx</code> 。  以下是驱动器C：根目录的示例： </p>
<pre class="notranslate">cd c:\
unzip nginx-1.15.7.zip
cd nginx-1.15.7
start nginx
</pre>

<p>  运行<code>tasklist</code>命令行实用程序以查看nginx进程： </p>
<pre class="notranslate">C:\nginx-1.15.7&gt;tasklist /fi "imagename eq nginx.exe"

Image Name           PID Session Name     Session#    Mem Usage
=============== ======== ============== ========== ============
nginx.exe            652 Console                 0      2 780 K
nginx.exe           1332 Console                 0      3 112 K
</pre>

<p>  其中一个进程是主进程，另一个进程是工作进程。  如果nginx未启动，请在错误日志文件<code>logs\error.log</code>查找原因。  如果尚未创建日志文件，则应在Windows事件日志中报告其原因。  如果显示错误页面而不是预期页面，还要在<code>logs\error.log</code>文件中查找原因。 </p>
<p>   nginx / Windows使用运行它的目录作为配置中相对路径的前缀。  在上面的示例中，前缀为<code>C:\nginx-1.15.7\</code> 。  必须使用正斜杠以UNIX样式指定配置文件中的路径： </p>
<pre class="notranslate">access_log   logs/site.log;
root         C:/web/html;
</pre>



<p>   nginx / Windows作为标准控制台应用程序（而非服务）运行，可以使用以下命令进行管理： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">nginx -s stop</td><td class="notranslate">fast shutdown</td><br><td class="notranslate">nginx -s quit</td><td class="notranslate">graceful shutdown</td><br><tr><td class="notranslate">nginx -s reload</td><td class="notranslate"><br>changing configuration,<br>starting new worker processes with a new configuration,<br>graceful shutdown of old worker processes<br></td></tr><td class="notranslate">nginx -s reopen</td><td class="notranslate">re-opening log files</td><br></tbody></table>



</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><ul>
<li>虽然可以启动几个工作人员，但实际上只有一个工作。 -   一个worker可以处理不超过1024个并发连接。 -   不支持UDP代理功能。 <h4 id="可能的未来增强功能"><a href="#可能的未来增强功能" class="headerlink" title="可能的未来增强功能"></a>可能的未来增强功能</h4></li>
<li>作为服务运行。 -   使用I / O完成端口作为连接处理方法。 -   在单个工作进程中使用多个工作线程。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[varindex-nginx中文手册]]></title>
      <url>/ngx/varindex.html</url>
      <content type="html"><![CDATA[<p>varindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的变量索引"><a href="#按字母顺序排列的变量索引" class="headerlink" title="按字母顺序排列的变量索引"></a>按字母顺序排列的变量索引</h2><p>   <a href="http/ngx_http_browser_module.html#var_ancient_browser">$ ancient_browser</a> <br>   <a href="http/ngx_http_core_module.html#var_arg_">$ arg_</a> <br>   <a href="http/ngx_http_core_module.html#var_args">的$ args</a> <br>   <a href="http/ngx_http_core_module.html#var_binary_remote_addr">$ binary_remote_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_binary_remote_addr">$ binary_remote_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_body_bytes_sent">$ body_bytes_sent</a> <br>   <a href="stream/ngx_stream_core_module.html#var_bytes_received">$ bytes_received</a> <br>   <a href="http/ngx_http_core_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_connection">$ connection</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_connection">$ connection</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_connection">$ connection</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_connection_requests">$ connection_requests</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_connection_requests">$ connection_requests</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_active">$ connections_active</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_reading">$ connections_reading</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_waiting">$ connections_waiting</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_writing">$ connections_writing</a> <br>   <a href="http/ngx_http_core_module.html#var_content_length">$ CONTENT_LENGTH</a> <br>   <a href="http/ngx_http_core_module.html#var_content_type">$ CONTENT_TYPE</a> <br>   <a href="http/ngx_http_core_module.html#var_cookie_">$ cookie_</a> <br>   <a href="http/ngx_http_ssi_module.html#var_date_gmt">$ date_gmt</a> <br>   <a href="http/ngx_http_ssi_module.html#var_date_local">$ DATE_LOCAL</a> <br>   <a href="http/ngx_http_core_module.html#var_document_root">$ DOCUMENT_ROOT</a> <br>   <a href="http/ngx_http_core_module.html#var_document_uri">$ DOCUMENT_URI</a> <br>   <a href="http/ngx_http_fastcgi_module.html#var_fastcgi_path_info">$ fastcgi_path_info</a> <br>   <a href="http/ngx_http_fastcgi_module.html#var_fastcgi_script_name">$ fastcgi_script_name</a> <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_area_code">$ geoip_area_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_area_code">$ geoip_area_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city">$ geoip_city</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city">$ geoip_city</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_continent_code">$ geoip_city_continent_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_continent_code">$ geoip_city_continent_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_code">$ geoip_city_country_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_code">$ geoip_city_country_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_code3">$ geoip_city_country_code3</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_code3">$ geoip_city_country_code3</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_name">$ geoip_city_country_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_name">$ geoip_city_country_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_code">$ geoip_country_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_code">$ geoip_country_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_code3">$ geoip_country_code3</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_code3">$ geoip_country_code3</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_name">$ geoip_country_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_name">$ geoip_country_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_dma_code">$ geoip_dma_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_dma_code">$ geoip_dma_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_latitude">$ geoip_latitude</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_latitude">$ geoip_latitude</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_longitude">$ geoip_longitude</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_longitude">$ geoip_longitude</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_org">$ geoip_org</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_org">$ geoip_org</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_postal_code">$ geoip_postal_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_postal_code">$ geoip_postal_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_region">$ geoip_region</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_region">$ geoip_region</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_region_name">$ geoip_region_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_region_name">$ geoip_region_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_gzip_module.html#var_gzip_ratio">$ gzip_ratio</a> <br>   <a href="http/ngx_http_core_module.html#var_host">$主机</a> <br>   <a href="http/ngx_http_core_module.html#var_hostname">$ hostname</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_hostname">$ hostname</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_v2_module.html#var_http2">$ http2</a> <br>   <a href="http/ngx_http_core_module.html#var_http_">$ HTTP</a> <br>   <a href="http/ngx_http_core_module.html#var_https">$ HTTPS</a> <br>   <a href="http/ngx_http_referer_module.html#var_invalid_referer">$ invalid_referer</a> <br>   <a href="http/ngx_http_core_module.html#var_is_args">$ is_args</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#var_jwt_claim_">$ jwt<em>claim</em></a> <br>   <a href="http/ngx_http_auth_jwt_module.html#var_jwt_header_">$ jwt<em>header</em></a> <br>   <a href="http/ngx_http_core_module.html#var_limit_rate">$ limit_rate</a> <br>   <a href="http/ngx_http_memcached_module.html#var_memcached_key">$ memcached_key</a> <br>   <a href="http/ngx_http_browser_module.html#var_modern_browser">$ modern_browser</a> <br>   <a href="http/ngx_http_core_module.html#var_msec">$ msec</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_msec">$ msec</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_msec">$ msec</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_browser_module.html#var_msie">$ MSIE</a> <br>   <a href="http/ngx_http_core_module.html#var_nginx_version">$ nginx_version</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_nginx_version">$ nginx_version</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_pid">$ pid</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_pid">$ pid</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_pipe">$ pipe</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_pipe">$ pipe</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_protocol">$协议</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_add_x_forwarded_for">$ proxy_add_x_forwarded_for</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_host">$ proxy_host使用</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_port">话$ proxy_port</a> <br>   <a href="http/ngx_http_core_module.html#var_proxy_protocol_addr">$ proxy_protocol_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_proxy_protocol_addr">$ proxy_protocol_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_proxy_protocol_port">$ proxy_protocol_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_proxy_protocol_port">$ proxy_protocol_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_query_string">$ QUERY_STRING</a> <br>   <a href="http/ngx_http_realip_module.html#var_realip_remote_addr">$ realip_remote_addr</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#var_realip_remote_addr">$ realip_remote_addr</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_realip_module.html#var_realip_remote_port">$ realip_remote_port</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#var_realip_remote_port">$ realip_remote_port</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_core_module.html#var_realpath_root">$ realpath_root</a> <br>   <a href="http/ngx_http_core_module.html#var_remote_addr">$ remote_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_remote_addr">$ remote_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_remote_port">$ remote_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_remote_port">$ remote_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_remote_user">$ REMOTE_USER</a> <br>   <a href="http/ngx_http_core_module.html#var_request">$请求</a> <br>   <a href="http/ngx_http_core_module.html#var_request_body">$ request_body</a> <br>   <a href="http/ngx_http_core_module.html#var_request_body_file">$ REQUEST_BODY_FILE</a> <br>   <a href="http/ngx_http_core_module.html#var_request_completion">$ request_completion</a> <br>   <a href="http/ngx_http_core_module.html#var_request_filename">$ REQUEST_FILENAME</a> <br>   <a href="http/ngx_http_core_module.html#var_request_id">$ REQUEST_ID</a> <br>   <a href="http/ngx_http_core_module.html#var_request_length">$ request_length</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_request_length">$ request_length</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_core_module.html#var_request_method">$ REQUEST_METHOD</a> <br>   <a href="http/ngx_http_core_module.html#var_request_time">$ request_time</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_request_time">$ request_time</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_core_module.html#var_request_uri">$ REQUEST_URI</a> <br>   <a href="http/ngx_http_core_module.html#var_scheme">$方案</a> <br>   <a href="http/ngx_http_secure_link_module.html#var_secure_link">$ secure_link</a> <br>   <a href="http/ngx_http_secure_link_module.html#var_secure_link_expires">$ secure_link_expires</a> <br>   <a href="http/ngx_http_core_module.html#var_sent_http_">$ sent<em>http</em></a> <br>   <a href="http/ngx_http_core_module.html#var_sent_trailer_">$ sent<em>trailer</em></a> <br>   <a href="http/ngx_http_core_module.html#var_server_addr">$ server_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_server_addr">$ server_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_server_name">$ SERVER_NAME</a> <br>   <a href="http/ngx_http_core_module.html#var_server_port">$ server_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_server_port">$ server_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_server_protocol">$ SERVER_PROTOCOL</a> <br>   <a href="http/ngx_http_session_log_module.html#var_session_log_binary_id">$ session_log_binary_id</a> <br>   <a href="http/ngx_http_session_log_module.html#var_session_log_id">$ session_log_id</a> <br>   <a href="stream/ngx_stream_core_module.html#var_session_time">$ session_time</a> <br>   <a href="http/ngx_http_slice_module.html#var_slice_range">$ slice_range</a> <br>   <a href="http/ngx_http_spdy_module.html#var_spdy">$ SPDY</a> <br>   <a href="http/ngx_http_spdy_module.html#var_spdy_request_priority">$ spdy_request_priority</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_cipher">$ ssl_cipher</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_cipher">$ ssl_cipher</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_ciphers">$ ssl_ciphers</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_ciphers">$ ssl_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_cert">$ ssl_client_cert</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_cert">$ ssl_client_cert</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_escaped_cert">$ ssl_client_escaped_cert</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_fingerprint">$ ssl_client_fingerprint</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_fingerprint">$ ssl_client_fingerprint</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_i_dn">$ ssl_client_i_dn</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_i_dn">$ ssl_client_i_dn</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_i_dn_legacy">$ ssl_client_i_dn_legacy</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_raw_cert">$ ssl_client_raw_cert</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_raw_cert">$ ssl_client_raw_cert</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_s_dn">$ ssl_client_s_dn</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_s_dn">$ ssl_client_s_dn</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_s_dn_legacy">$ ssl_client_s_dn_legacy</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_serial">$ ssl_client_serial</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_serial">$ ssl_client_serial</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_end">$ ssl_client_v_end</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_end">$ ssl_client_v_end</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_remain">$ ssl_client_v_remain</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_remain">$ ssl_client_v_remain</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_start">$ ssl_client_v_start</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_start">$ ssl_client_v_start</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_verify">$ ssl_client_verify</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_verify">$ ssl_client_verify</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_curves">$ ssl_curves</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_curves">$ ssl_curves</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_early_data">$ ssl_early_data</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_alpn_protocols">$ ssl_preread_alpn_protocols</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_protocol">$ ssl_preread_protocol</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_server_name">$ ssl_preread_server_name</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_protocol">$ ssl_protocol</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_protocol">$ ssl_protocol</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_server_name">$ ssl_server_name</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_server_name">$ ssl_server_name</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_session_id">$ ssl_session_id</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_session_id">$ ssl_session_id</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_session_reused">$ ssl_session_reused</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_session_reused">$ ssl_session_reused</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_core_module.html#var_status">$ status</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_status">$ status</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_status">$ status</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rtt</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rttvar</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_snd_cwnd</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rcv_space</a> <br>   <a href="http/ngx_http_core_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_time_local">$ time_local</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_time_local">$ time_local</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_time_local">$ time_local</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_userid_module.html#var_uid_got">$ uid_got</a> <br>   <a href="http/ngx_http_userid_module.html#var_uid_reset">$ uid_reset</a> <br>   <a href="http/ngx_http_userid_module.html#var_uid_set">$ uid_set</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_addr">$ upstream_addr</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_addr">$ upstream_addr</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_bytes_received">$ upstream_bytes_received</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_bytes_received">$ upstream_bytes_received</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_bytes_sent">$ upstream_bytes_sent</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_bytes_sent">$ upstream_bytes_sent</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_cache_status">$ upstream_cache_status</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_connect_time">$ upstream_connect_time</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_connect_time">$ upstream_connect_time</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_cookie_">$ upstream<em>cookie</em></a> <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_first_byte_time">$ upstream_first_byte_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_header_time">$ upstream_header_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_http_">$ upstream<em>http</em></a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_queue_time">$ upstream_queue_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_response_length">$ upstream_response_length</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_response_time">$ upstream_response_time</a> <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_session_time">$ upstream_session_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_status">$ upstream_status</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_trailer_">$ upstream<em>trailer</em></a> <br>   <a href="http/ngx_http_core_module.html#var_uri">$ URI</a> <br></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syslog-nginx中文手册]]></title>
      <url>/ngx/syslog.html</url>
      <content type="html"><![CDATA[<p>syslog<br><a id="more"></a></p>
<h2 id="记录到syslog"><a href="#记录到syslog" class="headerlink" title="记录到syslog"></a>记录到syslog</h2><p>   <a href="ngx_core_module.html#error_log">error_log</a>和<a href="http/ngx_http_log_module.html#access_log">access_log</a>指令支持记录到syslog。  以下参数配置到syslog的日志记录： </p>
<blockquote>
<p>  错误消息的严重性由nginx确定，因此在<code>error_log</code>指令中忽略该参数。 </p>
</blockquote>
<p>   syslog配置示例： </p>
<pre class="notranslate">error_log syslog:server=192.168.1.1 debug;

access_log syslog:server=unix:/var/log/nginx.sock,nohostname;
access_log syslog:server=[2001:db8::1]:12345,facility=local7,tag=nginx,severity=info combined;
</pre>





<blockquote>
<p>  从版本1.7.1开始，可以登录到syslog。  作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，从1.5.3版开始，可以使用日志记录到syslog。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syntax-nginx中文手册]]></title>
      <url>/ngx/syntax.html</url>
      <content type="html"><![CDATA[<p>syntax<br><a id="more"></a></p>
<h2 id="配置文件测量单位"><a href="#配置文件测量单位" class="headerlink" title="配置文件测量单位"></a>配置文件测量单位</h2><p>  大小可以以字节，千字节（后缀<code>k</code>和<code>K</code> ）或兆字节（后缀<code>m</code>和<code>M</code> ）来指定，例如，“ <code>1024</code> ”，“ <code>8k</code> ”，“ <code>1m</code> ”。 </p>
<p>  也可以使用<code>g</code>或<code>G</code>后缀以千兆字节为<code>g</code>指定偏移量。 </p>
<p>  可以使用以下后缀以毫秒，秒，分钟，小时，天等指定时间间隔： </p>
<td width="20%" class="notranslate">ms</td><td class="notranslate">milliseconds</td><br><td width="20%" class="notranslate">s</td><td class="notranslate">seconds</td><br><td width="20%" class="notranslate">m</td><td class="notranslate">minutes</td><br><td width="20%" class="notranslate">h</td><td class="notranslate">hours</td><br><td width="20%" class="notranslate">d</td><td class="notranslate">days</td><br><td width="20%" class="notranslate">w</td><td class="notranslate">weeks</td><br><td width="20%" class="notranslate">M</td><td class="notranslate">months, 30 days</td><br><td width="20%" class="notranslate">y</td><td class="notranslate">years, 365 days</td>



<p>  通过按从最高有效到最低有序的顺序指定多个单元，可以将多个单元组合成单个值，并且可选地由空格分隔。  例如，“ <code>1h 30m</code> ”指定与“ <code>90m</code> ”或“ <code>5400s</code> ”相同的时间。  没有后缀的值表示秒。  建议始终指定后缀。 </p>
<p>  某些时间间隔只能以秒分辨率指定。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[switches-nginx中文手册]]></title>
      <url>/ngx/switches.html</url>
      <content type="html"><![CDATA[<p>switches<br><a id="more"></a></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>   nginx支持以下命令行参数： </p>
<ul>
<li><code>-?</code>   |   <code>-h</code> - 打印命令行参数的帮助。 -    <code>-c &lt;code class=&quot;notranslate&quot;&gt;*file*</code> - 使用备用配置<code>*file*</code>而不是默认文件。 </li><li>   <code>-g &lt;code class=&quot;notranslate&quot;&gt;*directives*</code> - 设置<a href="ngx_core_module.html">全局配置指令</a> ，例如， <blockquote class="example"><pre class="notranslate">nginx -g “pid /var/run/nginx.pid; worker_processes <code>sysctl -n hw.ncpu</code>;”<br></pre></blockquote></li>-    <code>-p &lt;code class=&quot;notranslate&quot;&gt;*prefix*</code> - 设置nginx路径前缀，即保留服务器文件的目录（默认值为<code>*/usr/local/nginx*</code> ）。 -    <code>-q</code> - 在配置测试期间禁止出现非错误消息。 -    <code>-s &lt;code class=&quot;notranslate&quot;&gt;*signal*</code> - 向主进程发送<em>信号</em> 。  参数<em>信号</em>可以是以下之一： <ul class="compact"><li>   <code>stop</code> - 快速关闭 -    <code>quit</code> - 优雅地关闭 -    <code>reload</code> - 重新加载配置，使用新配置启动新的工作进程，正常关闭旧的工作进程。 -    <code>reopen</code> - 重新打开日志文件 </li>
</ul>
</ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reference-nginx中文手册]]></title>
      <url>/ngx/reference.html</url>
      <content type="html"><![CDATA[<p>reference<br><a id="more"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><td align="left" class="notranslate"> <a href="#http_stream">nginx objects</a> <br>     <a href="#http">HTTP Request</a> <br>     <a href="#stream">Stream Session</a> <br> <a href="#core">Core</a> <br>     <a href="#string">String</a> <br>     <a href="#core_json">JSON</a> <br>     <a href="#crypto">Crypto</a> <br>     <a href="#njs_api_timers">Timers</a> <br>     <a href="#njs_api_fs">File System</a> <br></td>

<p>   <a href="index.html">njs</a>提供了扩展nginx功能的对象，方法和属性。 </p>
<h4 id="nginx对象"><a href="#nginx对象" class="headerlink" title="nginx对象"></a>nginx对象</h4><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>   HTTP请求对象仅在<a href="http/ngx_http_js_module.html">ngx_http_js_module</a>模块中可用。  对象的所有字符串属性都是<a href="#string">字节字符串</a> 。 </p>
<p>  例如，可以使用语法<code>headersIn.foo</code>或<code>headersIn[&#39;Foo&#39;]</code>访问<code>Foo</code>标头 </p>
<p>  例如，可以使用语法<code>headersOut.foo</code>或<code>headersOut[&#39;Foo&#39;]</code>访问<code>Foo</code>标头 </p>
<p>  可以指定重定向URL（对于代码301,302,303,307和308）或响应正文文本（对于其他代码）作为第二个参数 </p>
<p>  如果<code>options</code>是一个字符串，那么它包含子请求参数字符串。  否则， <code>options</code>应该是具有以下键的对象： </p>
<p>  完成<code>callback</code>接收子请求响应对象，其方法和属性与父请求对象相同。 </p>
<h4 id="流会话"><a href="#流会话" class="headerlink" title="流会话"></a>流会话</h4><p>  流会话对象仅在<a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a>模块中可用。  对象的所有字符串属性都是<a href="#string">字节字符串</a> 。 </p>
<blockquote>
<p>  在njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>之前，流会话对象具有一些当前<a href="#stream_obsolete">被删除的</a>属性。 </p>
</blockquote>
<p>   <code>event</code>可以是以下字符串之一： </p>
<p>  完成回调具有以下原型： <code>callback(data, flags)</code> ，其中<code>data</code>是字符串， <code>flags</code>是具有以下属性的对象： </p>
<h4 id="过时的属性"><a href="#过时的属性" class="headerlink" title="过时的属性"></a>过时的属性</h4><p>  这些属性已在njs <a href="njs/changes.html#njs0.2.4">0.2.4中</a>删除，并且与现有的njs代码不向后兼容。 </p>
<blockquote>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_deny">s.deny（）</a>方法。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，如果没有<a href="#s_allow">调用s.allow（）</a> ， <a href="#s_deny">s.deny（）</a> ， <a href="#s_decline">s.decline（）</a> ， <a href="#s_done">s.done（）</a>并且注册了回调， <a href="#s_deny">则会</a>实现相应的行为。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_send">s.send（）</a>方法进行编写。  对于读取，当前缓冲区可用作<code>event</code>回调的第一个参数。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_decline">s.decline（）</a>方法。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_on_callback_last">flags.last</a>属性。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，可以抛出适当的异常来报告错误。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应使用相应的<a href="#s_on">事件</a> （ <code>upload</code>或<code>download</code> ）来处理来自客户端的数据。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_allow">s.allow（）</a>方法。 </p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p>  有两种类型的字符串： <code>Unicode string</code> （默认）和<code>byte string</code> 。 </p>
<p>   <code>Unicode string</code>对应于包含Unicode字符的ECMAScript字符串。 </p>
<p>   <code>Byte strings</code>包含一系列字节。  它们用于将Unicode字符串序列化为外部数据，并从外部源反序列化。  例如， <a href="#string_toutf8">toUTF8（）</a>方法使用UTF8编码将Unicode字符串序列化为字节字符串： </p>
<pre class="notranslate">&gt;&gt; '£'.toUTF8().toString('hex')
'c2a3'  /* C2 A3 is the UTF8 representation of 00A3 ('£') code point */
</pre>

<p>   <a href="#string_tobytes">toBytes（）</a>方法将代码点最多为255的Unicode字符串序列化为字节字符串，否则返回<code>null</code> ： </p>
<pre class="notranslate">&gt;&gt; '£'.toBytes().toString('hex')
'a3'  /* a3 is a byte equal to 00A3 ('£') code point  */
</pre>

<p>  只有字节字符串可以转换为不同的编码。  例如，字符串不能直接编码为<code>hex</code> ： </p>
<pre class="notranslate">&gt;&gt; 'αβγδ'.toString('base64')
TypeError: argument must be a byte string
    at String.prototype.toString (native)
    at main (native)
</pre>

<p>  要将Unicode字符串转换为十六进制，首先应将其转换为字节字符串，然后转换为十六进制： </p>
<pre class="notranslate">&gt;&gt; 'αβγδ'.toUTF8().toString('base64')
'zrHOss6zzrQ='
</pre>



<pre class="notranslate">&gt;&gt; String.bytesFrom([0x62, 0x75, 0x66, 0x66, 0x65, 0x72])
'buffer'

&gt;&gt; String.bytesFrom('YnVmZmVy', 'base64')
'buffer'
</pre>

<pre class="notranslate">&gt;&gt; String.fromCharCode(97, 98, 99, 100)
'abcd'
</pre>

<pre class="notranslate">&gt;&gt; String.fromCodePoint(97, 98, 99, 100)
'abcd'
</pre>

<pre class="notranslate">&gt;&gt; 'ABCD'.codePointAt(3);
68
</pre>

<pre class="notranslate">&gt;&gt; "a".concat("b", "c")
'abc'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.endsWith('abc')
true
&gt;&gt; 'abca'.endsWith('abc')
false
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.includes('bc')
true
</pre>

<pre class="notranslate">&gt;&gt; 'abcdef'.indexOf('de', 2)
3
</pre>

<pre class="notranslate">&gt;&gt; "nginx".lastIndexOf("gi")
1
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.length
4
</pre>

<pre class="notranslate">&gt;&gt; 'nginx'.match( /ng/i )
'ng'
</pre>

<pre class="notranslate">&gt;&gt; '1234'.padEnd(8, 'abcd')
'1234abcd'
</pre>

<pre class="notranslate">&gt;&gt; '1234'.padStart(8, 'abcd')
'abcd1234'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.repeat(3)
'abcabcabc'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefgh'.replace('d', 1)
'abc1efgh'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefgh'.search('def')
3
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefghijklmno'.slice(NaN, 5)
'abcde'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.split('')
[
 'a',
 'b',
 'c'
]
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.startsWith('abc')
true
&gt; 'aabc'.startsWith('abc')
false
</pre>

<pre class="notranslate">&gt;&gt;  'abcdefghijklmno'.substr(3, 5)
'defgh'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefghijklmno'.substring(3, 5)
'de'
</pre>

<pre class="notranslate">&gt;&gt; 'ΑΒΓΔ'.toLowerCase()
'αβγδ'
</pre>

<p>  如果未指定<code>encoding</code> ，则返回ECMAScript中指定的Unicode字符串或字节字符串。 </p>
<p>   （特定于njs）如果指定了<code>encoding</code> ，则将<a href="#string_tobytes">字节字符串</a>编码为<code>hex</code> ， <code>base64</code>或<code>base64url</code> 。 </p>
<pre class="notranslate">&gt;&gt;  'αβγδ'.toUTF8().toString('base64url')
'zrHOss6zzrQ'
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.toUpperCase()
'ΑΒΓΔ'
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.toUTF8().length
8
&gt;&gt; 'αβγδ'.length
4
</pre>

<pre class="notranslate">&gt;&gt; '   abc  '.trim()
'abc'
</pre>

<pre class="notranslate">&gt;&gt; encodeURI('012αβγδ')
'012%CE%B1%CE%B2%CE%B3%CE%B4'
</pre>

<pre class="notranslate">&gt;&gt; encodeURIComponent('[@?=')
'%5B%40%3F%3D'
</pre>

<pre class="notranslate">&gt;&gt; decodeURI('012%CE%B1%CE%B2%CE%B3%CE%B4')
'012αβγδ'
</pre>

<pre class="notranslate">&gt;&gt; decodeURIComponent('%5B%40%3F%3D')
'[@?='
</pre>



<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>   <code>JSON</code>对象（ES 5.1）提供了将njs值转换为JSON格式和从JSON格式转换的函数。 </p>
<pre class="notranslate">&gt;&gt; var json = JSON.parse('{"a":1, "b":true}')
&gt;&gt; json.a
1

&gt;&gt; JSON.stringify(json)
'{"a":1,"b":true}'

&gt;&gt; JSON.stringify(json, undefined, 1)
'{\n "a": 1,\n "b": true\n}'

&gt;&gt; JSON.stringify({ x: [10, undefined, function(){}] })
'{"x":[10,null,null]}'

&gt;&gt; JSON.stringify({"a":1, "toJSON": function() {return "xxx"}})
'"xxx"'

# Example with function replacer

&gt;&gt; function replacer(key, value) {return (typeof value === 'string') ? undefined : value}
&gt;&gt;JSON.stringify({a:1, b:"b", c:true}, replacer)
'{"a":1,"c":true}'
</pre>



<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>   Crypto模块提供加密功能支持。   <code>require(&#39;crypto&#39;)</code>返回Crypto模块对象。 </p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><pre class="notranslate">&gt;&gt; var cr = require('crypto')
undefined

&gt;&gt; cr.createHash('sha1').update('A').update('B').digest('base64url')
'BtlFlCqiamG-GMPiK_GbvKjdK10'
</pre>



<h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><pre class="notranslate">&gt;&gt; var cr = require('crypto')
undefined

&gt;&gt; cr.createHmac('sha1', 'secret.key').update('AB').digest('base64url')
'Oglm93xn23_MkiaEq_e9u8zk374'
</pre>



<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><pre class="notranslate">function handler(v)
{
    // ...
}

t = setTimeout(handler, 12);

// ...

clearTimeout(t);
</pre>



<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>  文件系统模块提供文件操作。   <code>require(&#39;fs&#39;)</code>返回模块对象。 </p>
<pre class="notranslate">&gt;&gt; var fs = require('fs')
undefined
&gt;&gt; var file = fs.readFileSync('/file/path.tar.gz')
undefined
&gt;&gt; var gzipped = /^\x1f\x8b/.test(file); gzipped
true
</pre>

<pre class="notranslate">&gt;&gt; var fs = require('fs')
undefined
&gt;&gt; var file = fs.writeFileSync('hello.txt', 'Hello world')
undefined
</pre>



<h4 id="文件系统标志"><a href="#文件系统标志" class="headerlink" title="文件系统标志"></a>文件系统标志</h4><p>   <code>flag</code>选项可以接受以下值： </p>
<ul>
<li><code>a</code> - 打开要追加的文件。  如果文件不存在，则创建该文件 -    <code>ax</code> - 与<code>a</code>相同但如果文件已存在则失败 -    <code>a+</code> - 打开一个文件进行阅读和追加。  如果该文件不存在，则将创建该文件 -    <code>ax+</code> - 与<code>a+</code>相同但如果文件已经存在则失败 -    <code>as</code> - 打开一个文件以便以同步模式追加。  如果该文件不存在，则将创建该文件 -    <code>as+</code> - 打开一个文件以便以同步模式读取和追加。  如果该文件不存在，则将创建该文件 -    <code>r</code> - 打开文件进行阅读。  如果文件不存在，则会发生异常 -    <code>r+</code> - 打开一个文件进行读写。  如果文件不存在，则会发生异常 -    <code>rs+</code> - 打开一个文件，以同步模式读写。  指示操作系统绕过本地文件系统缓存 -    <code>w</code> - 打开文件进行写作。  如果该文件不存在，则将创建该文件。  如果文件存在，则将替换它 -    <code>wx</code> - 与<code>w</code>相同但如果文件已存在则失败 -    <code>w+</code> - 打开一个文件进行读写。  如果该文件不存在，则将创建该文件。  如果文件存在，则将替换它 -    <code>wx+</code> - 与<code>w+</code>相同但如果文件已存在则失败 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_google_perftools_module-nginx中文手册]]></title>
      <url>/ngx/ngx_google_perftools_module.html</url>
      <content type="html"><![CDATA[<p>ngx_google_perftools_module<br><a id="more"></a></p>
<h2 id="Module-ngx-google-perftools-module"><a href="#Module-ngx-google-perftools-module" class="headerlink" title="Module ngx_google_perftools_module"></a>Module ngx_google_perftools_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#google_perftools_profiles">google_perftools_profiles</a> <br></td>

<p>   <code>ngx_google_perftoos_module</code>模块（0.6.29）支持使用<a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">Google Performance Tools</a>分析nginx工作进程。  该模块适用于nginx开发人员。 </p>
<p>  默认情况下不会构建此模块，应使用<code>--with-google_perftools_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">gperftools</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">google_perftools_profiles /path/to/profile;
</pre>

<p>  配置文件将存储为<code>/path/to/profile.&amp;lt;worker_pid&amp;gt;</code> 。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**google_perftools_profiles*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  设置一个文件名，用于保存nginx工作进程的分析信息。  工作进程的ID始终是文件名的一部分，并在点后面附加到文件名的末尾。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_core_module-nginx中文手册]]></title>
      <url>/ngx/ngx_core_module.html</url>
      <content type="html"><![CDATA[<p>ngx_core_module<br><a id="more"></a></p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#accept_mutex">accept_mutex</a> <br>     <a href="#accept_mutex_delay">accept_mutex_delay</a> <br>     <a href="#daemon">daemon</a> <br>     <a href="#debug_connection">debug_connection</a> <br>     <a href="#debug_points">debug_points</a> <br>     <a href="#env">env</a> <br>     <a href="#error_log">error_log</a> <br>     <a href="#events">events</a> <br>     <a href="#include">include</a> <br>     <a href="#load_module">load_module</a> <br>     <a href="#lock_file">lock_file</a> <br>     <a href="#master_process">master_process</a> <br>     <a href="#multi_accept">multi_accept</a> <br>     <a href="#pcre_jit">pcre_jit</a> <br>     <a href="#pid">pid</a> <br>     <a href="#ssl_engine">ssl_engine</a> <br>     <a href="#thread_pool">thread_pool</a> <br>     <a href="#timer_resolution">timer_resolution</a> <br>     <a href="#use">use</a> <br>     <a href="#user">user</a> <br>     <a href="#worker_aio_requests">worker_aio_requests</a> <br>     <a href="#worker_connections">worker_connections</a> <br>     <a href="#worker_cpu_affinity">worker_cpu_affinity</a> <br>     <a href="#worker_priority">worker_priority</a> <br>     <a href="#worker_processes">worker_processes</a> <br>     <a href="#worker_rlimit_core">worker_rlimit_core</a> <br>     <a href="#worker_rlimit_nofile">worker_rlimit_nofile</a> <br>     <a href="#worker_shutdown_timeout">worker_shutdown_timeout</a> <br>     <a href="#working_directory">working_directory</a> <br></td>

<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">user www www;
worker_processes 2;

error_log /var/log/nginx-error.log info;

events {
    use kqueue;
    worker_connections 2048;
}

...
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**accept_mutexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">accept_mutex off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果启用了<code>accept_mutex</code> ，则工作进程将依次接受新连接。  否则，将通知所有工作进程有关新连接的信息，如果新连接的数量很少，则某些工作进程可能只是浪费系统资源。 </p>
<blockquote>
<p>  无需在支持<a href="events.html#epoll">EPOLLEXCLUSIVE</a>标志（1.11.3）的系统上或使用<a href="http/ngx_http_core_module.html#reuseport">reuseport</a>时<a href="http/ngx_http_core_module.html#reuseport">启用accept_mutex</a> 。 </p>
<p>  在1.11.3版之前，默认值为<code>on</code> 。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**accept_mutex_delay*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">accept_mutex_delay 500ms;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果启用了<a href="#accept_mutex">accept_mutex</a> ，则指定当另一个工作进程当前正在接受新连接时，工作进程将尝试重新启动接受新连接的最长时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**daemonon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">daemon on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  确定nginx是否应该成为守护进程。  主要用于开发过程中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**debug_connection**     &lt;code class=&quot;notranslate&quot;&gt;*address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  为选定的客户端连接启用调试日志。  其他连接将使用<a href="#error_log">error_log</a>指令设置的日志记录级别。  调试连接由IPv4或IPv6（1.3.0,1.2.1）地址或网络指定。  也可以使用主机名指定连接。  对于使用UNIX域套接字（1.3.0,1.2.1）的连接，调试日志由“ <code>unix:</code> ”参数启用。 </p>
<pre class="notranslate">events {
    debug_connection 127.0.0.1;
    debug_connection localhost;
    debug_connection 192.0.2.0/24;
    debug_connection ::1;
    debug_connection 2001:0db8::/32;
    debug_connection unix:;
    ...
}
</pre>



<blockquote>
<p>  要使此指令起作用，需要使用<code>--with-debug</code>构建nginx，请参阅“ <a href="debugging_log.html">调试日志</a> ”。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**debug_pointsabort</code> | <code>stop</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令用于调试。 </p>
<p>  当检测到内部错误时，例如在重新启动工作进程时套接字泄漏，启用<code>debug_points</code>会导致核心文件创建（ <code>abort</code> ）或停止进程（ <code>stop</code> ）以使用系统调试器进行进一步分析。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**env*variable*</code> [= <code>*value*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">env TZ;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  默认情况下，nginx会删除从其父进程继承的所有环境变量，但TZ变量除外。  该指令允许保留一些继承的变量，更改其值或创建新的环境变量。  那么这些变量是： </p>
<ul>
<li>在可执行文件的<a href="control.html#upgrade">实时升级</a>期间继承; -   由<a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a>模块使用; -   由工作进程使用。  应该记住，以这种方式控制系统库并不总是可行的，因为库只在初始化期间检查变量是常见的，远在它们可以使用该指令设置之前。  一个例外是上面提到的可执行文件的<a href="control.html#upgrade">实时升级</a> 。 </li>
</ul>
<p>  除非明确配置，否则TZ变量始终继承并可供<a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a>模块使用。 </p>
<p>  用法示例： </p>
<pre class="notranslate">env MALLOC_OPTIONS;
env PERL5LIB=/data/site/modules;
env OPENSSL_ALLOW_PROXY_CERTS=1;
</pre>





<blockquote>
<p>   NGINX环境变量由nginx在内部使用，不应由用户直接设置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**error_log*file*</code> [ <code>*level*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">error_log logs/error.log error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> , <code>http</code> , <code>mail</code> , <code>stream</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  配置日志记录。  可以在同一级别指定多个日志（1.5.2）。  如果在<code>main</code>配置级别上未明确定义将日志写入文件，则将使用默认文件。 </p>
<p>  第一个参数定义将存储日志的<code>*file*</code> 。  特殊值<code>stderr</code>选择标准错误文件。  可以通过指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  可以通过指定“ <code>memory:</code> ”前缀和缓冲区<code>*size*</code>来配置记录到<a href="debugging_log.html#memory">循环内存缓冲区</a> ，通常用于调试（1.7.11）。 </p>
<p>  第二个参数确定日志记录<code>*level*</code> ，可以是以下之一： <code>debug</code> ， <code>info</code> ， <code>notice</code> ， <code>warn</code> ， <code>error</code> ， <code>crit</code> ， <code>alert</code>或<code>emerg</code> 。  上面的日志级别按严重性增加的顺序列出。  设置某个日志级别将导致记录指定和更严重日志级别的所有消息。  例如，默认级别<code>error</code>将导致记录<code>error</code> ， <code>crit</code> ， <code>alert</code>和<code>emerg</code>消息。  如果省略此参数，则使用<code>error</code> 。 </p>
<blockquote>
<p>  要使<code>debug</code>日志记录正常工作，需要使用<code>--with-debug</code>构建nginx，请参阅“ <a href="debugging_log.html">调试日志</a> ”。 </p>
<p>  该指令可以在从1.7.11版本开始的<code>stream</code>级别上指定，也可以在从1.9.0版本开始的<code>mail</code>级别上指定。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**events** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供配置文件上下文，其中指定了影响连接处理的指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**include*file*</code> | <code>*mask*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>any</code> <br>                </td></p>
<p>  包含另一个<code>*file*</code>或与指定<code>*mask*</code>匹配的文件到配置中。  包含的文件应包含语法正确的指令和块。 </p>
<p>  用法示例： </p>
<pre class="notranslate">include mime.types;
include vhosts/*.conf;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**load_module*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.9.11版中。 </p>
<p>  加载动态模块。 </p>
<p>  例： </p>
<pre class="notranslate">load_module modules/ngx_mail_module.so;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**lock_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">lock_file logs/nginx.lock;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>   nginx使用锁定机制来实现<a href="#accept_mutex">accept_mutex</a>并序列化对共享内存的访问。  在大多数系统上，锁是使用原子操作实现的，并且忽略该指令。  在其他系统上，使用“锁定文件”机制。  该指令指定锁文件名称的前缀。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**master_processon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">master_process on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  确定是否已启动工作进程。  该指令适用于nginx开发人员。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**multi_accepton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">multi_accept off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果禁用<code>multi_accept</code>则工作进程将一次接受一个新连接。  否则，工作进程将一次接受所有新连接。 </p>
<blockquote>
<p>  如果使用<a href="events.html#kqueue">kqueue</a>连接处理方法，则忽略该指令，因为它报告了等待接受的新连接的数量。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pcre_jiton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pcre_jit off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用或禁用对配置解析时已知的正则表达式使用“即时编译”（PCRE JIT）。 </p>
<p>   PCRE JIT可以显着加快正则表达式的处理速度。 </p>
<blockquote>
<p>  从使用<code>--enable-jit</code>配置参数构建的8.20版开始，JIT在PCRE库中可用。  当使用nginx（– <code>--with-pcre=</code> ）构建PCRE库时，通过<code>--with-pcre-jit</code>配置参数启用JIT支持。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pid*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pid logs/nginx.pid;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义将存储主进程的进程ID的<code>*file*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_engine*device*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义硬件SSL加速器的名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**thread_pool**     &lt;code class=&quot;notranslate&quot;&gt;*name*</code>    <code>threads</code> = <code>*number*</code>    [ <code>max_queue</code> = <code>*number*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">thread_pool default threads=32 max_queue=65536;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  定义用于多线程读取和发送文件<a href="http/ngx_http_core_module.html#aio">而不阻塞</a>工作进程的命名线程池。 </p>
<p>   <code>threads</code>参数定义池中的线程数。 </p>
<p>  如果池中的所有线程都忙，则新任务将在队列中等待。   <code>max_queue</code>参数限制允许在队列中等待的任务数。  默认情况下，队列中最多可以等待65536个任务。  当队列溢出时，任务完成并出现错误。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**timer_resolution*interval*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  减少工作进程中的计时器分辨率，从而减少<code>gettimeofday()</code>系统调用的次数。  默认情况下，每次收到内核事件时都会调用<code>gettimeofday()</code> 。  在降低分辨率的情况下， <code>gettimeofday()</code>仅在每个指定的<code>*interval*</code>调用一次。 </p>
<p>  例： </p>
<pre class="notranslate">timer_resolution 100ms;
</pre>



<p>  间隔的内部实现取决于使用的方法： </p>
<ul>
<li>如果使用<code>kqueue</code> ， <code>EVFILT_TIMER</code>过滤器; -    <code>timer_create()</code>如果使用了<code>eventport</code> ; -    <code>setitimer()</code>否则。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**use*method*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  指定要使用的<a href="events.html">连接处理</a> <code>*method*</code> 。  通常不需要明确指定它，因为nginx默认使用最有效的方法。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**user*user*</code> [ <code>*group*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">user nobody nobody;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程使用的<code>*user*</code>和<code>*group*</code>凭据。  如果省略group，则使用名称等于<code>*user*</code>的组。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_aio_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_aio_requests 32;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  该指令出现在1.1.4和1.0.7版本中。 </p>
<p>  将<a href="http/ngx_http_core_module.html#aio">aio</a>与<a href="events.html#epoll">epoll</a>连接处理方法一起使用时，设置单个工作进程的未完成异步I / O操作的最大<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_connections*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_connections 512;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  设置工作进程可以打开的最大并发连接数。 </p>
<p>  应该记住，这个数字包括所有连接（例如与代理服务器的连接等），而不仅仅是与客户端的连接。  另一个考虑因素是实际的并发连接数不能超过最大打开文件数的当前限制，可以通过<a href="#worker_rlimit_nofile">worker_rlimit_nofile</a>更改。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_cpu_affinity*cpumask*</code> …; <br> <code>**worker_cpu_affinityauto</code> [ <code>*cpumask*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  将工作进程绑定到CPU组。  每个CPU集由允许的CPU的位掩码表示。  应该为每个工作进程定义一个单独的集合。  默认情况下，工作进程不绑定到任何特定的CPU。 </p>
<p>  例如， </p>
<pre class="notranslate">worker_processes    4;
worker_cpu_affinity 0001 0010 0100 1000;
</pre>

<p>  将每个工作进程绑定到一个单独的CPU，同时 </p>
<pre class="notranslate">worker_processes    2;
worker_cpu_affinity 0101 1010;
</pre>

<p>  将第一个工作进程绑定到CPU0 / CPU2，将第二个工作进程绑定到CPU1 / CPU3。  第二个例子适用于超线程。 </p>
<p>  特殊值<code>auto</code> （1.9.10）允许将工作进程自动绑定到可用的CPU： </p>
<pre class="notranslate">worker_processes auto;
worker_cpu_affinity auto;
</pre>

<p>  可选的mask参数可用于限制可用于自动绑定的CPU： </p>
<pre class="notranslate">worker_cpu_affinity auto 01010101;
</pre>





<blockquote>
<p>  该指令仅适用于FreeBSD和Linux。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_priority*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_priority 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的调度优先级，就像使用<code>nice</code>命令一样：负数表示更高的优先级。  允许范围通常在-20到20之间变化。 </p>
<p>  例： </p>
<pre class="notranslate">worker_priority -10;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_processes*number*</code> | <code>auto</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_processes 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的数量。 </p>
<p>  最佳值取决于许多因素，包括（但不限于）CPU核心数，存储数据的硬盘驱动器数和负载模式。  如果有疑问，将其设置为可用CPU核心数将是一个良好的开端（值“ <code>auto</code> ”将尝试自动检测它）。 </p>
<blockquote>
<p>  从版本1.3.8和1.2.5开始支持<code>auto</code>参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_rlimit_core*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  更改工作进程的核心文件（ <code>RLIMIT_CORE</code> ）的最大大小限制。  用于在不重新启动主进程的情况下增加限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_rlimit_nofile*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  更改工作进程的最大打开文件数（ <code>RLIMIT_NOFILE</code> ）限制。  用于在不重新启动主进程的情况下增加限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_shutdown_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.11.11版中。 </p>
<p>  配置正常关闭工作进程的超时。  当<code>*time*</code>到期时，nginx将尝试关闭当前打开的所有连接以方便关闭。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**working_directory*directory*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的当前工作目录。  它主要在编写核心文件时使用，在这种情况下，工作进程应具有指定目录的写入权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx_dtrace_pid_provider-nginx中文手册]]></title>
      <url>/ngx/nginx_dtrace_pid_provider.html</url>
      <content type="html"><![CDATA[<p>nginx_dtrace_pid_provider<br><a id="more"></a></p>
<h2 id="使用DTrace-pid提供程序调试nginx"><a href="#使用DTrace-pid提供程序调试nginx" class="headerlink" title="使用DTrace pid提供程序调试nginx"></a>使用DTrace pid提供程序调试nginx</h2><p>  本文假设读者具有nginx内部和<a href="#see_also">DTrace</a>的一般知识。 </p>
<p>  尽管使用<a href="debugging_log.html">–with-debug</a>选项构建的nginx已经提供了大量有关请求处理的信息，但有时需要更彻底地跟踪代码路径的特定部分，同时省略其余的调试输出。   DTrace pid提供程序（在Solaris，macOS上提供）是一个用于探索userland程序内部的有用工具，因为它不需要任何代码更改，它可以帮助完成任务。  用于跟踪和打印nginx函数调用的简单DTrace脚本可能如下所示： </p>
<pre class="notranslate">#pragma D option flowindent

pid$target:nginx::entry {
}

pid$target:nginx::return {
}
</pre>



<p>  但是，函数调用跟踪的DTrace功能仅提供有限的有用信息。  函数参数的实时检查通常更有趣，但也更复杂一些。  以下示例旨在帮助读者更熟悉DTrace以及使用DTrace分析nginx行为的过程。 </p>
<p>  将DTrace与nginx一起使用的常见方案之一如下：附加到nginx工作进程以记录请求行和请求开始时间。  要附加的相应函数是<code>ngx_http_process_request()</code> ，所讨论的参数是指向<code>ngx_http_request_t</code>结构的指针。  用于此类请求记录的DTrace脚本可以如下所示： </p>
<pre class="notranslate">pid$target::*ngx_http_process_request:entry
{
    this-&gt;request = (ngx_http_request_t *)copyin(arg0, sizeof(ngx_http_request_t));
    this-&gt;request_line = stringof(copyin((uintptr_t)this-&gt;request-&gt;request_line.data,
                                         this-&gt;request-&gt;request_line.len));
    printf("request line = %s\n", this-&gt;request_line);
    printf("request start sec = %d\n", this-&gt;request-&gt;start_sec);
}
</pre>



<p>  应该注意的是，在上面的示例中，DTrace需要一些关于<code>ngx_http_process_request</code>结构的知识。  不幸的是，虽然可以在DTrace脚本中使用特定的<code>#include</code>指令，然后将其传递给C预处理器（带有<code>-C</code>标志），但这并不能真正起作用。  由于存在大量的交叉依赖性，因此几乎所有的nginx头文件都必须包含在内。  反过来，基于<code>configure</code>脚本设置，nginx标头将包括PCRE，OpenSSL和各种系统头文件。  虽然理论上所有与特定nginx构建相关的头文件都可能包含在DTrace脚本预处理和编译中，但实际上DTrace脚本很可能由于某些头文件中的语法未知而无法编译。 </p>
<p>  上述问题可以通过在DTrace脚本中仅包含相关且必要的结构和类型定义来解决。   DTrace必须知道结构，类型和字段偏移的大小。  因此，可以通过手动优化用于DTrace的结构定义来进一步减少依赖性。 </p>
<p>  让我们使用上面的DTrace脚本示例，看看它需要什么样的结构定义才能正常工作。 </p>
<p>  首先应该包括configure生成的<code>objs/ngx_auto_config.h</code>文件，因为它定义了一些影响各种<code>#ifdef</code>的常量。  之后， <code>ngx_table_elt_t</code>一些基本类型和定义（如<code>ngx_str_t</code> ， <code>ngx_table_elt_t</code> ， <code>ngx_uint_t</code>等）放在DTrace脚本的开头。  这些定义是紧凑的，常用且不太可能经常改变。 </p>
<p>  然后是<code>ngx_http_process_request_t</code>结构，其中包含许多指向其他结构的指针。  因为这些指针实际上与此脚本无关，并且因为它们具有相同的大小，所以可以用void指针替换它们。  不是更改定义，最好添加适当的typedef，但是： </p>
<pre class="notranslate">typedef ngx_http_upstream_t     void;
typedef ngx_http_request_body_t void;
</pre>

<p>  最后但并非最不重要的是，有必要添加两个成员结构的定义（ <code>ngx_http_headers_in_t</code> ， <code>ngx_http_headers_out_t</code> ），回调函数的声明和常量的定义。 </p>
<p>  最终的DTrace脚本可以从<a href="http://nginx.org/download/trace_process_request.d" target="_blank" rel="noopener">这里</a>下载。 </p>
<p>  以下示例显示了运行此脚本的输出： </p>
<pre class="notranslate"># dtrace -C -I ./objs -s trace_process_request.d -p 4848
dtrace: script 'trace_process_request.d' matched 1 probe
CPU     ID                    FUNCTION:NAME
  1      4 .XAbmO.ngx_http_process_request:entry request line = GET / HTTP/1.1
request start sec = 1349162898

  0      4 .XAbmO.ngx_http_process_request:entry request line = GET /en/docs/nginx_dtrace_pid_provider.html HTTP/1.1
request start sec = 1349162899
</pre>



<p>  使用类似的技术，读者应该能够跟踪其他nginx函数调用。 </p>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><ul>
<li><a href="http://docs.oracle.com/cd/E19253-01/817-6223/index.html" target="_blank" rel="noopener">Solaris动态跟踪指南</a> -    <a href="http://dtrace.org/blogs/brendan/2011/02/09/dtrace-pid-provider/" target="_blank" rel="noopener">有关DTrace pid提供程序的简介文章</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux_packages-nginx中文手册]]></title>
      <url>/ngx/linux_packages.html</url>
      <content type="html"><![CDATA[<p>linux_packages<br><a id="more"></a></p>
<h2 id="nginx：Linux包"><a href="#nginx：Linux包" class="headerlink" title="nginx：Linux包"></a>nginx：Linux包</h2><p>  目前，nginx软件包可用于以下发行版和版本： </p>
<p>   RHEL / CentOS的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">6.x</td><td class="notranslate">x86_64, i386</td><br><td width="20%" class="notranslate">7.4+</td><td class="notranslate">x86_64, ppc64le</td><br></tbody></table>



</blockquote>
<p>   Debian的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td width="20%" class="notranslate">Codename</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">8.x</td><td width="20%" class="notranslate">jessie</td><td class="notranslate">x86_64, i386</td><br><td width="20%" class="notranslate">9.x</td><td width="20%" class="notranslate">stretch</td><td class="notranslate">x86_64, i386</td><br></tbody></table>



</blockquote>
<p>   Ubuntu的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td width="20%" class="notranslate">Codename</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">14.04</td><td width="20%" class="notranslate">trusty</td><td class="notranslate">x86_64, i386, aarch64/arm64</td><br><td width="20%" class="notranslate">16.04</td><td width="20%" class="notranslate">xenial</td><td class="notranslate">x86_64, i386, ppc64el, aarch64/arm64</td><br><td width="20%" class="notranslate">18.04</td><td width="20%" class="notranslate">bionic</td><td class="notranslate">x86_64, aarch64/arm64</td><br><td width="20%" class="notranslate">18.10</td><td width="20%" class="notranslate">cosmic</td><td class="notranslate">x86_64</td><br></tbody></table>



</blockquote>
<p>   SLES： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">12</td><td class="notranslate">x86_64</td><br><td width="20%" class="notranslate">15</td><td class="notranslate">x86_64</td><br></tbody></table>



</blockquote>
<p>  要启用Linux软件包的自动更新，请为RHEL / CentOS发行版设置yum存储库，为Debian / Ubuntu发行版设置apt存储库，或为SLES设置zypper存储库。 </p>
<h4 id="用于稳定版本的预制包"><a href="#用于稳定版本的预制包" class="headerlink" title="用于稳定版本的预制包"></a>用于稳定版本的预制包</h4><p>  要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为<code>/etc/yum.repos.d/nginx.repo</code>的文件： </p>
<pre class="notranslate">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/
gpgcheck=0
enabled=1
</pre>

<p>  对于6.x或7.x版本，将“ <code>OS</code> ”替换为“ <code>rhel</code> ”或“ <code>centos</code> ”，取决于所使用的分布，将“ <code>OSRELEASE</code> ”替换为“ <code>6</code> ”或“ <code>7</code> ”。 </p>
<p>  对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到<code>apt</code>程序密钥环。  请从我们的网站下载<a href="/keys/nginx_signing.key">此密钥</a> ，并使用以下命令将其添加到<code>apt</code>程序密钥环： </p>
<pre class="notranslate">sudo apt-key add nginx_signing.key
</pre>



<p>  对于Debian，用Debian分发<a href="#distributions">代号</a>取代<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/debian/ *codename* nginx
deb-src http://nginx.org/packages/debian/ *codename* nginx
</pre>



<p>  对于Ubuntu，使用Ubuntu分发<a href="#distributions">代号来</a>替换<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/ubuntu/ *codename* nginx
deb-src http://nginx.org/packages/ubuntu/ *codename* nginx
</pre>



<p>  对于Debian / Ubuntu，然后运行以下命令： </p>
<pre class="notranslate">apt-get update
apt-get install nginx
</pre>



<p>  对于SLES 12，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/sles/12' nginx
</pre>



<p>  对于SLES 15，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/sles/15' nginx
</pre>



<h4 id="Mainline版本的预构建包"><a href="#Mainline版本的预构建包" class="headerlink" title="Mainline版本的预构建包"></a>Mainline版本的预构建包</h4><p>  要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为<code>/etc/yum.repos.d/nginx.repo</code>的文件： </p>
<pre class="notranslate">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/mainline/OS/OSRELEASE/$basearch/
gpgcheck=0
enabled=1
</pre>

<p>  对于6.x或7.x版本，将“ <code>OS</code> ”替换为“ <code>rhel</code> ”或“ <code>centos</code> ”，取决于所使用的分布，将“ <code>OSRELEASE</code> ”替换为“ <code>6</code> ”或“ <code>7</code> ”。 </p>
<p>  对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到<code>apt</code>程序密钥环。  请从我们的网站下载<a href="/keys/nginx_signing.key">此密钥</a> ，并使用以下命令将其添加到<code>apt</code>程序密钥环： </p>
<pre class="notranslate">sudo apt-key add nginx_signing.key
</pre>



<p>  对于Debian，用Debian分发<a href="#distributions">代号</a>取代<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/mainline/debian/ *codename* nginx
deb-src http://nginx.org/packages/mainline/debian/ *codename* nginx
</pre>



<p>  对于Ubuntu，使用Ubuntu分发<a href="#distributions">代号来</a>替换<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/mainline/ubuntu/ *codename* nginx
deb-src http://nginx.org/packages/mainline/ubuntu/ *codename* nginx
</pre>



<p>  对于Debian / Ubuntu，然后运行以下命令： </p>
<pre class="notranslate">apt-get update
apt-get install nginx
</pre>



<p>  对于SLES 12，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/mainline/sles/12' nginx
</pre>



<p>  对于SLES 15，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/mainline/sles/15' nginx
</pre>



<h4 id="源包"><a href="#源包" class="headerlink" title="源包"></a>源包</h4><p>  包装源可以在<a href="http://hg.nginx.org/pkg-oss" target="_blank" rel="noopener">包装源库中找到</a> 。 </p>
<p>   <code>default</code>分支包含当前主线版本的打包源，而<code>stable-*</code>分支包含稳定版本的最新源。  要构建二进制包，请在Debian / Ubuntu上的<code>debian/</code>目录中运行<code>make</code> ，或在RHEL / CentOS / SLES上的<code>rpm/SPECS/</code>运行<code>make</code> 。 </p>
<p>  打包源在nginx使用的相同的<a href="LICENSE">2条款BSD类许可证</a>下分发。 </p>
<h4 id="动态模块"><a href="#动态模块" class="headerlink" title="动态模块"></a>动态模块</h4><p>  主nginx包是使用所有模块构建的，这些模块不需要额外的库来避免额外的依赖性。  从版本1.9.11开始，nginx支持<a href="ngx_core_module.html#load_module">动态模块</a> ，以下模块构建为动态模块并作为单独的软件包提供： </p>
<pre class="notranslate">nginx-module-geoip
nginx-module-image-filter
nginx-module-njs
nginx-module-perl
nginx-module-xslt
</pre>



<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>   RPM软件包和Debian / Ubuntu存储库都使用数字签名来验证下载软件包的完整性和来源。  为了检查签名，有必要下载<a href="/keys/nginx_signing.key">nginx签名密钥</a>并将其导入<code>rpm</code>或<code>apt</code>程序的密钥环： </p>
<ul>
<li>在Debian / Ubuntu上： <blockquote class="example"><pre class="notranslate">sudo apt-key add nginx_signing.key</pre></blockquote>-   在RHEL / CentOS上： <blockquote class="example"><pre class="notranslate">sudo rpm –import nginx_signing.key</pre></blockquote>-   在SLES上： <blockquote class="example"><pre class="notranslate">sudo rpm –import nginx_signing.key</pre></blockquote><pre class="notranslate">sudo rpm --import nginx_signing.key</pre>



</li>
</ul>
<p>  在Debian / Ubuntu / SLES上，默认情况下会检查签名，但在RHEL / CentOS上需要设置 </p>
<pre class="notranslate">gpgcheck=1</pre>

<p>  在<code>/etc/yum.repos.d/nginx.repo</code>文件中。 </p>
<p>  由于我们的<a href="en/pgp_keys.html">PGP密钥</a>和软件包位于同一台服务器上，因此它们同样受信任。  强烈建议另外验证下载的PGP密钥的真实性。   PGP具有“信任网”概念，当一个密钥由其他人的密钥签名时，该密钥又由另一个密钥签名，依此类推。  通常可以构建从任意密钥到您知道并亲自信任的某个人密钥的链，从而验证链中第一个密钥的真实性。   <a href="http://www.dewinter.com/gnupg_howto/english/GPGMiniHowto-1.html" target="_blank" rel="noopener">GPG Mini Howto</a>详细描述了这一概念。  我们的密钥有足够的签名，其真实性相对容易检查。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[install-nginx中文手册]]></title>
      <url>/ngx/install.html</url>
      <content type="html"><![CDATA[<p>install<br><a id="more"></a></p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>   nginx的安装方式可能不同，具体取决于操作系统。 </p>
<h4 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h4><p>  对于Linux，可以使用nginx.org中的nginx <a href="linux_packages.html">包</a> 。 </p>
<h4 id="在FreeBSD上安装"><a href="#在FreeBSD上安装" class="headerlink" title="在FreeBSD上安装"></a>在FreeBSD上安装</h4><p>  在FreeBSD上，可以从<a href="http://www.freebsd.org/doc/handbook/pkgng-intro.html" target="_blank" rel="noopener">软件包</a>或通过<a href="http://www.freebsd.org/doc/handbook/ports-using.html" target="_blank" rel="noopener">ports</a>系统安装nginx。   ports系统提供了更大的灵活性，允许在众多选项中进行选择。  该端口将使用指定的选项编译nginx并安装它。 </p>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p>  如果需要一些特殊功能，包和端口不可用，也可以从源文件编译nginx。  虽然更灵活，但这种方法对初学者来说可能很复杂。  有关更多信息，请参阅<a href="configure.html">从源构建nginx</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[index-nginx中文手册]]></title>
      <url>/ngx/index.html</url>
      <content type="html"><![CDATA[<p>index<br><a id="more"></a></p>
<h2 id="nginx文档"><a href="#nginx文档" class="headerlink" title="nginx文档"></a>nginx文档</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p><a href="install.html">安装nginx</a> -    <a href="configure.html">从Sources构建nginx</a> -    <a href="beginners_guide.html">初学者指南</a> -    <a href="https://www.nginx.com/resources/admin-guide/" target="_blank" rel="noopener">管理员指南</a> -    <a href="control.html">控制nginx</a> -    <a href="events.html">连接处理方法</a> -    <a href="hash.html">设置哈希值</a> -    <a href="debugging_log.html">调试日志</a> -    <a href="syslog.html">记录到syslog</a> -    <a href="syntax.html">配置文件测量单位</a> -    <a href="switches.html">命令行参数</a> -    <a href="windows.html">适用于Windows的nginx</a> </p>
</li>
<li><p><a href="http/request_processing.html">nginx如何处理请求</a> -    <a href="http/server_names.html">服务器名称</a> -    <a href="http/load_balancing.html">使用nginx作为HTTP负载均衡器</a> -    <a href="http/configuring_https_servers.html">配置HTTPS服务器</a> </p>
</li>
<li><p><a href="stream/stream_processing.html">nginx如何处理TCP / UDP会话</a> </p>
</li>
<li><p><a href="njs/index.html">用njs编写脚本</a> </p>
</li>
<li><p><a href="http://www.aosabook.org/en/nginx.html" target="_blank" rel="noopener">“开源应用程序架构”中的“nginx”一章</a> </p>
</li>
</ul>
<h4 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h4><ul>
<li><p><a href="howto_build_on_win32.html">使用Visual C在Win32平台上构建nginx</a> -    <a href="https://www.nginx.com/resources/admin-guide/setting-nginx-plus-environment-amazon-ec2/" target="_blank" rel="noopener">在Amazon EC2上设置NGINX Plus环境</a> -    <a href="nginx_dtrace_pid_provider.html">使用DTrace pid提供程序调试nginx</a> </p>
</li>
<li><p><a href="http/converting_rewrite_rules.html">转换重写规则</a> -    <a href="http/websocket.html">WebSocket代理</a> </p>
</li>
</ul>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><ul>
<li><a href="contributing_changes.html">贡献变化</a> -    <a href="dev/development_guide.html">开发指南</a> </li>
</ul>
<h4 id="模块参考"><a href="#模块参考" class="headerlink" title="模块参考"></a>模块参考</h4><ul>
<li><a href="dirindex.html">按字母顺序排列的指令索引</a> -    <a href="varindex.html">按字母顺序排列的变量索引</a> </li>
</ul>
<ul>
<li><a href="ngx_core_module.html">核心功能</a> </li>
</ul>
<ul>
<li><a href="http/ngx_http_core_module.html">ngx_http_core_module</a> -    <a href="http/ngx_http_access_module.html">ngx_http_access_module</a> -    <a href="http/ngx_http_addition_module.html">ngx_http_addition_module</a> -    <a href="http/ngx_http_api_module.html">ngx_http_api_module</a> -    <a href="http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> -    <a href="http/ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> -    <a href="http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> -    <a href="http/ngx_http_autoindex_module.html">ngx_http_autoindex_module</a> -    <a href="http/ngx_http_browser_module.html">ngx_http_browser_module</a> -    <a href="http/ngx_http_charset_module.html">ngx_http_charset_module</a> -    <a href="http/ngx_http_dav_module.html">ngx_http_dav_module</a> -    <a href="http/ngx_http_empty_gif_module.html">ngx_http_empty_gif_module</a> -    <a href="http/ngx_http_f4f_module.html">ngx_http_f4f_module</a> -    <a href="http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a> -    <a href="http/ngx_http_flv_module.html">ngx_http_flv_module</a> -    <a href="http/ngx_http_geo_module.html">ngx_http_geo_module</a> -    <a href="http/ngx_http_geoip_module.html">ngx_http_geoip_module</a> -    <a href="http/ngx_http_grpc_module.html">ngx_http_grpc_module</a> -    <a href="http/ngx_http_gunzip_module.html">ngx_http_gunzip_module</a> -    <a href="http/ngx_http_gzip_module.html">ngx_http_gzip_module</a> -    <a href="http/ngx_http_gzip_static_module.html">ngx_http_gzip_static_module</a> -    <a href="http/ngx_http_headers_module.html">ngx_http_headers_module</a> -    <a href="http/ngx_http_hls_module.html">ngx_http_hls_module</a> -    <a href="http/ngx_http_image_filter_module.html">ngx_http_image_filter_module</a> -    <a href="http/ngx_http_index_module.html">ngx_http_index_module</a> -    <a href="http/ngx_http_js_module.html">ngx_http_js_module</a> -    <a href="http/ngx_http_keyval_module.html">ngx_http_keyval_module</a> -    <a href="http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a> -    <a href="http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a> -    <a href="http/ngx_http_log_module.html">ngx_http_log_module</a> -    <a href="http/ngx_http_map_module.html">ngx_http_map_module</a> -    <a href="http/ngx_http_memcached_module.html">ngx_http_memcached_module</a> -    <a href="http/ngx_http_mirror_module.html">ngx_http_mirror_module</a> -    <a href="http/ngx_http_mp4_module.html">ngx_http_mp4_module</a> -    <a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a> -    <a href="http/ngx_http_proxy_module.html">ngx_http_proxy_module</a> -    <a href="http/ngx_http_random_index_module.html">ngx_http_random_index_module</a> -    <a href="http/ngx_http_realip_module.html">ngx_http_realip_module</a> -    <a href="http/ngx_http_referer_module.html">ngx_http_referer_module</a> -    <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> -    <a href="http/ngx_http_scgi_module.html">ngx_http_scgi_module</a> -    <a href="http/ngx_http_secure_link_module.html">ngx_http_secure_link_module</a> -    <a href="http/ngx_http_session_log_module.html">ngx_http_session_log_module</a> -    <a href="http/ngx_http_slice_module.html">ngx_http_slice_module</a> -    <a href="http/ngx_http_spdy_module.html">ngx_http_spdy_module</a> -    <a href="http/ngx_http_split_clients_module.html">ngx_http_split_clients_module</a> -    <a href="http/ngx_http_ssi_module.html">ngx_http_ssi_module</a> -    <a href="http/ngx_http_ssl_module.html">ngx_http_ssl_module</a> -    <a href="http/ngx_http_status_module.html">ngx_http_status_module</a> -    <a href="http/ngx_http_stub_status_module.html">ngx_http_stub_status_module</a> -    <a href="http/ngx_http_sub_module.html">ngx_http_sub_module</a> -    <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> -    <a href="http/ngx_http_upstream_conf_module.html">ngx_http_upstream_conf_module</a> -    <a href="http/ngx_http_upstream_hc_module.html">ngx_http_upstream_hc_module</a> -    <a href="http/ngx_http_userid_module.html">ngx_http_userid_module</a> -    <a href="http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module</a> -    <a href="http/ngx_http_v2_module.html">ngx_http_v2_module</a> -    <a href="http/ngx_http_xslt_module.html">ngx_http_xslt_module</a> </li>
</ul>
<ul>
<li><a href="mail/ngx_mail_core_module.html">ngx_mail_core_module</a> -    <a href="mail/ngx_mail_auth_http_module.html">ngx_mail_auth_http_module</a> -    <a href="mail/ngx_mail_proxy_module.html">ngx_mail_proxy_module</a> -    <a href="mail/ngx_mail_ssl_module.html">ngx_mail_ssl_module</a> -    <a href="mail/ngx_mail_imap_module.html">ngx_mail_imap_module</a> -    <a href="mail/ngx_mail_pop3_module.html">ngx_mail_pop3_module</a> -    <a href="mail/ngx_mail_smtp_module.html">ngx_mail_smtp_module</a> </li>
</ul>
<ul>
<li><a href="stream/ngx_stream_core_module.html">ngx_stream_core_module</a> -    <a href="stream/ngx_stream_access_module.html">ngx_stream_access_module</a> -    <a href="stream/ngx_stream_geo_module.html">ngx_stream_geo_module</a> -    <a href="stream/ngx_stream_geoip_module.html">ngx_stream_geoip_module</a> -    <a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a> -    <a href="stream/ngx_stream_keyval_module.html">ngx_stream_keyval_module</a> -    <a href="stream/ngx_stream_limit_conn_module.html">ngx_stream_limit_conn_module</a> -    <a href="stream/ngx_stream_log_module.html">ngx_stream_log_module</a> -    <a href="stream/ngx_stream_map_module.html">ngx_stream_map_module</a> -    <a href="stream/ngx_stream_proxy_module.html">ngx_stream_proxy_module</a> -    <a href="stream/ngx_stream_realip_module.html">ngx_stream_realip_module</a> -    <a href="stream/ngx_stream_return_module.html">ngx_stream_return_module</a> -    <a href="stream/ngx_stream_split_clients_module.html">ngx_stream_split_clients_module</a> -    <a href="stream/ngx_stream_ssl_module.html">ngx_stream_ssl_module</a> -    <a href="stream/ngx_stream_ssl_preread_module.html">ngx_stream_ssl_preread_module</a> -    <a href="stream/ngx_stream_upstream_module.html">ngx_stream_upstream_module</a> -    <a href="stream/ngx_stream_upstream_hc_module.html">ngx_stream_upstream_hc_module</a> -    <a href="stream/ngx_stream_zone_sync_module.html">ngx_stream_zone_sync_module</a> </li>
</ul>
<ul>
<li><a href="ngx_google_perftools_module.html">ngx_google_perftools_module</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[howto_build_on_win32-nginx中文手册]]></title>
      <url>/ngx/howto_build_on_win32.html</url>
      <content type="html"><![CDATA[<p>howto_build_on_win32<br><a id="more"></a></p>
<h2 id="使用Visual-C在Win32平台上构建nginx"><a href="#使用Visual-C在Win32平台上构建nginx" class="headerlink" title="使用Visual C在Win32平台上构建nginx"></a>使用Visual C在Win32平台上构建nginx</h2><td align="left" class="notranslate"> <a href="#build_steps">Build steps</a> <br> <a href="#see_also">See also</a> <br></td>

<h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>  要在MicrosoftWin32®平台上构建nginx，您需要： </p>
<ul>
<li>Microsoft Visual C编译器。  已知Microsoft VisualStudio®8和10可以使用。 -    <a href="http://www.mingw.org/wiki/MSYS" target="_blank" rel="noopener">MSYS</a> 。 -    Perl，如果你想用SSL支持构建OpenSSL®和nginx。  例如<a href="http://www.activestate.com/activeperl" target="_blank" rel="noopener">ActivePerl</a>或<a href="http://strawberryperl.com" target="_blank" rel="noopener">Strawberry Perl</a> 。 -    <a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>客户。 -    <a href="http://www.pcre.org" target="_blank" rel="noopener">PCRE</a> ， <a href="http://zlib.net" target="_blank" rel="noopener">zlib</a>和<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库源。 </li>
</ul>
<h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><p>  确保在开始构建之前将Perl，Mercurial和MSYS bin目录的路径添加到PATH环境变量中。  要设置Visual C环境，请从Visual C目录运行vcvarsall.bat脚本。 </p>
<p>  要构建nginx： </p>
<ul>
<li>启动MSYS bash。 </li><li>  查看hg.nginx.org存储库中的nginx源代码。  例如： <blockquote class="example"><pre class="notranslate">hg clone <a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">http://hg.nginx.org/nginx</a><br></pre></blockquote></li><li>  创建一个build和lib目录，并将zlib，PCRE和OpenSSL库源解压缩到lib目录中： <blockquote class="example"><pre class="notranslate">mkdir objs<br>mkdir objs/lib<br>cd objs/lib<br>tar -xzf ../../pcre-8.42.tar.gz<br>tar -xzf ../../zlib-1.2.11.tar.gz<br>tar -xzf ../../openssl-1.0.2q.tar.gz<br></pre></blockquote></li><li>  运行configure脚本： <blockquote class="example"><pre class="notranslate">auto/configure \<br>–with-cc=cl \<br>–with-debug \<br>–prefix= \<br>–conf-path=conf/nginx.conf \<br>–pid-path=logs/nginx.pid \<br>–http-log-path=logs/access.log \<br>–error-log-path=logs/error.log \<br>–sbin-path=nginx.exe \<br>–http-client-body-temp-path=temp/client_body_temp \<br>–http-proxy-temp-path=temp/proxy_temp \<br>–http-fastcgi-temp-path=temp/fastcgi_temp \<br>–http-scgi-temp-path=temp/scgi_temp \<br>–http-uwsgi-temp-path=temp/uwsgi_temp \<br>–with-cc-opt=-DFD_SETSIZE=1024 \<br>–with-pcre=objs/lib/pcre-8.42 \<br>–with-zlib=objs/lib/zlib-1.2.11 \<br>–with-openssl=objs/lib/openssl-1.0.2q \<br>–with-openssl-opt=no-asm \<br>–with-select_module \<br>–with-http_ssl_module<br></pre></blockquote></li><li>  运行make： <blockquote class="example"><pre class="notranslate">nmake<br></pre></blockquote></li><pre class="notranslate">mkdir objs
mkdir objs/lib
cd objs/lib
tar -xzf ../../pcre-8.42.tar.gz
tar -xzf ../../zlib-1.2.11.tar.gz
tar -xzf ../../openssl-1.0.2q.tar.gz
</pre>


</ul>
<pre class="notranslate">nmake
</pre>



<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><ul>
<li><a href="windows.html">适用于Windows的nginx</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hash-nginx中文手册]]></title>
      <url>/ngx/hash.html</url>
      <content type="html"><![CDATA[<p>hash<br><a id="more"></a></p>
<h2 id="设置哈希值"><a href="#设置哈希值" class="headerlink" title="设置哈希值"></a>设置哈希值</h2><p>  为了快速处理静态数据集，例如服务器名称， <a href="http/ngx_http_map_module.html#map">映射</a>指令的值，MIME类型，请求头字符串的名称，nginx使用哈希表。  在启动期间和每次重新配置时，nginx选择最小可能大小的散列表，使得存储具有相同散列值的密钥的桶大小不超过配置的参数（散列桶大小）。  表的大小以桶表示。  继续调整，直到表大小超过散列最大大小参数。  大多数哈希都有相应的指令允许更改这些参数，例如，对于服务器名称哈希，它们是<a href="http/ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>和<a href="http/ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> 。 </p>
<p>  散列桶大小参数与处理器的高速缓存行大小的倍数对齐。  这通过减少内存访问的数量来加速现代处理器上的散列中的密钥搜索。  如果散列桶大小等于一个处理器的高速缓存行大小，那么在最坏的情况下，密钥搜索期间的内存访问次数将是两次 - 首先计算存储区地址，第二次是在存储桶内的密钥搜索期间。  因此，如果nginx发出请求增加散列最大大小或散列桶大小的消息，则应首先增加第一个参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[examples-nginx中文手册]]></title>
      <url>/ngx/examples.html</url>
      <content type="html"><![CDATA[<p>examples<br><a id="more"></a></p>
<h2 id="示例nginx配置"><a href="#示例nginx配置" class="headerlink" title="示例nginx配置"></a>示例nginx配置</h2><p>  示例站点配置，将所有请求传递给后端，但以“/ download /”开头的图像和请求除外。 </p>
<pre class="notranslate">user  www www;

worker_processes  2;

pid /var/run/nginx.pid;

#                          [ debug | info | notice | warn | error | crit ]

error_log  /var/log/nginx.error_log  info;

events {
    worker_connections   2000;

    # use [ kqueue | epoll | /dev/poll | select | poll ];
    use kqueue;
}

http {

    include       conf/mime.types;
    default_type  application/octet-stream;


    log_format main      '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         '"$gzip_ratio"';

    log_format download  '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         '"$http_range" "$sent_http_content_range"';

    client_header_timeout  3m;
    client_body_timeout    3m;
    send_timeout           3m;

    client_header_buffer_size    1k;
    large_client_header_buffers  4 4k;

    gzip on;
    gzip_min_length  1100;
    gzip_buffers     4 8k;
    gzip_types       text/plain;

    output_buffers   1 32k;
    postpone_output  1460;

    sendfile         on;
    tcp_nopush       on;
    tcp_nodelay      on;
    send_lowat       12000;

    keepalive_timeout  75 20;

    #lingering_time     30;
    #lingering_timeout  10;
    #reset_timedout_connection  on;


    server {
        listen        one.example.com;
        server_name   one.example.com  www.one.example.com;

        access_log   /var/log/nginx.access_log  main;

        location / {
            proxy_pass         http://127.0.0.1/;
            proxy_redirect     off;

            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            #proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;

            client_max_body_size       10m;
            client_body_buffer_size    128k;

            client_body_temp_path      /var/nginx/client_body_temp;

            proxy_connect_timeout      70;
            proxy_send_timeout         90;
            proxy_read_timeout         90;
            proxy_send_lowat           12000;

            proxy_buffer_size          4k;
            proxy_buffers              4 32k;
            proxy_busy_buffers_size    64k;
            proxy_temp_file_write_size 64k;

            proxy_temp_path            /var/nginx/proxy_temp;

            charset  koi8-r;
        }

        error_page  404  /404.html;

        location = /404.html {
            root  /spool/www;
        }

        location /old_stuff/ {
            rewrite   ^/old_stuff/(.*)$  /new_stuff/$1  permanent;
        }

        location /download/ {

            valid_referers  none  blocked  server_names  *.example.com;

            if ($invalid_referer) {
                #rewrite   ^/   http://www.example.com/;
                return   403;
            }

            #rewrite_log  on;

            # rewrite /download/*/mp3/*.any_ext to /download/*/mp3/*.mp3
            rewrite ^/(download/.*)/mp3/(.*)\..*$
                    /$1/mp3/$2.mp3                   break;

            root         /spool/www;
            #autoindex    on;
            access_log   /var/log/nginx-download.access_log  download;
        }

        location ~* \.(jpg|jpeg|gif)$ {
            root         /spool/www;
            access_log   off;
            expires      30d;
        }
    }
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[events-nginx中文手册]]></title>
      <url>/ngx/events.html</url>
      <content type="html"><![CDATA[<p>events<br><a id="more"></a></p>
<h2 id="连接处理方法"><a href="#连接处理方法" class="headerlink" title="连接处理方法"></a>连接处理方法</h2><p>   nginx支持各种连接处理方法。  特定方法的可用性取决于所使用的平台。  在支持多种方法的平台上，nginx通常会自动选择最有效的方法。  但是，如果需要，可以<a href="ngx_core_module.html#use">使用use</a>指令显式选择连接处理方法。 </p>
<p>  支持以下连接处理方法： </p>
<ul>
<li><code>select</code> - 标准方法。  支持模块自动构建在缺乏更有效方法的平台上。   <code>--with-select_module</code>和<code>--without-select_module</code>配置参数可用于强制启用或禁用此模块的构建。 -    <code>poll</code> - 标准方法。  支持模块自动构建在缺乏更有效方法的平台上。   <code>--with-poll_module</code>和<code>--without-poll_module</code>配置参数可用于强制启用或禁用此模块的构建。 -    <code>kqueue</code> - 在FreeBSD 4.1 +，OpenBSD 2.9 +，NetBSD 2.0和macOS上使用的有效方法。 -    Linux 2.6+上使用的<code>epoll</code> -efficient方法。 <blockquote class="note">  自1.11.3起，支持<code>EPOLLRDHUP</code> （Linux 2.6.17，glibc 2.8）和<code>EPOLLEXCLUSIVE</code> （Linux 4.5，glibc 2.24）标志。 </blockquote><blockquote class="note">  一些较旧的发行版（如SuSE 8.2）提供了为2.4内核添加epoll支持的补丁。 </blockquote>-    <code>/dev/poll</code> -  Solaris 7 11/99 +，HP / UX 11.22+（eventport），IRIX 6.5.15+和Tru64 UNIX 5.1A +上使用的有效方法。 -    <code>eventport</code> - 事件端口，Solaris 10+上使用的方法（由于已知问题，建议使用<code>/dev/poll</code>方法）。 <blockquote>
<p>  一些较旧的发行版（如SuSE 8.2）提供了为2.4内核添加epoll支持的补丁。 </p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dirindex-nginx中文手册]]></title>
      <url>/ngx/dirindex.html</url>
      <content type="html"><![CDATA[<p>dirindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的指令索引"><a href="#按字母顺序排列的指令索引" class="headerlink" title="按字母顺序排列的指令索引"></a>按字母顺序排列的指令索引</h2><p>   <a href="http/ngx_http_core_module.html#absolute_redirect">absolute_redirect</a> <br>   <a href="ngx_core_module.html#accept_mutex">accept_mutex</a> <br>   <a href="ngx_core_module.html#accept_mutex_delay">accept_mutex_delay</a> <br>   <a href="http/ngx_http_log_module.html#access_log">access_log</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#access_log">access_log</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_addition_module.html#add_after_body">add_after_body</a> <br>   <a href="http/ngx_http_addition_module.html#add_before_body">add_before_body</a> <br>   <a href="http/ngx_http_headers_module.html#add_header">add_header</a> <br>   <a href="http/ngx_http_headers_module.html#add_trailer">add_trailer</a> <br>   <a href="http/ngx_http_addition_module.html#addition_types">addition_types</a> <br>   <a href="http/ngx_http_core_module.html#aio">AIO</a> <br>   <a href="http/ngx_http_core_module.html#aio_write">aio_write</a> <br>   <a href="http/ngx_http_core_module.html#alias">别号</a> <br>   <a href="http/ngx_http_access_module.html#allow">允许</a> （ngx_http_access_module） <br>   <a href="stream/ngx_stream_access_module.html#allow">允许</a> （ngx_stream_access_module） <br>   <a href="http/ngx_http_browser_module.html#ancient_browser">ancient_browser</a> <br>   <a href="http/ngx_http_browser_module.html#ancient_browser_value">ancient_browser_value</a> <br>   <a href="http/ngx_http_api_module.html#api">API</a> <br>   <a href="http/ngx_http_auth_basic_module.html#auth_basic">auth_basic</a> <br>   <a href="http/ngx_http_auth_basic_module.html#auth_basic_user_file">auth_basic_user_file</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http">auth_http</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_header">auth_http_header</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_pass_client_cert">auth_http_pass_client_cert</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_timeout">auth_http_timeout</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt">auth_jwt</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_claim_set">auth_jwt_claim_set</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_header_set">auth_jwt_header_set</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_key_file">auth_jwt_key_file</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_key_request">auth_jwt_key_request</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_leeway">auth_jwt_leeway</a> <br>   <a href="http/ngx_http_auth_request_module.html#auth_request">auth_request</a> <br>   <a href="http/ngx_http_auth_request_module.html#auth_request_set">auth_request_set</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex">自动索引</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_exact_size">autoindex_exact_size</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_format">autoindex_format</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_localtime">autoindex_localtime</a> <br>   <a href="http/ngx_http_rewrite_module.html#break">打破</a> <br>   <a href="http/ngx_http_charset_module.html#charset">字符集</a> <br>   <a href="http/ngx_http_charset_module.html#charset_map">charset_map</a> <br>   <a href="http/ngx_http_charset_module.html#charset_types">charset_types</a> <br>   <a href="http/ngx_http_core_module.html#chunked_transfer_encoding">chunked_transfer_encoding</a> <br>   <a href="http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#client_body_in_file_only">client_body_in_file_only</a> <br>   <a href="http/ngx_http_core_module.html#client_body_in_single_buffer">client_body_in_single_buffer</a> <br>   <a href="http/ngx_http_core_module.html#client_body_temp_path">client_body_temp_path</a> <br>   <a href="http/ngx_http_core_module.html#client_body_timeout">client_body_timeout</a> <br>   <a href="http/ngx_http_core_module.html#client_header_buffer_size">client_header_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#client_header_timeout">client_header_timeout</a> <br>   <a href="http/ngx_http_core_module.html#client_max_body_size">client_max_body_size</a> <br>   <a href="http/ngx_http_core_module.html#connection_pool_size">connection_pool_size</a> <br>   <a href="http/ngx_http_dav_module.html#create_full_put_path">create_full_put_path</a> <br>   <a href="ngx_core_module.html#daemon">守护进程</a> <br>   <a href="http/ngx_http_dav_module.html#dav_access">dav_access</a> <br>   <a href="http/ngx_http_dav_module.html#dav_methods">dav_methods</a> <br>   <a href="ngx_core_module.html#debug_connection">debug_connection</a> <br>   <a href="ngx_core_module.html#debug_points">debug_points</a> <br>   <a href="http/ngx_http_core_module.html#default_type">default_type文件</a> <br>   <a href="http/ngx_http_access_module.html#deny">拒绝</a> （ngx_http_access_module） <br>   <a href="stream/ngx_stream_access_module.html#deny">拒绝</a> （ngx_stream_access_module） <br>   <a href="http/ngx_http_core_module.html#directio">的directio</a> <br>   <a href="http/ngx_http_core_module.html#directio_alignment">directio_alignment</a> <br>   <a href="http/ngx_http_core_module.html#disable_symlinks">disable_symlinks</a> <br>   <a href="http/ngx_http_empty_gif_module.html#empty_gif">empty_gif</a> <br>   <a href="ngx_core_module.html#env">ENV</a> <br>   <a href="ngx_core_module.html#error_log">error_log中</a> <br>   <a href="http/ngx_http_core_module.html#error_page">error_page</a> <br>   <a href="http/ngx_http_core_module.html#etag">ETAG</a> <br>   <a href="ngx_core_module.html#events">事件</a> <br>   <a href="http/ngx_http_headers_module.html#expires">到期</a> <br>   <a href="http/ngx_http_f4f_module.html#f4f">F4F</a> <br>   <a href="http/ngx_http_f4f_module.html#f4f_buffer_size">f4f_buffer_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_bind">fastcgi_bind</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffer_size">fastcgi_buffer_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffering">fastcgi_buffering</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffers">fastcgi_buffers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_busy_buffers_size">fastcgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache">fastcgi_cache</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_background_update">fastcgi_cache_background_update</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_bypass">fastcgi_cache_bypass</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_key">fastcgi_cache_key</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock">fastcgi_cache_lock</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock_age">fastcgi_cache_lock_age</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_max_range_offset">fastcgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_methods">fastcgi_cache_methods</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_min_uses">fastcgi_cache_min_uses</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_path">fastcgi_cache_path</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_purge">fastcgi_cache_purge</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_revalidate">fastcgi_cache_revalidate</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_use_stale">fastcgi_cache_use_stale</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_valid">fastcgi_cache_valid</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_catch_stderr">fastcgi_catch_stderr</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_connect_timeout">fastcgi_connect_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_force_ranges">fastcgi_force_ranges</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_hide_header">fastcgi_hide_header</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_ignore_client_abort">fastcgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_index">fastcgi_index</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_intercept_errors">fastcgi_intercept_errors</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_limit_rate">fastcgi_limit_rate</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream">fastcgi_next_upstream</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream_timeout">fastcgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream_tries">fastcgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_no_cache">fastcgi_no_cache</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_header">fastcgi_pass_header</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_request_body">fastcgi_pass_request_body</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_read_timeout">fastcgi_read_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_send_lowat">fastcgi_send_lowat</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_send_timeout">fastcgi_send_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_socket_keepalive">fastcgi_socket_keepalive</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_split_path_info">fastcgi_split_path_info</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_store">fastcgi_store</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_store_access">fastcgi_store_access</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_temp_path">fastcgi_temp_path</a> <br>   <a href="http/ngx_http_flv_module.html#flv">FLV</a> <br>   <a href="http/ngx_http_geo_module.html#geo">geo</a> （ngx_http_geo_module） <br>   <a href="stream/ngx_stream_geo_module.html#geo">geo</a> （ngx_stream_geo_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_city">geoip_city</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_city">geoip_city</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_country">geoip_country</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_country">geoip_country</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_org">geoip_org</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_org">geoip_org</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_proxy">geoip_proxy</a> <br>   <a href="http/ngx_http_geoip_module.html#geoip_proxy_recursive">geoip_proxy_recursive</a> <br>   <a href="ngx_google_perftools_module.html#google_perftools_profiles">google_perftools_profiles</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_bind">grpc_bind</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_buffer_size">grpc_buffer_size</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_connect_timeout">grpc_connect_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_hide_header">grpc_hide_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ignore_headers">grpc_ignore_headers</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_intercept_errors">grpc_intercept_errors</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream">grpc_next_upstream</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream_timeout">grpc_next_upstream_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream_tries">grpc_next_upstream_tries</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_pass">grpc_pass</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_pass_header">grpc_pass_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_read_timeout">grpc_read_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_send_timeout">grpc_send_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_set_header">grpc_set_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_socket_keepalive">grpc_socket_keepalive</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_certificate">grpc_ssl_certificate</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_certificate_key">grpc_ssl_certificate_key</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_ciphers">grpc_ssl_ciphers</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_crl">grpc_ssl_crl</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_name">grpc_ssl_name</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_password_file">grpc_ssl_password_file</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_protocols">grpc_ssl_protocols</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_server_name">grpc_ssl_server_name</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_session_reuse">grpc_ssl_session_reuse</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_trusted_certificate">grpc_ssl_trusted_certificate</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_verify">grpc_ssl_verify</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_verify_depth">grpc_ssl_verify_depth</a> <br>   <a href="http/ngx_http_gunzip_module.html#gunzip">gunzip解</a> <br>   <a href="http/ngx_http_gunzip_module.html#gunzip_buffers">gunzip_buffers</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip">gzip的</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_buffers">gzip_buffers</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_comp_level">gzip_comp_level</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_disable">gzip_disable</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_min_length">gzip_min_length</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a> <br>   <a href="http/ngx_http_gzip_static_module.html#gzip_static">gzip_static</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_types">gzip_types</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_vary">gzip_vary</a> <br>   <a href="http/ngx_http_upstream_module.html#hash">hash</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#hash">hash</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_hc_module.html#health_check">health_check</a> （ngx_http_upstream_hc_module） <br>   health_check（ngx_stream_upstream_hc_module） <br>   <a href="stream/ngx_stream_upstream_hc_module.html#health_check_timeout">health_check_timeout</a> <br>   <a href="http/ngx_http_hls_module.html#hls">HLS</a> <br>   <a href="http/ngx_http_hls_module.html#hls_buffers">hls_buffers</a> <br>   <a href="http/ngx_http_hls_module.html#hls_forward_args">hls_forward_args</a> <br>   <a href="http/ngx_http_hls_module.html#hls_fragment">hls_fragment</a> <br>   <a href="http/ngx_http_hls_module.html#hls_mp4_buffer_size">hls_mp4_buffer_size</a> <br>   <a href="http/ngx_http_hls_module.html#hls_mp4_max_buffer_size">hls_mp4_max_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#http">HTTP</a> <br>   <a href="http/ngx_http_v2_module.html#http2_body_preread_size">http2_body_preread_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_chunk_size">http2_chunk_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_idle_timeout">http2_idle_timeout</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_concurrent_pushes">http2_max_concurrent_pushes</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_concurrent_streams">http2_max_concurrent_streams</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_field_size">http2_max_field_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_header_size">http2_max_header_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_requests">http2_max_requests</a> <br>   <a href="http/ngx_http_v2_module.html#http2_push">http2_push</a> <br>   <a href="http/ngx_http_v2_module.html#http2_push_preload">http2_push_preload</a> <br>   <a href="http/ngx_http_v2_module.html#http2_recv_buffer_size">http2_recv_buffer_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_recv_timeout">http2_recv_timeout</a> <br>   <a href="http/ngx_http_rewrite_module.html#if">如果</a> <br>   <a href="http/ngx_http_core_module.html#if_modified_since">if_modified_since</a> <br>   <a href="http/ngx_http_core_module.html#ignore_invalid_headers">ignore_invalid_headers</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter">image_filter</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_buffer">image_filter_buffer</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_interlace">image_filter_interlace</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_jpeg_quality">image_filter_jpeg_quality</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_sharpen">image_filter_sharpen</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_transparency">image_filter_transparency</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_webp_quality">image_filter_webp_quality</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_auth">imap_auth</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_capabilities">imap_capabilities</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_client_buffer">imap_client_buffer</a> <br>   <a href="ngx_core_module.html#include">包括</a> <br>   <a href="http/ngx_http_index_module.html#index">指数</a> <br>   <a href="http/ngx_http_core_module.html#internal">内部</a> <br>   <a href="http/ngx_http_upstream_module.html#ip_hash">ip_hash</a> <br>   <a href="stream/ngx_stream_js_module.html#js_access">js_access</a> <br>   <a href="http/ngx_http_js_module.html#js_content">js_content</a> <br>   <a href="stream/ngx_stream_js_module.html#js_filter">js_filter</a> <br>   <a href="http/ngx_http_js_module.html#js_include">js_include</a> （ngx_http_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_include">js_include</a> （ngx_stream_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_preread">js_preread</a> <br>   <a href="http/ngx_http_js_module.html#js_set">js_set</a> （ngx_http_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_set">js_set</a> （ngx_stream_js_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive">活着</a> <br>   <a href="http/ngx_http_core_module.html#keepalive_disable">keepalive_disable</a> <br>   <a href="http/ngx_http_core_module.html#keepalive_requests">keepalive_requests</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive_requests">keepalive_requests</a> （ngx_http_upstream_module） <br>   <a href="http/ngx_http_core_module.html#keepalive_timeout">keepalive_timeout</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive_timeout">keepalive_timeout</a> （ngx_http_upstream_module） <br>   <a href="http/ngx_http_keyval_module.html#keyval">keyval</a> （ngx_http_keyval_module） <br>   <a href="stream/ngx_stream_keyval_module.html#keyval">keyval</a> （ngx_stream_keyval_module） <br>   <a href="http/ngx_http_keyval_module.html#keyval_zone">keyval_zone</a> （ngx_http_keyval_module） <br>   <a href="stream/ngx_stream_keyval_module.html#keyval_zone">keyval_zone</a> （ngx_stream_keyval_module） <br>   <a href="http/ngx_http_core_module.html#large_client_header_buffers">large_client_header_buffers</a> <br>   <a href="http/ngx_http_upstream_module.html#least_conn">least_conn</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#least_conn">least_conn</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#least_time">least_time</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#least_time">least_time</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn">limit_conn</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn">limit_conn</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_log_level">limit_conn_log_level</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn_log_level">limit_conn_log_level</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_status">limit_conn_status</a> <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_zone">limit_conn_zone</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn_zone">limit_conn_zone</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_core_module.html#limit_except">limit_except</a> <br>   <a href="http/ngx_http_core_module.html#limit_rate">limit_rate</a> <br>   <a href="http/ngx_http_core_module.html#limit_rate_after">limit_rate_after</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req">limit_req</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_log_level">limit_req_log_level</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_status">limit_req_status</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_zone">limit_req_zone</a> <br>   <a href="http/ngx_http_limit_conn_module.html#limit_zone">limit_zone</a> <br>   <a href="http/ngx_http_core_module.html#lingering_close">lingering_close</a> <br>   <a href="http/ngx_http_core_module.html#lingering_time">lingering_time</a> <br>   <a href="http/ngx_http_core_module.html#lingering_timeout">lingering_timeout</a> <br>   <a href="http/ngx_http_core_module.html#listen">听</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#listen">听</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#listen">听</a> （ngx_stream_core_module） <br>   <a href="ngx_core_module.html#load_module">load_module</a> <br>   <a href="http/ngx_http_core_module.html#location">地点</a> <br>   <a href="ngx_core_module.html#lock_file">LOCK_FILE</a> <br>   <a href="http/ngx_http_log_module.html#log_format">log_format</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#log_format">log_format</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_core_module.html#log_not_found">log_not_found</a> <br>   <a href="http/ngx_http_core_module.html#log_subrequest">log_subrequest</a> <br>   <a href="mail/ngx_mail_core_module.html#mail">邮件</a> <br>   <a href="http/ngx_http_map_module.html#map">地图</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map">地图</a> （ngx_stream_map_module） <br>   <a href="http/ngx_http_map_module.html#map_hash_bucket_size">map_hash_bucket_size</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map_hash_bucket_size">map_hash_bucket_size</a> （ngx_stream_map_module） <br>   <a href="http/ngx_http_map_module.html#map_hash_max_size">map_hash_max_size</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map_hash_max_size">map_hash_max_size</a> （ngx_stream_map_module） <br>   <a href="ngx_core_module.html#master_process">master_process</a> <br>   <a href="http/ngx_http_upstream_hc_module.html#match">匹配</a> （ngx_http_upstream_hc_module） <br>   <a href="stream/ngx_stream_upstream_hc_module.html#match">匹配</a> （ngx_stream_upstream_hc_module） <br>   <a href="http/ngx_http_core_module.html#max_ranges">max_ranges</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_bind">memcached_bind</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_buffer_size">memcached_buffer_size</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_connect_timeout">memcached_connect_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_force_ranges">memcached_force_ranges</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_gzip_flag">memcached_gzip_flag</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream">memcached_next_upstream</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream_timeout">memcached_next_upstream_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream_tries">memcached_next_upstream_tries</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_read_timeout">memcached_read_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_send_timeout">memcached_send_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_socket_keepalive">memcached_socket_keepalive</a> <br>   <a href="http/ngx_http_core_module.html#merge_slashes">merge_slashes</a> <br>   <a href="http/ngx_http_dav_module.html#min_delete_depth">min_delete_depth</a> <br>   <a href="http/ngx_http_mirror_module.html#mirror">镜子</a> <br>   <a href="http/ngx_http_mirror_module.html#mirror_request_body">mirror_request_body</a> <br>   <a href="http/ngx_http_browser_module.html#modern_browser">modern_browser</a> <br>   <a href="http/ngx_http_browser_module.html#modern_browser_value">modern_browser_value</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4">MP4</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_buffer_size">mp4_buffer_size</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_limit_rate">mp4_limit_rate</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_limit_rate_after">mp4_limit_rate_after</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_max_buffer_size">mp4_max_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#msie_padding">msie_padding</a> <br>   <a href="http/ngx_http_core_module.html#msie_refresh">msie_refresh</a> <br>   <a href="ngx_core_module.html#multi_accept">multi_accept</a> <br>   <a href="http/ngx_http_upstream_module.html#ntlm">NTLM</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache">open_file_cache</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_errors">open_file_cache_errors</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_min_uses">open_file_cache_min_uses</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_valid">open_file_cache_valid</a> <br>   <a href="http/ngx_http_log_module.html#open_log_file_cache">open_log_file_cache</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#open_log_file_cache">open_log_file_cache</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_core_module.html#output_buffers">output_buffers</a> <br>   <a href="http/ngx_http_charset_module.html#override_charset">override_charset</a> <br>   <a href="ngx_core_module.html#pcre_jit">pcre_jit</a> <br>   <a href="http/ngx_http_perl_module.html#perl">perl的</a> <br>   <a href="http/ngx_http_perl_module.html#perl_modules">perl_modules</a> <br>   <a href="http/ngx_http_perl_module.html#perl_require">perl_require</a> <br>   <a href="http/ngx_http_perl_module.html#perl_set">perl_set</a> <br>   <a href="ngx_core_module.html#pid">PID</a> <br>   <a href="mail/ngx_mail_pop3_module.html#pop3_auth">pop3_auth</a> <br>   <a href="mail/ngx_mail_pop3_module.html#pop3_capabilities">pop3_capabilities</a> <br>   <a href="http/ngx_http_core_module.html#port_in_redirect">port_in_redirect</a> <br>   <a href="http/ngx_http_core_module.html#postpone_output">postpone_output</a> <br>   <a href="stream/ngx_stream_core_module.html#preread_buffer_size">preread_buffer_size</a> <br>   <a href="stream/ngx_stream_core_module.html#preread_timeout">preread_timeout</a> <br>   <a href="mail/ngx_mail_core_module.html#protocol">协议</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_bind">proxy_bind</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_bind">proxy_bind</a> （ngx_stream_proxy_module） <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_buffer">proxy_buffer</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffering">proxy_buffering</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffers">proxy_buffers</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_busy_buffers_size">proxy_busy_buffers_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache">proxy_cache</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_background_update">proxy_cache_background_update</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_bypass">proxy_cache_bypass</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_convert_head">proxy_cache_convert_head</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_key">proxy_cache_key</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock">proxy_cache_lock</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock_age">proxy_cache_lock_age</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_max_range_offset">proxy_cache_max_range_offset</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_methods">proxy_cache_methods</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_min_uses">proxy_cache_min_uses</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_path">proxy_cache_path</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_purge">proxy_cache_purge</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_revalidate">proxy_cache_revalidate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_use_stale">proxy_cache_use_stale</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_valid">proxy_cache_valid</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_cookie_domain">proxy_cookie_domain</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cookie_path">proxy_cookie_path</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_download_rate">proxy_download_rate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_force_ranges">proxy_force_ranges</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_headers_hash_bucket_size">proxy_headers_hash_bucket_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_headers_hash_max_size">proxy_headers_hash_max_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_hide_header">proxy_hide_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ignore_client_abort">proxy_ignore_client_abort</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_intercept_errors">proxy_intercept_errors</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_limit_rate">proxy_limit_rate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_max_temp_file_size">proxy_max_temp_file_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_method">proxy_method</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_tries">proxy_next_upstream_tries</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream_tries">proxy_next_upstream_tries</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_no_cache">proxy_no_cache</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_pass">proxy_pass</a> （ngx_stream_proxy_module） <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_pass_error_message">proxy_pass_error_message</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_header">proxy_pass_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_request_body">proxy_pass_request_body</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_request_headers">proxy_pass_request_headers</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_protocol">proxy_protocol</a> <br>   <a href="stream/ngx_stream_core_module.html#proxy_protocol_timeout">proxy_protocol_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_read_timeout">proxy_read_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_redirect">proxy_redirect</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_requests">proxy_requests</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_responses">proxy_responses</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_send_lowat">proxy_send_lowat</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_send_timeout">proxy_send_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_set_body">proxy_set_body</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_set_header">proxy_set_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_socket_keepalive">proxy_socket_keepalive</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_socket_keepalive">proxy_socket_keepalive</a> （ngx_stream_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl">proxy_ssl</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_certificate">proxy_ssl_certificate</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_certificate">proxy_ssl_certificate</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_ciphers">proxy_ssl_ciphers</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_ciphers">proxy_ssl_ciphers</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_crl">proxy_ssl_crl</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_crl">proxy_ssl_crl</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_name">proxy_ssl_name</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_name">proxy_ssl_name</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_password_file">proxy_ssl_password_file</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_password_file">proxy_ssl_password_file</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_protocols">proxy_ssl_protocols</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_protocols">proxy_ssl_protocols</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_server_name">proxy_ssl_server_name</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_server_name">proxy_ssl_server_name</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_verify">proxy_ssl_verify</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_verify">proxy_ssl_verify</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_store">proxy_store</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_store_access">proxy_store_access</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_temp_file_write_size">proxy_temp_file_write_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_temp_path">proxy_temp_path</a> <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_timeout">proxy_timeout</a> （ngx_mail_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_timeout">proxy_timeout</a> （ngx_stream_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_upload_rate">proxy_upload_rate</a> <br>   <a href="http/ngx_http_upstream_module.html#queue">队列</a> <br>   <a href="http/ngx_http_upstream_module.html#random">随机的</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#random">随机的</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_random_index_module.html#random_index">random_index</a> <br>   <a href="http/ngx_http_core_module.html#read_ahead">read_ahead</a> <br>   <a href="http/ngx_http_realip_module.html#real_ip_header">real_ip_header</a> <br>   <a href="http/ngx_http_realip_module.html#real_ip_recursive">real_ip_recursive</a> <br>   <a href="http/ngx_http_core_module.html#recursive_error_pages">recursive_error_pages</a> <br>   <a href="http/ngx_http_referer_module.html#referer_hash_bucket_size">referer_hash_bucket_size</a> <br>   <a href="http/ngx_http_referer_module.html#referer_hash_max_size">referer_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#request_pool_size">request_pool_size</a> <br>   <a href="http/ngx_http_core_module.html#reset_timedout_connection">reset_timedout_connection</a> <br>   <a href="http/ngx_http_core_module.html#resolver">解析器</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#resolver">解析器</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#resolver">解析器</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_rewrite_module.html#return">return</a> （ngx_http_rewrite_module） <br>   <a href="stream/ngx_stream_return_module.html#return">return</a> （ngx_stream_return_module） <br>   <a href="http/ngx_http_rewrite_module.html#rewrite">改写</a> <br>   <a href="http/ngx_http_rewrite_module.html#rewrite_log">rewrite_log</a> <br>   <a href="http/ngx_http_core_module.html#root">根</a> <br>   <a href="http/ngx_http_core_module.html#satisfy">满足</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_bind">scgi_bind</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffer_size">scgi_buffer_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffering">scgi_buffering</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffers">scgi_buffers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_busy_buffers_size">scgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache">scgi_cache</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_background_update">scgi_cache_background_update</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_bypass">scgi_cache_bypass</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_key">scgi_cache_key</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock">scgi_cache_lock</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock_age">scgi_cache_lock_age</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_max_range_offset">scgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_methods">scgi_cache_methods</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_min_uses">scgi_cache_min_uses</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_path">scgi_cache_path</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_purge">scgi_cache_purge</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_revalidate">scgi_cache_revalidate</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_use_stale">scgi_cache_use_stale</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_valid">scgi_cache_valid</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_connect_timeout">scgi_connect_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_force_ranges">scgi_force_ranges</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_hide_header">scgi_hide_header</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_ignore_client_abort">scgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_intercept_errors">scgi_intercept_errors</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_limit_rate">scgi_limit_rate</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_max_temp_file_size">scgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream">scgi_next_upstream</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream_timeout">scgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream_tries">scgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_no_cache">scgi_no_cache</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_param">scgi_param</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_header">scgi_pass_header</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_request_body">scgi_pass_request_body</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_request_headers">scgi_pass_request_headers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_read_timeout">scgi_read_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_send_timeout">scgi_send_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_socket_keepalive">scgi_socket_keepalive</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_store">scgi_store</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_store_access">scgi_store_access</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_temp_file_write_size">scgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_temp_path">scgi_temp_path</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link">secure_link</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link_md5">secure_link_md5</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link_secret">secure_link_secret</a> <br>   <a href="http/ngx_http_core_module.html#send_lowat">send_lowat</a> <br>   <a href="http/ngx_http_core_module.html#send_timeout">send_timeout</a> <br>   <a href="http/ngx_http_core_module.html#sendfile">发送文件</a> <br>   <a href="http/ngx_http_core_module.html#sendfile_max_chunk">sendfile_max_chunk</a> <br>   <a href="http/ngx_http_core_module.html#server">服务器</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#server">服务器</a> （ngx_http_upstream_module） <br>   <a href="mail/ngx_mail_core_module.html#server">服务器</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#server">服务器</a> （ngx_stream_core_module） <br>   <a href="stream/ngx_stream_upstream_module.html#server">服务器</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_core_module.html#server_name">server_name</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#server_name">server_name</a> （ngx_mail_core_module） <br>   <a href="http/ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a> <br>   <a href="http/ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> <br>   <a href="http/ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#server_tokens">server_tokens</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log">session_log</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log_format">session_log_format</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log_zone">session_log_zone</a> <br>   <a href="http/ngx_http_rewrite_module.html#set">组</a> <br>   <a href="http/ngx_http_realip_module.html#set_real_ip_from">set_real_ip_from</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#set_real_ip_from">set_real_ip_from</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_slice_module.html#slice">切片</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_auth">SMTP_AUTH</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_capabilities">smtp_capabilities</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_client_buffer">smtp_client_buffer</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_greeting_delay">smtp_greeting_delay</a> <br>   <a href="http/ngx_http_charset_module.html#source_charset">source_charset</a> <br>   <a href="http/ngx_http_spdy_module.html#spdy_chunk_size">spdy_chunk_size</a> <br>   <a href="http/ngx_http_spdy_module.html#spdy_headers_comp">spdy_headers_comp</a> <br>   <a href="http/ngx_http_split_clients_module.html#split_clients">split_clients</a> （ngx_http_split_clients_module） <br>   <a href="stream/ngx_stream_split_clients_module.html#split_clients">split_clients</a> （ngx_stream_split_clients_module） <br>   <a href="http/ngx_http_ssi_module.html#ssi">SSI</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_last_modified">ssi_last_modified</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_min_file_chunk">ssi_min_file_chunk</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_silent_errors">ssi_silent_errors</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_types">ssi_types</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_value_length">ssi_value_length</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl">ssl</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl">ssl</a> （ngx_mail_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_buffer_size">ssl_buffer_size</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_early_data">ssl_early_data</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_stream_ssl_module） <br>   <a href="ngx_core_module.html#ssl_engine">ssl_engine</a> <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_handshake_timeout">ssl_handshake_timeout</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="stream/ngx_stream_ssl_preread_module.html#ssl_preread">ssl_preread</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling">ssl_stapling</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_file">ssl_stapling_file</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_responder">ssl_stapling_responder</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_verify">ssl_stapling_verify</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_stream_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#starttls">STARTTLS</a> <br>   <a href="http/ngx_http_upstream_module.html#state">state</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#state">state</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_status_module.html#status">状态</a> <br>   <a href="http/ngx_http_status_module.html#status_format">status_format的</a> <br>   <a href="http/ngx_http_api_module.html#status_zone">status_zone</a> （ngx_http_api_module） <br>   <a href="http/ngx_http_status_module.html#status_zone">status_zone</a> （ngx_http_status_module） <br>   <a href="http/ngx_http_upstream_module.html#sticky">黏</a> <br>   <a href="http/ngx_http_upstream_module.html#sticky_cookie_insert">sticky_cookie_insert</a> <br>   <a href="stream/ngx_stream_core_module.html#stream">流</a> <br>   <a href="http/ngx_http_stub_status_module.html#stub_status">stub_status</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter">sub_filter</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_last_modified">sub_filter_last_modified</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_once">sub_filter_once</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_types">sub_filter_types</a> <br>   <a href="http/ngx_http_core_module.html#subrequest_output_buffer_size">subrequest_output_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#tcp_nodelay">tcp_nodelay</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#tcp_nodelay">tcp_nodelay</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#tcp_nopush">tcp_nopush</a> <br>   <a href="ngx_core_module.html#thread_pool">thread_pool</a> <br>   <a href="mail/ngx_mail_core_module.html#timeout">超时</a> <br>   <a href="ngx_core_module.html#timer_resolution">timer_resolution</a> <br>   <a href="http/ngx_http_core_module.html#try_files">try_files</a> <br>   <a href="http/ngx_http_core_module.html#types">类型</a> <br>   <a href="http/ngx_http_core_module.html#types_hash_bucket_size">types_hash_bucket_size</a> <br>   <a href="http/ngx_http_core_module.html#types_hash_max_size">types_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#underscores_in_headers">underscores_in_headers</a> <br>   <a href="http/ngx_http_rewrite_module.html#uninitialized_variable_warn">uninitialized_variable_warn</a> <br>   <a href="http/ngx_http_upstream_module.html#upstream">上游</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#upstream">上游</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a> <br>   <a href="ngx_core_module.html#use">使用</a> <br>   <a href="ngx_core_module.html#user">用户</a> <br>   <a href="http/ngx_http_userid_module.html#userid">用户身份</a> <br>   <a href="http/ngx_http_userid_module.html#userid_domain">userid_domain</a> <br>   <a href="http/ngx_http_userid_module.html#userid_expires">userid_expires</a> <br>   <a href="http/ngx_http_userid_module.html#userid_mark">userid_mark</a> <br>   <a href="http/ngx_http_userid_module.html#userid_name">userid_name</a> <br>   <a href="http/ngx_http_userid_module.html#userid_p3p">userid_p3p</a> <br>   <a href="http/ngx_http_userid_module.html#userid_path">userid_path</a> <br>   <a href="http/ngx_http_userid_module.html#userid_service">userid_service</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_bind">uwsgi_bind</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffer_size">uwsgi_buffer_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffering">uwsgi_buffering</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffers">uwsgi_buffers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_busy_buffers_size">uwsgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache">uwsgi_cache</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_background_update">uwsgi_cache_background_update</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_bypass">uwsgi_cache_bypass</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_key">uwsgi_cache_key</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock">uwsgi_cache_lock</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock_age">uwsgi_cache_lock_age</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_max_range_offset">uwsgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_methods">uwsgi_cache_methods</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_min_uses">uwsgi_cache_min_uses</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_path">uwsgi_cache_path</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_purge">uwsgi_cache_purge</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_revalidate">uwsgi_cache_revalidate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_use_stale">uwsgi_cache_use_stale</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_valid">uwsgi_cache_valid</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_connect_timeout">uwsgi_connect_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_force_ranges">uwsgi_force_ranges</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_hide_header">uwsgi_hide_header</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ignore_client_abort">uwsgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_intercept_errors">uwsgi_intercept_errors</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_limit_rate">uwsgi_limit_rate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_modifier1">uwsgi_modifier1</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_modifier2">uwsgi_modifier2</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream">uwsgi_next_upstream</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream_timeout">uwsgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream_tries">uwsgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_no_cache">uwsgi_no_cache</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_param">uwsgi_param</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_header">uwsgi_pass_header</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_request_body">uwsgi_pass_request_body</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_read_timeout">uwsgi_read_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_send_timeout">uwsgi_send_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_socket_keepalive">uwsgi_socket_keepalive</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_certificate">uwsgi_ssl_certificate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_certificate_key">uwsgi_ssl_certificate_key</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_ciphers">uwsgi_ssl_ciphers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_crl">uwsgi_ssl_crl</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_name">uwsgi_ssl_name</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_password_file">uwsgi_ssl_password_file</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_protocols">uwsgi_ssl_protocols</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_server_name">uwsgi_ssl_server_name</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_session_reuse">uwsgi_ssl_session_reuse</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_trusted_certificate">uwsgi_ssl_trusted_certificate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_verify">uwsgi_ssl_verify</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_verify_depth">uwsgi_ssl_verify_depth</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_store">uwsgi_store</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_store_access">uwsgi_store_access</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_temp_path">uwsgi_temp_path</a> <br>   <a href="http/ngx_http_referer_module.html#valid_referers">valid_referers</a> <br>   <a href="http/ngx_http_core_module.html#variables_hash_bucket_size">variables_hash_bucket_size</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#variables_hash_bucket_size">variables_hash_bucket_size</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#variables_hash_max_size">variables_hash_max_size</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#variables_hash_max_size">variables_hash_max_size</a> （ngx_stream_core_module） <br>   <a href="ngx_core_module.html#worker_aio_requests">worker_aio_requests</a> <br>   <a href="ngx_core_module.html#worker_connections">worker_connections</a> <br>   <a href="ngx_core_module.html#worker_cpu_affinity">worker_cpu_affinity</a> <br>   <a href="ngx_core_module.html#worker_priority">worker_priority</a> <br>   <a href="ngx_core_module.html#worker_processes">worker_processes</a> <br>   <a href="ngx_core_module.html#worker_rlimit_core">worker_rlimit_core</a> <br>   <a href="ngx_core_module.html#worker_rlimit_nofile">worker_rlimit_nofile</a> <br>   <a href="ngx_core_module.html#worker_shutdown_timeout">worker_shutdown_timeout</a> <br>   <a href="ngx_core_module.html#working_directory">working_directory的</a> <br>   <a href="mail/ngx_mail_proxy_module.html#xclient">X客户端</a> <br>   <a href="http/ngx_http_xslt_module.html#xml_entities">xml_entities</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_last_modified">xslt_last_modified</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_param">xslt_param</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_string_param">xslt_string_param</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_stylesheet">xslt_stylesheet</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_types">xslt_types</a> <br>   <a href="http/ngx_http_upstream_module.html#zone">zone</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#zone">zone</a> （ngx_stream_upstream_module） <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync">zone_sync</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_buffers">zone_sync_buffers</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_connect_retry_interval">zone_sync_connect_retry_interval</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_connect_timeout">zone_sync_connect_timeout</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_interval">zone_sync_interval</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_recv_buffer_size">zone_sync_recv_buffer_size</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_server">zone_sync_server</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl">zone_sync_ssl</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_certificate">zone_sync_ssl_certificate</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_certificate_key">zone_sync_ssl_certificate_key</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_ciphers">zone_sync_ssl_ciphers</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_crl">zone_sync_ssl_crl</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_name">zone_sync_ssl_name</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_password_file">zone_sync_ssl_password_file</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_protocols">zone_sync_ssl_protocols</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_server_name">zone_sync_ssl_server_name</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_trusted_certificate">zone_sync_ssl_trusted_certificate</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_verify">zone_sync_ssl_verify</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_verify_depth">zone_sync_ssl_verify_depth</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_timeout">zone_sync_timeout</a> <br></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[debugging_log-nginx中文手册]]></title>
      <url>/ngx/debugging_log.html</url>
      <content type="html"><![CDATA[<p>debugging_log<br><a id="more"></a></p>
<h2 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h2><td align="left" class="notranslate"> <a href="#clients">Debugging log for selected clients</a> <br> <a href="#memory">Logging to a cyclic memory buffer</a> <br></td>

<p>  要启用调试日志，需要配置nginx以在构建期间支持调试： </p>
<pre class="notranslate">./configure --with-debug ...
</pre>

<p>  然后应使用<a href="ngx_core_module.html#error_log">error_log</a>指令设置<code>debug</code>级别： </p>
<pre class="notranslate">error_log /path/to/log debug;
</pre>

<p>  要验证nginx是否配置为支持调试，请运行<code>nginx -V</code>命令： </p>
<pre class="notranslate">configure arguments: --with-debug ...
</pre>

<p>  预构建的<a href="linux_packages.html">Linux</a>软件包为使用<code>nginx-debug</code>二进制文件（1.9.8）调试日志提供了开箱即用的支持，可以使用命令运行 </p>
<pre class="notranslate">service nginx stop
service nginx-debug start
</pre>

<p>  然后设置<code>debug</code>级别。  用于Windows的nginx二进制版本始终使用调试日志支持构建，因此仅设置<code>debug</code>级别就足够了。 </p>
<p>  请注意，重新定义日志而不指定<code>debug</code>级别将禁用调试日志。  在下面的示例中，重新定义<a href="http/ngx_http_core_module.html#server">服务器</a>级别上的日志会禁用此服务器的调试日志： </p>
<pre class="notranslate">error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log;
        ...
</pre>

<p>  为避免这种情况，应重新定义重新定义日志的行，或者还应添加<code>debug</code>级别规范： </p>
<pre class="notranslate">error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log debug;
        ...
</pre>



<h4 id="调试所选客户端的日志"><a href="#调试所选客户端的日志" class="headerlink" title="调试所选客户端的日志"></a>调试所选客户端的日志</h4><p>  也可以仅为<a href="ngx_core_module.html#debug_connection">选定的客户端地址</a>启用调试日志： </p>
<pre class="notranslate">error_log /path/to/log;

events {
    debug_connection 192.168.1.1;
    debug_connection 192.168.10.0/24;
}
</pre>



<h4 id="记录到循环内存缓冲区"><a href="#记录到循环内存缓冲区" class="headerlink" title="记录到循环内存缓冲区"></a>记录到循环内存缓冲区</h4><p>  调试日志可以写入循环内存缓冲区： </p>
<pre class="notranslate">error_log memory:32m debug;
</pre>

<p>  即使在高负载下，在<code>debug</code>级别上记录到内存缓冲区也不会对性能产生重大影响。  在这种情况下，可以使用<code>gdb</code>脚本提取日志，如下所示： </p>
<pre class="notranslate">set $log = ngx_cycle-&gt;log

while $log-&gt;writer != ngx_log_memory_writer
    set $log = $log-&gt;next
end

set $buf = (ngx_log_memory_buf_t *) $log-&gt;wdata
dump binary memory debug_log.txt $buf-&gt;start $buf-&gt;end
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[control-nginx中文手册]]></title>
      <url>/ngx/control.html</url>
      <content type="html"><![CDATA[<p>control<br><a id="more"></a></p>
<h2 id="控制nginx"><a href="#控制nginx" class="headerlink" title="控制nginx"></a>控制nginx</h2><td align="left" class="notranslate"> <a href="#reconfiguration">Changing Configuration</a> <br> <a href="#logs">Rotating Log-files</a> <br> <a href="#upgrade">Upgrading Executable on the Fly</a> <br></td>

<p>   nginx可以用信号控制。  默认情况下，主进程的进程ID将写入文件<code>/usr/local/nginx/logs/nginx.pid</code> 。  此名称可以在配置时更改，也可以使用<a href="ngx_core_module.html#pid">pid</a>指令在<code>nginx.conf</code>更改。  主进程支持以下信号： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">TERM, INT</td><td class="notranslate">fast shutdown</td><br><td width="20%" class="notranslate">QUIT</td><td class="notranslate">graceful shutdown</td><br><tr><td width="20%" class="notranslate">HUP</td><td class="notranslate">changing configuration,<br>keeping up with a changed time zone (only for FreeBSD and Linux),<br>starting new worker processes with a new configuration,<br>graceful shutdown of old worker processes</td></tr><td width="20%" class="notranslate">USR1</td><td class="notranslate">re-opening log files</td><br><td width="20%" class="notranslate">USR2</td><td class="notranslate">upgrading an executable file</td><br><td width="20%" class="notranslate">WINCH</td><td class="notranslate">graceful shutdown of worker processes</td><br></tbody></table>



</blockquote>
<p>  虽然不是必需的，但也可以通过信号控制单个工作进程。  支持的信号是： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">TERM, INT</td><td class="notranslate">fast shutdown</td><br><td width="20%" class="notranslate">QUIT</td><td class="notranslate">graceful shutdown</td><br><td width="20%" class="notranslate">USR1</td><td class="notranslate">re-opening log files</td><br><tr><td width="20%" class="notranslate">WINCH</td><td class="notranslate">abnormal termination for debugging<br>(requires <a href="ngx_core_module.html#debug_points">debug_points</a> to be enabled)<br></td></tr></tbody></table>



</blockquote>
<h4 id="改变配置"><a href="#改变配置" class="headerlink" title="改变配置"></a>改变配置</h4><p>  为了让nginx重新读取配置文件，应该将HUP信号发送到主进程。  主进程首先检查语法有效性，然后尝试应用新配置，即打开日志文件和新的侦听套接字。  如果此操作失败，则会回滚更改并继续使用旧配置。  如果成功，它将启动新的工作进程，并向旧工作进程发送消息，请求它们正常关闭。  旧工作进程关闭侦听套接字并继续为旧客户端提供服务。  在为所有客户端提供服务后，将关闭旧工作进程。 </p>
<p>  让我们通过例子来说明这一点。  想象一下，nginx是在FreeBSD和命令上运行的 </p>
<pre class="notranslate">ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep '(nginx|PID)'
</pre>

<p>  产生以下输出： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  如果将HUP发送到主进程，则输出变为： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</pre>



<p>   PID 33129的旧工作进程之一仍然继续工作。  退出一段时间后： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</pre>



<h4 id="旋转日志文件"><a href="#旋转日志文件" class="headerlink" title="旋转日志文件"></a>旋转日志文件</h4><p>  为了旋转日志文件，需要先重命名它们。  之后，应将USR1信号发送到主进程。  然后，主进程将重新打开所有当前打开的日志文件，并为作为所有者的工作进程正在运行的非特权用户分配。  成功重新打开后，主进程将关闭所有打开的文件，并将消息发送到工作进程，要求他们重新打开文件。  工作进程还会立即打开新文件并关闭旧文件。  因此，旧文件几乎可立即用于后期处理，例如压缩。 </p>
<h4 id="即时升级可执行文件"><a href="#即时升级可执行文件" class="headerlink" title="即时升级可执行文件"></a>即时升级可执行文件</h4><p>  为了升级服务器可执行文件，应首先使用新的可执行文件代替旧文件。  之后，应将USR2信号发送到主进程。  主进程首先使用进程ID将其文件重命名为带有<code>.oldbin</code>后缀的新文件，例如<code>/usr/local/nginx/logs/nginx.pid.oldbin</code> ，然后启动一个新的可执行文件，该文件又启动新的工作进程： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  之后，所有工作进程（新旧进程）继续接受请求。  如果将WINCH信号发送到第一个主进程，它将向其工作进程发送消息，请求它们正常关闭，然后它们将开始退出： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33135 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  一段时间后，只有新的工作进程才会处理请求： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  应该注意的是，旧的主进程不会关闭其侦听套接字，并且可以管理它以在需要时再次启动其工作进程。  如果由于某种原因新的可执行文件无法接受，可以执行以下操作之一： </p>
<ul>
<li>将HUP信号发送到旧的主进程。  旧的主进程将启动新的工作进程，而无需重新读取配置。  之后，通过将QUIT信号发送到新的主进程，可以正常关闭所有新进程。 -   将TERM信号发送到新的主进程。  然后它会向其工作进程发送一条消息，要求它们立即退出，并且它们几乎都会立即退出。   （如果新进程由于某种原因没有退出，则应将KILL信号发送给它们以强制它们退出。）当新的主进程退出时，旧的主进程将自动启动新的进程进程。 </li>
</ul>
<p>  如果新的主进程退出，则旧的主进程将使用进程ID从文件名中丢弃<code>.oldbin</code>后缀。 </p>
<p>  如果升级成功，则应将QUIT信号发送到旧的主进程，并且只保留新进程： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
36264     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[contributing_changes-nginx中文手册]]></title>
      <url>/ngx/contributing_changes.html</url>
      <content type="html"><![CDATA[<p>contributing_changes<br><a id="more"></a></p>
<h2 id="贡献变化"><a href="#贡献变化" class="headerlink" title="贡献变化"></a>贡献变化</h2><td align="left" class="notranslate"> <a href="#getting_sources">Getting Sources</a> <br> <a href="#formatting_changes">Formatting Changes</a> <br> <a href="#before_submitting">Before Submitting</a> <br> <a href="#submitting_changes">Submitting Changes</a> <br> <a href="#license">License</a> <br></td>

<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>   <a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>用于存储源代码。  可以使用以下命令克隆<a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">存储库</a> ： </p>
<pre class="notranslate">hg clone http://hg.nginx.org/nginx
</pre>



<h4 id="格式化更改"><a href="#格式化更改" class="headerlink" title="格式化更改"></a>格式化更改</h4><p>  应根据nginx使用的<a href="dev/development_guide.html#code_style">代码样式</a>格式化更改。  有时，没有明确的规则;  在这种情况下，检查现有nginx源的格式并模仿这种风格。  如果样式与周围的代码相对应，则更有可能接受更改。 </p>
<p>  提交更改以创建Mercurial <a href="https://www.mercurial-scm.org/wiki/ChangeSet" target="_blank" rel="noopener">变更集</a> 。  请确保更改作者的指定<a href="https://www.mercurial-scm.org/wiki/QuickStart#Setting_a_username" target="_blank" rel="noopener">电子邮件</a>地址和真实姓名正确无误。 </p>
<p>  提交消息应该有一个单行的概要，后面跟一个空行后的详细描述。  希望第一行不超过67个符号。  可以使用<code>hg export</code>命令获取作为补丁的结果变更集： </p>
<pre class="notranslate"># HG changeset patch
# User Filipe Da Silva &lt;username@example.com&gt;
# Date 1368089668 -7200
#      Thu May 09 10:54:28 2013 +0200
# Node ID 2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2
# Parent  822b82191940ef309cd1e6502f94d50d811252a1
Mail: removed surplus ngx_close_connection() call.

It is already called for a peer connection a few lines above.

diff -r 822b82191940 -r 2220de0521ca src/mail/ngx_mail_auth_http_module.c
--- a/src/mail/ngx_mail_auth_http_module.c      Wed May 15 15:04:49 2013 +0400
+++ b/src/mail/ngx_mail_auth_http_module.c      Thu May 09 10:54:28 2013 +0200
@@ -699,7 +699,6 @@ ngx_mail_auth_http_process_headers(ngx_m

                     p = ngx_pnalloc(s-&gt;connection-&gt;pool, ctx-&gt;err.len);
                     if (p == NULL) {
-                        ngx_close_connection(ctx-&gt;peer.connection);
                         ngx_destroy_pool(ctx-&gt;pool);
                         ngx_mail_session_internal_server_error(s);
                         return;
</pre>



<h4 id="在提交之前"><a href="#在提交之前" class="headerlink" title="在提交之前"></a>在提交之前</h4><p>  在提交更改之前，有几点值得考虑： </p>
<ul>
<li>建议的更改应适用于广泛的<a href="index.html#tested_os_and_platforms">受支持平台</a> 。 -   尽量明确为什么需要建议的更改，并尽可能提供用例。 </li><li>  通过测试套件传递更改是确保它们不会导致回归的好方法。  可以使用以下命令克隆包含测试的<a href="http://hg.nginx.org/nginx-tests" target="_blank" rel="noopener">存储库</a> ： <blockquote class="example"><pre class="notranslate">hg clone <a href="http://hg.nginx.org/nginx-tests" target="_blank" rel="noopener">http://hg.nginx.org/nginx-tests</a><br></pre></blockquote></li>
</ul>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>  建议的更改应发送到<a href="support.html#nginx_devel">nginx开发</a>邮件列表。  提交变更集的首选方便方法是使用<a href="https://www.mercurial-scm.org/wiki/PatchbombExtension" target="_blank" rel="noopener">patchbomb</a>扩展。 </p>
<h4 id="执照"><a href="#执照" class="headerlink" title="执照"></a>执照</h4><p>  提交更改意味着授予项目在相应<a href="LICENSE">许可</a>下使用它的权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[configure-nginx中文手册]]></title>
      <url>/ngx/configure.html</url>
      <content type="html"><![CDATA[<p>configure<br><a id="more"></a></p>
<h2 id="从Sources构建nginx"><a href="#从Sources构建nginx" class="headerlink" title="从Sources构建nginx"></a>从Sources构建nginx</h2><p>  使用<code>configure</code>命令配置构建。  它定义了系统的各个方面，包括允许nginx用于连接处理的方法。  最后它创建了一个<code>Makefile</code> 。 </p>
<p>   <code>configure</code>命令支持以下参数： </p>
<p>  参数用法示例（所有这些都需要在一行中输入）： </p>
<pre class="notranslate">./configure
    --sbin-path=/usr/local/nginx/nginx
    --conf-path=/usr/local/nginx/nginx.conf
    --pid-path=/usr/local/nginx/nginx.pid
    --with-http_ssl_module
    --with-pcre=../pcre-8.42
    --with-zlib=../zlib-1.2.11
</pre>



<p>  配置完成后，使用<code>make</code>编译和安装nginx。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compatibility-nginx中文手册]]></title>
      <url>/ngx/compatibility.html</url>
      <content type="html"><![CDATA[<p>compatibility<br><a id="more"></a></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><td align="left" class="notranslate"> <a href="#supported">What is currently supported</a> <br> <a href="#not_supported">What is not supported yet</a> <br></td>

<p>   njs是根据<a href="http://www.ecma-international.org/ecma-262/5.1/" target="_blank" rel="noopener">ECMAScript 5.1</a> （严格模式）创建的，带有一些<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript 6</a>及更高版本的扩展。  合规性仍在不断发展。 </p>
<h4 id="目前支持什么"><a href="#目前支持什么" class="headerlink" title="目前支持什么"></a>目前支持什么</h4><ul>
<li>布尔值，数字，字符串，对象，数组，函数和正则表达式 -    ES5.1运算符，ES7指数运算符 -    ES5.1语句： <code>var</code> ， <code>if</code> ， <code>else</code> ， <code>switch</code> ， <code>for</code> ， <code>for in</code> ， <code>while</code> ， <code>do while</code> ， <code>break</code> ， <code>continue</code> ， <code>return</code> ， <code>try</code> ， <code>catch</code> ， <code>throw</code> ， <code>finally</code> -    ES6 <code>Number</code>和<code>Math</code>属性和方法 -    <code>String</code>方法： <ul class="compact"><li>   ES5.1： <a href="reference.html#string_fromcharcode"><code>fromCharCode</code></a> ， <a href="reference.html#string_concat"><code>concat</code></a> ， <a href="reference.html#string_slice"><code>slice</code></a> ， <a href="reference.html#string_substring"><code>substring</code></a> ， <a href="reference.html#string_substr"><code>substr</code></a> ， <a href="reference.html#string_charat"><code>charAt</code></a> ， <a href="reference.html#string_indexof"><code>indexOf</code></a> ， <a href="reference.html#string_lastindexof"><code>lastIndexOf</code></a> ， <a href="reference.html#string_tolowercase"><code>toLowerCase</code></a> ， <a href="reference.html#string_touppercase"><code>toUpperCase</code></a> ， <a href="reference.html#string_trim"><code>trim</code></a> ， <a href="reference.html#string_search"><code>search</code></a> ， <a href="reference.html#string_match"><code>match</code></a> ， <a href="reference.html#string_split"><code>split</code></a> ， <a href="reference.html#string_replace"><code>replace</code></a> -    ES6： <a href="reference.html#string_fromcodepoint"><code>fromCodePoint</code></a> ， <a href="reference.html#string_codepointat"><code>codePointAt</code></a> ， <a href="reference.html#string_includes"><code>includes</code></a> ， <a href="reference.html#string_startswith"><code>startsWith</code></a> ， <a href="reference.html#string_endswith"><code>endsWith</code></a> ， <a href="reference.html#string_repeat"><code>repeat</code></a> -    ES8： <a href="reference.html#string_padstart"><code>padStart</code></a> ， <a href="reference.html#string_padend"><code>padEnd</code></a> -   非标准： <a href="reference.html#string_bytesfrom"><code>bytesFrom</code></a> （ <a href="reference.html#string_bytesfrom"><code>bytesFrom</code></a> ） <a href="reference.html#string_fromutf8"><code>fromUTF8</code></a> ， <a href="reference.html#string_toutf8"><code>toUTF8</code></a> ， <a href="reference.html#string_frombytes"><code>fromBytes</code></a> ， <a href="reference.html#string_tobytes"><code>toBytes</code></a> -    ES5.1： <code>create</code> （不带属性列表的支持）， <code>keys</code> ， <code>defineProperty</code> ， <code>defineProperties</code> ， <code>getOwnPropertyDescriptor</code> ， <code>getPrototypeOf</code> ， <code>hasOwnProperty</code> ， <code>isPrototypeOf</code> ， <code>preventExtensions</code> ， <code>isExtensible</code> ， <code>freeze</code> ， <code>isFrozen</code> ， <code>seal</code> ， <code>isSealed</code> -    ES5.1： <code>isArray</code> ， <code>slice</code> ， <code>splice</code> ， <code>push</code> ， <code>pop</code> ， <code>unshift</code> ， <code>shift</code> ， <code>reverse</code> ， <code>sort</code> ， <code>join</code> ， <code>concat</code> ， <code>indexOf</code> ， <code>lastIndexOf</code> ， <code>forEach</code> ， <code>some</code> ， <code>every</code> ， <code>filter</code> ， <code>map</code> ， <code>reduce</code> ， <code>reduceRight</code> -    ES6： <code>of</code> ， <code>fill</code> ， <code>find</code> ， <code>findIndex</code> -    ES7： <code>includes</code> </li>
</ul>
<h4 id="什么是不支持的"><a href="#什么是不支持的" class="headerlink" title="什么是不支持的"></a>什么是不支持的</h4><ul>
<li>ES6 <code>let</code>和<code>const</code>声明 -   标签 -    <code>eval</code>功能 -    <code>new Function()</code>构造函数 -    <code>setInterval</code> ， <code>setImmediate</code>函数 </li>
</ul>
</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[changes-nginx中文手册]]></title>
      <url>/ngx/changes.html</url>
      <content type="html"><![CDATA[<p>changes<br><a id="more"></a></p>
<h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><h4 id="变化为0-2-6"><a href="#变化为0-2-6" class="headerlink" title="变化为0.2.6"></a>变化为0.2.6</h4><p>  发布日期：2018年11月27日 </p>
<p>  核心： </p>
<ul>
<li>特点：使内置原型可变。 -   特征：使全局对象变得可变。 -   功能： <code>console.time()</code>和<code>console.timeEnd()</code>方法。 -   功能：允许重新声明变量和函数。 -   功能：扩展<code>Object.defineProperty()</code>规范一致性。 -   功能：为CLI引入安静模式以处理来自stdin的简单表达式。 -   特点：引入紧凑形式的回溯来处理堆栈溢出。 -   改进：改进各种例外的措辞。 -   修正：修复闭包值处理。 -   修正：各种值类型的固定相等运算符。 -   修正：修复了各种范围内“this”关键字的处理。 -   修正：修复了<code>Object.keys()</code>处理非对象值的问题。 -   修正：在<code>if</code>语句中修复了throw语句的解析。 -   修正：修复throw语句后的换行符。 -   修正：修复if语句中没有换行符的语句解析。 -   修正： <code>njs_array_expand()</code>固定大小<code>uint32_t</code>溢出。 -   修正： <code>object_value</code>类型的固定<code>typeof</code>运算符。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-5"><a href="#变化为0-2-5" class="headerlink" title="变化为0.2.5"></a>变化为0.2.5</h4><p>  发布日期：2018年10月30日 </p>
<p>   nginx模块： </p>
<ul>
<li>修正：在流模块中修复计数待处理事件。 -   修正：修复了流模块中的<code>s.off()</code> 。 -   修正：修复了流模块中<code>js_filter</code>中数据块的处理。 -   修正：在http模块中修复了http <code>status</code>和<code>contentType</code> getter。 -   修正：在http模块中修复了http响应和父getter。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：参数对象支持。 -   特征：非整数分数支持。 -   改进：处理<code>Array.prototype.slice()</code>非数组值。 -   修正：修复了<code>Array.prototype.length</code> setter -   修正：固定<code>njs_array_alloc()</code> ，长度&gt; 2 ** 31。 -   修正：处理32位<code>njs_array_alloc()</code>上的<code>njs_array_alloc()</code> int溢出。 -   修正：修复代码大小不匹配错误消息。 -   修正：修复循环中的删除操作符。 -   修正：修复了复杂对象的<code>Object.getOwnPropertyDescriptor()</code> （继承自<code>Array</code>和<code>string</code>值）。 -   修正：修复了非对象属性的<code>Object.prototype.hasOwnProperty()</code> -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-4"><a href="#变化为0-2-4" class="headerlink" title="变化为0.2.4"></a>变化为0.2.4</h4><p>  发布日期：2018年9月18日 </p>
<p>   nginx模块： </p>
<ul>
<li>更改：重构的流模块处理程序。   新方法和属性： <a href="reference.html#s_on">s.on（）</a> ， <a href="reference.html#s_off">s.off（）</a> ， <a href="reference.html#s_allow">s.allow（）</a> ， <a href="reference.html#s_done">s.done（）</a> ， <a href="reference.html#s_decline">s.decline（）</a> ， <a href="reference.html#s_deny">s.deny（）</a> 。   删除了<a href="reference.html#stream">Stream</a>对象的属性： <code>s.OK</code> ， <code>s.ABORT</code> ， <code>s.AGAIN</code> ， <code>s.DECLINED</code> ， <code>s.ERROR</code> （替换为<a href="reference.html#s_allow">s.allow（）</a> ， <a href="reference.html#s_done">s.done（）</a> ， <a href="reference.html#s_deny">s.deny（）</a> ）。    <code>s.buffer</code> （用于读取替换为相应回调的数据参数，用于写入使用<a href="reference.html#s_send">s.send（）</a> ）。    <code>s.fromUpstream</code> （替换为相应事件的回调）。    <code>s.eof</code> （替换为 ``   <a href="reference.html#s_on_callback_last">flags.last</a> ）。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：添加了<code>Function.prototype.length</code> 。 -   功能：介绍沙盒模式。 -   改进：适当时添加异常字符串。 -   改进：改进了原始类型转换异常的措辞。 -   修正：为尝试更改冻结属性而抛出<code>TypeError</code> 。 -   修正：修复现有属性的<code>Object.defineProperty()</code> 。 -   修正：在for for迭代时尊重可枚举属性。 -   修正：尊重属性处理程序的可写属性。 -   修正：修复了函数参数中的异常处理。 -   修正：修复了不同值类型的<code>Object.prototype.toString</code> 。 -   修正：修复了对象类型参数的<code>Object()</code>构造函数。 -   修正：固定对象和字符串的比较。 -   修正：修复了未定义参数的<code>String.slice()</code> 。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-3"><a href="#变化为0-2-3" class="headerlink" title="变化为0.2.3"></a>变化为0.2.3</h4><p>  发布日期：2018年7月31日 </p>
<p>   nginx模块： </p>
<ul>
<li>修正：从<code>Reply</code>对象进行子请求导致分段错误。 -   修正：获取主<a href="reference.html#http">HTTP Request</a>对象的parent属性导致了分段错误。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：为值添加了漂亮的字符串表示。 -   功能：正确打印浮点数。 -   功能：正确解析浮点数。 -   功能： <a href="reference.html#string_bytesfrom">String.bytesFrom（）</a>方法（将<code>hex</code> ， <code>base64</code> ， <code>base64url</code>解码为字节字符串）。 -   功能： <a href="reference.html#string_padstart">String.padStart（）</a>和<a href="reference.html#string_padend">String.padEnd（）</a>方法。 -   功能：增加了对二进制文字的支持。 -   改进：在数字解析中添加有关非法令牌的信息。 -   改进：允许在八进制文字值中使用大写字母<code>O</code> -   改进：在<code>console.log()</code>添加了对多个参数的支持。 -   修正：修复了将<code>call()</code>应用于外部值的方法。 -   修正：应用于对象的固定加法运算符。 -   修正：在<code>njs_vm_value_to_ext_string()</code>修复异常处理。 -   修正：使用布尔，null和未定义的参数修复<code>Number()</code> 。 -   修正：修复了设置非数字<code>Array.length</code>错误处理。 -   修正：修复全局对象的自动完成。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-2"><a href="#变化为0-2-2" class="headerlink" title="变化为0.2.2"></a>变化为0.2.2</h4><p>  发布日期：2018年6月19日 </p>
<p>   nginx模块： </p>
<ul>
<li>更改：合并HTTP <code>Response</code>和<code>Reply</code>到<a href="reference.html#http">HTTP请求</a> 。  新成员<code>Request</code> ： <ul class="compact"><li>   <code>req.status</code> （ <code>res.status</code> ） -    <code>req.parent</code> （ <code>reply.parent</code> ） -    <code>req.requestBody</code> （ <code>req.body</code> ） -    <code>req.responseBody</code> （ <code>reply.body</code> ） -    <code>req.headersIn</code> （ <code>req.headers</code> ） -    <code>req.headersOut</code> （ <code>res.headers</code> ） -    <code>req.sendHeader()</code> （ <code>res.sendHeader()</code> ） -    <code>req.send()</code> （ <code>res.send()</code> ） -    <code>req.finish()</code> （ <code>res.finish()</code> ） -    <code>req.return()</code> （ <code>res.return()</code> ）<br>弃用的<code>Request</code>成员： </li>
<li><p><code>req.body</code> （使用<code>req.requestBody</code>或<code>req.responseBody</code> ） -    <code>req.headers</code> （使用<code>req.headersIn</code>或<code>req.headersOut</code> ） -  <code>req.response</code><br>已弃用的属性将在下一版本中删除。 </p>
<p>功能：HTTP <a href="reference.html#r_internal_redirect">internalRedirect（）</a>方法。 </p>
</li>
</ul>
<p>  核心： </p>
<ul>
<li>修正：在<code>crypto.createHmac()</code>修复了heap-buffer-overflow。 </li>
</ul>
<h4 id="变化为0-2-1"><a href="#变化为0-2-1" class="headerlink" title="变化为0.2.1"></a>变化为0.2.1</h4><p>  发布日期：2018年5月31日 </p>
<p>   nginx模块： </p>
<ul>
<li>功能：HTTP请求正文getter。 -   改进：将njs vm移动到<code>main</code>配置。 -   改进：改进了<a href="http/ngx_http_js_module.html#js_set">js_set</a>和<a href="http/ngx_http_js_module.html#js_content">js_content</a>指令的日志记录。 -   改进：在<a href="http/ngx_http_js_module.html#js_content">js_content</a>处理程序中默认将状态代码设置为500 -   改进：在<a href="http/ngx_http_js_module.html#js_content">js_content</a>处理程序中添加了返回状态代码的调试 -   修正：修复了<a href="http/ngx_http_js_module.html#js_include">js_include中的</a>错误记录。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：添加了数组长度设置器。 -   改进：公共标头<code>cleanup. njscript.h</code>   <code>cleanup. njscript.h</code>重命名为<code>njs.h</code> -   修正：调用<code>digest()</code>后修复了crypto <code>update()</code>方法。 -   修正：修复了大小&lt;= alg size&gt; 64的密钥的<code>crypto.createHmac()</code> 。 -   修正：修复了带空单元格的数组的<code>JSON.stringify()</code> 。 -   修正：修复了<code>JSON.stringify()</code>不支持的类型的异常类型。 -   修正：修复了函数未定义参数的处理。 -   修正：修复了对<code>Object.getOwnPropertyDescriptor()</code>缺失<code>arg</code>的处理。 -   修正：修复了<code>Object.getOwnPropertyDescriptor()</code>中属性的处理。 -   修正：修复了<code>Array.length</code>属性的可写标志。 -   修正： <code>clearTimeout()</code>固定返回值类型。 -   修正：修复了<code>njs_vm_external_bind()</code> 。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-0"><a href="#变化为0-2-0" class="headerlink" title="变化为0.2.0"></a>变化为0.2.0</h4><p>  发布日期：2018年4月3日 </p>
<ul>
<li>功能：通过CLI报告njs版本。 -   功能：转换异常的类型的文本描述。 -   功能： <code>setTimeout()</code>和<code>clearTimeout()</code>方法。 -   功能：字节字符串为<code>hex</code> ， <code>base64</code> ， <code>base64url</code>编码。 -   功能： <a href="https://nodejs.org/api/crypto.html#crypto_class_hash" target="_blank" rel="noopener">Node.js样式</a> <code>Crypto</code>方法。 -   功能：HTTP和流<code>warn()</code>和<code>error()</code>方法。 -   功能：HTTP <code>subrequest()</code>方法。 -   功能：HTTP <code>return()</code>方法。 -   修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-15"><a href="#变化0-1-15" class="headerlink" title="变化0.1.15"></a>变化0.1.15</h4><p>  发布日期：2017年11月20日 </p>
<ul>
<li>功能： <code>Error</code> ， <code>EvalError</code> ， <code>InternalError</code> ， <code>RangeError</code> ， <code>ReferenceError</code> ， <code>SyntaxError</code> ， <code>TypeError</code> ， <code>URIError</code>对象。 -   功能：八进制文字支持。 -   功能： <a href="https://nodejs.org/api/fs.html#fs_file_system" target="_blank" rel="noopener">Node.js样式</a> <code>File system</code>访问方法： <code>fs.readFile()</code> ， <code>fs.readFileSync()</code> ， <code>fs.appendFile()</code> ， <code>fs.appendFileSync()</code> ， <code>fs.writeFile()</code> ， <code>fs.writeFileSync()</code> 。 -   功能：nginx模块在异常时打印回溯。 -   修正：杂项错误已得到修复。 </li>
</ul>
<h4 id="变化0-1-14"><a href="#变化0-1-14" class="headerlink" title="变化0.1.14"></a>变化0.1.14</h4><p>  发布日期：2017年10月9日 </p>
<ul>
<li>功能：JSON对象。 -   功能：交互式shell中的对象级完成。 -   功能：各种配置改进。 -   修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-13"><a href="#变化0-1-13" class="headerlink" title="变化0.1.13"></a>变化0.1.13</h4><p>  发布日期：2017年8月31日 </p>
<ul>
<li>功能：交互式shell中的<code>console.log()</code>和<code>console.help()</code>方法。 -   功能：交互式shell在异常时打印回溯。 -   功能：如果<code>libedit</code>可用，默认情况下为交互式shell。 -   修正：在命令行模式下从<code>stdin</code>处理大文件。 -   修正：改进了<code>editline</code>检测。 </li>
</ul>
<h4 id="变化0-1-12"><a href="#变化0-1-12" class="headerlink" title="变化0.1.12"></a>变化0.1.12</h4><p>  发布日期：2017年8月8日 </p>
<ul>
<li>功能：交互式shell。 -   修正：在<code>Object.isSealed()</code> 。 </li>
</ul>
<h4 id="0-1-11的变化"><a href="#0-1-11的变化" class="headerlink" title="0.1.11的变化"></a>0.1.11的变化</h4><p>  发行日期：2017年6月27日 </p>
<ul>
<li>功能： <code>Object.keys()</code> ， <code>Object.prototype.hasOwnProperty()</code>方法。 -   功能： <code>Object.defineProperty()</code> ， <code>Object.defineProperties()</code> ， <code>Object.getOwnPropertyDescriptor()</code>方法。 -   功能： <code>Object.getPrototypeOf()</code> ， <code>Object.prototype.isPrototypeOf()</code>方法。 -   功能： <code>Object.preventExtensions()</code> ， <code>Object.isExtensible()</code> ， <code>Object.freeze()</code> ， <code>Object.isFrozen()</code> ， <code>Object.seal()</code> ， <code>Object.isSealed()</code>方法。 -   特征：科学记数法（ <code>3.35e10</code> ）文字支持。 -   功能：十六进制（ <code>0x1123</code> ）文字支持。 -   修正：处理大型数组索引。 -   修正：在<code>parseInt()</code>和<code>Date.parse()</code> 。 </li>
</ul>
<h4 id="变化0-1-10"><a href="#变化0-1-10" class="headerlink" title="变化0.1.10"></a>变化0.1.10</h4><p>  发行日期：2017年4月4日 </p>
<ul>
<li>功能：嵌套函数和函数闭包。 -   功能： <code>Array.of()</code> ， <code>Array.prototype.fill()</code> ， <code>Array.prototype.find()</code> ， <code>Array.prototype.findIndex()</code>方法。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-9"><a href="#变化0-1-9" class="headerlink" title="变化0.1.9"></a>变化0.1.9</h4><p>  发布日期：2017年2月1日 </p>
<ul>
<li>修正：在nginx中使用njs时，未初始化全局变量。 </li>
</ul>
<h4 id="变化0-1-8"><a href="#变化0-1-8" class="headerlink" title="变化0.1.8"></a>变化0.1.8</h4><p>  发布日期：2017年1月24日 </p>
<ul>
<li>更改：强制执行<code>strict</code>模式，必须显式声明变量。 -   功能： <code>for</code>和<code>for-in</code>循环支持变量声明。 -   修正：全局和功能范围已得到修复。 -   修正：现在<code>for-in</code>循环不会丢弃属性变量的最后一个值。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-7"><a href="#变化0-1-7" class="headerlink" title="变化0.1.7"></a>变化0.1.7</h4><p>  发布日期：2016年12月27日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用<a href="http/ngx_http_js_module.html#js_include">js_include</a>指令。 -   特征：取幂运算符。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-6"><a href="#变化0-1-6" class="headerlink" title="变化0.1.6"></a>变化0.1.6</h4><p>  发布日期：2016年12月13日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用<a href="http/ngx_http_js_module.html#js_set">js_set</a>指令。 -   特征：ES6 <code>Math</code>方法。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[beginners_guide-nginx中文手册]]></title>
      <url>/ngx/beginners_guide.html</url>
      <content type="html"><![CDATA[<p>beginners_guide<br><a id="more"></a></p>
<h2 id="初学者指南"><a href="#初学者指南" class="headerlink" title="初学者指南"></a>初学者指南</h2><td align="left" class="notranslate"> <a href="#control">Starting, Stopping, and Reloading Configuration</a> <br> <a href="#conf_structure">Configuration File’s Structure</a> <br> <a href="#static">Serving Static Content</a> <br> <a href="#proxy">Setting Up a Simple Proxy Server</a> <br> <a href="#fastcgi">Setting Up FastCGI Proxying</a> <br></td>

<p>  本指南提供了对nginx的基本介绍，并介绍了可以使用它完成的一些简单任务。  据推测，nginx已安装在阅读器的机器上。  如果不是，请参阅<a href="install.html">安装nginx</a>页面。  本指南介绍如何启动和停止nginx，重新加载其配置，解释配置文件的结构，并介绍如何设置nginx以提供静态内容，如何将nginx配置为代理服务器，以及如何将其与一个FastCGI应用程序。 </p>
<p>   nginx有一个主进程和几个工作进程。  主进程的主要目的是读取和评估配置，并维护工作进程。  工作进程会对请求进行实际处理。   nginx使用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分发请求。  工作进程数在配置文件中定义，可以针对给定配置进行修复，也可以自动调整为可用CPU内核数（请参阅<a href="ngx_core_module.html#worker_processes">worker_processes</a> ）。 </p>
<p>   nginx及其模块的工作方式在配置文件中确定。  默认情况下，配置文件名为<code>nginx.conf</code>并放在目录<code>/usr/local/nginx/conf</code> ， <code>/etc/nginx</code>或<code>/usr/local/etc/nginx</code> 。 </p>
<h4 id="启动，停止和重新加载配置"><a href="#启动，停止和重新加载配置" class="headerlink" title="启动，停止和重新加载配置"></a>启动，停止和重新加载配置</h4><p>  要启动nginx，请运行可执行文件。  启动nginx后，可以通过使用<code>-s</code>参数调用可执行文件来控制它。  使用以下语法： </p>
<pre class="notranslate">nginx -s *signal*
</pre>

<p>   <em>信号</em>可能是以下之一： </p>
<ul>
<li><code>stop</code> - 快速关机 -    <code>quit</code> - 正常关机 -    <code>reload</code> - 重新加载配置文件 -    <code>reopen</code> - 重新打开日志文件<br>例如，要在等待工作进程完成当前请求的服务时停止nginx进程，可以执行以下命令： </li>
</ul>
<pre class="notranslate">nginx -s quit
</pre>



<blockquote>
<p>  此命令应在启动nginx的同一用户下执行。 </p>
</blockquote>
<p>  在将重新加载配置的命令发送到nginx或重新启动之前，将不会应用配置文件中所做的更改。  要重新加载配置，请执行： </p>
<pre class="notranslate">nginx -s reload
</pre>



<p>  一旦主进程收到重新加载配置的信号，它将检查新配置文件的语法有效性并尝试应用其中提供的配置。  如果成功，主进程将启动新的工作进程并向旧工作进程发送消息，请求它们关闭。  否则，主进程将回滚更改并继续使用旧配置。  旧工作进程，接收命令关闭，停止接受新连接并继续为当前请求提供服务，直到所有此类请求都得到服务。  之后，旧工作进程退出。 </p>
<p>  也可以借助Unix工具（如<code>kill</code>实用程序）将信号发送到nginx进程。  在这种情况下，信号直接发送到具有给定进程ID的进程。  默认情况下，nginx主进程的进程ID写入目录<code>/usr/local/nginx/logs</code>或<code>/var/run</code>的<code>nginx.pid</code> 。  例如，如果主进程ID是1628，要发送导致nginx正常关闭的QUIT信号，请执行： </p>
<pre class="notranslate">kill -s QUIT 1628
</pre>

<p>  要获取所有正在运行的nginx进程的列表，可以使用<code>ps</code>实用程序，例如，通过以下方式： </p>
<pre class="notranslate">ps -ax | grep nginx
</pre>

<p>  有关向nginx发送信号的更多信息，请参阅<a href="control.html">控制nginx</a> 。 </p>
<h4 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h4><p>   nginx由模块组成，这些模块由配置文件中指定的指令控制。  指令分为简单指令和块指令。  一个简单的指令包括由空格分隔的名称和参数，以分号（ <code>;</code> ）结尾。  块指令与简单指令具有相同的结构，但它不是以分号结尾，而是以大括号（ <code>{</code>和<code>}</code> ）包围的一组附加指令结束。  如果块指令可以在大括号内包含其他指令，则称为上下文（示例： <a href="ngx_core_module.html#events">events</a> ， <a href="http/ngx_http_core_module.html#http">http</a> ， <a href="http/ngx_http_core_module.html#server">server</a>和<a href="http/ngx_http_core_module.html#location">location</a> ）。 </p>
<p>  放置在任何上下文之外的配置文件中的指令被认为是在<a href="ngx_core_module.html">主</a>上下文中。   <code>events</code>和<code>http</code>指令驻留在<code>main</code>上下文中， <code>server</code>位于<code>http</code> ，位于<code>server</code> 。 </p>
<p>   <code>#</code>符号后面的其余部分被视为评论。 </p>
<h4 id="提供静态内容"><a href="#提供静态内容" class="headerlink" title="提供静态内容"></a>提供静态内容</h4><p>  一个重要的Web服务器任务是提供文件（例如图像或静态HTML页面）。  您将实现一个示例，根据请求，将从不同的本地目录提供文件： <code>/data/www</code> （可能包含HTML文件）和<code>/data/images</code> （包含图像）。  这将需要编辑配置文件并在<a href="http/ngx_http_core_module.html#http">http</a>块内设置具有两个<a href="http/ngx_http_core_module.html#location">位置</a>块的<a href="http/ngx_http_core_module.html#server">服务器</a>块。 </p>
<p>  首先，创建<code>/data/www</code>目录并将包含任何文本内容的<code>index.html</code>文件放入其中，然后创建<code>/data/images</code>目录并在其中放置一些图像。 </p>
<p>  接下来，打开配置文件。  默认配置文件已包含几个<code>server</code>块的示例，主要是注释掉的。  现在注释掉所有这些块并启动一个新的<code>server</code>块： </p>
<pre class="notranslate">http {
    server {
    }
}
</pre>

<p>  通常，配置文件可以包括由它们<a href="http/ngx_http_core_module.html#listen">监听</a>的端口和<a href="http/server_names.html">服务器名称</a> <a href="http/request_processing.html">区分</a>的多个<code>server</code>块。  一旦nginx决定哪个<code>server</code>处理请求，它就会根据<code>server</code>块内定义的<code>location</code>指令的参数测试请求头中指定的URI。 </p>
<p>  将以下<code>location</code>块添加到<code>server</code>块： </p>
<pre class="notranslate">location / {
    root /data/www;
}
</pre>

<p>  此<code>location</code>块指定与请求中的URI进行比较的“ <code>/</code> ”前缀。  对于匹配请求，URI将添加到<a href="http/ngx_http_core_module.html#root">根</a>指令中指定的路径，即<code>/data/www</code> ，以形成本地文件系统上所请求文件的路径。  如果存在多个匹配的<code>location</code>块，则nginx选择具有最长前缀的<code>location</code>块。  上面的<code>location</code>块提供长度为1的最短前缀，因此仅当所有其他<code>location</code>块无法提供匹配时，才会使用此块。 </p>
<p>  接下来，添加第二个<code>location</code>块： </p>
<pre class="notranslate">location /images/ {
    root /data;
}
</pre>

<p>  它将匹配以<code>/images/</code>开头的请求（ <code>location /</code>也匹配此类请求，但前缀较短）。 </p>
<p>  生成的<code>server</code>块配置应如下所示： </p>
<pre class="notranslate">server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
</pre>

<p>  这已经是服务器的工作配置，它可以侦听标准端口80，并且可以在本地计算机上访问<code>http://localhost/</code> 。  响应具有以<code>/images/</code>开头的URI的请求，服务器将从<code>/data/images</code>目录发送文件。  例如，响应<code>http://localhost/images/example.png</code>请求，nginx将发送<code>/data/images/example.png</code>文件。  如果此类文件不存在，nginx将发送指示404错误的响应。   URI不以<code>/images/</code>开头的请求将映射到<code>/data/www</code>目录。  例如，响应<code>http://localhost/some/example.html</code>请求，nginx将发送<code>/data/www/some/example.html</code>文件。 </p>
<p>  要应用新配置，请启动nginx（如果尚未启动）或通过执行以下命令将<code>reload</code>信号发送到nginx的主进程： </p>
<pre class="notranslate">nginx -s reload
</pre>





<blockquote>
<p>  如果某些内容无法按预期工作，您可以尝试在目录<code>/usr/local/nginx/logs</code>或<code>/var/log/nginx</code>中的<code>access.log</code>和<code>error.log</code>文件中找出原因。 </p>
</blockquote>
<h4 id="设置简单的代理服务器"><a href="#设置简单的代理服务器" class="headerlink" title="设置简单的代理服务器"></a>设置简单的代理服务器</h4><p>   nginx的一个常见用途是将其设置为代理服务器，这意味着服务器接收请求，将它们传递给代理服务器，从中检索响应，然后将它们发送给客户端。 </p>
<p>  我们将配置一个基本代理服务器，它使用来自本地目录的文件处理图像请求，并将所有其他请求发送到代理服务器。  在此示例中，将在单个nginx实例上定义两个服务器。 </p>
<p>  首先，通过向nginx的配置文件添加一个以上的<code>server</code>块来定义代理服务器，其中包含以下内容： </p>
<pre class="notranslate">server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
</pre>

<p>  这将是一个侦听端口8080的简单服务器（之前，自使用标准端口80以来尚未指定<code>listen</code>指令）并将所有请求映射到本地文件系统上的<code>/data/up1</code>目录。  创建此目录并将<code>index.html</code>文件放入其中。  请注意， <code>root</code>指令放在<code>server</code>上下文中。  当选择用于提供请求的<code>location</code>块不包括自己的<code>root</code>指令时，使用这样的<code>root</code>指令。 </p>
<p>  接下来，使用上一节中的服务器配置并对其进行修改以使其成为代理服务器配置。  在第一个<code>location</code>块中，将<a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>指令与参数中指定的代理服务器的协议，名称和端口放在一起（在我们的示例中，它是<code>http://localhost:8080</code> ）： </p>
<pre class="notranslate">server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
</pre>



<p>  我们将修改第二个<code>location</code>块，该块当前将带有<code>/images/</code>前缀的请求映射到<code>/data/images</code>目录下的文件，以使其与具有典型文件扩展名的图像请求相匹配。  修改后的<code>location</code>块如下所示： </p>
<pre class="notranslate">location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
</pre>

<p>  该参数是一个正则表达式，匹配以<code>.gif</code> ， <code>.jpg</code>或<code>.png</code>结尾的所有URI。  正则表达式应该以<code>~</code> 。  相应的请求将映射到<code>/data/images</code>目录。 </p>
<p>  当nginx选择一个<code>location</code>块来提供请求时，它首先检查指定前缀的<a href="http/ngx_http_core_module.html#location">位置</a>指令，记住具有最长前缀的<code>location</code> ，然后检查正则表达式。  如果与正则表达式匹配，则nginx选择此<code>location</code> ，否则，它会选择之前记住的那个。 </p>
<p>  生成的代理服务器配置如下所示： </p>
<pre class="notranslate">server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre>

<p>  此服务器将过滤以<code>.gif</code> ， <code>.jpg</code>或<code>.png</code>结尾的请求，并将它们映射到<code>/data/images</code>目录（通过将URI添加到<code>root</code>指令的参数），并将所有其他请求传递给上面配置的代理服务器。 </p>
<p>  要应用新配置，请将<code>reload</code>信号发送到nginx，如前面部分所述。 </p>
<p>  可以使用<a href="http/ngx_http_proxy_module.html">更多</a>指令来进一步配置代理连接。 </p>
<h4 id="设置FastCGI代理"><a href="#设置FastCGI代理" class="headerlink" title="设置FastCGI代理"></a>设置FastCGI代理</h4><p>   nginx可用于将请求路由到FastCGI服务器，这些服务器运行使用各种框架和编程语言（如PHP）构建的应用程序。 </p>
<p>  使用FastCGI服务器的最基本的nginx配置包括使用<a href="http/ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>指令而不是<code>proxy_pass</code>指令，以及<a href="http/ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a>指令来设置传递给FastCGI服务器的参数。  假设可以在<code>localhost:9000</code>上访问FastCGI服务器。  以上一节中的代理配置为基础，将<code>proxy_pass</code>指令替换为<code>fastcgi_pass</code>指令，并将参数更改为<code>localhost:9000</code> 。  在PHP中， <code>SCRIPT_FILENAME</code>参数用于确定脚本名称， <code>QUERY_STRING</code>参数用于传递请求参数。  结果配置为： </p>
<pre class="notranslate">server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre>

<p>  这将设置一个服务器，该服务器将除静态图像请求之外的所有请求路由到通过FastCGI协议在<code>localhost:9000</code>上运行的代理服务器。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm学习]]></title>
      <url>/java/JVM%E5%AD%A6%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<p>JVM Java Virtual Machine (java虚拟机)</p>
<a id="more"></a>
<h1 id="JDK8-以后-Hotspot-JRockit-优秀特性"><a href="#JDK8-以后-Hotspot-JRockit-优秀特性" class="headerlink" title="JDK8 以后 Hotspot+JRockit 优秀特性"></a>JDK8 以后 Hotspot+JRockit 优秀特性</h1>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[guava教程]]></title>
      <url>/java/guava%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>guava教程</p>
<blockquote>
<p>guava谷歌出品,高效工具类<br>目标：节约时间，资源，提高生产力  Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<br>集合 [collections]<br>缓存 [caching]<br>原生类型支持 [primitives support]<br>并发库 [concurrency libraries]<br>通用注解 [common annotations]<br>字符串处理 [string processing]<br>I/O 等等<br><a id="more"></a></p>
</blockquote>
<h1 id="集合的创建-可变，不可变"><a href="#集合的创建-可变，不可变" class="headerlink" title="集合的创建, 可变，不可变"></a>集合的创建, 可变，不可变</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 普通Collection的创建</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">// 不变Collection的创建</span><br><span class="line">ImmutableList&lt;String&gt; iList = ImmutableList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(&quot;e1&quot;, &quot;e2&quot;);</span><br><span class="line">ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;);</span><br><span class="line"></span><br><span class="line">immutable(不可变)对象</span><br><span class="line">1.在多线程操作下，是线程安全的。</span><br><span class="line">2.所有不可变集合会比可变集合更有效的利用资源。</span><br><span class="line">3.中途不可改变</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList(&quot;Richard&quot;, &quot;Amy&quot;, &quot;Lily&quot;, &quot;Sarah&quot;);</span><br><span class="line">List&lt;Integer&gt; numbers = Lists.newArrayList(11, 78, 89, 45, 30);</span><br><span class="line">//创建加初始化</span><br></pre></td></tr></table></figure>
<h2 id="特殊的数据类型"><a href="#特殊的数据类型" class="headerlink" title="特殊的数据类型"></a>特殊的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单</span><br><span class="line">创建方式:  Multiset&lt;String&gt; set = HashMultiset.create();</span><br><span class="line">Multimap: key-value  key可以重复  </span><br><span class="line">创建方式: Multimap&lt;String, String&gt; teachers = ArrayListMultimap.create();</span><br><span class="line">BiMap: 双向Map(Bidirectional Map) 键与值都不能重复</span><br><span class="line">创建方式:  BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">Table: 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  //和sql中的联合主键有点像</span><br><span class="line">创建方式: Table&lt;String, String, Integer&gt; tables = HashBasedTable.create();</span><br></pre></td></tr></table></figure>
<h1 id="集合转字符串"><a href="#集合转字符串" class="headerlink" title="集合转字符串"></a>集合转字符串</h1><h2 id="list-转字符串"><a href="#list-转字符串" class="headerlink" title="list 转字符串"></a>list 转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for(int i=0; i&lt;list.size(); i++)&#123;</span><br><span class="line">	str = str + &quot;-&quot; +list.get(i);</span><br><span class="line">&#125;</span><br><span class="line">//str 为-aa-bb-cc</span><br><span class="line">//use guava</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String result = Joiner.on(&quot;-&quot;).join(list);</span><br><span class="line">//result为  aa-bb-cc</span><br></pre></td></tr></table></figure>
<h2 id="map转字符串"><a href="#map转字符串" class="headerlink" title="map转字符串"></a>map转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(&quot;xiaoming&quot;, 12);</span><br><span class="line">map.put(&quot;xiaohong&quot;,13);</span><br><span class="line">String result = Joiner.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).join(map);</span><br><span class="line">// result为 xiaoming=12,xiaohong=13</span><br></pre></td></tr></table></figure>
<h1 id="字符串转集合"><a href="#字符串转集合" class="headerlink" title="字符串转集合"></a>字符串转集合</h1><h2 id="字符串转list"><a href="#字符串转list" class="headerlink" title="字符串转list"></a>字符串转list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">String a = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">String[] strs = a.split(&quot;-&quot;);</span><br><span class="line">for(int i=0; i&lt;strs.length; i++)&#123;</span><br><span class="line">	list.add(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//use guava</span><br><span class="line">String str = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">List&lt;String&gt; list = Splitter.on(&quot;-&quot;).splitToList(str);</span><br><span class="line">//list为  [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h2 id="字符串转map"><a href="#字符串转map" class="headerlink" title="字符串转map"></a>字符串转map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;xiaoming=11,xiaohong=23&quot;;</span><br><span class="line">Map&lt;String,String&gt; map = Splitter.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).split(str);</span><br></pre></td></tr></table></figure>
<h1 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;aa.dd,,ff,,.&quot;;</span><br><span class="line">List&lt;String&gt; result = Splitter.onPattern(&quot;[.|,]&quot;).omitEmptyStrings().splitToList(input);</span><br></pre></td></tr></table></figure>
<h1 id="差集合集并集"><a href="#差集合集并集" class="headerlink" title="差集合集并集"></a>差集合集并集</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashSet setA = newHashSet(1, 2, 3, 4, 5);  </span><br><span class="line">HashSet setB = newHashSet(4, 5, 6, 7, 8);  </span><br><span class="line">   </span><br><span class="line">SetView union = Sets.union(setA, setB);  </span><br><span class="line">System.out.println(&quot;union:&quot;);  </span><br><span class="line">for (Integer integer : union)  </span><br><span class="line">    System.out.println(integer);           //union:12345867</span><br><span class="line">   </span><br><span class="line">SetView difference = Sets.difference(setA, setB);  </span><br><span class="line">System.out.println(&quot;difference:&quot;);  </span><br><span class="line">for (Integer integer : difference)  </span><br><span class="line">    System.out.println(integer);        //difference:123</span><br><span class="line">   </span><br><span class="line">SetView intersection = Sets.intersection(setA, setB);  </span><br><span class="line">System.out.println(&quot;intersection:&quot;);  </span><br><span class="line">for (Integer integer : intersection)  </span><br><span class="line">    System.out.println(integer);  //intersection:45</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapDifference differenceMap = Maps.difference(mapA, mapB);  </span><br><span class="line">differenceMap.areEqual();  </span><br><span class="line">Map entriesDiffering = differenceMap.entriesDiffering();  </span><br><span class="line">Map entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();  </span><br><span class="line">Map entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();  </span><br><span class="line">Map entriesInCommon = differenceMap.entriesInCommon();</span><br></pre></td></tr></table></figure>
<h1 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">       CharSource charSource = Resources.asByteSource(url).asCharSource(StandardCharsets.UTF_8);</span><br><span class="line">       charSource.readLines().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> guava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot常用的注解]]></title>
      <url>/spring-boot/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot 常用的注解<br><a id="more"></a></p>
<blockquote>
<p>@PropertySource(value = “classpath:test.properties”) 加载配置文件<br>@ConfigurationProperties(prefix=”spring”) 提取前缀<br>@ConditionOnProperty 根据配置文件加载class</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot @Import @ImportResource 注解]]></title>
      <url>/spring-boot/springboot%20@Import%20@ImportResource%20%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot @Import @ImportResource 注解<br><a id="more"></a></p>
<h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><blockquote>
<p>@Import注解在4.2之前只支持导入配置类；在4.2以及之后，@Import注解支持导入普通java类，并将其声明成一个bean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DemoService &#123;  </span><br><span class="line">    public void doSomething()&#123;  </span><br><span class="line">        System.out.println(&quot;everything is all fine&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@Configuration  </span><br><span class="line">@Import(DemoService.class)  </span><br><span class="line">public class DemoConfig &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AnnotationConfigApplicationContext context =  </span><br><span class="line">                new AnnotationConfigApplicationContext(&quot;com.example&quot;);  </span><br><span class="line">        DemoService ds = context.getBean(DemoService.class);  </span><br><span class="line">        ds.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h1><h2 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Controller</span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;url&#125;&quot;)</span><br><span class="line">	private String url;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	public String hello() &#123;</span><br><span class="line">		System.err.println(url);</span><br><span class="line">		return &quot;hello&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cons-java"><a href="#cons-java" class="headerlink" title="cons.java"></a>cons.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(&quot;classpath:test.xml&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class cons &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="test-xml"><a href="#test-xml" class="headerlink" title="test.xml"></a>test.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:/test.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="test-properties"><a href="#test-properties" class="headerlink" title="test.properties"></a>test.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">password=root</span><br><span class="line">url=127.0.0.1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单服务器开发]]></title>
      <url>/c/%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<p> 简单服务器开发</p>
 <a id="more"></a>
<h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	 struct  sockaddr_in  server,client;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 int cfd;</span><br><span class="line">	 int sfd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">     server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 int ret=bind(sfd,(struct sockaddr *)&amp;server,sizeof(server));</span><br><span class="line">	 if(ret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;bind error\n&quot;);</span><br><span class="line">	 	return -1; </span><br><span class="line">	 &#125;</span><br><span class="line">	 int lret=listen(sfd,10);</span><br><span class="line">	 if(lret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;listen error\n&quot;);</span><br><span class="line">	 	return -1;</span><br><span class="line">	 &#125;</span><br><span class="line">	 int len=sizeof(client);</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	cfd=accept(sfd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">	 	char str[]=&quot;hello world\n&quot;;</span><br><span class="line">	 	write(cfd,str,sizeof(str));</span><br><span class="line">	 	while(1)&#123;</span><br><span class="line">	 		read(cfd,buf,1000);</span><br><span class="line">		    printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	 		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	 	</span><br><span class="line">	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	 close(cfd);</span><br><span class="line">	 close(sfd);</span><br><span class="line">	 printf(&quot;over\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main()&#123;</span><br><span class="line">	 struct sockaddr_in server;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 char buff[1000];</span><br><span class="line">	 int fd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">	 server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 connect(fd,(struct sockaddr*)&amp;server,sizeof(server));</span><br><span class="line">	 read(fd,buf,1000);</span><br><span class="line">	 printf(&quot;%s\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	 </span><br><span class="line">	     scanf(&quot;%s&quot;,buff);</span><br><span class="line">        </span><br><span class="line">	     write(fd,buff,sizeof(buff));</span><br><span class="line">	     </span><br><span class="line">	   	</span><br><span class="line">	 &#125; </span><br><span class="line">	</span><br><span class="line">	 close(fd);	  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_image_filter_module应用]]></title>
      <url>/nginx/ngx_http_image_filter_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p> ngx_http_image_filter_module 缩略图应用</p>
 <a id="more"></a>
<h1 id="安装yum-install-y-gd-devel"><a href="#安装yum-install-y-gd-devel" class="headerlink" title="安装yum install -y gd-devel"></a>安装yum install -y gd-devel</h1><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-hhtp_image_filter_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	image_filter off;</span><br><span class="line">image_filter test;</span><br><span class="line">image_filter size;</span><br><span class="line">image_filter rotate 90 | 180 | 270;</span><br><span class="line">image_filter resize width height;</span><br><span class="line">image_filter crop width height;</span><br><span class="line">Default:	</span><br><span class="line">image_filter off;</span><br><span class="line">Context:	location</span><br></pre></td></tr></table></figure>
<h1 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~* /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ &#123;            </span><br><span class="line">    set $h $2;</span><br><span class="line">    set $w $3;</span><br><span class="line">    if ($h = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($w = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    #根据给定的长宽生成缩略图</span><br><span class="line">    image_filter resize $h $w;</span><br><span class="line">    #原图最大2M，要裁剪的图片超过2M返回415错误，需要调节参数image_filter_buffer </span><br><span class="line">    image_filter_buffer 2M;                          </span><br><span class="line">     </span><br><span class="line">    #error_page  415              /img/notfound.jpg;</span><br><span class="line">    try_files /img/$1.$4  /img/notfound.jpg;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问缩略图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003_90x90.jpg</span><br><span class="line"></span><br><span class="line">访问原图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003.jpg</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_addition_module应用]]></title>
      <url>/nginx/ngx_http_addition_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>ngx_http_addition_module在响应之前或者之后追加文本内容，比如js,html</p>
<a id="more"></a>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">cd nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_addition_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><blockquote>
<p>Syntax:    add_before_body uri;<br>Default:    —<br>Context:    http, server, location</p>
<p>Syntax:    add_after_body uri;<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<h1 id="nginx-conf-配置"><a href="#nginx-conf-配置" class="headerlink" title="nginx.conf 配置"></a>nginx.conf 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_before_body /head.html;</span><br><span class="line">    add_after_body  /foot.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim head.html</span><br><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim foot.html</span><br><span class="line"></span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用后</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot统一异常处理]]></title>
      <url>/java/springboot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
      <content type="html"><![CDATA[<p>springboot 统一异常处理</p>
<a id="more"></a>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">@EnableAutoConfiguration  //1</span><br><span class="line">@ComponentScan         //2 </span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	String home() &#123;</span><br><span class="line">		System.err.println(1 / 0);</span><br><span class="line">		return &quot;Hello World!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p> 标注 1,2 可以换成@SpringBootApplication<br> @SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScan</p>
</blockquote>
</blockquote>
<h1 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ex &#123;</span><br><span class="line">	@ExceptionHandler(RuntimeException.class)</span><br><span class="line">	@ResponseBody // 拦截返回是 json返回结果</span><br><span class="line">	public Map&lt;String, Object&gt; exceptionHandler() &#123;</span><br><span class="line">		Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		result.put(&quot;code&quot;, &quot;500&quot;);</span><br><span class="line">		result.put(&quot;msg&quot;, &quot;亲,系统错误,请稍后重试....&quot;);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"><a href="#ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常" class="headerlink" title="@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"></a>@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.cmc.schedule.handler;</span><br><span class="line"></span><br><span class="line">import com.gionee.base.entity.JsonResult;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.ConversionNotSupportedException;</span><br><span class="line">import org.springframework.beans.TypeMismatchException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotWritableException;</span><br><span class="line">import org.springframework.web.HttpMediaTypeNotAcceptableException;</span><br><span class="line">import org.springframework.web.HttpRequestMethodNotSupportedException;</span><br><span class="line">import org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常拦截处理器</span><br><span class="line"> *</span><br><span class="line"> * @author chenmc</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice</span><br><span class="line">@ResponseBody</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String logExceptionFormat = &quot;Capture Exception By GlobalExceptionHandler: Code: %s Detail: %s&quot;;</span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    //运行时异常  </span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    public String runtimeExceptionHandler(RuntimeException ex) &#123;</span><br><span class="line">        return resultFormat(1, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空指针异常  </span><br><span class="line">    @ExceptionHandler(NullPointerException.class)</span><br><span class="line">    public String nullPointerExceptionHandler(NullPointerException ex) &#123;</span><br><span class="line">        return resultFormat(2, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换异常  </span><br><span class="line">    @ExceptionHandler(ClassCastException.class)</span><br><span class="line">    public String classCastExceptionHandler(ClassCastException ex) &#123;</span><br><span class="line">        return resultFormat(3, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //IO异常  </span><br><span class="line">    @ExceptionHandler(IOException.class)</span><br><span class="line">    public String iOExceptionHandler(IOException ex) &#123;</span><br><span class="line">        return resultFormat(4, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //未知方法异常  </span><br><span class="line">    @ExceptionHandler(NoSuchMethodException.class)</span><br><span class="line">    public String noSuchMethodExceptionHandler(NoSuchMethodException ex) &#123;</span><br><span class="line">        return resultFormat(5, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组越界异常  </span><br><span class="line">    @ExceptionHandler(IndexOutOfBoundsException.class)</span><br><span class="line">    public String indexOutOfBoundsExceptionHandler(IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        return resultFormat(6, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMessageNotReadableException.class&#125;)</span><br><span class="line">    public String requestNotReadable(HttpMessageNotReadableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..requestNotReadable&quot;);</span><br><span class="line">        return resultFormat(7, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;TypeMismatchException.class&#125;)</span><br><span class="line">    public String requestTypeMismatch(TypeMismatchException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..TypeMismatchException&quot;);</span><br><span class="line">        return resultFormat(8, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;MissingServletRequestParameterException.class&#125;)</span><br><span class="line">    public String requestMissingServletRequest(MissingServletRequestParameterException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..MissingServletRequest&quot;);</span><br><span class="line">        return resultFormat(9, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //405错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpRequestMethodNotSupportedException.class&#125;)</span><br><span class="line">    public String request405(HttpRequestMethodNotSupportedException ex) &#123;</span><br><span class="line">        return resultFormat(10, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //406错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMediaTypeNotAcceptableException.class&#125;)</span><br><span class="line">    public String request406(HttpMediaTypeNotAcceptableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;406...&quot;);</span><br><span class="line">        return resultFormat(11, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //500错误  </span><br><span class="line">    @ExceptionHandler(&#123;ConversionNotSupportedException.class, HttpMessageNotWritableException.class&#125;)</span><br><span class="line">    public String server500(RuntimeException ex) &#123;</span><br><span class="line">        System.out.println(&quot;500...&quot;);</span><br><span class="line">        return resultFormat(12, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈溢出</span><br><span class="line">    @ExceptionHandler(&#123;StackOverflowError.class&#125;)</span><br><span class="line">    public String requestStackOverflow(StackOverflowError ex) &#123;</span><br><span class="line">        return resultFormat(13, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //其他错误</span><br><span class="line">    @ExceptionHandler(&#123;Exception.class&#125;)</span><br><span class="line">    public String exception(Exception ex) &#123;</span><br><span class="line">        return resultFormat(14, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T extends Throwable&gt; String resultFormat(Integer code, T ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        log.error(String.format(logExceptionFormat, code, ex.getMessage()));</span><br><span class="line">        return JsonResult.failed(code, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java动态代理实现连接池]]></title>
      <url>/java/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</url>
      <content type="html"><![CDATA[<p> java动态代理实现连接池</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">import sun.font.CreatedFontTracker;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author michael</span><br><span class="line"> * Description: </span><br><span class="line"> *代理：如果对某个接口中的某个指定的方法的功能进行扩展，而不想实现接口里所有方法，可以使用（动态代理）代理模式</span><br><span class="line"> *java中代理模式:静态/动态/cglib（Spring）</span><br><span class="line"> *使用动态代理，可以检测接口中方法的执行</span><br><span class="line"> *</span><br><span class="line"> *Proxy</span><br><span class="line"> *static Object newProxyInstance(</span><br><span class="line"> *ClassLoader loader,  定义代理类的类加载器</span><br><span class="line"> *Class&lt;?&gt;[] interfaces,   代理类要实现的接口列表</span><br><span class="line"> *InvocationHandler h)  指派方法调用的调用处理程序 </span><br><span class="line"> * 2017年5月1日</span><br><span class="line"> */</span><br><span class="line">public class Pool &#123;</span><br><span class="line">	private int init_count = 3;</span><br><span class="line">	private int max_count = 6;</span><br><span class="line">	private int current_count = 0;</span><br><span class="line">	private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	//1.构造函数，初始化连接放入连接池</span><br><span class="line">	public Pool()&#123;</span><br><span class="line">		for (int i = 0; i &lt; init_count; i++) &#123;</span><br><span class="line">			current_count++;</span><br><span class="line">			Connection conn = createConnection();</span><br><span class="line">			pool.add(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//2.创建一个新的连接方法</span><br><span class="line">	private Connection createConnection()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">			final Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">			//对con创建代理对象</span><br><span class="line">			Connection proxy = (Connection)Proxy.newProxyInstance(</span><br><span class="line">					con.getClass().getClassLoader(), </span><br><span class="line">					/*con.getClass().getInterfaces(),*/  //当目标对象是一个具体的类时</span><br><span class="line">					new Class[]&#123;Connection.class&#125;,   //目标对象实现的接口</span><br><span class="line">					new InvocationHandler() &#123;</span><br><span class="line">						</span><br><span class="line">						@Override</span><br><span class="line">						public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">								throws Throwable &#123;</span><br><span class="line">							//方法返回值</span><br><span class="line">							Object result = null;</span><br><span class="line">							//当前执行的方法名</span><br><span class="line">							String methodName = method.getName();</span><br><span class="line">							//判断是否执行了close方法的时候，把连接放到连接池</span><br><span class="line">							if(&quot;close&quot;.equals(methodName))&#123;</span><br><span class="line">								System.out.println(&quot;begin:当前执行了close方法&quot;);</span><br><span class="line">								//连接放入连接池</span><br><span class="line">								pool.addLast(con);</span><br><span class="line">								System.out.println(&quot;end:当前连接已经放入连接池&quot;);</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">							//调用目标对象方法</span><br><span class="line">							method.invoke(con, args);</span><br><span class="line">							&#125;</span><br><span class="line">							return result;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					);</span><br><span class="line">			return proxy;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			throw new RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//3.获取连接</span><br><span class="line">	public  Connection getConnection()&#123;</span><br><span class="line">		//3.1判断连接池中是否有链接，如果有连接，则直接用</span><br><span class="line">		if(pool.size()&gt;0)&#123;</span><br><span class="line">			return pool.removeFirst();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//3.2连接池中没有连接，判断，如果没有达到最大连接数，创建</span><br><span class="line">		if(current_count&lt;max_count)&#123;</span><br><span class="line">			//记录当前使用的连接数</span><br><span class="line">			current_count++;</span><br><span class="line">			return createConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		//3.3如果当前已经达到最大连接数，抛出异常</span><br><span class="line">		throw new RuntimeException(&quot;当前已经达到最大连接数！&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//4.释放连接</span><br><span class="line">	public void realeaseConnection(Connection con)&#123;</span><br><span class="line">		//4.1 判断：池的数目如果小于初始化练级，就放入池中</span><br><span class="line">		if(pool.size()&lt;init_count)&#123;</span><br><span class="line">			pool.addLast(con);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			//关闭</span><br><span class="line">			try &#123;</span><br><span class="line">				current_count-- ;</span><br><span class="line">				con.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">		Pool pool = new Pool();</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">		</span><br><span class="line">		//使用连接</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">	</span><br><span class="line">		Connection con1 = pool.getConnection();</span><br><span class="line">		con1.close();//如果没用动态代理，连接就关闭了</span><br><span class="line">		//希望：当关闭连接的时候，要把连接放入连接池。（当调用Connetion接口的close方法时候，希望触发pool.addLast(con)操作）</span><br><span class="line">		//解决1:实现Connection接口，重写close方法（方法太多，不太现实）</span><br><span class="line">		//解决2：</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		System.out.println(&quot;连接池&quot;+pool.pool.size());</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM中GC Minor-GC Major-GC Full-GC区别]]></title>
      <url>/java/JVM%E4%B8%ADGC%20Minor-GC%20Major-GC%20Full-GC%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p>JVM中GC Minor-GC Major-GC Full-GC区别</p>
<a id="more"></a>
<p>#JVM 内存分布</p>
<p>JVM堆包含 ，Eden,Survivor,Old 区</p>
<h1 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor-GC"></a>Minor-GC</h1><p>在Young space(Eden,survivor 区) 中的垃圾回收称为Minor-GC</p>
<blockquote>
<blockquote>
<p>不能为新对象分配空间的时候，Eden区满了，分配空间越快，Minor-GC越频繁<br>当内存池慢了后, 它的完整的内容会被复制出去，指针可以从0开始重新跟踪空闲内存。所以取代传统的标记-交换-压缩（Mark, Sweep , Compact）, Eden区和Survivor区使用标记-复制方式（Mark , Copy）. 因此在Eden区和Survivor区无内存碎片。写指针总是指向内存池的顶部。</p>
<p>在Minor GC时, 年老代（Tenured generation）可以被忽略. 年老代对年轻代的引用被认为是实际的GC根root。 在标记阶段年轻代对年老代的引用可以被简单的忽略。<br>出于常理, 所有的Minor GC都会触发stop-the-world暂停, 它意味着会暂停应用的所有线程. 对于大部分应用而言，暂停的延迟可以忽略不计。这是因为Eden中大部分的对象都可以垃圾回收掉，而不会被复制到Survivor/Old区。但如果相反，大部分的新对象不能被回收， Minor GC暂停会占用更多的时间。</p>
</blockquote>
</blockquote>
<h1 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major-GC"></a>Major-GC</h1><h2 id="Major-GC-清理年老区（old-space）"><a href="#Major-GC-清理年老区（old-space）" class="headerlink" title="Major GC 清理年老区（old space）"></a>Major GC 清理年老区（old space）</h2><h1 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full-GC"></a>Full-GC</h1><h2 id="清理年轻代，老年代"><a href="#清理年轻代，老年代" class="headerlink" title="清理年轻代，老年代"></a>清理年轻代，老年代</h2>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA自带的加密算法-MD5\SHA1\BASE64]]></title>
      <url>/java/BASE64.html</url>
      <content type="html"><![CDATA[<p>JAVA自带的加密算法-MD5\SHA1\BASE64<br>引入 commons-codec.jar<br><a id="more"></a></p>
<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.md5Hex(str);</span><br></pre></td></tr></table></figure>
<h1 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.shaHex(str);</span><br></pre></td></tr></table></figure>
<h1 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h1><blockquote>
<blockquote>
<p>加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str= &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">byte[] b = Base64.encodeBase64(str.getBytes(), true);</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
<p>解密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String  str = &quot;123&quot;;</span><br><span class="line">byte[] b = Base64.decodeBase64(str.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中常见的坑]]></title>
      <url>/java/java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91.html</url>
      <content type="html"><![CDATA[<p>Java中常见的坑</p>
<h1 id="System-out-println-Object-toString"><a href="#System-out-println-Object-toString" class="headerlink" title="System.out.println( Object.toString )"></a>System.out.println( Object.toString )</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123; “Hello”, “World” &#125;;</span><br><span class="line">System.out.println(words);</span><br><span class="line"></span><br><span class="line">output: [Ljava.lang.String;@45ee12b7</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>改造</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(words));</span><br><span class="line"></span><br><span class="line">output: [Hello, World]</span><br></pre></td></tr></table></figure>
<h1 id="list-toArray-T-array"><a href="#list-toArray-T-array" class="headerlink" title="list.toArray(T[] array)"></a>list.toArray(T[] array)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);</span><br><span class="line">  list.add(&quot;222&quot;); </span><br><span class="line">  list.add(&quot;111&quot;); </span><br><span class="line">  String[] array = new String[list.size()];  #list.size()</span><br><span class="line">  array = list.toArray(array);</span><br></pre></td></tr></table></figure>
<h1 id="不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"><a href="#不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。" class="headerlink" title="不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"></a>不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator(); </span><br><span class="line">  while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">#加锁</span><br><span class="line"></span><br><span class="line">Map m = Collections.synchronizedMap(new HashMap());</span><br><span class="line">synchronized(m) &#123;</span><br><span class="line">     while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> 创建线程安全集合</span><br><span class="line"> Collection c=Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"> List list=Collections.synchronizedList(new ArrayList());</span><br><span class="line"> Set s=Collections.synchronizedSet(new HashSet());</span><br><span class="line"> Map m=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Three.js展示全景图]]></title>
      <url>/%E5%9F%BA%E4%BA%8EThree.js%E5%B1%95%E7%A4%BA%E5%85%A8%E6%99%AF%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<p>基于Three.js展示全景图</p>
<a id="more"></a>
<h1 id="初始化插件-创建PhotoSphereViewer对象"><a href="#初始化插件-创建PhotoSphereViewer对象" class="headerlink" title="初始化插件,创建PhotoSphereViewer对象"></a>初始化插件,创建PhotoSphereViewer对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var PSV = new PhotoSphereViewer(&#123;</span><br><span class="line">        // 全景图的完整路径</span><br><span class="line">        panorama: img, </span><br><span class="line">        // 放全景图的元素</span><br><span class="line">        container: div,</span><br><span class="line">        // 可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。（设置为false禁用它）</span><br><span class="line">        time_anim: false,</span><br><span class="line">		tilt_up_max: 0,</span><br><span class="line">		tilt_down_max: 0,</span><br><span class="line"></span><br><span class="line">        // 可选值，默认为false。显示导航条。</span><br><span class="line">        navbar: true,</span><br><span class="line"></span><br><span class="line">        // 可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">        size: &#123;</span><br><span class="line">            width: &apos;100%&apos;,</span><br><span class="line">            height: canvasHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="配置参数备注"><a href="#配置参数备注" class="headerlink" title="配置参数备注"></a>配置参数备注</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">panorama：必填参数，全景图的路径。</span><br><span class="line">container：必填参数，放置全景图的div元素。</span><br><span class="line">autoload：可选，默认值为true，true为自动调用全景图，false为在后面加载全景图(通过.load()方法)。</span><br><span class="line">us empdata：可选，默认值为true，如果Photo Sphere Viewer必须读入XMP数据则为true。</span><br><span class="line">default_position：可选，默认值为&#123;&#125;，定义默认的位置，及用户看见的第一个点，例如：&#123;long: Math.PI, lat: Math.PI/2&#125;。</span><br><span class="line">min_fov：可选，默认值为30，观察的最小区域，单位degrees，在1-179之间。</span><br><span class="line">max_fov：可选，默认值为90，观察的最大区域，单位degrees，在1-179之间。</span><br><span class="line">allow_user_interactions：可选，默认值为true，设置为false则禁止用户和全景图交互(导航条不可用)。</span><br><span class="line">tilt_up_max：可选，默认值为Math.PI/2，向上倾斜的最大角度，单位radians。</span><br><span class="line">tilt_down_max：可选，默认值为Math.PI/2，向下倾斜的最大角度，单位radians。</span><br><span class="line">zoom_level：可选，默认值为0，默认的缩放级别，值在0-100之间。</span><br><span class="line">long_offset：可选，默认值为PI/360，mouse/touch移动时每像素经过的经度值。</span><br><span class="line">lat_offset：可选，默认值为PI/180，mouse/touch移动时每像素经过的纬度值。</span><br><span class="line">time_anim：可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。(设置为false禁用它)</span><br><span class="line">theta_offset：过时的选项，可选，默认值为1440，自动动画时水平方向的速度。</span><br><span class="line">anim_speed：可选，默认值为2rpm，动画的速度，每秒/分钟多少radians/degrees/revolutions。</span><br><span class="line">navbar：可选值，默认为false。显示导航条。</span><br><span class="line">navbar_style：可选值，默认为&#123;&#125;。导航条的自定义样式。下面是可用的样式列表：</span><br><span class="line">backgroundColor：导航条的背景颜色，默认值为rgba(61, 61, 61, 0.5)。</span><br><span class="line">buttonsColor：按钮的前景颜色，默认值为transparent。</span><br><span class="line">activeButtonsBackgroundColor：按钮激活状态的背景颜色，默认值为rgba(255, 255, 255, 0.1)。</span><br><span class="line">buttonsHeight：按钮的高度，单位像素，默认值为20。</span><br><span class="line">autorotateThickness：autorotate图标的厚度，单位像素，默认值为1。</span><br><span class="line">zoomRangeWidth：缩放的范围，单位显示，默认值50。</span><br><span class="line">zoomRangeThickness：缩放的范围的厚度，单位像素，默认值1。</span><br><span class="line">zoomRangeDisk：缩放范围的圆盘直径，单位像素，默认值为7。</span><br><span class="line">fullscreenRatio：全屏图标的比例，默认值为3/4。</span><br><span class="line">fullscreenThickness：全屏图标的厚度，单位像素，默认值为2。</span><br><span class="line">loading_msg：可选，默认值为Loading…，图片加载时的提示文字。</span><br><span class="line">loading_img：可选，默认值为null，在加载时显示的图片的路径。</span><br><span class="line">size：可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">onready：可选值，默认值为null。当全景图准备就绪并且第一张图片显示时的回调函数。</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Three.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Three.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat启动流程]]></title>
      <url>/tomcat/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>tomcat 启动启动过程分析<br><a id="more"></a></p>
<h1 id="org-apache-catalina-startup-Bootstrap-main"><a href="#org-apache-catalina-startup-Bootstrap-main" class="headerlink" title="org.apache.catalina.startup.Bootstrap.main"></a>org.apache.catalina.startup.Bootstrap.main</h1><blockquote>
<blockquote>
<p>org.apache.catalina.startup.Bootstrap.main 启动的入口方法</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">           if (command.equals(&quot;startd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;start&quot;;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stopd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;stop&quot;;</span><br><span class="line">               daemon.stop();</span><br><span class="line">           &#125; else if (command.equals(&quot;start&quot;)) &#123;</span><br><span class="line">               daemon.setAwait(true);</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stop&quot;)) &#123;</span><br><span class="line">               daemon.stopServer(args);</span><br><span class="line">           &#125; else if (command.equals(&quot;configtest&quot;)) &#123;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               if (null==daemon.getServer()) &#123;</span><br><span class="line">                   System.exit(1);</span><br><span class="line">               &#125;</span><br><span class="line">               System.exit(0);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-gt-initClassLoaders"><a href="#main-gt-initClassLoaders" class="headerlink" title="main()-&gt;initClassLoaders()"></a>main()-&gt;initClassLoaders()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commonLoader = createClassLoader(&quot;common&quot;, null);</span><br><span class="line">#导入源码目录的 D:\apache-tomcat-xxxx-src\lib 的jar</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); </span><br><span class="line">#导入 org.apache.catalina.startup.Catalina</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  daemon.setAwait(true);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  daemon 可以看成 org.apache.catalina.startup.Catalina类</span><br></pre></td></tr></table></figure>
<h1 id="org-apache-catalina-startup-Catalina"><a href="#org-apache-catalina-startup-Catalina" class="headerlink" title="org.apache.catalina.startup.Catalina"></a>org.apache.catalina.startup.Catalina</h1><blockquote>
<blockquote>
<p>start()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">		if (getServer() == null) &#123;</span><br><span class="line">			load(); //重点处理server.xml</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	.......</span><br><span class="line">		try &#123;</span><br><span class="line">			getServer().start();</span><br><span class="line">		&#125; catch (LifecycleException e) &#123;</span><br><span class="line">			log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;), e);</span><br><span class="line">			try &#123;</span><br><span class="line">				getServer().destroy();</span><br><span class="line">			&#125; catch (LifecycleException e1) &#123;</span><br><span class="line">				log.debug(&quot;destroy() failed for failed Server &quot;, e1);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>load()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void load() &#123;</span><br><span class="line">.....</span><br><span class="line">Digester digester = createStartDigester(); </span><br><span class="line">.....</span><br><span class="line">getServer().setCatalina(this);</span><br><span class="line">getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line">#设置 catalina.home、catalina.base</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>createStartDigester() 加载解析server.xml</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br><span class="line"></span><br><span class="line">		// When the &apos;engine&apos; is found, set the parentClassLoader.</span><br><span class="line">		digester.addRule(&quot;Server/Service/Engine&quot;, new SetParentClassLoaderRule(parentClassLoader));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Cluster/&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>Catalina.java 创建 server service engine 添加监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Server的启动过程"><a href="#Server的启动过程" class="headerlink" title="Server的启动过程"></a>Server的启动过程</h1><blockquote>
<blockquote>
<p>Server 的默认实现是 org.apache.catalina.core.StandardServer，StandardServer 继承自 LifecycleMBeanBase，LifecycleMBeanBase又继承自 LifecycleBase。 init 和 start 方法就定义在 LifecycleBase 中，LifecycleBase 里的init和start方法又调用initInternal和startInternal方法，这两个方法都是模板方法有子类实现。所以 StandardServer 执行  initInternal 和 startInternal 方法。<br>同时 init 和 start 方法分别循环调用了每个Service的 init 和 start 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardServer</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line">		System.err.println(&quot;startInternal\n&quot;);</span><br><span class="line">		fireLifecycleEvent(CONFIGURE_START_EVENT, null);</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Services</span><br><span class="line">		synchronized (servicesLock) &#123;</span><br><span class="line">			for (int i = 0; i &lt; services.length; i++) &#123;</span><br><span class="line">				services[i].start(); //启动service</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Service-的启动过程"><a href="#Service-的启动过程" class="headerlink" title="Service 的启动过程"></a>Service 的启动过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardService</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">		if (log.isInfoEnabled())</span><br><span class="line">			log.info(sm.getString(&quot;standardService.start.name&quot;, this.name));</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		// Start our defined Container first</span><br><span class="line">		if (engine != null) &#123;</span><br><span class="line">			synchronized (engine) &#123;</span><br><span class="line">				engine.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		synchronized (executors) &#123;</span><br><span class="line">			for (Executor executor : executors) &#123;</span><br><span class="line">				executor.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mapperListener.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Connectors second</span><br><span class="line">		synchronized (connectorsLock) &#123;</span><br><span class="line">			for (Connector connector : connectors) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					// If it has already failed, don&apos;t try and start it</span><br><span class="line">					if (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">						connector.start();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					log.error(sm.getString(&quot;standardService.connector.startFailed&quot;, connector), e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Engine-的启动"><a href="#Engine-的启动" class="headerlink" title="Engine 的启动"></a>Engine 的启动</h1><blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardEngine<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       // Log our server identification information</span><br><span class="line">       if(log.isInfoEnabled())</span><br><span class="line">           log.info( &quot;Starting Servlet Engine: &quot; + ServerInfo.getServerInfo());</span><br><span class="line"></span><br><span class="line">       // Standard container startup</span><br><span class="line">       super.startInternal(); #调用父类方法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> org.apache.catalina.core.ContainerBase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        // Start our subordinate components, if any</span><br><span class="line">        logger = null;</span><br><span class="line">        getLogger();</span><br><span class="line">        Cluster cluster = getClusterInternal();</span><br><span class="line">        if (cluster instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) cluster).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Realm realm = getRealmInternal();</span><br><span class="line">        if (realm instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) realm).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start our child containers, if any</span><br><span class="line">        Container children[] = findChildren();</span><br><span class="line">        List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">            results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean fail = false;</span><br><span class="line">        for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;containerBase.threadedStartFailed&quot;), e);</span><br><span class="line">                fail = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (fail) &#123;</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;containerBase.threadedStartFailed&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start the Valves in our pipeline (including the basic), if any</span><br><span class="line">        if (pipeline instanceof Lifecycle)</span><br><span class="line">            ((Lifecycle) pipeline).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">        // Start our thread</span><br><span class="line">        threadStart(); #转Context 启动</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Context-启动"><a href="#Context-启动" class="headerlink" title="Context 启动"></a>Context 启动</h1><blockquote>
<blockquote>
<p>threadStart(); </p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  protected void threadStart() &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        thread = new Thread(new ContainerBackgroundProcessor(), threadName);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line">        thread.start(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected class ContainerBackgroundProcessor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">                processChildren(ContainerBase.this);</span><br><span class="line">        ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.ContainerBackgroundProcessor.processChildren(Container)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void processChildren(Container container) &#123;</span><br><span class="line">         ...</span><br><span class="line">               container.backgroundProcess();</span><br><span class="line">        ...   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardContext.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">	super.backgroundProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	# 此时 listener 为org.apache.catalina.startup.HostConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.lifecycleEvent(LifecycleEvent)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">check();</span><br><span class="line"></span><br><span class="line">deployApps(); # 部署webapps 下的应用</span><br><span class="line"></span><br><span class="line">protected void deployApps() &#123;</span><br><span class="line"></span><br><span class="line">        File appBase = host.getAppBaseFile();</span><br><span class="line">        File configBase = host.getConfigBaseFile();</span><br><span class="line">        String[] filteredAppPaths = filterAppPaths(appBase.list());</span><br><span class="line">        // Deploy XML descriptors from configBase</span><br><span class="line">        deployDescriptors(configBase, configBase.list());</span><br><span class="line">        // Deploy WARs</span><br><span class="line">        deployWARs(appBase, filteredAppPaths);</span><br><span class="line">        // Deploy expanded folders</span><br><span class="line">        deployDirectories(appBase, filteredAppPaths);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.createDigester(String)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected static Digester createDigester(String contextClassName) &#123;</span><br><span class="line">#contextClassName= org.apache.catalina.core.StandardContext</span><br><span class="line">       Digester digester = new Digester();</span><br><span class="line">       digester.setValidating(false);</span><br><span class="line">       // Add object creation rule</span><br><span class="line">       digester.addObjectCreate(&quot;Context&quot;, contextClassName, &quot;className&quot;);</span><br><span class="line">       // Set the properties on that object (it doesn&apos;t matter if extra</span><br><span class="line">       // properties are set)</span><br><span class="line">       digester.addSetProperties(&quot;Context&quot;);</span><br><span class="line">       return (digester);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.ContextConfig监听StandardContext的事件</p>
<blockquote>
<p>调用 org.apache.catalina.core.StandardContext.startInternal()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123; </span><br><span class="line">       ......</span><br><span class="line">       fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); // 解析web.xml的</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"> # 启动web.xml的 listener 例如 ：contextloaderlistener</span><br><span class="line">       if (ok) &#123;</span><br><span class="line">				if (!listenerStart()) &#123;</span><br><span class="line">log.error(sm.getString(&quot;standardContext.listenerFail&quot;));</span><br><span class="line">					ok = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<p> org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	#此时的listener 为 org.apache.catalina.startup.ContextConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>解析  web.xml org.apache.catalina.startup.ContextConfig.configureStart()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void configureStart() &#123;</span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">		webConfig();  #  真正解析 web.xml</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> tomcat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot自义定错误返回页面和json格式]]></title>
      <url>/spring-boot%E8%87%AA%E4%B9%89%E5%AE%9A%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E5%92%8Cjson%E6%A0%BC%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<p>springboot发生错误时，在浏览器端访问和用测试接口的软件看到的返回页面是不一样的。</p>
<blockquote>
<p>浏览器端  返回 Whitelabel Error Page页面<br>测试接口的软件返回一个json 字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;timestamp&quot;: 1492063521109,</span><br><span class="line">&quot;status&quot;: 404,</span><br><span class="line">&quot;error&quot;: &quot;Not Found&quot;,</span><br><span class="line">&quot;message&quot;: &quot;No message available&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/test/auth&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h1 id="spring根据请求的-produces返回不同值"><a href="#spring根据请求的-produces返回不同值" class="headerlink" title="spring根据请求的 produces返回不同值"></a>spring根据请求的 produces返回不同值</h1><blockquote>
<p>BasicErrorController.java源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(produces = &quot;text/html&quot;) #浏览器访问</span><br><span class="line">public ModelAndView errorHtml(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping  #接口测试软件  application/json 默认没写</span><br><span class="line">@ResponseBody</span><br><span class="line">public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>@RequestMapping(value = “/produces”, produces = “application/json”)：表示将功能处理方法将生产json格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/json”时即可匹配;<br>@RequestMapping(value = “/produces”, produces = “application/xml”)：表示将功能处理方法将生产xml格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/xml”时即可匹配。</p>
</blockquote>
<h1 id="自定义浏览器端错误的返回页面"><a href="#自定义浏览器端错误的返回页面" class="headerlink" title="自定义浏览器端错误的返回页面"></a>自定义浏览器端错误的返回页面</h1><h2 id="重写BasicErrorController"><a href="#重写BasicErrorController" class="headerlink" title="重写BasicErrorController"></a>重写BasicErrorController</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		response.setStatus(getStatus(request).value());</span><br><span class="line">		Map&lt;String, Object&gt; model = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML));</span><br><span class="line">		return new ModelAndView(&quot;error/404.html&quot;, model);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-src-main-resources-public-error-404-html-页面"><a href="#创建-src-main-resources-public-error-404-html-页面" class="headerlink" title="创建 src/main/resources/public/error/404.html 页面"></a>创建 src/main/resources/public/error/404.html 页面</h2><h1 id="自定义测试软件返回json"><a href="#自定义测试软件返回json" class="headerlink" title="自定义测试软件返回json"></a>自定义测试软件返回json</h1><blockquote>
<p>重写BasicErrorController</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		map.put(&quot;msg&quot;, body.get(&quot;message&quot;));</span><br><span class="line">		map.put(&quot;code&quot;, body.get(&quot;status&quot;));</span><br><span class="line">		map.put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot过滤器验证token]]></title>
      <url>/spring-boot/spring-token.html</url>
      <content type="html"><![CDATA[<p>springboot过滤器验证token<br><a id="more"></a></p>
<h1 id="token-java"><a href="#token-java" class="headerlink" title="token.java"></a>token.java</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TokenInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService adminService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">        String user = request.getHeader(&quot;userId&quot;);</span><br><span class="line">        if (token == null || user == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer userId = Integer.valueOf(user);</span><br><span class="line">        //获取Service实例</span><br><span class="line">        if (userService == null) &#123;</span><br><span class="line">            BeanFactory factory = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());</span><br><span class="line">            userService = (UserService) factory.getBean(&quot;userService&quot;);</span><br><span class="line">            adminService = (AdminService) factory.getBean(&quot;adminService&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //增加日活量</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            adminService.addAccessCount(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        String checkToken = userService.selectToken(userId);</span><br><span class="line">        //检查头部请求</span><br><span class="line">        if (!checkToken.equals(token)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> token </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> token </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot-Access-Control-Allow-Origin]]></title>
      <url>/spring-boot/spring-boot-Access-Control-Allow-Origin.html</url>
      <content type="html"><![CDATA[<p>springboot 跨域研究</p>
<a id="more"></a>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><blockquote>
<p>在前后端开发的模式中，前端通常使用ajax调用后端服务器的接口，常见错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:8080’ is therefore not allowed access.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="springboot-解决跨域的方案"><a href="#springboot-解决跨域的方案" class="headerlink" title="springboot 解决跨域的方案"></a>springboot 解决跨域的方案</h1><h2 id="通过UrlBasedCorsConfigurationSource解决"><a href="#通过UrlBasedCorsConfigurationSource解决" class="headerlink" title="通过UrlBasedCorsConfigurationSource解决"></a>通过UrlBasedCorsConfigurationSource解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    private CorsConfiguration buildConfig() &#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1 设置访问源地址</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2 设置访问源请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3 设置访问源请求方法</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4 对接口配置跨域设置</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过拦截器解决"><a href="#通过拦截器解决" class="headerlink" title="通过拦截器解决"></a>通过拦截器解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CORSConfiguration &#123;</span><br><span class="line">	@Bean</span><br><span class="line">	public WebMvcConfigurer corsConfigurer() &#123;</span><br><span class="line">		return new WebMvcConfigurerAdapter() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">				registry.addMapping(&quot;/**&quot;).allowedHeaders(&quot;*&quot;).allowedMethods(&quot;*&quot;).allowedOrigins(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过注解解决"><a href="#通过注解解决" class="headerlink" title="通过注解解决"></a>通过注解解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &quot;http://a.com&quot;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-mybatis-druid整合]]></title>
      <url>/spring-boot-mybatis-druid%E6%95%B4%E5%90%88.html</url>
      <content type="html"><![CDATA[<p>springboot mybatis  druid简单整合</p>
<a id="more"></a>
<h1 id="在eclipse-中创建maven-工程-修改pom-xml-文件"><a href="#在eclipse-中创建maven-工程-修改pom-xml-文件" class="headerlink" title="在eclipse 中创建maven 工程, 修改pom.xml 文件"></a>在eclipse 中创建maven 工程, 修改pom.xml 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  </span><br><span class="line">   &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; </span><br><span class="line"> &lt;/parent&gt;  </span><br><span class="line"> &lt;dependencies&gt; </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.1.5&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.3.0&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">     &lt;scope&gt;runtime&lt;/scope&gt; </span><br><span class="line">   &lt;/dependency&gt; </span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h1 id="在-src-main-resources下创建application-properties"><a href="#在-src-main-resources下创建application-properties" class="headerlink" title="在 src/main/resources下创建application.properties"></a>在 src/main/resources下创建application.properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">server.session.timeout=10</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/service_data?characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#mybatis</span><br><span class="line">mybatis.type-aliases-package=com.we.pojo</span><br><span class="line">mybatis.mapper-locations=classpath*:com/we/mapperxml/*.xml</span><br></pre></td></tr></table></figure>
<h1 id="编写Application-java-类"><a href="#编写Application-java-类" class="headerlink" title="编写Application.java 类"></a>编写Application.java 类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication()</span><br><span class="line">@ComponentScan(&quot;com.we&quot;) #很重要不配  404 </span><br><span class="line">@MapperScan(value = &quot;com.we.mapper&quot;) #很重要</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编写业务逻辑-启动spring-boot"><a href="#编写业务逻辑-启动spring-boot" class="headerlink" title="编写业务逻辑,启动spring boot"></a>编写业务逻辑,启动spring boot</h1><h1 id="druid-sql-监控功能"><a href="#druid-sql-监控功能" class="headerlink" title="druid sql 监控功能"></a>druid sql 监控功能</h1><blockquote>
<p>项目启动后访问 <a href="http://localhost:8088/druid/" target="_blank" rel="noopener">http://localhost:8088/druid/</a> 可以看见登录界面<br>修改默认访问账号密码<br>新建一个java文件  例如：druidConfig.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class druidConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ServletRegistrationBean druidServlet() &#123;</span><br><span class="line">		ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean();</span><br><span class="line">		servletRegistrationBean.setServlet(new StatViewServlet());</span><br><span class="line">		servletRegistrationBean.addUrlMappings(&quot;/druid/*&quot;);</span><br><span class="line">		Map&lt;String, String&gt; initParameters = new HashMap&lt;String, String&gt;();</span><br><span class="line">		initParameters.put(&quot;loginUsername&quot;, &quot;admin&quot;); // ++监控页面登录用户名</span><br><span class="line">		initParameters.put(&quot;loginPassword&quot;, &quot;admin&quot;); // ++监控页面登录用户密码</span><br><span class="line">		servletRegistrationBean.setInitParameters(initParameters);</span><br><span class="line">		return servletRegistrationBean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这样就可以直接用 admin  admin 进入监控系统</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
            <tag> druid </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-feign伪rpc集成]]></title>
      <url>/spring-boot-feign%E4%BC%AArpc%E9%9B%86%E6%88%90.html</url>
      <content type="html"><![CDATA[<p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。可以认为是一种伪RPC。<br><a id="more"></a></p>
<h1 id="和springboot整合"><a href="#和springboot整合" class="headerlink" title="和springboot整合"></a>和springboot整合</h1><blockquote>
<p>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.3.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="配置application-properties-文件"><a href="#配置application-properties-文件" class="headerlink" title="配置application.properties 文件"></a>配置application.properties 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign.name=feignName</span><br><span class="line">feign.url=http://localhost:88</span><br><span class="line">feign.client.config.default.loggerLevel = full</span><br><span class="line">feign.connectTimeoutMillis=1000   #连接超时,单位毫秒</span><br><span class="line">feign.readTimeoutMillis=15000     #读超时,单位毫秒</span><br></pre></td></tr></table></figure>
<h1 id="编写feign的-interface"><a href="#编写feign的-interface" class="headerlink" title="编写feign的 interface"></a>编写feign的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(url = &quot;$&#123;feign.url&#125;&quot;, name = &quot;feign.name&quot;)</span><br><span class="line">public interface testfeign &#123;</span><br><span class="line">	@RequestMapping(value = &quot;/version&quot;, method = RequestMethod.GET)</span><br><span class="line">	public String version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在controller-注入上面的-interface"><a href="#在controller-注入上面的-interface" class="headerlink" title="在controller 注入上面的 interface"></a>在controller 注入上面的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private testfeign stestfeign;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;testfeign&quot;)</span><br><span class="line">	private String pub() &#123;</span><br><span class="line">		return stestfeign.version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置项目启动文件"><a href="#配置项目启动文件" class="headerlink" title="配置项目启动文件"></a>配置项目启动文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">@EnableFeignClients(basePackages = &quot;im.nginx.test&quot;)</span><br><span class="line">#im.nginx.test 为feign interface 文件所在的包</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> feign </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> feign </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/nginx%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p>title: nginx常用基本变量及数据结构<br>tags: [nginx]<br>categories: nginx</p>
<a id="more"></a>
<h1 id="nginx-常用基本变量"><a href="#nginx-常用基本变量" class="headerlink" title="nginx 常用基本变量"></a>nginx 常用基本变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int  ngx_fd_t;</span><br><span class="line">typedef intptr_t        ngx_int_t;</span><br><span class="line">typedef uintptr_t       ngx_uint_t;</span><br><span class="line">typedef intptr_t        ngx_flag_t;</span><br><span class="line">typedef void *          ngx_buf_tag_t;</span><br></pre></td></tr></table></figure>
<h1 id="nginx常用数据结构"><a href="#nginx常用数据结构" class="headerlink" title="nginx常用数据结构"></a>nginx常用数据结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct &#123;</span><br><span class="line">     size_t      len;</span><br><span class="line">     u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br><span class="line"></span><br><span class="line">typedef struct stat  ngx_file_info_t;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_conf_get_module_loc_conf 分析]]></title>
      <url>/ngx_http_conf_get_module_loc_conf.html</url>
      <content type="html"><![CDATA[<p>自定义参数处理函数中会用到ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);<br>获取配置块</p>
<a id="more"></a>
<h1 id="ngx-http-conf-get-module-loc-conf"><a href="#ngx-http-conf-get-module-loc-conf" class="headerlink" title="ngx_http_conf_get_module_loc_conf"></a>ngx_http_conf_get_module_loc_conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_http_conf_get_module_loc_conf(cf, module)                         \</span><br><span class="line">    ((ngx_http_conf_ctx_t *) cf-&gt;ctx)-&gt;loc_conf[module.ctx_index]</span><br></pre></td></tr></table></figure>
<h1 id="引出loc-conf初始化函数-ngx-http-block"><a href="#引出loc-conf初始化函数-ngx-http-block" class="headerlink" title="引出loc_conf初始化函数 ngx_http_block"></a>引出loc_conf初始化函数 ngx_http_block</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> *ngx_http_commands 命令集的回调函数 </span><br><span class="line"> *HTTP模块初始化的入口函数 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">static char *  </span><br><span class="line">ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)  </span><br><span class="line">&#123;  </span><br><span class="line">    char                        *rv;  </span><br><span class="line">    ngx_uint_t                   mi, m, s;  </span><br><span class="line">    ngx_conf_t                   pcf;  </span><br><span class="line">    ngx_http_module_t           *module;  </span><br><span class="line">    ngx_http_conf_ctx_t         *ctx;  </span><br><span class="line">    ngx_http_core_loc_conf_t    *clcf;  </span><br><span class="line">    ngx_http_core_srv_conf_t   **cscfp;  </span><br><span class="line">    ngx_http_core_main_conf_t   *cmcf;  </span><br><span class="line">  </span><br><span class="line">    if (*(ngx_http_conf_ctx_t **) conf) &#123;  </span><br><span class="line">        return &quot;is duplicate&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* the main http context */  </span><br><span class="line">  </span><br><span class="line">    /* 分配一块内存，存放http配置上下文 */  </span><br><span class="line">    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t));  </span><br><span class="line">    if (ctx == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    *(ngx_http_conf_ctx_t **) conf = ctx;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* count the number of the http modules and set up their indices */  </span><br><span class="line">  </span><br><span class="line">    /* 计算http模块个数 */  </span><br><span class="line">    ngx_http_max_module = ngx_count_modules(cf-&gt;cycle, NGX_HTTP_MODULE);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* the http main_conf context, it is the same in the all http contexts */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 最外层的HTTP配置 </span><br><span class="line">     * http </span><br><span class="line">      &#123; </span><br><span class="line">      include       mime.types; </span><br><span class="line">      default_type  application/octet-stream; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool,  </span><br><span class="line">                                 sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;main_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null srv_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">    /** </span><br><span class="line">     * server层的配置 </span><br><span class="line">     *   server </span><br><span class="line">  &#123; </span><br><span class="line">    listen       80; </span><br><span class="line">    #server_name  blog.s135.com; </span><br><span class="line">    index index.html index.htm index.php; </span><br><span class="line">    root   /home/wwwroot/; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;srv_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null loc_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * location 层的配置 </span><br><span class="line">    location ~ .*\.(php|php5)?$ </span><br><span class="line">    &#123; </span><br><span class="line">      #fastcgi_pass  unix:/tmp/php-cgi.sock; </span><br><span class="line">      fastcgi_pass  127.0.0.1:9000; </span><br><span class="line">      fastcgi_index index.php; </span><br><span class="line">      include fcgi.conf; </span><br><span class="line">    &#125; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;loc_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * create the main_conf&apos;s, the null srv_conf&apos;s, and the null loc_conf&apos;s </span><br><span class="line">     * of the all http modules </span><br><span class="line">     */  </span><br><span class="line">     /** </span><br><span class="line">      * 调用：create_main_conf、create_srv_conf、create_loc_conf </span><br><span class="line">      * 创建配置 </span><br><span class="line">      */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_main_conf) &#123;  </span><br><span class="line">            ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf);  </span><br><span class="line">            if (ctx-&gt;main_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_srv_conf) &#123;  </span><br><span class="line">            ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf);  </span><br><span class="line">            if (ctx-&gt;srv_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_loc_conf) &#123;  </span><br><span class="line">            ctx-&gt;loc_conf[mi] = module-&gt;create_loc_conf(cf);  </span><br><span class="line">            if (ctx-&gt;loc_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    pcf = *cf;  </span><br><span class="line">    cf-&gt;ctx = ctx;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * preconfiguration 预先初始化配置信息 </span><br><span class="line">     */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;preconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;preconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* parse inside the http&#123;&#125; block */  </span><br><span class="line">  </span><br><span class="line">    cf-&gt;module_type = NGX_HTTP_MODULE;  </span><br><span class="line">    cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF;  </span><br><span class="line">    rv = ngx_conf_parse(cf, NULL);  </span><br><span class="line">  </span><br><span class="line">    if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">        goto failed;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * init http&#123;&#125; main_conf&apos;s, merge the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     * and its location&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 初始化main配置 </span><br><span class="line">     * 合并 server srv_conf </span><br><span class="line">     * 合并location loc_conf </span><br><span class="line">     */  </span><br><span class="line">    cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">    cscfp = cmcf-&gt;servers.elts;  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        /* init http&#123;&#125; main_conf&apos;s */  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;init_main_conf) &#123;  </span><br><span class="line">            rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]);  </span><br><span class="line">            if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">                goto failed;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        rv = ngx_http_merge_servers(cf, cmcf, module, mi);  </span><br><span class="line">        if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">            goto failed;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* create location trees */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 创建 location模块的trees </span><br><span class="line">     */  </span><br><span class="line">    for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) &#123;  </span><br><span class="line">  </span><br><span class="line">        clcf = cscfp[s]-&gt;ctx-&gt;loc_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;postconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;postconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_variables_init_vars(cf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * http&#123;&#125;&apos;s cf-&gt;ctx was needed while the configuration merging </span><br><span class="line">     * and in postconfiguration process </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* optimize the lists of ports, addresses and server names */  </span><br><span class="line">  </span><br><span class="line">    /* ngx_http_optimize_servers 初始化listen 端口号 ip地址 服务器等监听信息*/  </span><br><span class="line">    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return NGX_CONF_OK;  </span><br><span class="line">  </span><br><span class="line">failed:  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">    return rv;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ngx-http-conf-ctx-t"><a href="#ngx-http-conf-ctx-t" class="headerlink" title="ngx_http_conf_ctx_t"></a>ngx_http_conf_ctx_t</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">     void        **main_conf;</span><br><span class="line">     void        **srv_conf;</span><br><span class="line">     void        **loc_conf;</span><br><span class="line"> &#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-location正则表达式匹配规则及动静分离]]></title>
      <url>/nginx-location%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<p>nginx，location常用正则表达式，及nginx动静分离<br><a id="more"></a></p>
<h1 id="nginx匹配规则"><a href="#nginx匹配规则" class="headerlink" title="nginx匹配规则"></a>nginx匹配规则</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~      波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~     ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">=      进行普通字符精确匹配</span><br><span class="line">@      &quot;@&quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</span><br><span class="line">!~（!~*） 表示区分大小写不正则匹配和不区分大小写不正则匹配</span><br></pre></td></tr></table></figure>
<h1 id="nginx正则表达式"><a href="#nginx正则表达式" class="headerlink" title="nginx正则表达式"></a>nginx正则表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">. ： 匹配除换行符以外的任意字符</span><br><span class="line">? ： 重复0次或1次</span><br><span class="line">+ ： 重复1次或更多次</span><br><span class="line">* ： 重复0次或更多次</span><br><span class="line">\d ：匹配数字</span><br><span class="line">^ ： 匹配字符串的开始</span><br><span class="line">$ ： 匹配字符串的介绍</span><br><span class="line">&#123;n&#125; ： 重复n次</span><br><span class="line">&#123;n,&#125; ： 重复n次或更多次</span><br><span class="line">[c] ： 匹配单个字符c</span><br><span class="line">[a-z] ： 匹配a-z小写字母的任意一个</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 当正则表达式中含有 {} 是,必须将 正则表达式用 “” 引起来否则会报错<br>nginx: [emerg] pcre_compile() failed: missing ) in “/one/(\d” in /usr/local/nginx/conf/nginx.conf:56</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#rewrite ^/test/([\d]&#123;3&#125;)/$ /index.php?id=$1 break;  #报错</span><br><span class="line">#修改为</span><br><span class="line">rewrite &quot;^/test/([\d]&#123;3&#125;)/$&quot; /index.php?id=$1 break;</span><br><span class="line"></span><br><span class="line">#本条可以不用引号</span><br><span class="line">rewrite ^/(\d+)/$ /index.php?id=$1 break;</span><br></pre></td></tr></table></figure></p>
<h1 id="动静分离清单"><a href="#动静分离清单" class="headerlink" title="动静分离清单"></a>动静分离清单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /web/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /web/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> location </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-if指令与全局变量]]></title>
      <url>/nginx-if%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</url>
      <content type="html"><![CDATA[<p>if判断指令<br>语法为if(condition){…}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：</p>
<blockquote>
<p>当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false<br>直接比较变量和内容时，使用=或!=<br>~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配</p>
</blockquote>
<a id="more"></a>
<h1 id="if-常用判断"><a href="#if-常用判断" class="headerlink" title="if 常用判断"></a>if 常用判断</h1><p>-f和!-f用来判断是否存在文件<br>-d和!-d用来判断是否存在目录<br>-e和!-e用来判断是否存在文件或目录<br>-x和!-x用来判断文件是否可执行</p>
<h2 id="if应用"><a href="#if应用" class="headerlink" title="if应用"></a>if应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; //限速，$slow可以通过 set 指令设置</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; //防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nginx-常用全局变量"><a href="#nginx-常用全局变量" class="headerlink" title="nginx 常用全局变量"></a>nginx 常用全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$args ： #这个变量等于请求行中的参数，同$query_string</span><br><span class="line">$is_args : 如果请求带有参数, 值为 ? 否则为空字符串</span><br><span class="line">$content_length ： 请求头中的Content-length字段。</span><br><span class="line">$content_type ： 请求头中的Content-Type字段。</span><br><span class="line">$document_root ： 当前请求在root指令中指定的值。</span><br><span class="line">$host ： 请求主机头字段，否则为服务器名称。</span><br><span class="line">$http_user_agent ： 客户端agent信息</span><br><span class="line">$http_cookie ： 客户端cookie信息</span><br><span class="line">$limit_rate ： 这个变量可以限制连接速率。</span><br><span class="line">$request_method ： 客户端请求的动作，通常为GET或POST。</span><br><span class="line">$remote_addr ： 客户端的IP地址。</span><br><span class="line">$remote_port ： 客户端的端口。</span><br><span class="line">$remote_user ： 已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$scheme ： HTTP方法（如http，https）。</span><br><span class="line">$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</span><br><span class="line">$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</span><br><span class="line">$server_name ： 服务器名称。</span><br><span class="line">$server_port ： 请求到达服务器的端口号。</span><br><span class="line">$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</span><br><span class="line">$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</span><br><span class="line">$document_uri ： 与$uri相同。</span><br><span class="line">$nginx_version： 当前nginx版本</span><br><span class="line">$request: 原始请求 GET /one/2222 HTTP/1.1</span><br><span class="line">$status:  响应状态码</span><br><span class="line">$http_referer: url跳转来源</span><br><span class="line">$request_body : 客户端请求主体</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> if </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-args-query-string-uri详解]]></title>
      <url>/nginx-args-query-string-uri%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>Nginx 中常见和url操作相关的变量</p>
<blockquote>
<p>$args<br>$query_string<br>$request_uri<br>$uri<br>$document_uri</p>
</blockquote>
<p>以上变量有什么联系和区别呢?</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url:  http://nginx.im/nginx/im/?page=1</span><br><span class="line">$args -&gt;    page=1</span><br><span class="line">$query_string -&gt; page=1</span><br><span class="line">$request_uri  -&gt; /nginx/im/?page=1</span><br><span class="line">$uri       -&gt;  /nginx/im</span><br><span class="line">$document_uri -&gt; /nginx/im</span><br><span class="line">**总结**</span><br><span class="line">$args &lt;=&gt; $query_string 获取？后面的参数</span><br><span class="line">$request_uri  获取除了host 之外所有的</span><br><span class="line">$uri &lt;=&gt; $cocuemnt_uri 获取请求路径</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> uri </tag>
            
            <tag> query_string </tag>
            
            <tag> request_uri </tag>
            
            <tag> document_uri </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON字符串转换为Map]]></title>
      <url>/json/fastjson.html</url>
      <content type="html"><![CDATA[<p>JSON字符串转换为Map<br><a id="more"></a></p>
<h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zkn.newlearn.json;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class JsonToMapTest01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        String str = &quot;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;&quot;;</span><br><span class="line">        //第一种方式</span><br><span class="line">        Map maps = (Map)JSON.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : maps.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;     &quot; + ((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式</span><br><span class="line">        Map mapTypes = JSON.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类的parseObject来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapTypes.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapTypes.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第三种方式</span><br><span class="line">        Map mapType = JSON.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类,指定解析类型，来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapType.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapType.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第四种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map json = (Map) JSONObject.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject类的parse方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第五种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第六种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map mapObj = JSONObject.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map: json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        String strArr = &quot;&#123;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;,&quot; +</span><br><span class="line">                &quot;&#123;\&quot;00\&quot;:\&quot;zhangsan\&quot;,\&quot;11\&quot;:\&quot;lisi\&quot;,\&quot;22\&quot;:\&quot;wangwu\&quot;,\&quot;33\&quot;:\&quot;maliu\&quot;&#125;&#125;&quot;;</span><br><span class="line">       // JSONArray.parse()</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java排列组合随机字符串应用]]></title>
      <url>/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>已知固定长度的字符串字典</p>
<blockquote>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
</blockquote>
<p>按字典序输出固定随机字符串</p>
<a id="more"></a>
<h1 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static String randomChar(String dict, String pre, Integer len) &#123;</span><br><span class="line"></span><br><span class="line">		Integer dictLen = dict.length() - 1;</span><br><span class="line">		char[] preChar = pre.toCharArray();</span><br><span class="line">		char[] chArray = new char[len];</span><br><span class="line">		char achar = preChar[len - 1];</span><br><span class="line">		Integer preCharIndex = dict.indexOf(achar);</span><br><span class="line">		if ((preCharIndex + 1) &gt; dictLen) &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(0);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(preCharIndex + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">			Integer preCharIndex1 = dict.indexOf(preChar[i + 1]); // 25</span><br><span class="line">			Integer preCharIndex2 = dict.indexOf(chArray[i + 1]); // 0</span><br><span class="line">			Integer preCharIndex3 = dict.indexOf(preChar[i]); //</span><br><span class="line">			if (Math.abs(preCharIndex1 - preCharIndex2) &gt; 1) &#123;</span><br><span class="line">				if (preCharIndex3 + 1 &gt; dictLen) &#123;</span><br><span class="line">					chArray[i] = dict.charAt(0);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				chArray[i] = dict.charAt(preCharIndex3 + 1);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				chArray[i] = preChar[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return new String(chArray);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 随机字符串 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-zip压缩单文件]]></title>
      <url>/java-zip%E5%8E%8B%E7%BC%A9%E5%8D%95%E6%96%87%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<p>java开发中经常用到压缩文件,在JDK中自带zip 压缩相关的类</p>
<blockquote>
<p>ZipOutputStream<br>ZipEntry</p>
<blockquote>
<p>在压缩文件中，每一个压缩的内容都可以用一个ZipEntry 表示，所以在进行压缩之前必须通过putNextEntry 设置一个ZipEntry 即可。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h1 id="单文件压缩"><a href="#单文件压缩" class="headerlink" title="单文件压缩"></a>单文件压缩</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># in为原始文件的绝对路径</span><br><span class="line">public static void zip(String in) throws Exception &#123;</span><br><span class="line">		File file = new File(in);</span><br><span class="line">		File zipFile = new File(in + &quot;.zip&quot;);</span><br><span class="line">		InputStream input = new FileInputStream(file);</span><br><span class="line">		ZipOutputStream zipOut = null;</span><br><span class="line">		zipOut = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">		zipOut.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">		zipOut.setComment(&quot;这是一个压缩文件&quot;);</span><br><span class="line">		int temp = 0;</span><br><span class="line">		while ((temp = input.read()) != -1) &#123;</span><br><span class="line">			zipOut.write(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">		zipOut.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> zip </tag>
            
            <tag> ZipInputStream </tag>
            
            <tag> ZipFile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java常用的一些代码片段]]></title>
      <url>/java%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<p>收集整理java开放中常用的一些代码片段（长期更新）</p>
<a id="more"></a>
<blockquote>
<p>字符串翻转</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String str)&#123;  </span><br><span class="line">        return new StringBuilder(str).reverse().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>spring 中读取 src/main/resource 下的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void testClassPathResource() throws IOException &#123;</span><br><span class="line">    Resource res = new      ClassPathResource(&quot;resource/ApplicationContext.xml&quot;);</span><br><span class="line">   InputStream input = res.getInputStream();</span><br><span class="line">   Assert.assertNotNull(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file = ResourceUtils.getFile(&quot;classpath:doc&quot;);</span><br><span class="line">str = FileUtils.readFileToString(file, &quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> java常用代码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson解析json字符串]]></title>
      <url>/fastjson%E8%A7%A3%E6%9E%90json%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      <content type="html"><![CDATA[<p>在微服务开发过程中,常要解析json 字符串, 用fastjson解析json 字符串</p>
<a id="more"></a>
<h1 id="获取单个value值"><a href="#获取单个value值" class="headerlink" title="获取单个value值"></a>获取单个value值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;&#123;\&quot;msg\&quot;:\&quot;111\&quot;,\&quot;code\&quot;:200,\&quot;data\&quot;:&#123;\&quot;total\&quot;:15,\&quot;pages\&quot;:8,\&quot;list\&quot;:[&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;,&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;],\&quot;pageNum\&quot;:1&#125;&#125;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Object test(String str, String key) &#123;</span><br><span class="line">		Map mapTypes = JSON.parseObject(str);</span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		return ((JSONObject) mapTypes).getString(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果json字符串是一个json数组"><a href="#如果json字符串是一个json数组" class="headerlink" title="如果json字符串是一个json数组"></a>如果json字符串是一个json数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;Map&lt;String, Object&gt;&gt; GetJsonList(String str) &#123;</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; retmap = JSON.parseObject(str, new TypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">		return retmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[error-assignment-to-expression-with-array-type-error]]></title>
      <url>/error-assignment-to-expression-with-array-type-error.html</url>
      <content type="html"><![CDATA[<p>在结构体赋值操作中，编译器报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: assignment to expression with array type error</span><br></pre></td></tr></table></figure></p>
<p>如何才能避免这种错误呢？<br><a id="more"></a></p>
<h1 id="代码现场"><a href="#代码现场" class="headerlink" title="代码现场"></a>代码现场</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        char ss[10];</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        struct test t1;</span><br><span class="line">        t1.a=10;</span><br><span class="line">        t1.b=20;</span><br><span class="line">        t1.ss=&quot;1111111&quot;; # 编译器报错</span><br><span class="line">        printf(&quot;%d, %d, %s\n&quot;, t1.a, t1.b, t1.ss);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把一个字符串赋值给一个字符数组？"><a href="#把一个字符串赋值给一个字符数组？" class="headerlink" title="把一个字符串赋值给一个字符数组？"></a>把一个字符串赋值给一个字符数组？</h2><p>如果我们这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        char s[10]=&quot;ssssss&quot;;</span><br><span class="line">        printf(&quot;%s\n&quot;,s);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序能完美运行。为什么在结构体中是不行的？</p>
<blockquote>
<p>C语言只有在定义字符数组的时候才能用“=”来初始化变量，其它情况下是不能直接用“=”来为字符数组赋值的，<br>结构体中数组成员ss表示数组名，是一个指针，具有常量特性，表示数组存储空间的开始地址，而C语言中不能对常量赋值。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote>
<p>声明字符串时直接赋值<br>用scanf函数给字符串输入值<br>用strcpy函数给字符串赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(t1.ss,&quot;1111111&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx启动流程]]></title>
      <url>/Nginx%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>nginx启动流程，从main函数开始,一个重要的结构体ngx_cycle_s</p>
<a id="more"></a>
<h1 id="ngx-cycle-s"><a href="#ngx-cycle-s" class="headerlink" title="ngx_cycle_s"></a>ngx_cycle_s</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0038 struct ngx_cycle_s &#123;</span><br><span class="line">0039     void                  ****conf_ctx;</span><br><span class="line">0040     ngx_pool_t               *pool;</span><br><span class="line">0041 </span><br><span class="line">0042     ngx_log_t                *log;</span><br><span class="line">0043     ngx_log_t                 new_log;</span><br><span class="line">0044 </span><br><span class="line">0045     ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */</span><br><span class="line">0046 </span><br><span class="line">0047     ngx_connection_t        **files;</span><br><span class="line">0048     ngx_connection_t         *free_connections;</span><br><span class="line">0049     ngx_uint_t                free_connection_n;</span><br><span class="line">0050 </span><br><span class="line">0051     ngx_module_t            **modules;</span><br><span class="line">0052     ngx_uint_t                modules_n;</span><br><span class="line">0053     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */</span><br><span class="line">0054 </span><br><span class="line">0055     ngx_queue_t               reusable_connections_queue;</span><br><span class="line">0056     ngx_uint_t                reusable_connections_n;</span><br><span class="line">0057 </span><br><span class="line">0058     ngx_array_t               listening;</span><br><span class="line">0059     ngx_array_t               paths;</span><br><span class="line">0060 </span><br><span class="line">0061     ngx_array_t               config_dump;</span><br><span class="line">0062     ngx_rbtree_t              config_dump_rbtree;</span><br><span class="line">0063     ngx_rbtree_node_t         config_dump_sentinel;</span><br><span class="line">0064 </span><br><span class="line">0065     ngx_list_t                open_files;</span><br><span class="line">0066     ngx_list_t                shared_memory;</span><br><span class="line">0067 </span><br><span class="line">0068     ngx_uint_t                connection_n;</span><br><span class="line">0069     ngx_uint_t                files_n;</span><br><span class="line">0070 </span><br><span class="line">0071     ngx_connection_t         *connections;</span><br><span class="line">0072     ngx_event_t              *read_events;</span><br><span class="line">0073     ngx_event_t              *write_events;</span><br><span class="line">0074 </span><br><span class="line">0075     ngx_cycle_t              *old_cycle;</span><br><span class="line">0076 </span><br><span class="line">0077     ngx_str_t                 conf_file;</span><br><span class="line">0078     ngx_str_t                 conf_param;</span><br><span class="line">0079     ngx_str_t                 conf_prefix;</span><br><span class="line">0080     ngx_str_t                 prefix;</span><br><span class="line">0081     ngx_str_t                 lock_file;</span><br><span class="line">0082     ngx_str_t                 hostname;</span><br><span class="line">0083 &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="填充ngx-cycle-t数据"><a href="#填充ngx-cycle-t数据" class="headerlink" title="填充ngx_cycle_t数据"></a>填充ngx_cycle_t数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">int ngx_cdecl</span><br><span class="line">main(int argc, char *const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_int_t         i;</span><br><span class="line">    ngx_log_t        *log;</span><br><span class="line">    ngx_cycle_t      *cycle, init_cycle;</span><br><span class="line">    ngx_core_conf_t  *ccf;</span><br><span class="line"></span><br><span class="line">    ngx_debug_init();</span><br><span class="line"></span><br><span class="line">    if (ngx_strerror_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 解析命令行参数 */</span><br><span class="line">    if (ngx_get_options(argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 显示版本号与帮助信息 */</span><br><span class="line">    if (ngx_show_version) &#123;</span><br><span class="line">        ngx_write_stderr(&quot;nginx version: &quot; NGINX_VER NGX_LINEFEED);</span><br><span class="line"></span><br><span class="line">        if (ngx_show_help) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">                &quot;Usage: nginx [-?hvVtq] [-s signal] [-c filename] &quot;</span><br><span class="line">                             &quot;[-p prefix] [-g directives]&quot; NGX_LINEFEED</span><br><span class="line">                             NGX_LINEFEED</span><br><span class="line">                &quot;Options:&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -?,-h         : this help&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -v            : show version and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -V            : show version and configure options then exit&quot;</span><br><span class="line">                                   NGX_LINEFEED</span><br><span class="line">                &quot;  -t            : test configuration and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -q            : suppress non-error messages &quot;</span><br><span class="line">                                   &quot;during configuration testing&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -s signal     : send signal to a master process: &quot;</span><br><span class="line">                                   &quot;stop, quit, reopen, reload&quot; NGX_LINEFEED</span><br><span class="line">#ifdef NGX_PREFIX</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: &quot;</span><br><span class="line">                                   NGX_PREFIX &quot;)&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: NONE)&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">                &quot;  -c filename   : set configuration file (default: &quot;</span><br><span class="line">                                   NGX_CONF_PATH &quot;)&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -g directives : set global directives out of configuration &quot;</span><br><span class="line">                                   &quot;file&quot; NGX_LINEFEED NGX_LINEFEED</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_show_configure) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">#ifdef NGX_COMPILER</span><br><span class="line">                &quot;built by &quot; NGX_COMPILER NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#if (NGX_SSL)</span><br><span class="line">#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME</span><br><span class="line">                &quot;TLS SNI support enabled&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;TLS SNI support disabled&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">                &quot;configure arguments:&quot; NGX_CONFIGURE NGX_LINEFEED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!ngx_test_config) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* TODO */ ngx_max_sockets = -1;</span><br><span class="line"></span><br><span class="line">    /* 初始化并更新时间 */</span><br><span class="line">    ngx_time_init();</span><br><span class="line"></span><br><span class="line">#if (NGX_PCRE)</span><br><span class="line">    ngx_regex_init();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ngx_pid = ngx_getpid();</span><br><span class="line"></span><br><span class="line">    /* 初始化日志信息 */</span><br><span class="line">    log = ngx_log_init(ngx_prefix);</span><br><span class="line">    if (log == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* STUB */</span><br><span class="line">#if (NGX_OPENSSL)</span><br><span class="line">    ngx_ssl_init(log);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * init_cycle-&gt;log is required for signal handlers and</span><br><span class="line">     * ngx_process_options()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 全局变量init_cycle清零，并创建改变量的内存池pool */</span><br><span class="line">    ngx_memzero(&amp;init_cycle, sizeof(ngx_cycle_t));</span><br><span class="line">    init_cycle.log = log;</span><br><span class="line">    ngx_cycle = &amp;init_cycle;</span><br><span class="line"></span><br><span class="line">    init_cycle.pool = ngx_create_pool(1024, log);</span><br><span class="line">    if (init_cycle.pool == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 保存命令行参数至全局变量ngx_os_argv、ngx_argc、ngx_argv */</span><br><span class="line">    if (ngx_save_argv(&amp;init_cycle, argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle中的成员：prefix、conf_prefix、conf_file、conf_param 等字段 */</span><br><span class="line">    if (ngx_process_options(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化系统相关变量，如：内存页面大小ngx_pagesize、最大连接数ngx_max_sockets等 */</span><br><span class="line">    if (ngx_os_init(log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 初始化 CRC 表（循环冗余校验表） */</span><br><span class="line">    if (ngx_crc32_table_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 通过环境变量NGINX完成socket的继承，将其保存在全局变量init_cycle的listening数组中 */</span><br><span class="line">    if (ngx_add_inherited_sockets(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化每个模块module的index，并计算ngx_max_module */</span><br><span class="line">    ngx_max_module = 0;</span><br><span class="line">    for (i = 0; ngx_modules[i]; i++) &#123;</span><br><span class="line">        ngx_modules[i]-&gt;index = ngx_max_module++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle ，这里很重要 */</span><br><span class="line">    cycle = ngx_init_cycle(&amp;init_cycle);</span><br><span class="line">    if (cycle == NULL) &#123;</span><br><span class="line">        if (ngx_test_config) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test failed&quot;,</span><br><span class="line">                           init_cycle.conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_test_config) &#123;</span><br><span class="line">        if (!ngx_quiet_mode) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test is successful&quot;,</span><br><span class="line">                           cycle-&gt;conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 信号处理 */</span><br><span class="line">    if (ngx_signal) &#123;</span><br><span class="line">        return ngx_signal_process(cycle, ngx_signal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_os_status(cycle-&gt;log);</span><br><span class="line"></span><br><span class="line">    ngx_cycle = cycle;</span><br><span class="line"></span><br><span class="line">    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line">    if (ccf-&gt;master &amp;&amp; ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        ngx_process = NGX_PROCESS_MASTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if !(NGX_WIN32)</span><br><span class="line"></span><br><span class="line">    /* 初始化信号，注册相关信号 */</span><br><span class="line">    if (ngx_init_signals(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 若无socket继承，则创建守护进程，并设置守护进程标志 */</span><br><span class="line">    if (!ngx_inherited &amp;&amp; ccf-&gt;daemon) &#123;</span><br><span class="line">        if (ngx_daemon(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_inherited) &#123;</span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* 记录进程ID */</span><br><span class="line">    if (ngx_create_pidfile(&amp;ccf-&gt;pid, cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_log_redirect_stderr(cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (log-&gt;file-&gt;fd != ngx_stderr) &#123;</span><br><span class="line">        if (ngx_close_file(log-&gt;file-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,</span><br><span class="line">                          ngx_close_file_n &quot; built-in log failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_use_stderr = 0;</span><br><span class="line"></span><br><span class="line">    /* 进入进程处理 */</span><br><span class="line">    if (ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        /* 单进程工作模式 */</span><br><span class="line">        ngx_single_process_cycle(cycle);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* master-worker 多进程模式工作 */</span><br><span class="line">        ngx_master_process_cycle(cycle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7-rc-local不起作用修复]]></title>
      <url>/centos7-rc-local%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E4%BF%AE%E5%A4%8D.html</url>
      <content type="html"><![CDATA[<p>在centos7版本以下的系统中, 尝尝用rc.local 自动启动一些软件. 但是在centos7 中 默认rc.local 是不起作用的, centos7 中把 SysV 替换成  system 。centos7保留了rc.local ,只需要简单的设置就可以开启.</p>
<a id="more"></a>
<h1 id="设置rc-local-权限"><a href="#设置rc-local-权限" class="headerlink" title="设置rc.local 权限"></a>设置rc.local 权限</h1><p>我们在一下目录可以看见rc.local<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.local</span><br><span class="line">/etc/rc.d/rc.local</span><br><span class="line">#/etc/rc.local 是 /etc/rc.d/rc.local的软连接</span><br></pre></td></tr></table></figure></p>
<p>chmod +x /etc/rc.d/rc.local </p>
<h1 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable  rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="启动rc-local-service"><a href="#启动rc-local-service" class="headerlink" title="启动rc-local.service"></a>启动rc-local.service</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start   rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="在-etc-rc-local-编写启动软件指令"><a href="#在-etc-rc-local-编写启动软件指令" class="headerlink" title="在/etc/rc.local 编写启动软件指令"></a>在/etc/rc.local 编写启动软件指令</h1>]]></content>
      
        <categories>
            
            <category> centos7 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos7 </tag>
            
            <tag> rc.local </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The real difference between $host and $http_host]]></title>
      <url>/The-real-difference-between-$host-and-$http_host.html</url>
      <content type="html"><![CDATA[<p>Nginx中$host与$http_host的区别<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The wiki page of &quot;$host&quot; says $host and $host_addr are different only when there is no &quot;Host&quot; header or the &quot;Host&quot; header is empty. But I found when &quot;Host&quot; contains port number, $host never contains the port number while $http_host is equal to the value of &quot;Host&quot; header. </span><br><span class="line"></span><br><span class="line">That is, if &quot;Host: foo:8080&quot;, then </span><br><span class="line">$http_host = foo:8080 </span><br><span class="line">$host = foo </span><br><span class="line"></span><br><span class="line">$http_host是request里的host header </span><br><span class="line">$host是server&#123;&#125;里的server_name里的第一个</span><br><span class="line"></span><br><span class="line">&quot;192.168.160.1&quot; http_host:&quot;192.168.160.159:808&quot; host:&quot;192.168.160.159&quot; &quot;[08/Apr/2016:15:37:06 +0800]&quot; &quot;GET / HTTP/1.1&quot; &quot;304&quot; &quot;0&quot; &quot;171&quot; &quot;-&quot; &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;0.000&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> host </tag>
            
            <tag> http_host </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Faile- to-star- component-Unable-to-register-MBean]]></title>
      <url>/Failed%20to%20start%20component.html</url>
      <content type="html"><![CDATA[<p>部署springboot war包到 tomcat出现以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[]]</span><br><span class="line">Caused by: org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><blockquote>
<p>需要为每个项目配置JMX的域，  修改application.properties中的属性spring.jmx.default-domain=applicationname</p>
</blockquote>
<h1 id="spring-jmx-default-domain"><a href="#spring-jmx-default-domain" class="headerlink" title="spring.jmx.default-domain"></a>spring.jmx.default-domain</h1><blockquote>
<p>解决tomcat同时部署两个SpringBoot应用提示InstanceAlreadyExistsException</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言结构体研究]]></title>
      <url>/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%A0%94%E7%A9%B6.html</url>
      <content type="html"><![CDATA[<p>总结一些C语言结构体中常用的知识点</p>
<a id="more"></a>
<h1 id="C-语言结构体之点运算符-和箭头运算符-gt-的区别"><a href="#C-语言结构体之点运算符-和箭头运算符-gt-的区别" class="headerlink" title="C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别"></a>C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别</h1><blockquote>
<p>相同点：两者都是二元操作符，而且右边的操作数都是成员的名称。<br>不通点：点运算符( . )的左边操作数是一个结果为结构的表达式；</p>
<blockquote>
<p>箭头运算符( -&gt; )的左边的操作数是一个指向结构体的指针。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct          // 定义一个结构体类型：TEST</span><br><span class="line">&#123;</span><br><span class="line">    int age;            // 结构体成员：age</span><br><span class="line">&#125;TEST;</span><br><span class="line">TEST data;              // 声明一个结构体变量</span><br><span class="line">TEST *pdata;            // 声明一个指向结构体的指针</span><br><span class="line">// 访问数据操作如下：</span><br><span class="line">data.age = 24;          // 结构体变量通过点运算符( . )访问</span><br><span class="line">pdata-&gt;age = 24;        // 指向结构体的指针通过箭头运算符( -&gt; )访问</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
