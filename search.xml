<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[CDN调度器HAProxy、Nginx、Varnish-nginx案例]]></title>
      <url>/nginx/web/the-cdn-scheduler-nginx-haproxy-varnish.html</url>
      <content type="html"><![CDATA[<p>web,the-cdn-scheduler-nginx-haproxy-varnish,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>CDN功能如下：<br>
1、将全网IP分为若干个IP段组，分组的依据通常是运营商或者地域，目的是让相同网络环境中的用户聚集到相同的组内；<br>
2、依据CDN服务器们的网络和容量，确定哪些CDN服务器适合服务哪些IP段组；<br>
3、根据以上两步得到的结论，让用户去最适合他的服务器得到服务。</p>
<p>说白了，就是根据用户不同的来源IP把用户请求重定向到不同的CDN服务器上去。<br>
那么，如何实现呢？</p>
<p>智能DNS是办法之一，稳定可靠且有效。<br>
但至少在两个环境下它不能完全满足我们：<br>
1、需要特别精细的调度时。由于大多数DNS Server不支持DNS扩展协议，所以拿不到用户的真实IP，只能根据Local DNS来调度。<br>
2、访问特别频繁时。由于每次调度都将触发一次DNS，如果请求变得密集，DNS请求本身带来的开销也会相应变大；<br>
3、需要根据服务器的带宽容量、连接数、负载情况、当机与否来调度时。由于DNS Server没有CDN节点服务器的信息，这种调度会变得困难。</p>
<p>这时候我们可以：<br>
1、将用户先行引导到某一台或几台统一的服务器上去；<br>
2、让它拿到用户的真实IP，计算出服务他的服务器；<br>
3、通过HTTP302或其它方式把用户定位到最终服务器上。</p>
<p>部署在用户先访问到的那几台服务器上，负责定位IP然后重定向用户请求的那个软件，我们叫它“调度器”。</p>
<p><strong>HAProxy实现：</strong><br>
HAProxy不支持形如0.0.0.1-0.8.255.255 cn的IP段表示方法，只支持1.1.4.0/22 “CN”的IP段表示方法。<br>
1、我们需要先把IP段转化成它认识的方式；<br>
a&gt; 下载iprang.c或者iprang.c本地镜像；<br>
b&gt; 编译gcc -s -O3 -o iprange iprange.c；<br>
c&gt; 整理IP段列表geo.txt形如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># head geo.txt
"1.0.0.0","1.0.0.255","AU"
"1.0.1.0","1.0.3.255","CN"
"1.0.4.0","1.0.7.255","AU"
"1.0.8.0","1.0.15.255","CN"
"1.0.16.0","1.0.31.255","JP"
"1.0.32.0","1.0.63.255","CN"
"1.0.64.0","1.0.127.255","JP"
"1.0.128.0","1.0.255.255","TH"
"1.1.0.0","1.1.0.255","CN"
"1.1.1.0","1.1.1.255","AU"</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>d&gt; 输出HAProxy认识的IP段列表：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cut -d, -f1,2,5 geo.txt | ./iprange | head
1.0.0.0/24 "AU"
1.0.1.0/24 "CN"
1.0.2.0/23 "CN"
1.0.4.0/22 "AU"
1.0.8.0/21 "CN"
1.0.16.0/20 "JP"
1.0.32.0/19 "CN"
1.0.64.0/18 "JP"
1.0.128.0/17 "TH"
1.1.0.0/24 "CN"
1.1.1.0/24 "AU"</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>e&gt; 便于管理的目的，将整合后的IP段归类到同一个文件中：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cut -d, -f1,2,5 geo.txt | ./iprange | sed 's/"//g' | awk -F' ' '{ print $1 &gt;&gt; $2".subnets" }'
# ls *.subnets
A1.subnets  AX.subnets  BW.subnets  CX.subnets  FJ.subnets  GR.subnets  IR.subnets  LA.subnets  ML.subnets  NF.subnets  PR.subnets  SI.subnets  TK.subnets  VE.subnets
# cat AU.subnets 
1.0.0.0/24
1.0.4.0/22
1.1.1.0/24</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>f&gt; 把这些文件放到同一个文件夹下，我们以/etc/haproxy/conf/为例。</p>
<p>2、正确配置HAProxy以这些IP段为规则正确调度；<br>
下面是一个haproxy.cfg的例子。配置好后重启Haproxy即可。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>global
    log         127.0.0.1 local2 debug

    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     8000
    user        haproxy
    group       haproxy
    daemon

    stats socket /var/lib/haproxy/stats

defaults
    mode                    http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8
    option                  <a href="http://www.ttlsa.com/redis/" title="redis" target="_blank">redis</a>patch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 8000

frontend  main *:5000
    acl geo_A1 src -f /etc/haproxy/conf/A1.subnets
    acl geo_AX src -f /etc/haproxy/conf/AX.subnets
    acl geo_BW src -f /etc/haproxy/conf/BW.subnets
    acl geo_CX src -f /etc/haproxy/conf/CX.subnets
    acl geo_FJ src -f /etc/haproxy/conf/FJ.subnets

    ...

    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=A1\ HTTP if geo_A1
    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=AX\ HTTP if geo_AX
    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=BW\ HTTP if geo_BW
    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=CX\ HTTP if geo_CX
    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=FJ\ HTTP if geo_FJ

    ...

    default_backend             static

backend static
    server      static 127.0.0.1:6081 check</pre></div>
			 
		</div>
<!-- [Format Time: 0.0029 seconds] -->
<p><strong>Nginx实现：</strong><br>
Nginx可以在核心模块HttpGeoModule（http://wiki.nginx.org/HttpGeoModule）的配合下实现调度：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http{

...

geo $useriprang {
    ranges;
    default a;
    0.0.0.1-0.8.255.255 a;
    0.9.0.0-0.255.255.255   a;
    1.0.0.0-1.0.0.255   a;
    1.0.1.0-1.0.1.255   b;
    1.0.2.0-1.0.3.255   b;
    1.0.4.0-1.0.7.255   a;
    ...
    223.255.252.0-223.255.253.255   c;
    223.255.254.0-223.255.254.255   a;
    223.255.255.0-223.255.255.255   a;
}

upstream backend {
    server 127.0.0.1:81;
}

server {
    listen       80;
    client_max_body_size 10240m;

    location / {
        proxy_redirect off;
        proxy_pass http://backend$request_uri&amp;useriprang=$useriprang;
        proxy_next_upstream http_502 http_504 error timeout invalid_header;
        proxy_cache cache_one;
        proxy_cache_key $host:$server_port$uri$is_args$args;
        expires  5s;
    }

}

...

}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p><strong>Varnish实现：</strong><br>
Varnish则有两个插件可以实现调度：<br>
https://github.com/cosimo/varnish-geoip （Last updated: 28/05/2013）<br>
https://github.com/meetup/varnish-geoip-plugin （Last updated: 2010）</p>
<p>性能问题<br>
如上所述，使用Haproxy、Nginx、Varnish都能快速实现这个功能。<br>
其中Nginx和Varnish使用了二分法在IP表中定位用户IP，而Haproxy是逐条过滤。<br>
所以在IP分得较细，IP段组较多（归类后超过1000组）时，Haproxy会出现明显的性能衰减，其余两者没有这个问题。</p>
<p>其它<br>
本文使用的软件版本如下：<br>
HAProxy1.4.22，Nginx1.2.9，Varnish3.0.4。<br>
HAProxy和Varnish都是目前的最新版本。<br>
本文有参考http://blog.exceliance.fr/2012/07/02/use-geoip-database-within-haproxy/<br>
转自：http://blog.yikuyiku.com/?p=3851</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[srcache_nginx redis 清除缓存-nginx案例]]></title>
      <url>/nginx/web/srcache_nginx-redis-purge-cache.html</url>
      <content type="html"><![CDATA[<p>web,srcache_nginx-redis-purge-cache,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>srcache_nginx + redis 缓存方案，我公司业务上用到的比较多。srcache_nginx 模块相关参数介绍，可以参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》。 redis是一种高效的key-value存储。nginx更是被广泛使用的web服务器。srcache_nginx redis 构建缓存系统应用一例可以参见：http://www.ttlsa.com/html/3952.html 。有时，又需要清除缓存。那么缓存该如何清除呢？ 缓存的清除操作与nginx缓存清除大同小异。关于nginx清缓存遇到的问题可以参考下：《nginx purge更新缓存404错误》。看配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~ /purge(/.*) {
                set $key $1?$args;
                set_md5 $redis_key $key;
                redis2_query del $redis_key;
                redis2_pass redis;
        }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>测试：</p>
<p>在删除前，缓存已经存在于redis中</p>
<p>清缓存操作：</p>
<p>验证是否还存在于redis中</p>
<p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/3961.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx 同一个IP上配置多个HTTPS主机-nginx案例]]></title>
      <url>/nginx/web/multiple-https-host-nginx-with-a-ip-configuration.html</url>
      <content type="html"><![CDATA[<p>web,multiple-https-host-nginx-with-a-ip-configuration,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>最近公司域名更变，同时，又要新旧域名同时运行。 那么，对于https的域名在同一个IP上如何同时存在多个虚拟主机呢？遂，查看了下nginx手册，有这么一段内容，如下：</p>
<p>如果在同一个IP上配置多个HTTPS主机，会出现一个很普遍的问题：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen          443;
    server_name     www.example.com;
    ssl             on;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          443;
    server_name     www.example.org;
    ssl             on;
    ssl_certificate www.example.org.crt;
    ...
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>使用上面的配置，不论浏览器请求哪个主机，都只会收到默认主机www.example.com的证书。这是由SSL协议本身的行为引起的——先建立SSL连接，再发送HTTP请求，所以nginx建立SSL连接时不知道所请求主机的名字，因此，它只会返回默认主机的证书。</p>
<p>最古老的也是最稳定的解决方法就是每个HTTPS主机使用不同的IP地址：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen          192.168.1.1:443;
    server_name     www.example.com;
    ssl             on;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443;
    server_name     www.example.org;
    ssl             on;
    ssl_certificate www.example.org.crt;
    ...
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>那么，在同一个IP上，如何配置多个HTTPS主机呢？</p>
<p>nginx支持TLS协议的SNI扩展（Server Name Indication，简单地说这个扩展使得在同一个IP上可以以不同的证书serv不同的域名）。不过，SNI扩展还必须有客户端的支持，另外本地的OpenSSL必须支持它。</p>
<p>如果启用了SSL支持，nginx便会自动识别OpenSSL并启用SNI。是否启用SNI支持，是在编译时由当时的 ssl.h 决定的（SSL_CTRL_SET_TLSEXT_HOSTNAME），如果编译时使用的OpenSSL库支持SNI，则目标系统的OpenSSL库只要支持它就可以正常使用SNI了。</p>
<p>nginx在默认情况下是TLS SNI support disabled。</p>
<p>启用方法：</p>
<p>需要重新编译nginx并启用TLS。步骤如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://www.openssl.org/source/openssl-1.0.1e.tar.gz
# tar zxvf openssl-1.0.1e.tar.gz 
# ./configure --prefix=/usr/local/nginx --with-http_ssl_module \
--with-openssl=./openssl-1.0.1e \
--with-openssl-opt="enable-tlsext" 
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>查看是否启用：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx/sbin/nginx -V
TLS SNI support enabled</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这样就可以在 同一个IP上配置多个HTTPS主机了。</p>
<p>实例如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server  {
        listen 443;
        server_name   www.ttlsa.com;
        index index.html index.htm index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;
        root  /data/wwwroot/www.ttlsa.com/webroot;
        ssl on;
        ssl_certificate "/usr/local/nginx/conf/ssl/www.ttlsa.com.public.cer";
        ssl_certificate_key "/usr/local/nginx/conf/ssl/www.ttlsa.com.private.key";   
		......
}		

server  {
        listen 443;
        server_name   www.heytool.com;
        index index.html index.htm index.php;
        root  /data/wwwroot/www.heytool.com/webroot;
        ssl on;
        ssl_certificate "/usr/local/nginx/conf/ssl/www.heytool.com.public.cer";
        ssl_certificate_key "/usr/local/nginx/conf/ssl/www.heytool.com.private.key";   
		......
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>这样访问每个虚拟主机都正常。</p>
<p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/4288.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[apache和nginx支持SSI配置-nginx案例]]></title>
      <url>/nginx/web/apache-and-nginx-support-ssi-configuration.html</url>
      <content type="html"><![CDATA[<p>web,apache-and-nginx-support-ssi-configuration<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong><span>一. 前言</span></strong></h3>
<p>SSI是一种类似于ASP的基于服务器的网页制作技术。将内容发送到浏览器之前，可以使用“服务器端包含 (SSI）”指令将文本、图形或应用程序信息包含到网页中。例如，可以使用 SSI 包含时间/日期戳、版权声明或供客户填写并返回的表单。对于在多个文件中重复出现的文本或图形，使用包含文件是一种简便的方法。将内容存入一个包含文件中即可，而不必将内容输入所有文件。通过一个非常简单的语句即可调用包含文件，此语句指示 Web 服务器将内容插入适当网页。而且，使用包含文件时，对内容的所有更改只需在一个地方就能完成。<br>
因为包含 SSI 指令的文件要求特殊处理，所以必须为所有 SSI 文件赋予 SSI文件扩展名。默认扩展名是 .stm、.shtm 和 .shtml</p>
<h3><strong>二. apache配置</strong></h3>
<p>apache默认不支持ssi的，可以在apache下做如下设置：<br>
修改Apache配置文件httpd.conf<br>
1. 确认加载include.so模块，将注释去掉：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>LoadModule include_module libexec/apache2/mod_include.so</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>2. AddType部分去掉这两段注释：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>AddType text/html .shtml
AddOutputFilter INCLUDES .shtml</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>3. Directory目录权限里面找到</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>Options Indexes FollowSymLinks
增加Includes修改为：
Options Indexes FollowSymLinks Includes</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>4. 重新启动Apache</p>
<h3><strong>三. nginx配置</strong></h3>
<p>1. 相关指令说明：<br>
ssi<br>
语法：ssi [ on | off ]<br>
默认值：ssi off<br>
配置段段：http, server, location, if<br>
启用SSI处理。<br>
[warning]注意如果启用SSI，那么Last-Modified头和Content-Length头不会传递。[/warning]</p>
<p>ssi_silent_errors<br>
语法：ssi_silent_errors [on|off]<br>
默认值：ssi_silent_errors off<br>
配置段：http, server, location<br>
如果在处理SSI的过程中出现“[an error occurred while processing the directive]”错误，禁止将其输出。</p>
<p>ssi_types<br>
语法：ssi_types mime-type [mime-type …]<br>
默认值：ssi_types text/html<br>
配置段：http, server, location<br>
默认只解析text/html类型，这个参数可以指定其他的MIME类型。</p>
<p>ssi_value_length<br>
语法：ssi_value_length length<br>
默认值：ssi_value_length 256<br>
配置段：http, server, location<br>
定义允许SSI使用的参数值的长度。</p>
<p>2. 在nginx下做如下设置：<br>
<br>
如需转载请注明出处：http://www.ttlsa.com/html/3134.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx map使用方法-nginx案例]]></title>
      <url>/nginx/nginx/using-nginx-map-method.html</url>
      <content type="html"><![CDATA[<p>nginx,using-nginx-map-method,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>map指令使用ngx_http_map_module模块提供的。默认情况下，nginx有加载这个模块，除非人为的 --without-http_map_module。<br>
ngx_http_map_module模块可以创建变量，这些变量的值与另外的变量值相关联。允许分类或者同时映射多个值到多个不同值并储存到一个变量中，map指令用来创建变量，但是仅在变量被接受的时候执行视图映射操作，对于处理没有引用变量的请求时，这个模块并没有性能上的缺失。</p>
<h3><strong>一. ngx_http_map_module模块指令说明</strong></h3>
<p>map<br>
语法: map $var1 $var2 { ... }<br>
默认值: —<br>
配置段: http<br>
map为一个变量设置的映射表。映射表由两列组成，匹配模式和对应的值。<br>
在 map 块里的参数指定了源变量值和结果值的对应关系。<br>
匹配模式可以是一个简单的字符串或者正则表达式，使用正则表达式要用('~')。<br>
一个正则表达式如果以 “~” 开头，表示这个正则表达式对大小写敏感。以 “~*”开头，表示这个正则表达式对大小写不敏感。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>map $http_user_agent $agent {
        default "";
        ~curl curl;
        ~*apachebench" ab;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>正则表达式里可以包含命名捕获和位置捕获，这些变量可以跟结果变量一起被其它指令使用。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>map $uri $value {
    /ttlsa_com                   /index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;
    ~^/ttlsa_com/(?<suffix>.*)$  /boy/;
    ~/fz(/.*)                    /index.php?;                           
}</suffix></pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>[warning]不能在map块里面引用命名捕获或位置捕获变量。如~^/ttlsa_com/(.*)  /boy/$1; 这样会报错nginx: [emerg] unknown  variable。[/warning]如果源变量值包含特殊字符如‘~’，则要以‘\’来转义。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>map $http_referer $value {
    Mozilla    111;
    \~Mozilla  222;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>结果变量可以是一个字符串也可以是另外一个变量。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>map $num $limit {
          1 $binary_remote_addr;
          0 "";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>map指令有三个参数：<br>
default ： 指定如果没有匹配结果将使用的默认值。当没有设置 default，将会用一个空的字符串作为默认的结果。<br>
hostnames ： 允许用前缀或者后缀掩码指定域名作为源变量值。这个参数必须写在值映射列表的最前面。<br>
include ： 包含一个或多个含有映射值的文件。</p>
<p>如果匹配到多个特定的变量，如掩码和正则同时匹配，那么会按照下面的顺序进行选择：<br>
1. 没有掩码的字符串<br>
2. 最长的带前缀的字符串，例如: “*.example.com”<br>
3. 最长的带后缀的字符串，例如：“mail.*”<br>
4. 按顺序第一个先匹配的正则表达式 （在配置文件中体现的顺序）<br>
5. 默认值</p>
<p>map_hash_bucket_size<br>
语法: map_hash_bucket_size size;<br>
默认值: map_hash_bucket_size 32|64|128;<br>
配置段: http<br>
指定一个映射表中的变量在哈希表中的最大值，这个值取决于处理器的缓存。</p>
<p>map_hash_max_size<br>
语法: map_hash_max_size size;<br>
默认值: map_hash_max_size 2048;<br>
配置段: http<br>
设置映射表对应的哈希表的最大值。</p>
<h3><strong>二. 实例</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	map $http_user_agent $agent {
		~curl curl;
		~*chrome chrome;
	}
	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location /hello {
			default_type text/plain;
			echo http_user_agent: $http_user_agent;
			echo agent: agent:$agent;
		}
	}
}
# curl 127.0.0.1:8080/hello  
http_user_agent: curl/7.15.5 (x86_64-redhat-<a href="http://www.ttlsa.com/linux/" title="linux" target="_blank">linux</a>-gnu) libcurl/7.15.5 OpenSSL/0.9.8b zlib/1.2.3 libidn/0.6.5
agent: curl</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p><br>
</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	map $uri $match {
        ~^/hello/(.*) http://www.ttlsa.com/;
	}
	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location /hello {
                default_type text/plain;
                echo uri: $uri;
                echo match: $match;
                echo capture: $1;
                echo new: $match$1;
        }
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<p>如需转载请注明出处：http://www.ttlsa.com/html/3206.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx geo使用方法-nginx案例]]></title>
      <url>/nginx/nginx/using-nginx-geo-method.html</url>
      <content type="html"><![CDATA[<p>nginx,using-nginx-geo-method,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p><span>geo指令使用ngx_http_geo_module模块提供的。默认情况下，nginx有加载这个模块，除非人为的 --without-http_geo_module。</span><br>
ngx_http_geo_module模块可以用来创建变量，其值依赖于客户端IP地址。</p>
<h3><strong>geo指令</strong></h3>
<p>语法: geo [$address] $variable { ... }<br>
默认值: —<br>
配置段: http<br>
定义从指定的变量获取客户端的IP地址。默认情况下，nginx从$remote_addr变量取得客户端IP地址，但也可以从其他变量获得。如</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>geo $remote_addr $geo {
        default 0;
        127.0.0.1 1;
}
geo $arg_ttlsa_com $geo {
        default 0;
        127.0.0.1 1;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>如果该变量的值不能代表一个合法的IP地址，那么nginx将使用地址“255.255.255.255”。<br>
nginx通过CIDR或者地址段来描述地址，支持下面几个参数：<br>
delete：删除指定的网络<br>
default：如果客户端地址不能匹配任意一个定义的地址，nginx将使用此值。 如果使用CIDR，可以用“0.0.0.0/0”代替default。<br>
include： 包含一个定义地址和值的文件，可以包含多个。<br>
proxy：定义可信地址。 如果请求来自可信地址，nginx将使用其“X-Forwarded-For”头来获得地址。 相对于普通地址，可信地址是顺序检测的。<br>
proxy_recursive：开启递归查找地址。 如果关闭递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中的最后一个地址来代替原始客户端地址。如果开启递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中最后一个与所有可信地址都不匹配的地址来代替原始客户端地址。<br>
ranges：使用以地址段的形式定义地址，这个参数必须放在首位。为了加速装载地址库，地址应按升序定义。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>geo $country {
    default        ZZ;
    include        conf/geo.conf;
    delete         127.0.0.0/16;
    proxy          192.168.100.0/24;
    proxy          2001:0db8::/32;

    127.0.0.0/24   US;
    127.0.0.1/32   RU;
    10.1.0.0/16    RU;
    192.168.1.0/24 UK;
}
vim conf/geo.conf
10.2.0.0/16    RU;
192.168.2.0/24 RU;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>地址段例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>geo $country {
    ranges;
    default                   ZZ;
    127.0.0.0-127.0.0.0       US;
    127.0.0.1-127.0.0.1       RU;
    127.0.0.1-127.0.0.255     US;
    10.1.0.0-10.1.255.255     RU;
    192.168.1.0-192.168.1.255 UK;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>[warning]遵循最精确匹配原则，即nginx使用能最精确匹配客户端地址的值。[/warning]</p>
<h3><strong>适用实例</strong></h3>
<p>上面的例子几乎都是官网说明例子。下面举例说明便于理解该指令的用法。<br>
1. 使用默认变量也就是$remote_addr</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	#geo $remote_addr $ttlsa_com {
	geo $ttlsa_com {
        default 0;
        127.0.0.1 1;
	}
	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location /hello {
			default_type text/plain;
			echo $ttlsa_com;
			echo $arg_boy;
		}
	}
}
# curl 127.0.0.1:8080/hello?boy=默北
1
默北</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>2. 使用指定变量</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	geo $arg_boy $ttlsa_com {
        default 0;
        127.0.0.1 1;
        8.8.8.8 2;
}
	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location /hello {
			default_type text/plain;
			echo $ttlsa_com;
			echo $arg_boy;
		}
	}
}
# curl 127.0.0.1:8080/hello?boy=8.8.8.8
2
8.8.8.8</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>3. 匹配原则</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	geo $arg_boy $ttlsa_com {
        default 0;
        127.0.0.1/24 24;
        127.0.0.1/32 32;
        8.8.8.8 2;
}
	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location /hello {
			default_type text/plain;
			echo $ttlsa_com;
			echo $arg_boy;
		}
	}
}
# curl 127.0.0.1:8080/hello?boy=127.0.0.1
32
127.0.0.1
# curl 127.0.0.1:8080/hello?boy=127.0.0.12
24
127.0.0.12</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>[warning]geo指令主要是根据IP来对变量进行赋值的。因此geo块下只能定义IP或网络段，否则会报错“nginx: [emerg] invalid network”。[/warning]</p>
<p>如需转载请注明出处：http://www.ttlsa.com/html/3203.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建nginx反向代理用做内网域名转发-nginx案例]]></title>
      <url>/nginx/nginx/use-nginx-proxy.html</url>
      <content type="html"><![CDATA[<p>nginx,use-nginx-proxy,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong>情景</strong></h3>
<p>由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。并且公司入口路由最多只能做20个端口映射。肯定以后不够用。<br>
然后k兄就提议可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p>
<p>涉及的知识：nginx编译安装，nginx反向代理基本配置，路由端口映射知识，还有网络域名等常识。</p>
<p>本次实验目标是做到：在浏览器中输入xxx123.tk能访问到内网机器192.168.10.38的3000端口，输入xxx456.tk能访问到内网机器192.168.10.40的80端口。</p>
<h3><strong>配置步骤</strong></h3>
<p>服务器ubuntu 12.04</p>
<p><span>###更新仓库</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>apt-get update -y
apt-get install wget -y</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span>#下载nginx和相关软件包</span></p>
<p>pcre是为了编译rewrite模块，zlib是为了支持gzip功能。额，这里nginx版本有点旧，因为我还要做升级nginx的实验用。大家可以装新版本。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>cd /usr/local/src
 wget <a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.33.tar.gz" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.33.tar.gz</a>
 wget <a href="http://zlib.net/zlib-1.2.8.tar.gz" target="_blank" rel="noopener">http://zlib.net/zlib-1.2.8.tar.gz</a>
 wget <a href="http://nginx.org/download/nginx-1.4.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.4.2.tar.gz</a>
 tar xf pcre-8.33.tar.gz
 tar xf zlib-1.2.8.tar.gz</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p><span>#安装编译环境</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre> apt-get install build-essential libtool -y</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span>#创建nginx用户</span></p>
<p>所谓的unprivileged user</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>useradd -s /bin/false -r -M -d /nonexistent www</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span>#开始编译安装</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/configure --with-pcre=/usr/local/src/pcre-8.33 --with-zlib=/usr/local/src/zlib-1.2.8 --user=www --group=www \
 --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module
 make
 make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p><span>#给文件夹授权</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>chown -R www:www /usr/local/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span>#修改配置文件</span><br>
vim nginx.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>user www www;
worker_processes 1;
error_log logs/error.log;
pid logs/nginx.pid;
worker_rlimit_nofile 65535;
events {
    use epoll;
    worker_connections 65535;
}
http {
    include mime.types;
    default_type application/octet-stream;
    include /usr/local/nginx/conf/reverse-proxy.conf;
    sendfile on;
    keepalive_timeout 65;
    gzip on;
    client_max_body_size 50m; #缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到本地再传给用户
    client_body_buffer_size 256k;
    client_header_timeout 3m;
    client_body_timeout 3m;
    send_timeout 3m;
    proxy_connect_timeout 300s; #nginx跟后端服务器连接超时时间(代理连接超时)
    proxy_read_timeout 300s; #连接成功后，后端服务器响应时间(代理接收超时)
    proxy_send_timeout 300s;
    proxy_buffer_size 64k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
    proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
    proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）
    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘
    proxy_ignore_client_abort on; #不允许代理端主动关闭连接
    server {
        listen 80;
        server_name localhost;
        location / {
            root html;
            index index.html index.htm;
        }
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root html;
        }
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0018 seconds] -->
<p>编辑反向代理服务器配置文件：<br>
vim /usr/local/nginx/conf/reverse-proxy.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server
{
    listen 80;
    server_name xxx123.tk;
    location / {
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://192.168.10.38:3000;
    }
    access_log logs/xxx123.tk_access.log;
}

server
{
    listen 80;
    server_name xxx456.tk;
    location / {
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://192.168.10.40:80;
    }
    access_log logs/xxx456.tk_access.log;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p>然后重新加载nginx配置文件，使之修改生效，再把xxx123.tk域名指向公司静态IP，这样就成功的做到了在浏览器中输入xxx123.tk的时候访问的内网服务器192.168.10.38的3000端口,输入xxx456.tk访问192.168.10.40的80端口的作用。<br>
如果想对后端机器做负载均衡，像下面这配置就可以把对nagios.xxx123.tk的请求分发给内网的131和132这两台机器做负载均衡了。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream monitor_server {
    server 192.168.0.131:80;
        server 192.168.0.132:80;
}

server
{
    listen 80;
    server_name nagios.xxx123.tk;
    location / {
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_pass http://monitor_server;
    }
    access_log logs/nagios.xxx123.tk_access.log;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>额，关于负载均衡和缓存就不多说了，这里只是要起到一个简单的“域名转发”功能。<br>
另外，由于http请求最后都是由反向代理服务器传递给后段的机器，所以后端的机器原来的访问日志记录的访问IP都是反向代理服务器的IP。<br>
要想能记录真实IP，需要修改后端机器的日志格式，这里假设后端也是一台nginx：<br>
在后端配置文件里面加入这一段即可：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>log_format access '$HTTP_X_REAL_IP - $remote_user [$time_local] "$request" '
'$status $body_bytes_sent "$http_referer" '
'"$http_user_agent" $HTTP_X_Forwarded_For';

access_log logs/access.log access;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>再看看原来日志的格式长什么样：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
# '$status $body_bytes_sent "$http_referer" '
# '"$http_user_agent" "$http_x_forwarded_for"';

#access_log logs/access.log main;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>看出区别了吧</p>
<p> </p>
<h3><strong>遇到的问题</strong></h3>
<p> </p>
<ul>
<li>之前没配置下面这段，访问时候偶尔会出现504 gateway timeout，由于偶尔出现，所以不太好排查</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    proxy_connect_timeout 300s;
    proxy_read_timeout 300s;
    proxy_send_timeout 300s;
    proxy_buffer_size 64k;
    proxy_buffers 4 32k;
    proxy_busy_buffers_size 64k;
    proxy_temp_file_write_size 64k;
    proxy_ignore_client_abort on;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>报错日志：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>...upstream timed out (110: Connection timed out) while reading response header from upstream, client: ...(后面的省略）</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>从日志看来是连接超时了，网上一通乱查之后估计可能是后端服务器响应超时了，本着大胆假设，小心求证的原则，既然假设了错误原因就要做实验重现错误：那就调整代理超时参数，反过来把代理超时阀值设小（比如1ms）看会不会次次出现504。后来发现把proxy_read_timeout 这个参数设置成1ms的时候，每次访问都出现504。于是把这个参数调大，加入上面那段配置，解决问题了。</p>
<p>有问题可以直接EMAIL作者，当然也可以加入我们ttlsa群单独私聊或者群里发提问。</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ttserver+nginx构建高并发高可用性应用-nginx案例]]></title>
      <url>/nginx/nginx/ttserver-nginx-1429.html</url>
      <content type="html"><![CDATA[<p>nginx,ttserver-nginx-1429,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>ttserver+nginx构建高并发高可用性应用</p>
<p>ttserver一款兼容memcached协议，也可以通过HTTP协议进行数据交换，支持故障转移，高可用性，高并发的分布式key-value持久存储系统。key-value分布式存储系统的特点是查询快，存储数量大，高并发，非常适合通过主键进行查询的操作。</p>
<p>下面的案例是将图片以二进制的方式存入到ttserver中，并通过http方式读取图片。</p>
<p>一.配置nginx</p>
<p>nginx_upstream_check_module模块地址： https://github.com/yaoweibin/nginx_upstream_check_module</p>
<p>nginx需要添加nginx_upstream_check_module模块，用于对后端服务器的健康情况检测，如果后端服务器不可用，则把这台服务器移除负载均衡轮循集群，所有的请求不往这台服务器上转发，待这台服务器恢复正常后，再把这台加入到负载均衡集群。这是LB的基本功能。</p>
<p># vi nginx.conf</p>
<p>user www-data;</p>
<p>worker_processes 8;</p>
<p>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</p>
<p>error_log /var/log/nginx/error.log crit;</p>
<p>pid /var/run/nginx.pid;</p>
<p>worker_rlimit_nofile 65535;</p>
<p>events {</p>
<p>use epoll;</p>
<p>worker_connections 65535;</p>
<p>}</p>
<p>http {</p>
<p>include /etc/nginx/mime.types;</p>
<p>default_type application/octet-stream;</p>
<p>server_tokens off;</p>
<p>access_log off;</p>
<p>sendfile on;</p>
<p>tcp_nopush on;</p>
<p>keepalive_timeout 0;</p>
<p>tcp_nodelay on;</p>
<p>client_max_body_size 200m;</p>
<p>gzip on;</p>
<p>gzip_min_length 1k;</p>
<p>gzip_buffers 4 16k;</p>
<p>gzip_http_version 1.1;</p>
<p>gzip_comp_level 5;</p>
<p>gzip_disable "MSIE [1-6]\.(?!.*SV1)";</p>
<p>gzip_types text/plain application/x-javascript text/css application/xml text/javascript;</p>
<p>include /etc/nginx/conf.d/*.conf;</p>
<p>include /etc/nginx/sites-enabled/*;</p>
<p>}</p>
<p># vi default</p>
<p>server {</p>
<p>listen 80;</p>
<p>server_name 192.168.1.213;</p>
<p>memcached_connect_timeout 1s;</p>
<p>location / {</p>
<p>root /www/web/tmp;</p>
<p>error_page 404 = @fallback;</p>
<p>}</p>
<p>location ~ ^/ttlsa/ttlsa_([0-9a-zA-Z]\.+)$ {</p>
<p>set $memcached_key $1; //memcached键值</p>
<p>add_header X-ttserver-key $memcached_key; //添加一个header信息</p>
<p>memcached_pass ttserver;</p>
<p>memcached_next_upstream error timeout; //当发生错误或超时时，将请求转发到upstream下一个服务器</p>
<p>default_type text/html;</p>
<p>error_page 404 = @fallback;</p>
<p>}</p>
<p>location @fallback {</p>
<p>rewrite ^ http://www.ttlsa.com redirect;</p>
<p>}</p>
<p>}</p>
<p># vi upstream.conf</p>
<p>upstream ttserver {</p>
<p>server 192.168.1.60:1978;</p>
<p>server 192.168.1.60:1979;</p>
<p>check interval=3000 rise=2 fall=2 timeout=1000; //interval检测周期3s一次，fall宕机标记2次失败后标记不可用</p>
<p>}</p>
<p>二.配置ttserver</p>
<p>需要将ttserver配置成主主结构。</p>
<p>ttserver的介绍，安装，配置参见： http://www.ttlsa.com/html/1220.html</p>
<p>三.测试</p>
<p>1.上传界面</p>
<p># vi upload.php</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;</p>
<p>&lt;title&gt;Upload Files&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h2&gt;Select files to upload&lt;/h2&gt;</p>
<p>&lt;form enctype="multipart/form-data" action="/store.php" method="post"&gt;</p>
<p>&lt;input type="file" name="file"&gt;&lt;br&gt;</p>
<p>&lt;input type="submit" name="submit" value="Upload"&gt;</p>
<p>&lt;/form&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>2.存入ttserver</p>
<p># vi store.php</p>
<p>[codesyntax lang="php"]</p>
<p>&lt;?php</p>
<p>/*</p>
<p>###################################</p>
<p>### author: www.ttlsa.com ###</p>
<p>### QQ群: 39514058 ###</p>
<p>### E-mail: service@ttlsa.com ###</p>
<p>###################################</p>
<p>*/</p>
<p>print_r($_FILES);</p>
<p>echo "&lt;br&gt;";</p>
<p>if($_FILES['file']['error'] !== 0){</p>
<p>die('Error upload file. Error code '.$_FILES['file']['error']);</p>
<p>}</p>
<p>$filename=$_FILES['file']['name'];</p>
<p>$tmpfilepath=$_FILES['file']['tmp_name'];</p>
<p>$content=file_get_contents($tmpfilepath);</p>
<p>echo '&lt;img src="data:image/jpeg;base64,', base64_encode($content), '"/&gt;';</p>
<p>echo "&lt;br&gt;";</p>
<p>$ttserver=new Memcache;</p>
<p>$ttserver-&gt;addServer('192.168.1.60',1978);</p>
<p>$ttserver-&gt;addServer('192.168.1.60',1979);</p>
<p>$rt=$ttserver-&gt;set($filename,$content,0,0);</p>
<p>if($rt){</p>
<p>echo "存储成功!\n";</p>
<p>}else{</p>
<p>echo "存储失败!\n";</p>
<p>}</p>
<p>?&gt;</p>
<p>[/codesyntax]</p>
<p>3.结果截图</p>
<p>上传图片：</p>
<p></p>
<p>通过HTTP从ttserver中取图片：</p>
<p></p>
<p>存在问题：</p>
<p>1.二进制传输问题： 二进制数据通过非纯8-bit的传输层传输时，会出现错误。最好是经过base64_encode编码后再传输。</p>
<p>2.序列化问题： Tokyo Tyrant使用memcached协议连接，用php的memcached客户端读取时不会自动反序列化。可使用unserialize()函数进行反序列化操作。此问题稍后再议。</p>
<p>表情图片，用户头像等等场景都可以使用此种方案。比如以用户ID号作为键值等等。</p>
<p>如需转载请注明出处： http://www.ttlsa.com/html/1429.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[srcache_nginx redis 构建缓存系统应用一例-nginx案例]]></title>
      <url>/nginx/nginx/to-build-an-application-cache-system-of-srcache_nginx-redis.html</url>
      <content type="html"><![CDATA[<p>nginx,to-build-an-application-cache-system-of-srcache_nginx-redis,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>srcache_nginx模块相关参数介绍，可以参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》。 redis是一种高效的key-value存储。</p>
<p>下面举一例应用，看配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream <a href="http://www.ttlsa.com/redis/" title="redis" target="_blank">redis</a> {
	server 127.0.0.1:6380;
	keepalive 512;
}

server {
	listen       80 backlog=1024 default;
	server_name  www.ttlsa.com;
	index index.html index.htm index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;
	root  /data/wwwroot/www.ttlsa.com/webroot;

	location / {
		set $flag 0;
		if ($uri ~ /thumb/[0-9]+_160.jpg$){
				set $flag "${flag}1";
		}
		if ($arg_unitid = 42012){
				set $flag "${flag}1";
		}
		if (!-e $request_filename) {
				rewrite ^/(.*)$ /index.php?kohana_uri=$1 last;
		}
	}
	location ~ .*\.php?$ {
		srcache_store_private on;
		srcache_methods GET;
		srcache_response_cache_control off;
		if ($flag = "011"){
			set $key $request_uri;
			set_escape_uri $escaped_key $key;
			srcache_fetch GET /redis $key;
			srcache_default_expire 172800;
			srcache_store PUT /redis2 key=$escaped_key&amp;exptime=$srcache_expire;

			add_header X-flag $flag;
			add_header X-Cached-From $srcache_fetch_status;
			add_header X-Cached-Store $srcache_store_status;
			add_header X-Key $key;
			set_md5 $md5key $key;
			add_header X-md5-key $md5key;
			add_header X-Query_String $query_string;
			add_header X-expire $srcache_expire;
		}	
		include fastcgi_params;
		fastcgi_pass  127.0.0.1:10080;
		fastcgi_index index.php;
		fastcgi_connect_timeout 300;
		fastcgi_send_timeout 300;
		fastcgi_read_timeout 300;
		fastcgi_buffer_size 128k;
		fastcgi_buffers 4 256k;
		fastcgi_busy_buffers_size 256k;
		fastcgi_temp_file_write_size 256k;
		fastcgi_intercept_errors on;
		fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
	}

	location = /redis {
		internal;
		set_md5 $redis_key $args;
		redis_pass redis;
	}

	location = /redis2 {
		internal;

		set_unescape_uri $exptime $arg_exptime;
		set_unescape_uri $key $arg_key;
		set_md5 $key;

		redis2_query set $key $echo_request_body;
		redis2_query expire $key $exptime;
		redis2_pass redis;
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0037 seconds] -->
<p>测试：</p>
<p></p>
<p>redis实例下：</p>
<p></p>
<p>可以记录下日志来测试加缓存前后的耗时。日志格式如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>log_format srcache_log '$remote_addr - $remote_user [$time_local] "$request" '
                                '"$status" $body_bytes_sent $request_time $bytes_sent $request_length '
                                '[$upstream_response_time] [$srcache_fetch_status] [$srcache_store_status] [$srcache_expire]';</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/3952.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_headers_module模块add_header和expires指令-nginx案例]]></title>
      <url>/nginx/nginx/the-ngx_http_headers_module-module-add_header-and-expires-instructions.html</url>
      <content type="html"><![CDATA[<p>nginx,the-ngx_http_headers_module-module-add_header-and-expires-instructions,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong><span>一. 前言</span></strong></h3>
<p>ngx_http_headers_module模块提供了两个重要的指令add_header和expires，来添加 “Expires” 和 “Cache-Control” 头字段，对响应头添加任何域字段。add_header可以用来标示请求访问到哪台服务器上，这个也可以通过nginx模块nginx-http-footer-filter研究使用来实现。expires指令用来对浏览器本地缓存的控制。</p>
<h3><strong>二. add_header指令</strong></h3>
<p>语法: add_header name value;<br>
默认值: —<br>
配置段: http, server, location, if in location<br>
对响应代码为200，201，204，206，301，302，303，304，或307的响应报文头字段添加任意域。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>add_header From ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>三. expires指令</strong></h3>
<p>语法: expires [modified] time;<br>
expires epoch | max | off;<br>
默认值: expires off;<br>
配置段: http, server, location, if in location<br>
在对响应代码为200，201，204，206，301，302，303，304，或307头部中是否开启对“Expires”和“Cache-Control”的增加和修改操作。<br>
可以指定一个正或负的时间值，Expires头中的时间根据目前时间和指令中指定的时间的和来获得。</p>
<p>epoch表示自1970年一月一日00:00:01 GMT的绝对时间，max指定Expires的值为2037年12月31日23:59:59，Cache-Control的值为10 years。<br>
Cache-Control头的内容随预设的时间标识指定：<br>
·设置为负数的时间值:Cache-Control: no-cache。<br>
·设置为正数或0的时间值：Cache-Control: max-age = #，这里#的单位为秒，在指令中指定。<br>
参数off禁止修改应答头中的"Expires"和"Cache-Control"。</p>
<p>实例一：对图片，flash文件在浏览器本地缓存30天</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
 {
           expires 30d;
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>实例二：对js，css文件在浏览器本地缓存1小时</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~ .*\.(js|css)$
 {
            expires 1h;
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如需转载请注明出处：http://www.ttlsa.com/html/3068.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_core_module模块提供的变量-nginx案例]]></title>
      <url>/nginx/nginx/the-ngx_http_core_module-module-provides-variable.html</url>
      <content type="html"><![CDATA[<p>nginx,the-ngx_http_core_module-module-provides-variable,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p><span>ngx_http_core_module模块在处理请求时，会有大量的变量，这些变量可以通过访问日志来记录下来，也可以用于其它nginx模块。在我们对请求做策略如改写等等都会使用到一些变量，顺便对ngx_http_core_module模块提供的变量总结了下，如下所示：</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>参数名称				注释
$arg_PARAMETER			HTTP 请求中某个参数的值，如/index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>?site=www.ttlsa.com，可以用$arg_site取得www.ttlsa.com这个值.
$args HTTP				请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中，$args表示字符串width=400&amp;height=200.
$binary_remote_addr		二进制格式的客户端地址。例如：\x0A\xE0B\x0E
$body_bytes_sent		表示在向客户端发送的http响应中，包体部分的字节数
$content_length			表示客户端请求头部中的Content-Length 字段
$content_type			表示客户端请求头部中的Content-Type 字段
$cookie_COOKIE			表示在客户端请求头部中的cookie 字段
$document_root			表示当前请求所使用的root 配置项的值
$uri					表示当前请求的URI，不带任何参数
$document_uri			与$uri 含义相同
$request_uri			表示客户端发来的原始请求URI，带完整的参数。$uri和$document_uri未必是用户的原始请求，在内部重定向后可能是重定向后的URI，而$request_uri 永远不会改变，始终是客户端的原始URI.
$host					表示客户端请求头部中的Host字段。如果Host字段不存在，则以实际处理的server（虚拟主机）名称代替。如果Host字段中带有端口，如IP:PORT，那么$host是去掉端口的，它的值为IP。$host 是全小写的。这些特性与http_HEADER中的http_host不同，http_host只取出Host头部对应的值。 
$hostname				表示 Nginx所在机器的名称，与 gethostbyname调用返回的值相同 	 
$http_HEADER			表示当前 HTTP请求中相应头部的值。HEADER名称全小写。例如，示请求中 Host头部对应的值 	用 $http_host表	 
$sent_http_HEADER		表示返回客户端的 HTTP响应中相应头部的值。HEADER名称全小写。例如，用 $sent_ http_content_type表示响应中 Content-Type头部对应的值 	 
$is_args				表示请求中的 URI是否带参数，如果带参数，$is_args值为 ?，如果不带参数，则是空字符串 	 
$limit_rate				表示当前连接的限速是多少，0表示无限速 	 
$nginx_version			表示当前 Nginx的版本号	 
$query_string			请求 URI中的参数，与 $args相同，然而 $query_string是只读的不会改变 	 
$remote_addr			表示客户端的地址 	 
$remote_port			表示客户端连接使用的端口 	 
$remote_user			表示使用 Auth Basic Module时定义的用户名 	 
$request_filename		表示用户请求中的 URI经过 root或 alias转换后的文件路径 	 
$request_body			表示 HTTP请求中的包体，该参数只在 proxy_pass或 fastcgi_pass中有意义 	 
$request_body_file		表示 HTTP请求中的包体存储的临时文件名 	 
$request_completion		当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用 HTTP range访问的并不是文件的最后一块，那么其值也是空字符串。
$request_method			表示 HTTP请求的方法名，如 GET、PUT、POST等 	 
$scheme					表示 HTTP scheme，如在请求 https://nginx.com/中表示 https 	 
$server_addr			表示服务器地址 	 
$server_name			表示服务器名称 	 
$server_port			表示服务器端口 	 
$server_protocol		表示服务器向客户端发送响应的协议，如 HTTP/1.1或 HTTP/1.0</pre></div>
			 
		</div>
<!-- [Format Time: 0.0029 seconds] -->
<p>如需转载请注明出处：http://www.ttlsa.com/html/2912.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[perl + fastcgi + nginx搭建-nginx案例]]></title>
      <url>/nginx/nginx/perl-fastcgi-nginx.html</url>
      <content type="html"><![CDATA[<p>nginx,perl-fastcgi-nginx,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx + fastcgi是php下最流行的一套环境了，那perl会不会也有fastcgi呢，当然有，今天来搭建下nginx下perl的fastcgi.性能方面也不亚于php，但是现在web程序php的流行程度perl无法比拟了，性能再好也枉然，但是部分小功能可以考虑使用perl的fastcgi来搞定.进入正题.</p>
<h2>1. 准备软件环境：</h2>
<p>nginx：http://www.nginx.org<br>
perl：系统自带<br>
fastcgi：http://www.cpan.org/modules/by-module/FCGI/</p>
<p>1.1 nginx安装<br>
nginx安装过无数次,这边不在重复安装过程,如果你还没有安装nginx并且不知道怎么安装nginx，那么请先参考之前的文章《nginx安装配置》</p>
<p>1.2 perl安装<br>
一般linux都有自带perl，可以不用安装，如果确实没有，请执行：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># yum install perl</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>1.3 perl-fastcgi安装</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src
# wget http://www.cpan.org/modules/by-module/FCGI/FCGI-0.74.tar.gz
# tar -xzvf FCGI-0.74.tar.gz
# cd FCGI-0.74
# perl Makefile.PL 
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h2>2. nginx虚拟主机配置</h2>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {

        listen       80;
        server_name  test.ttlsa.com;
        #access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;

        index index.html index.php index.html;
        root /data/site/test.ttlsa.com;

        location / 
        {

        }

        location ~ \.pl$ 
        {
            include fastcgi_params;
            fastcgi_pass  127.0.0.1:8999;
            #fastcgi_pass  unix:/var/run/ttlsa.com.perl.sock;
            fastcgi_index index.pl;
        }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>如果想把tcp/ip方式改为socket方式，可以修改fastcgi-wrapper.pl.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$socket = FCGI::OpenSocket( "127.0.0.1:8999", 10 ); #use IP sockets
改为
$socket = FCGI::OpenSocket( "/var/run/ttlsa.com.perl.sock", 10 ); #use IP sockets</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h2>3. 配置脚本</h2>
<p>3.1 fastcgi监听脚本<br>
文件路径：/usr/bin/fastcgi-wrapper.pl</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>#!/usr/bin/perl

use FCGI;
use Socket;
use POSIX qw(setsid);

require 'syscall.ph';

&amp;daemonize;

#this keeps the program alive or something after exec'ing perl scripts
END() { } BEGIN() { }
*CORE::GLOBAL::exit = sub { die "fakeexit\nrc=".shift()."\n"; };
eval q{exit};
if ($@) {
    exit unless $@ =~ /^fakeexit/;
};

&amp;main;

sub daemonize() {
    chdir '/'                 or die "Can't chdir to /: $!";
    defined(my $pid = fork)   or die "Can't fork: $!";
    exit if $pid;
    setsid                    or die "Can't start a new session: $!";
    umask 0;
}

sub main {
        $socket = FCGI::OpenSocket( "127.0.0.1:8999", 10 ); #use IP sockets
        $request = FCGI::Request( \*STDIN, \*STDOUT, \*STDERR, \%req_params, $socket );
        if ($request) { request_loop()};
            FCGI::CloseSocket( $socket );
}

sub request_loop {
        while( $request-&gt;Accept() &gt;= 0 ) {

           #processing any STDIN input from WebServer (for CGI-POST actions)
           $stdin_passthrough ='';
           $req_len = 0 + $req_params{'CONTENT_LENGTH'};
           if (($req_params{'REQUEST_METHOD'} eq 'POST') &amp;&amp; ($req_len != 0) ){
                my $bytes_read = 0;
                while ($bytes_read &lt; $req_len) {
                        my $data = '';
                        my $bytes = read(STDIN, $data, ($req_len - $bytes_read));
                        last if ($bytes == 0 || !defined($bytes));
                        $stdin_passthrough .= $data;
                        $bytes_read += $bytes;
                }
            }

            #running the cgi app
            if ( (-x $req_params{SCRIPT_FILENAME}) &amp;&amp;  #can I execute this?
                 (-s $req_params{SCRIPT_FILENAME}) &amp;&amp;  #Is this file empty?
                 (-r $req_params{SCRIPT_FILENAME})     #can I read this file?
            ){
        pipe(CHILD_RD, PARENT_WR);
        my $pid = open(KID_TO_READ, "-|");
        unless(defined($pid)) {
            print("Content-type: text/plain\r\n\r\n");
                        print "Error: CGI app returned no output - ";
                        print "Executing $req_params{SCRIPT_FILENAME} failed !\n";
            next;
        }
        if ($pid &gt; 0) {
            close(CHILD_RD);
            print PARENT_WR $stdin_passthrough;
            close(PARENT_WR);

            while(my $s = <kid_to_read>) { print $s; }
            close KID_TO_READ;
            waitpid($pid, 0);
        } else {
                    foreach $key ( keys %req_params){
                       $ENV{$key} = $req_params{$key};
                    }
                    # cd to the script's local directory
                    if ($req_params{SCRIPT_FILENAME} =~ /^(.*)\/[^\/]+$/) {
                            chdir $1;
                    }

            close(PARENT_WR);
            close(STDIN);
            #fcntl(CHILD_RD, F_DUPFD, 0);
            syscall(&amp;SYS_dup2, fileno(CHILD_RD), 0);
            #open(STDIN, "</kid_to_read></pre></div>
			 
		</div>
<!-- [Format Time: 0.0049 seconds] -->
<p>3.2 fastcgi自启动服务脚本：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>文件路径：/etc/rc.d/init.d/perl-fastcgi

#!/bin/sh
#
# nginx – this script starts and stops the nginx daemon
#
# chkconfig: - 85 15
# description: Nginx is an HTTP(S) server, HTTP(S) reverse \
# proxy and IMAP/POP3 proxy server
# processname: nginx
# config: /opt/nginx/conf/nginx.conf
# pidfile: /opt/nginx/logs/nginx.pid

# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ "$NETWORKING" = "no" ] &amp;&amp; exit 0

perlfastcgi="/usr/bin/fastcgi-wrapper.pl"
prog=$(basename perl)

lockfile=/var/lock/subsys/perl-fastcgi

start() {
    [ -x $perlfastcgi ] || exit 5
    echo -n $"Starting $prog: "
    daemon $perlfastcgi
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; touch $lockfile
    return $retval
}

stop() {
    echo -n $"Stopping $prog: "
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile
    return $retval
}

restart() {
    stop
    start
}

reload() {
    echo -n $”Reloading $prog: ”
    killproc $nginx -HUP
    RETVAL=$?
    echo
}

force_reload() {
    restart
}
rh_status() {
    status $prog
}

rh_status_q() {
    rh_status &gt;/dev/null 2&gt;&amp;1
}

case "$1" in
    start)
        rh_status_q &amp;&amp; exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
        ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
        exit 2
    esac</pre></div>
			 
		</div>
<!-- [Format Time: 0.0027 seconds] -->
<p>3.3 设置脚本权限</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># chmod a+x /usr/bin/fastcgi-wrapper.pl
# chmod a+x /etc/rc.d/init.d/perl-fastcgi</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h2><strong>4. FastCGI测试</strong></h2>
<hr>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>4.1 启动nginx与fastcgi
# /usr/local/nginx-1.4.2/sbin/nginx
# /etc/init.d/perl-fastcgi start</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>4.2 perl测试文件：<br>
文件路径/data/site/test.ttlsa.com/test.pl</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>#!/usr/bin/perl

print "Content-type:text/html\n\n";
print &lt;<endofhtml><title>Perl Environment Variables</title>

<h1>Perl Environment Variables</h1>
EndOfHTML

foreach $key (sort(keys %ENV)) {
    print "$key = $ENV{$key}<br>\n";
}

print "</endofhtml></pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h2>5. 访问测试</h2>
<p>5.1 访问</p>
<p>http://http:test.ttlsa.com/test.pl,出现内容表示OK.</p>
<p> </p>
<p><strong>6. 简单压力测试：</strong><br>
6.1 使用tcp/ip方式</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>ab -n 1000 -c 10 http://test.ttlsa.com/test.pl</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>他是在是太慢了，只好用10个并发，共计100个请求来测试.</p>
<div><p>perl + fastcgi + tcp-ip</p></div>
<p>6.2 使用socket方式：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>ab -n 100000 -c 500 http://test.ttlsa.com/test.pl</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p><div><p>perl + fastcgi + socket</p></div><p></p>
<p>很奇怪，使用tcp/ip方式，每秒就140多个请求，而使用socket方式却有5800个请求/秒。差距不是一般的大。顺便测试了一下php的fastcgi，大概请求在3000（tcp/ip方式），4800（socket方式）。</p>
<h2>7. 文件下载</h2>
<p>perl脚本下载：perl-fastcgi,fastcgi-wrapper.pl,test.perl三个文件</p>
<p> </p>
<p>转载请注明出处：<strong></strong> http://www.ttlsa.com/html/2411.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+set-misc-nginx-module模块说明-nginx案例]]></title>
      <url>/nginx/nginx/nginx_set-misc-nginx-module-module-description.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx_set-misc-nginx-module-module-description,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>set-misc-nginx-module模块是标准的HttpRewriteModule指令的扩展，提供更多的功能，如URI转义与非转义、JSON引述、Hexadecimal/MD5/SHA1/Base32/Base64编码与解码、随机数等等。在后面的应用中，都将会接触使用到这个模块的。该模块是由章亦春先生开发的，他开发的其他模块应用也会使用到这个模块的。充分使用nginx非阻塞模式，对性能上有极大的提高，我个人认为很有必要去弄懂弄透nginx，通过自己去动手动脑用实例来加以验证，不断的对模块参数命令加以理解，在实际环境中应用自如。某朋友说“招运维人员，不懂nginx的一律不要。”呵呵，有点道理的。</p>
<p>1. set-misc-nginx-module模块指令说明：<br>
set_if_empty<br>
语法：set_if_empty $dst &lt;src&gt;；<br>
默认值：no<br>
配置段：location, location if<br>
如果参数$dst是空的，则赋值为&lt;src&gt;。<br>
set $a 32;<br>
set_if_empty $a 56;<br>
$a的值为32.<br>
set $a '';<br>
set $value "hello, world"<br>
set_if_empty $a $value;<br>
$a的值为"hello, world"。</p>
<p>set_quote_sql_str<br>
语法：set_quote_sql_str $dst &lt;src&gt; / set_quote_sql_str $dst<br>
默认值：no<br>
配置段：location, location if<br>
当两个参数时，该指令将引用第二个参数&lt;src&gt;值。该指令通常用于防止SQL注入。mysql字符串值引用规则和分配第一个参数结果。<br>
location /test {<br>
set $value "hello\n\r'\"\\";<br>
set_quote_sql_str $quoted $value;</p>
<p>echo $quoted;<br>
}<br>
结果为'hello\n\r\'\"\\'。<br>
当是当个参数时，该指令将修改参数变量。如：<br>
location /test {<br>
set $value "hello\n\r'\"\\";<br>
set_quote_sql_str $value;</p>
<p>echo $value;<br>
}<br>
结果为'hello\n\r\'\"\\'。</p>
<p>set_quote_pgsql_str<br>
语法：set_quote_pgsql_str $dst &lt;src&gt; / set_quote_pgsql_str $dst<br>
默认值：no<br>
配置段： location, location if<br>
与set_quote_sql_str相似，但是要符合PostgreSQL的SQL字符串常量的引用规则。</p>
<p>set_quote_json_str<br>
语法：set_quote_json_str $dst &lt;src&gt; / set_quote_json_str $dst<br>
默认值：no<br>
配置段：location, location if<br>
当两个参数时，该指令将引用第二个参数&lt;src&gt;。JSON字符串值引用规则和分配第一个参数结果。<br>
location /test {<br>
set $value "hello\n\r'\"\\";<br>
set_quote_json_str $quoted $value;</p>
<p>echo $quoted;<br>
}<br>
结果为："hello\n\r'\"\\"。<br>
当当个参数时，该指令将修改参数变量。如：<br>
location /test {<br>
set $value "hello\n\r'\"\\";<br>
set_quote_json_str $value;</p>
<p>echo $value;<br>
}<br>
结果为："hello\n\r'\"\\"。</p>
<p>set_unescape_uri<br>
语法： set_unescape_uri $dst &lt;src&gt; / set_unescape_uri $dst<br>
默认值： no<br>
配置段：location, location if<br>
当两个参数时，该指令将非转义第二个参数&lt;src&gt;的值作为URI一部分，并分配第一个参数变量$dst分配结果。如：<br>
location /test {<br>
set_unescape_uri $key $arg_key;<br>
echo $key;<br>
}<br>
当请求GET /test?key=hello+world%21时，得到：hello world!。<br>
注意： nginx标准的变量$arg_PARAMETER保存原始的URI参数(转义过的)，因此需要set_unescape_uri指令来非转义先。</p>
<p>当单个参数时，该指令将修改参数变量位置，如：<br>
location /test {<br>
set $key $arg_key;<br>
set_unescape_uri $key;</p>
<p>echo $key;<br>
}<br>
当请求GET /test?key=hello+world%21时，得到：hello world!。</p>
<p>set_escape_uri<br>
语法：set_escape_uri $dst &lt;src&gt; /set_escape_uri $dst<br>
默认值：no<br>
配置段：location, location if<br>
与set_unescape_uri相似。</p>
<p>set_hashed_upstream<br>
语法：set_hashed_upstream $dst &lt;upstream_list_name&gt; &lt;src&gt;<br>
默认值：no<br>
配置段：location, location if<br>
参数&lt;src&gt; hash后的值，对应于&lt;upstream_list_name&gt;中的某个upstream名称。<br>
upstream moon { ... }<br>
upstream sun { ... }<br>
upstream earth { ... }</p>
<p>upstream_list universe moon sun earth;</p>
<p>location /test {<br>
set_unescape_uri $key $arg_key;<br>
set $list_name universe;<br>
set_hashed_upstream $backend $list_name $key;</p>
<p>echo $backend;<br>
}<br>
当请求/test?key=blah时，得到的值是 "moon", "sun", "earth"其中一个。取决于参数key。</p>
<p>set_encode_base32<br>
语法：set_encode_base32 $dst &lt;src&gt; / set_encode_base32 $dst<br>
默认值：no<br>
配置段： location, location if<br>
当两个参数时，该指令将对第二个参数&lt;src&gt;进行base32(hex)编码，并将结果赋值给第一个变量参数$dst。 如：<br>
location /test {<br>
set $raw "abcde";<br>
set_encode_base32 $digest $raw;</p>
<p>echo $digest;<br>
}<br>
当请求/test时，得到：c5h66p35。<br>
默认情况下，字符=用来左填充字节对齐。可以通过 set_misc_base32_padding off来禁止填充。</p>
<p>当单个参数时，该指令将修改参数变量位置。如：<br>
location /test {<br>
set $value "abcde";<br>
set_encode_base32 $value;</p>
<p>echo $value;<br>
}<br>
当请求/test时，得到：c5h66p35。</p>
<p>set_misc_base32_padding<br>
语法：set_misc_base32_padding on|off<br>
默认值：on<br>
配置段：http, server, server if, location, location if<br>
当set_encode_base32指令以base32进行编码时，该指令控制是否以字符=来填充。</p>
<p>set_decode_base32<br>
语法：set_decode_base32 $dst &lt;src&gt; | set_decode_base32 $dst<br>
默认值：no<br>
配置段： location, location if<br>
与set_encode_base32相似，只不过是反过程。</p>
<p>set_encode_base64<br>
语法： set_encode_base64 $dst &lt;src&gt; |set_encode_base64 $dst<br>
默认值：no<br>
配置段；location, location if<br>
当两个参数时，该指令将对第二个参数&lt;src&gt;进行base64编码，并将结果赋值给第一个变量参数$dst。 如：<br>
location /test {<br>
set $raw "abcde";<br>
set_encode_base64 $digest $raw;</p>
<p>echo $digest;<br>
}<br>
当请求/test时，得到YWJjZGU=。</p>
<p>当单个参数时，该指令将修改参数变量位置。如：<br>
location /test {<br>
set $value "abcde";<br>
set_encode_base64 $value;</p>
<p>echo $value;<br>
}<br>
当请求/test时，得到YWJjZGU=。</p>
<p>set_decode_base64<br>
语法：set_decode_base64 $dst &lt;src&gt; | set_decode_base64 $dst<br>
默认值：no<br>
配置段：location, location if<br>
与set_encode_base64相似，只不过是反过程。</p>
<p>set_encode_hex<br>
语法：set_encode_hex $dst &lt;src&gt; | set_encode_hex $dst<br>
默认值：no<br>
配置段： location, location if<br>
当两个参数时，该指令将对第二个参数&lt;src&gt;进行hexadecimal编码，并将结果赋值给第一个变量参数$dst。 如：<br>
location /test {<br>
set $raw "章亦春";<br>
set_encode_hex $digest $raw;</p>
<p>echo $digest;<br>
}<br>
当请求/test时，得到：e7aba0e4baa6e698a5。</p>
<p>当单个参数时，该指令将修改参数变量位置。如：<br>
location /test {<br>
set $value "章亦春";<br>
set_encode_hex $value;</p>
<p>echo $value;<br>
}<br>
当请求/test时，得到：e7aba0e4baa6e698a5。</p>
<p>set_decode_hex<br>
语法：set_decode_hex $dst &lt;src&gt; | set_decode_hex $dst<br>
默认值：no<br>
配置段： location, location if<br>
与set_encode_hex相似，只不过是反过程。</p>
<p>set_sha1<br>
语法：set_sha1 $dst &lt;src&gt; | set_sha1 $dst<br>
默认值：no<br>
配置段：location, location if<br>
当两个参数时，该指令将对第二个参数&lt;src&gt;进行SHA-1编码，并将结果赋值给第一个变量参数$dst。 如：<br>
location /test {<br>
set $raw "hello";<br>
set_sha1 $digest $raw;</p>
<p>echo $digest;<br>
}<br>
当请求/test，得到：aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d。</p>
<p>当单个参数时，该指令将修改参数变量位置。如：<br>
location /test {<br>
set $value "hello";<br>
set_sha1 $value;</p>
<p>echo $value;<br>
}</p>
<p>set_md5<br>
语法：set_md5 $dst &lt;src&gt; | set_md5 $dst<br>
默认值：no<br>
配置段：location, location if<br>
当两个参数时，该指令将对第二个参数&lt;src&gt;进行MD5编码，并将结果赋值给第一个变量参数$dst。 如：<br>
location /test {<br>
set $raw "hello";<br>
set_sha1 $digest $raw;</p>
<p>echo $digest;<br>
}<br>
当请求/test，得到：5d41402abc4b2a76b9719d911017c592。</p>
<p>当单个参数时，该指令将修改参数变量位置。如：<br>
location /test {<br>
set $value "hello";<br>
set_sha1 $value;</p>
<p>echo $value;<br>
}</p>
<p>set_hmac_sha1<br>
语法：set_hmac_sha1 $dst &lt;secret_key&gt; &lt;src&gt; | set_hmac_sha1 $dst<br>
默认值：no<br>
配置段：location, location if<br>
为参数&lt;src&gt;计算HMAC-SHA1值，将结果赋值给参数变量$dst并带上密钥&lt;secret_key&gt;。如：<br>
location /test {<br>
set $secret 'thisisverysecretstuff';<br>
set $string_to_sign 'some string we want to sign';<br>
set_hmac_sha1 $signature $secret $string_to_sign;<br>
set_encode_base64 $signature $signature;<br>
echo $signature;<br>
}<br>
请求/test，得到：R/pvxzHC4NLtj7S+kXFg/NePTmk=。<br>
注意：该指令依赖于OpenSSL库，因此编译nginx时，需要--with-http_ssl_module。</p>
<p>set_random<br>
语法: set_random $res &lt;from&gt; &lt;to&gt;<br>
默认值：no<br>
配置段：location, location if<br>
生成从&lt;from&gt;与&lt;to&gt;之间的非负数的随机数。含&lt;from&gt; &lt;to&gt;。</p>
<p>set_secure_random_alphanum<br>
语法：set_secure_random_alphanum $res &lt;length&gt;<br>
默认值：no<br>
配置段：location, location if<br>
生成长度为&lt;length&gt;的随机字符串。字符有[a-zA-Z0-9]。</p>
<p>set_secure_random_lcalpha<br>
语法：set_secure_random_lcalpha $res &lt;length&gt;<br>
默认值：no<br>
配置段：location, location if<br>
生成长度为&lt;length&gt;的随机字符串。字符有[a-z]。</p>
<p>set_rotate<br>
语法：set_rotate $value &lt;from&gt; &lt;to&gt;<br>
默认值：no<br>
配置段：location, location if</p>
<p>set_local_today<br>
语法：set_local_today $dst<br>
默认值：no<br>
配置段：location, location if<br>
将本地的今天日期以"yyyy-mm-dd"格式赋值给参数变量$dst。</p>
<p>2. set-misc-nginx-module安装</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./configure --prefix=/usr/local/nginx \
--with-http_ssl_module \
--add-module=../ngx_devel_kit \
--add-module=../set-misc-nginx-module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>set-misc-nginx-module依赖ngx_devel_kit模块，且--add-module=ngx_devel_kit一定要早于--add-module=set-misc-nginx-module</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(8)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-8.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-8<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p> </p>
<p>与 $arg_XXX 类似，我们在 （二） 中提到过的内建变量 $cookie_XXX 变量也会在名为 XXX 的 cookie 不存在时返回特殊值“没找到”：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        content_by_<a href="http://www.ttlsa.com/monitor/lua/" title="lua" target="_blank">lua</a> '
            if ngx.var.cookie_user == nil then
                ngx.say("cookie user: missing")
            else
                ngx.say("cookie user: [", ngx.var.cookie_user, "]")
            end
        ';
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>利用 curl 命令行工具的 --cookie name=value 选项可以指定 name=value 为当前请求携带的 cookie（通过添加相应的 Cookie 请求头）。下面是若干次测试结果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl --cookie user=agentzh 'http://localhost:8080/test'
    cookie user: [agentzh]

    $ curl --cookie user= 'http://localhost:8080/test'
    cookie user: []

    $ curl 'http://localhost:8080/test'
    cookie user: missing</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>我们看到，cookie user 不存在以及取值为空字符串这两种情况被很好地区分开了：当 cookie user 不存在时，Lua 代码中的 ngx.var.cookie_user 返回了期望的 Lua nil 值。</p>
<p>在 Lua 里访问未创建的 Nginx 用户变量时，在 Lua 里也会得到 nil 值，而不会像先前的例子那样直接让 Nginx 拒绝加载配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        content_by_lua '
           ngx.say("$blah = ", ngx.var.blah)
        ';
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这里假设我们并没有在当前的 nginx.conf 配置文件中创建过用户变量 $blah，然后我们在 Lua 代码中通过 ngx.var.blah 直接引用它。上面这个配置可以顺利启动，因为 Nginx 在加载配置时只会编译 content_by_lua 配置指令指定的 Lua 代码而不会实际执行它，所以 Nginx 并不知道 Lua 代码里面引用了 $blah 这个变量。于是我们在运行时也会得到 nil 值。而 ngx_lua 提供的 ngx.say 函数会自动把 Lua 的 nil 值格式化为字符串 "nil" 输出，于是访问 /test 接口的结果是：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    curl 'http://localhost:8080/test'
    $blah = nil</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这正是我们所期望的。</p>
<p>上面这个例子中另一个值得注意的地方是，我们在 content_by_lua 配置指令的参数中提及了 $bar 符号，但却并没有触发“变量插值”（否则 Nginx 会在启动时抱怨 $blah 未创建）。这是因为 content_by_lua 配置指令并不支持参数的“变量插值”功能。我们前面在 （一） 中提到过，配置指令的参数是否允许“变量插值”，其实取决于该指令的实现模块。</p>
<p>设计返回“不合法”这一特殊值的例子是困难的，因为我们前面在 （七） 中已经看到，由 set 指令创建的变量在未初始化时确实是“不合法”，但一旦尝试读取它们时，Nginx 就会自动调用其“取处理程序”，而它们的“取处理程序”会自动返回空字符串并将之缓存住。于是我们最终得到的是完全合法的空字符串。下面这个使用了 Lua 代码的例子证明了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /foo {
        content_by_lua '
            if ngx.var.foo == nil then
                ngx.say("$foo is nil")
            else
                ngx.say("$foo = [", ngx.var.foo, "]")
            end
        ';
    }

    location /bar {
        set $foo 32;
        echo "foo = [$foo]";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>请求 /foo 接口的结果是：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/foo'
    $foo = []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们看到在 Lua 里面读取未初始化的 Nginx 变量 $foo 时得到的是空字符串。</p>
<p>最后值得一提的是，虽然前面反复指出 Nginx 变量只有字符串这一种数据类型，但这并不能阻止像 ngx_array_var 这样的第三方模块让 Nginx 变量也能存放数组类型的值。下面就是这样的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        array_split "," $arg_names to=$array;
        array_map "[$array_it]" $array;
        array_join " " $array to=$res;
        echo $res;
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>这个例子中使用了 ngx_array_var 模块的 array_split、 array_map 和 array_join 这三条配置指令，其含义很接近 Perl 语言中的内建函数 split、map 和 join（当然，其他脚本语言也有类似的等价物）。我们来看看访问 /test 接口的结果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?names=Tom,Jim,Bob
    [Tom] [Jim] [Bob]</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们看到，使用 ngx_array_var 模块可以很方便地处理这样具有不定个数的组成元素的输入数据，例如此例中的 names URL 参数值就是由不定个数的逗号分隔的名字所组成。不过，这种类型的复杂任务通过 ngx_lua 来做通常会更灵活而且更容易维护。</p>
<p>至此，本系列教程对 Nginx 变量的介绍终于可以告一段落了。我们在这个过程中接触到了许多标准的和第三方的 Nginx 模块，这些模块让我们得以很轻松地构造出许多有趣的小例子，从而可以深入探究 Nginx 变量的各种行为和特性。在后续的教程中，我们还会有很多机会与这些模块打交道。</p>
<p>通过前面讨论过的众多例子，我们应当已经感受到 Nginx 变量在 Nginx 配置语言中所扮演的重要角色：它是获取 Nginx 中各种信息（包括当前请求的信息）的主要途径和载体，同时也是各个模块之间传递数据的主要媒介之一。在后续的教程中，我们会经常看到 Nginx 变量的身影，所以现在很好地理解它们是非常重要的。</p>
<p>在下一个系列的教程，即 Nginx 配置指令的执行顺序系列 中，我们将深入探讨 Nginx 配置指令的执行顺序以及请求的各个处理阶段，因为很多 Nginx 用户都搞不清楚他们书写的众多配置指令之间究竟是按照何种时间顺序执行的，也搞不懂为什么这些指令实际执行的顺序经常和配置文件里的书写顺序大相径庭。</p>
<p> </p>
<p>[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a31"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a32"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a33"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a34"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a35"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a36"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a37"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a38"]</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(7)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-7.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-7<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>在 （一） 中我们提到过，Nginx 变量的值只有一种类型，那就是字符串，但是变量也有可能压根就不存在有意义的值。没有值的变量也有两种特殊的值：一种是“不合法”（invalid），另一种是“没找到”（not found）。</p>
<p>举例说来，当 Nginx 用户变量 $foo 创建了却未被赋值时，$foo 的值便是“不合法”；而如果当前请求的 URL 参数串中并没有提及 XXX 这个参数，则 $arg_XXX 内建变量的值便是“没找到”。</p>
<p>无论是“不合法”也好，还是“没找到”也罢，这两种 Nginx 变量所拥有的特殊值，和空字符串（""）这种取值是完全不同的，比如 JavaScript 语言中也有专门的 undefined 和 null 这两种特殊值，而 Lua 语言中也有专门的 nil 值: 它们既不等同于空字符串，也不等同于数字 0，更不是布尔值 false. 其实 SQL 语言中的 NULL 也是类似的一种东西。</p>
<p>虽然前面在 （一） 中我们看到，由 set 指令创建的变量未初始化就用在“变量插值”中时，效果等同于空字符串，但那是因为 set 指令为它创建的变量自动注册了一个“取处理程序”，将“不合法”的变量值转换为空字符串。为了验证这一点，我们再重新看一下 （一） 中讨论过的那个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /foo {
        echo "foo = [$foo]";
    }

    location /bar {
        set $foo 32;
        echo "foo = [$foo]";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>这里为了简单起见，省略了原先写出的外围 server 配置块。在这个例子里，我们在 /bar 接口中用 set 指令隐式地创建了 $foo 变量这个名字，然后我们在 /foo 接口中不对 $foo 进行初始化就直接使用 echo 指令输出。我们当时测试 /foo 接口的结果是</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/foo'
    foo = []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>从输出上看，未初始化的 $foo 变量确实和空字符串的效果等同。但细心的读者当时应该就已经注意到，对于上面这个请求，Nginx 的错误日志文件（一般文件名叫做 error.log）中多出一行类似下面这样的警告：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    [warn] 5765#0: *1 using uninitialized "foo" variable, ...</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这一行警告是谁输出的呢？答案是 set 指令为 $foo 注册的“取处理程序”。当 /foo 接口中的 echo 指令实际执行的时候，它会对它的参数 "foo = [$foo]" 进行“变量插值”计算。于是，参数串中的 $foo 变量会被读取，而 Nginx 会首先检查其值容器里的取值，结果它看到了“不合法”这个特殊值，于是它这才决定继续调用 $foo 变量的“取处理程序”。于是 $foo 变量的“取处理程序”开始运行，它向 Nginx 的错误日志打印出上面那条警告消息，然后返回一个空字符串作为 $foo 的值，并从此缓存在 $foo 的值容器中。</p>
<p>细心的读者会注意到刚刚描述的这个过程其实就是那些支持值缓存的内建变量的工作原理，只不过 set 指令在这里借用了这套机制来处理未正确初始化的 Nginx 变量。值得一提的是，只有“不合法”这个特殊值才会触发 Nginx 调用变量的“取处理程序”，而特殊值“没找到”却不会。</p>
<p>上面这样的警告一般会指示出我们的 Nginx 配置中存在变量名拼写错误，抑或是在错误的场合使用了尚未初始化的变量。因为值缓存的存在，这条警告在一个请求的生命期中也不会打印多次。当然，ngx_rewrite 模块专门提供了一条 uninitialized_variable_warn 配置指令可用于禁止这条警告日志。</p>
<p>刚才提到，内建变量 $arg_XXX 在请求 URL 参数 XXX 并不存在时会返回特殊值“找不到”，但遗憾的是在 Nginx 原生配置语言（我们估且这么称呼它）中是不能很方便地把它和空字符串区分开来的，比如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        echo "name: [$arg_name]";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这里我们输出 $arg_name 变量的值同时故意在请求中不提供 URL 参数 name:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test'
    name: []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们看到，输出特殊值“找不到”的效果和空字符串是相同的。因为这一回是 Nginx 的“变量插值”引擎自动把“找不到”给忽略了。</p>
<p>那么我们究竟应当如何捕捉到“找不到”这种特殊值的踪影呢？换句话说，我们应当如何把它和空字符串给区分开来呢？显然，下面这个请求中，URL 参数 name 是有值的，而且其值应当是空字符串：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?name='
    name: []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>但我们却无法将之和前面完全不提供 name 参数的情况给区分开。</p>
<p>幸运的是，通过第三方模块 ngx_lua，我们可以轻松地在 Lua 代码中做到这一点。请看下面这个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        content_by_lua '
            if ngx.var.arg_name == nil then
                ngx.say("name: missing")
            else
                ngx.say("name: [", ngx.var.arg_name, "]")
            end
        ';
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这个例子和前一个例子功能上非常接近，除了我们在 /test 接口中使用了 ngx_lua 模块的 content_by_lua 配置指令，嵌入了一小段我们自己的 Lua 代码来对 Nginx 变量 $arg_name 的特殊值进行判断。在这个例子中，当 $arg_name 的值为“没找到”（或者“不合法”）时，/foo 接口会输出 name: missing 这一行结果:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    curl 'http://localhost:8080/test'
    name: missing</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>因为这是我们第一次接触到 ngx_lua 模块，所以需要先简单介绍一下。ngx_lua 模块将 Lua 语言解释器（或者 LuaJIT 即时编译器）嵌入到了 Nginx 核心中，从而可以让用户在 Nginx 核心中直接运行 Lua 语言编写的程序。我们可以选择在 Nginx 不同的请求处理阶段插入我们的 Lua 代码。这些 Lua 代码既可以直接内联在 Nginx 配置文件中，也可以单独放置在外部 .lua 文件里，然后在 Nginx 配置文件中引用 .lua 文件的路径。</p>
<p>回到上面这个例子，我们在 Lua 代码里引用 Nginx 变量都是通过 ngx.var 这个由 ngx_lua 模块提供的 Lua 接口。比如引用 Nginx 变量 $VARIABLE 时，就在 Lua 代码里写作 ngx.var.VARIABLE 就可以了。当 Nginx 变量 $arg_name 为特殊值“没找到”（或者“不合法”）时， ngx.var.arg_name 在 Lua 世界中的值就是 nil，即 Lua 语言里的“空”（不同于 Lua 空字符串）。我们在 Lua 里输出响应体内容的时候，则使用了 ngx.say 这个 Lua 函数，也是 ngx_lua 模块提供的，功能上等价于 ngx_echo 模块的 echo 配置指令。</p>
<p>现在，如果我们提供空字符串取值的 name 参数，则输出就和刚才不相同了：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?name='
    name: []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>在这种情况下，Nginx 变量 $arg_name 的取值便是空字符串，这既不是“没找到”，也不是“不合法”，因此在 Lua 里，ngx.var.arg_name 就返回 Lua 空字符串（""），和刚才的 Lua nil 值就完全区分开了。</p>
<p>这种区分在有些应用场景下非常重要，比如有的 web service 接口会根据 name 这个 URL 参数是否存在来决定是否按 name 属性对数据集合进行过滤，而显然提供空字符串作为 name 参数的值，也会导致对数据集中取值为空串的记录进行筛选操作。</p>
<p>不过，标准的 $arg_XXX 变量还是有一些局限，比如我们用下面这个请求来测试刚才那个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?name'
    name: missing</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>此时，$arg_name 变量仍然读出“找不到”这个特殊值，这就明显有些违反常识。此外，$arg_XXX 变量在请求 URL 中有多个同名 XXX 参数时，就只会返回最先出现的那个 XXX 参数的值，而默默忽略掉其他实例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob'
    name: [Tom]</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>要解决这些局限，可以直接在 Lua 代码中使用 ngx_lua 模块提供的 ngx.req.get_uri_args 函数。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(6)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-6.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-6<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>Nginx 内建变量用在“子请求”的上下文中时，其行为也会变得有些微妙。</p>
<p>前面在 （三） 中我们已经知道，许多内建变量都不是简单的“存放值的容器”，它们一般会通过注册“存取处理程序”来表现得与众不同，而它们即使有存放值的容器，也只是用于缓存“存取处理程序”的计算结果。我们之前讨论过的 $args 变量正是通过它的“取处理程序”来返回当前请求的 URL 参数串。因为当前请求也可以是“子请求”，所以在“子请求”中读取 $args，其“取处理程序”会很自然地返回当前“子请求”的参数串。我们来看这样的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo "main args: $args";
        echo_location /sub "a=1&amp;b=2";
    }

    location /sub {
        echo "sub args: $args";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>这里在 /main 接口中，先用 echo 指令输出当前请求的 $args 变量的值，接着再用 echo_location 指令发起子请求 /sub. 这里值得注意的是，我们在 echo_location 语句中除了通过第一个参数指定“子请求”的 URI 之外，还提供了第二个参数，用以指定该“子请求”的 URL 参数串（即 a=1&amp;b=2）。最后我们定义了 /sub 接口，在里面输出了一下 $args 的值。请求 /main 接口的结果如下：</p>
<p>$ curl 'http://localhost:8080/main?c=3'<br>
main args: c=3<br>
sub args: a=1&amp;b=2</p>
<p>显然，当 $args 用在“主请求” /main 中时，输出的就是“主请求”的 URL 参数串，c=3；而当用在“子请求” /sub 中时，输出的则是“子请求”的参数串，a=1&amp;b=2。这种行为正符合我们的直觉。</p>
<p>与 $args 类似，内建变量 $uri 用在“子请求”中时，其“取处理程序”也会正确返回当前“子请求”解析过的 URI:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo "main uri: $uri";
        echo_location /sub;
    }

    location /sub {
        echo "sub uri: $uri";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>请求 /main 的结果是</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/main'
    main uri: /main
    sub uri: /sub</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这依然是我们所期望的。</p>
<p>但不幸的是，并非所有的内建变量都作用于当前请求。少数内建变量只作用于“主请求”，比如由标准模块 ngx_http_core 提供的内建变量 $request_method.</p>
<p>变量 $request_method 在读取时，总是会得到“主请求”的请求方法，比如 GET、POST 之类。我们来测试一下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo "main method: $request_method";
        echo_location /sub;
    }

    location /sub {
        echo "sub method: $request_method";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>在这个例子里，/main 和 /sub 接口都会分别输出 $request_method 的值。同时，我们在 /main 接口里利用 echo_location 指令发起一个到 /sub 接口的 GET “子请求”。我们现在利用 curl 命令行工具来发起一个到 /main 接口的 POST 请求：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl --data hello 'http://localhost:8080/main'
    main method: POST
    sub method: POST</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这里我们利用 curl 程序的 --data 选项，指定 hello 作为我们的请求体数据，同时 --data 选项会自动让发送的请求使用 POST 请求方法。测试结果证明了我们先前的预言，$request_method 变量即使在 GET “子请求” /sub 中使用，得到的值依然是“主请求” /main 的请求方法，POST.</p>
<p>有的读者可能觉得我们在这里下的结论有些草率，因为上例是先在“主请求”里读取（并输出）$request_method 变量，然后才发“子请求”的，所以这些读者可能认为这并不能排除 $request_method 在进入子请求之前就已经把第一次读到的值给缓存住，从而影响到后续子请求中的输出结果。不过，这样的顾虑是多余的，因为我们前面在 （五） 中也特别提到过，缓存所依赖的变量的值容器，是与当前请求绑定的，而由 ngx_echo 模块发起的“子请求”都禁用了父子请求之间的变量共享，所以在上例中，$request_method 内建变量即使真的使用了值容器作为缓存（事实上它也没有），它也不可能影响到 /sub 子请求。</p>
<p>为了进一步消除这部分读者的疑虑，我们不妨稍微修改一下刚才那个例子，将 /main 接口输出 $request_method 变量的时间推迟到“子请求”执行完毕之后：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo_location /sub;
        echo "main method: $request_method";
    }

    location /sub {
        echo "sub method: $request_method";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>让我们重新测试一下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl --data hello 'http://localhost:8080/main'
    sub method: POST
    main method: POST</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>可以看到，再次以 POST 方法请求 /main 接口的结果与原先那个例子完全一致，除了父子请求的输出顺序颠倒了过来（因为我们在本例中交换了 /main 接口中那两条输出配置指令的先后次序）。</p>
<p>由此可见，我们并不能通过标准的 $request_method 变量取得“子请求”的请求方法。为了达到我们最初的目的，我们需要求助于第三方模块 ngx_echo 提供的内建变量 $echo_request_method：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo "main method: $echo_request_method";
        echo_location /sub;
    }

    location /sub {
        echo "sub method: $echo_request_method";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>此时的输出终于是我们想要的了：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl --data hello 'http://localhost:8080/main'
    main method: POST
    sub method: GET</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们看到，父子请求分别输出了它们各自不同的请求方法，POST 和 GET.</p>
<p>类似 $request_method，内建变量 $request_uri 一般也返回的是“主请求”未经解析过的 URL，毕竟“子请求”都是在 Nginx 内部发起的，并不存在所谓的“未解析的”原始形式。</p>
<p>如果真如前面那部分读者所担心的，内建变量的值缓存在共享变量的父子请求之间起了作用，这无疑是灾难性的。我们前面在 （五） 中已经看到 ngx_auth_request 模块发起的“子请求”是与其“父请求”共享一套变量的。下面是一个这样的可怕例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    map $uri $tag {
        default     0;
        /main       1;
        /sub        2;
    }

    server {
        listen 8080;

        location /main {
            auth_request /sub;
            echo "main tag: $tag";
        }

        location /sub {
            echo "sub tag: $tag";
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>这里我们使用久违了的 map 指令来把内建变量 $uri 的值映射到用户变量 $tag 上。当 $uri 的值为 /main 时，则赋予 $tag 值 1，当 $uri 取值 /sub 时，则赋予 $tag 值 2，其他情况都赋 0. 接着，我们在 /main 接口中先用 ngx_auth_request 模块的 auth_request 指令发起到 /sub 接口的子请求，然后再输出变量 $tag 的值。而在 /sub 接口中，我们直接输出变量 $tag. 猜猜看，如果我们访问接口 /main，将会得到什么样的输出呢？</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/main'
    main tag: 2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>咦？我们不是分明把 /main 这个值映射到 1 上的么？为什么实际输出的是 /sub 映射的结果 2 呢？</p>
<p>其实道理很简单，因为我们的 $tag 变量在“子请求” /sub 中首先被读取，于是在那里计算出了值 2（因为 $uri 在那里取值 /sub，而根据 map 映射规则，$tag 应当取值 2），从此就被 $tag 的值容器给缓存住了。而 auth_request 发起的“子请求”又是与“父请求”共享一套变量的，于是当 Nginx 的执行流回到“父请求”输出 $tag 变量的值时，Nginx 就直接返回缓存住的结果 2 了。这样的结果确实太意外了。</p>
<p>从这个例子我们再次看到，父子请求间的变量共享，实在不是一个好主意。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(5)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-5.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-5<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>前面在 （二） 中我们已经了解到变量值容器的生命期是与请求绑定的，但是我当时有意避开了“请求”的正式定义。大家应当一直默认这里的“请求”都是指客户端发起的 HTTP 请求。其实在 Nginx 世界里有两种类型的“请求”，一种叫做“主请求”（main request），而另一种则叫做“子请求”（subrequest）。我们先来介绍一下它们。</p>
<p>所谓“主请求”，就是由 HTTP 客户端从 Nginx 外部发起的请求。我们前面见到的所有例子都只涉及到“主请求”，包括 （二） 中那两个使用 echo_exec 和 rewrite 指令发起“内部跳转”的例子。</p>
<p>而“子请求”则是由 Nginx 正在处理的请求在 Nginx 内部发起的一种级联请求。“子请求”在外观上很像 HTTP 请求，但实现上却和 HTTP 协议乃至网络通信一点儿关系都没有。它是 Nginx 内部的一种抽象调用，目的是为了方便用户把“主请求”的任务分解为多个较小粒度的“内部请求”，并发或串行地访问多个 location 接口，然后由这些 location 接口通力协作，共同完成整个“主请求”。当然，“子请求”的概念是相对的，任何一个“子请求”也可以再发起更多的“子子请求”，甚至可以玩递归调用（即自己调用自己）。当一个请求发起一个“子请求”的时候，按照 Nginx 的术语，习惯把前者称为后者的“父请求”（parent request）。值得一提的是，Apache 服务器中其实也有“子请求”的概念，所以来自 Apache 世界的读者对此应当不会感到陌生。</p>
<p>下面就来看一个使用了“子请求”的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        echo_location /foo;
        echo_location /bar;
    }

    location /foo {
        echo foo;
    }

    location /bar {
        echo bar;
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>这里在 location /main 中，通过第三方 ngx_echo 模块的 echo_location 指令分别发起到 /foo 和 /bar 这两个接口的 GET 类型的“子请求”。由 echo_location 发起的“子请求”，其执行是按照配置书写的顺序串行处理的，即只有当 /foo 请求处理完毕之后，才会接着处理 /bar 请求。这两个“子请求”的输出会按执行顺序拼接起来，作为 /main 接口的最终输出：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/main'
    foo
    bar</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们看到，“子请求”方式的通信是在同一个虚拟主机内部进行的，所以 Nginx 核心在实现“子请求”的时候，就只调用了若干个 C 函数，完全不涉及任何网络或者 UNIX 套接字（socket）通信。我们由此可以看出“子请求”的执行效率是极高的。</p>
<p>回到先前对 Nginx 变量值容器的生命期的讨论，我们现在依旧可以说，它们的生命期是与当前请求相关联的。每个请求都有所有变量值容器的独立副本，只不过当前请求既可以是“主请求”，也可以是“子请求”。即便是父子请求之间，同名变量一般也不会相互干扰。让我们来通过一个小实验证明一下这个说法：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        set $var main;
        echo_location /foo;
        echo_location /bar;
        echo "main: $var";
    }

    location /foo {
        set $var foo;
        echo "foo: $var";
    }

    location /bar {
        set $var bar;
        echo "bar: $var";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>在这个例子中，我们分别在 /main，/foo 和 /bar 这三个 location 配置块中为同一名字的变量，$var，分别设置了不同的值并予以输出。特别地，我们在 /main 接口中，故意在调用过 /foo 和 /bar 这两个“子请求”之后，再输出它自己的 $var 变量的值。请求 /main 接口的结果是这样的：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/main'
    foo: foo
    bar: bar
    main: main</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>显然，/foo 和 /bar 这两个“子请求”在处理过程中对变量 $var 各自所做的修改都丝毫没有影响到“主请求” /main. 于是这成功印证了“主请求”以及各个“子请求”都拥有不同的变量 $var 的值容器副本。</p>
<p>不幸的是，一些 Nginx 模块发起的“子请求”却会自动共享其“父请求”的变量值容器，比如第三方模块 ngx_auth_request. 下面是一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /main {
        set $var main;
        auth_request /sub;
        echo "main: $var";
    }

    location /sub {
        set $var sub;
        echo "sub: $var";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>这里我们在 /main 接口中先为 $var 变量赋初值 main，然后使用 ngx_auth_request 模块提供的配置指令 auth_request，发起一个到 /sub 接口的“子请求”，最后利用 echo 指令输出变量 $var 的值。而我们在 /sub 接口中则故意把 $var 变量的值改写成 sub. 访问 /main 接口的结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/main'
    main: sub</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们看到，/sub 接口对 $var 变量值的修改影响到了主请求 /main. 所以 ngx_auth_request 模块发起的“子请求”确实是与其“父请求”共享一套 Nginx 变量的值容器。</p>
<p>对于上面这个例子，相信有读者会问：“为什么‘子请求’ /sub 的输出没有出现在最终的输出里呢？”答案很简单，那就是因为 auth_request 指令会自动忽略“子请求”的响应体，而只检查“子请求”的响应状态码。当状态码是 2XX 的时候，auth_request 指令会忽略“子请求”而让 Nginx 继续处理当前的请求，否则它就会立即中断当前（主）请求的执行，返回相应的出错页。在我们的例子中，/sub “子请求”只是使用 echo 指令作了一些输出，所以隐式地返回了指示正常的 200 状态码。</p>
<p>如 ngx_auth_request 模块这样父子请求共享一套 Nginx 变量的行为，虽然可以让父子请求之间的数据双向传递变得极为容易，但是对于足够复杂的配置，却也经常导致不少难于调试的诡异 bug. 因为用户时常不知道“父请求”的某个 Nginx 变量的值，其实已经在它的某个“子请求”中被意外修改了。诸如此类的因共享而导致的不好的“副作用”，让包括 ngx_echo，ngx_lua，以及 ngx_srcache 在内的许多第三方模块都选择了禁用父子请求间的变量共享。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(4)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-4.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-4<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>在设置了“取处理程序”的情况下，Nginx 变量也可以选择将其值容器用作缓存，这样在多次读取变量的时候，就只需要调用“取处理程序”计算一次。我们下面就来看一个这样的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    map $args $foo {
        default     0;
        debug       1;
    }

    server {
        listen 8080;

        location /test {
            set $orig_foo $foo;
            set $args debug;
            echo "orginal foo: $orig_foo";
            echo "foo: $foo";
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>这里首次用到了标准 ngx_map 模块的 map 配置指令，我们有必要在此介绍一下。map 在英文中除了“地图”之外，也有“映射”的意思。比方说，中学数学里讲的“函数”就是一种“映射”。而 Nginx 的这个 map 指令就可以用于定义两个 Nginx 变量之间的映射关系，或者说是函数关系。回到上面这个例子，我们用 map 指令定义了用户变量 $foo 与 $args 内建变量之间的映射关系。特别地，用数学上的函数记法 y = f(x) 来说，我们的 $args 就是“自变量” x，而 $foo 则是“因变量” y，即 $foo 的值是由 $args 的值来决定的，或者按照书写顺序可以说，我们将 $args 变量的值映射到了 $foo 变量上。</p>
<p>现在我们再来看 map 指令定义的映射规则：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    map $args $foo {
        default     0;
        debug       1;
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>花括号中第一行的 default 是一个特殊的匹配条件，即当其他条件都不匹配的时候，这个条件才匹配。当这个默认条件匹配时，就把“因变量” $foo 映射到值 0. 而花括号中第二行的意思是说，如果“自变量” $args 精确匹配了 debug 这个字符串，则把“因变量” $foo 映射到值 1. 将这两行合起来，我们就得到如下完整的映射规则：当 $args 的值等于 debug 的时候，$foo 变量的值就是 1，否则 $foo 的值就为 0.</p>
<p>明白了 map 指令的含义，再来看 location /test. 在那里，我们先把当前 $foo 变量的值保存在另一个用户变量 $orig_foo 中，然后再强行把 $args 的值改写为 debug，最后我们再用 echo 指令分别输出 $orig_foo 和 $foo 的值。</p>
<p>从逻辑上看，似乎当我们强行改写 $args 的值为 debug 之后，根据先前的 map 映射规则，$foo 变量此时的值应当自动调整为字符串 1, 而不论 $foo 原先的值是怎样的。然而测试结果并非如此：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test'
    original foo: 0
    foo: 0</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>第一行输出指示 $orig_foo 的值为 0，这正是我们期望的：上面这个请求并没有提供 URL 参数串，于是 $args 最初的取值就是空，再根据我们先前定义的映射规则，$foo 变量在第一次被读取时的值就应当是 0（即匹配默认的那个 default 条件）。</p>
<p>而第二行输出显示，在强行改写 $args 变量的值为字符串 debug 之后，$foo 的条件仍然是 0 ，这显然不符合映射规则，因为当 $args 为 debug 时，$foo 的值应当是 1. 这究竟是为什么呢？</p>
<p>其实原因很简单，那就是 $foo 变量在第一次读取时，根据映射规则计算出的值被缓存住了。刚才我们说过，Nginx 模块可以为其创建的变量选择使用值容器，作为其“取处理程序”计算结果的缓存。显然，ngx_map 模块认为变量间的映射计算足够昂贵，需要自动将因变量的计算结果缓存下来，这样在当前请求的处理过程中如果再次读取这个因变量，Nginx 就可以直接返回缓存住的结果，而不再调用该变量的“取处理程序”再行计算了。</p>
<p>为了进一步验证这一点，我们不妨在请求中直接指定 URL 参数串为 debug:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?debug'
    original foo: 1
    foo: 1</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们看到，现在 $orig_foo 的值就成了 1，因为变量 $foo 在第一次被读取时，自变量 $args 的值就是 debug，于是按照映射规则，“取处理程序”计算返回的值便是 1. 而后续再读取 $foo 的值时，就总是得到被缓存住的 1 这个结果，而不论 $args 后来变成什么样了。</p>
<p>map 指令其实是一个比较特殊的例子，因为它可以为用户变量注册“取处理程序”，而且用户可以自己定义这个“取处理程序”的计算规则。当然，此规则在这里被限定为与另一个变量的映射关系。同时，也并非所有使用了“取处理程序”的变量都会缓存结果，例如我们前面在 （三） 中已经看到 $arg_XXX 并不会使用值容器进行缓存。</p>
<p>类似 ngx_map 模块，标准的 ngx_geo 等模块也一样使用了变量值的缓存机制。</p>
<p>在上面的例子中，我们还应当注意到 map 指令是在 server 配置块之外，也就是在最外围的 http 配置块中定义的。很多读者可能会对此感到奇怪，毕竟我们只是在 location /test 中用到了它。这倒不是因为我们不想把 map 语句直接挪到 location 配置块中，而是因为 map 指令只能在 http 块中使用！</p>
<p>很多 Nginx 新手都会担心如此“全局”范围的 map 设置会让访问所有虚拟主机的所有 location 接口的请求都执行一遍变量值的映射计算，然而事实并非如此。前面我们已经了解到 map 配置指令的工作原理是为用户变量注册 “取处理程序”，并且实际的映射计算是在“取处理程序”中完成的，而“取处理程序”只有在该用户变量被实际读取时才会执行（当然，因为缓存的存在，只在请求生命期中的第一次读取中才被执行），所以对于那些根本没有用到相关变量的请求来说，就根本不会执行任何的无用计算。</p>
<p>这种只在实际使用对象时才计算对象值的技术，在计算领域被称为“惰性求值”（lazy evaluation）。提供“惰性求值” 语义的编程语言并不多见，最经典的例子便是 Haskell. 与之相对的便是“主动求值” （eager evaluation）。我们有幸在 Nginx 中也看到了“惰性求值”的例子，但“主动求值”语义其实在 Nginx 里面更为常见，例如下面这行再普通不过的 set 语句：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    set $b "$a,$a";</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这里会在执行 set 规定的赋值操作时，“主动”地计算出变量 $b 的值，而不会将该求值计算延缓到变量 $b 实际被读取的时候。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(3)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-3.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-3<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>也有一些内建变量是支持改写的，其中一个例子是 $args. 这个变量在读取时返回当前请求的 URL 参数串（即请求 URL 中问号后面的部分，如果有的话 ），而在赋值时可以直接修改参数串。我们来看一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        set $orig_args $args;
        set $args "a=3&amp;b=4";
        echo "original args: $orig_args";
        echo "args: $args";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>这里我们把原始的 URL 参数串先保存在 $orig_args 变量中，然后通过改写 $args 变量来修改当前的 URL 参数串，最后我们用 echo 指令分别输出 $orig_args 和 $args 变量的值。接下来我们这样来测试这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test'
    original args:
    args: a=3&amp;b=4

    $ curl 'http://localhost:8080/test?a=0&amp;b=1&amp;c=2'
    original args: a=0&amp;b=1&amp;c=2
    args: a=3&amp;b=4</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>在第一次测试中，我们没有设置任何 URL 参数串，所以输出 $orig_args 变量的值时便得到空。而在第一次和第二次测试中，无论我们是否提供 URL 参数串，参数串都会在 location /test 中被强行改写成 a=3&amp;b=4.</p>
<p>需要特别指出的是，这里的 $args 变量和 $arg_XXX 一样，也不再使用属于自己的存放值的容器。当我们读取 $args 时，Nginx 会执行一小段代码，从 Nginx 核心中专门存放当前 URL 参数串的位置去读取数据；而当我们改写 $args 时，Nginx 会执行另一小段代码，对相同位置进行改写。Nginx 的其他部分在需要当前 URL 参数串的时候，都会从那个位置去读数据，所以我们对 $args 的修改会影响到所有部分的功能。我们来看一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        set $orig_a $arg_a;
        set $args "a=5";
        echo "original a: $orig_a";
        echo "a: $arg_a";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>这里我们先把内建变量 $arg_a 的值，即原始请求的 URL 参数 a 的值，保存在用户变量 $orig_a 中，然后通过对内建变量 $args 进行赋值，把当前请求的参数串改写为 a=5 ，最后再用 echo 指令分别输出 $orig_a 和 $arg_a 变量的值。因为对内建变量 $args 的修改会直接导致当前请求的 URL 参数串发生变化，因此内建变量 $arg_XXX 自然也会随之变化。测试的结果证实了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?a=3'
    original a: 3
    a: 5</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们看到，因为原始请求的 URL 参数串是 a=3, 所以 $arg_a 最初的值为 3, 但随后通过改写 $args 变量，将 URL 参数串又强行修改为 a=5, 所以最终 $arg_a 的值又自动变为了 5.</p>
<p>我们再来看一个通过修改 $args 变量影响标准的 HTTP 代理模块 ngx_proxy 的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {
        listen 8080;

        location /test {
            set $args "foo=1&amp;bar=2";
            proxy_pass http://127.0.0.1:8081/args;
        }
    }

    server {

        listen 8081;
        location /args {
            echo "args: $args";
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>这里我们在 http 配置块中定义了两个虚拟主机。第一个虚拟主机监听 8080 端口，其 /test 接口自己通过改写 $args 变量，将当前请求的 URL 参数串无条件地修改为 foo=1&amp;bar=2. 然后 /test 接口再通过 ngx_proxy 模块的 proxy_pass 指令配置了一个反向代理，指向本机的 8081 端口上的 HTTP 服务 /args. 默认情况下，ngx_proxy 模块在转发 HTTP 请求到远方 HTTP 服务的时候，会自动把当前请求的 URL 参数串也转发到远方。</p>
<p>而本机的 8081 端口上的 HTTP 服务正是由我们定义的第二个虚拟主机来提供的。我们在第二个虚拟主机的 location /args 中利用 echo 指令输出当前请求的 URL 参数串，以检查 /test 接口通过 ngx_proxy 模块实际转发过来的 URL 请求参数串。</p>
<p>我们来实际访问一下第一个虚拟主机的 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?blah=7'
    args: foo=1&amp;bar=2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们看到，虽然请求自己提供了 URL 参数串 blah=7，但在 location /test 中，参数串被强行改写成了 foo=1&amp;bar=2. 接着经由 proxy_pass 指令将我们被改写掉的参数串转发给了第二个虚拟主机上配置的 /args 接口，然后再把 /args 接口的 URL 参数串输出。事实证明，我们对 $args 变量的赋值操作，也成功影响到了 ngx_proxy 模块的行为。</p>
<p>在读取变量时执行的这段特殊代码，在 Nginx 中被称为“取处理程序”（get handler）；而改写变量时执行的这段特殊代码，则被称为“存处理程序”（set handler）。不同的 Nginx 模块一般会为它们的变量准备不同的“存取处理程序”，从而让这些变量的行为充满魔法。</p>
<p>其实这种技巧在计算世界并不鲜见。比如在面向对象编程中，类的设计者一般不会把类的成员变量直接暴露给类的用户，而是另行提供两个方法（method），分别用于该成员变量的读操作和写操作，这两个方法常常被称为“存取器”（accessor）。下面是 C++ 语言中的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    #include <string>
    using namespace std;
    class Person {
    public:
        const string get_name() {
            return m_name;
        }

        void set_name(const string name) {
            m_name = name;
        }

    private:
        string m_name;
    };</string></pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>在这个名叫 Person 的 C++ 类中，我们提供了 get_name 和 set_name 这两个公共方法，以作为私有成员变量 m_name 的“存取器”。</p>
<p>这样设计的好处是显而易见的。类的设计者可以在“存取器”中执行任意代码，以实现所需的业务逻辑以及“副作用”，比如自动更新与当前成员变量存在依赖关系的其他成员变量，抑或是直接修改某个与当前对象相关联的数据库表中的对应字段。而对于后一种情况，也许“存取器”所对应的成员变量压根就不存在，或者即使存在，也顶多扮演着数据缓存的角色，以缓解被代理数据库的访问压力。</p>
<p>与面向对象编程中的“存取器”概念相对应，Nginx 变量也是支持绑定“存取处理程序”的。Nginx 模块在创建变量时，可以选择是否为变量分配存放值的容器，以及是否自己提供与读写操作相对应的“存取处理程序”。</p>
<p>不是所有的 Nginx 变量都拥有存放值的容器。拥有值容器的变量在 Nginx 核心中被称为“被索引的”（indexed）；反之，则被称为“未索引的”（non-indexed）。</p>
<p>我们前面在 （二） 中已经知道，像 $arg_XXX 这样具有无数变种的变量群，是“未索引的”。当读取这样的变量时，其实是它的“取处理程序”在起作用，即实时扫描当前请求的 URL 参数串，提取出变量名所指定的 URL 参数的值。很多新手都会对 $arg_XXX 的实现方式产生误解，以为 Nginx 会事先解析好当前请求的所有 URL 参数，并且把相关的 $arg_XXX 变量的值都事先设置好。然而事实并非如此，Nginx 根本不会事先就解析好 URL 参数串，而是在用户读取某个 $arg_XXX 变量时，调用其“取处理程序”，即时去扫描 URL 参数串。类似地，内建变量 $cookie_XXX 也是通过它的“取处理程序”，即时去扫描 Cookie 请求头中的相关定义的。</p>
<p>想了解请看nginx变量使用方法详解2，下一篇nginx变量使用方法详解4</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(2)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-2.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-2,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>关于 Nginx 变量的另一个常见误区是认为变量容器的生命期，是与 location 配置块绑定的。其实不然。我们来看一个涉及“内部跳转”的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {
        listen 8080;

        location /foo {
            set $a hello;
            echo_exec /bar;
        }

        location /bar {
            echo "a = [$a]";
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>这里我们在 location /foo 中，使用第三方模块 ngx_echo 提供的 echo_exec 配置指令，发起到 location /bar 的“内部跳转”。所谓“内部跳转”，就是在处理请求的过程中，于服务器内部，从一个 location 跳转到另一个 location 的过程。这不同于利用 HTTP 状态码 301 和 302 所进行的“外部跳转”，因为后者是由 HTTP 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 URL 地址发生了变化。内部跳转和 Bourne Shell（或 Bash）中的 exec 命令很像，都是“有去无回”。另一个相近的例子是 C 语言中的 goto 语句。</p>
<p>既然是内部跳转，当前正在处理的请求就还是原来那个，只是当前的 location 发生了变化，所以还是原来的那一套 Nginx 变量的容器副本。对应到上例，如果我们请求的是 /foo 这个接口，那么整个工作流程是这样的：先在 location /foo 中通过 set 指令将 $a 变量的值赋为字符串 hello，然后通过 echo_exec 指令发起内部跳转，又进入到 location /bar 中，再输出 $a 变量的值。因为 $a 还是原来的 $a，所以我们可以期望得到 hello 这行输出。测试证实了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl localhost:8080/foo
a = [hello]</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>但如果我们从客户端直接访问 /bar 接口，就会得到空的 $a 变量的值，因为它依赖于 location /foo 来对 $a 进行初始化。</p>
<p>从上面这个例子我们看到，一个请求在其处理过程中，即使经历多个不同的 location 配置块，它使用的还是同一套 Nginx 变量的副本。这里，我们也首次涉及到了“内部跳转”这个概念。值得一提的是，标准 ngx_rewrite 模块的 rewrite 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 rewrite 配置指令可以改写成下面这样的形式：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {

        listen 8080;

        location /foo {
            set $a hello;
            rewrite ^ /bar;
        }

        location /bar {
            echo "a = [$a]";
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>其效果和使用 echo_exec 是完全相同的。后面我们还会专门介绍这个 rewrite 指令的更多用法，比如发起 301 和 302 这样的“外部跳转”。</p>
<p>从上面这个例子我们看到，Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 location 无关。</p>
<p>前面我们接触到的都是通过 set 指令隐式创建的 Nginx 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。既然有“用户自定义变量”，自然也就有由 Nginx 核心和各个 Nginx 模块提供的“预定义变量”，或者说“内建变量”（builtin variables）。</p>
<p>Nginx 内建变量最常见的用途就是获取关于请求或响应的各种信息。例如由 ngx_http_core 模块提供的内建变量 $uri，可以用来获取当前请求的 URI（经过解码，并且不含请求参数），而 $request_uri 则用来获取请求最原始的 URI （未经解码，并且包含请求参数）。请看下面这个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        echo "uri = $uri";
        echo "request_uri = $request_uri";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这里为了简单起见，连 server 配置块也省略了，和前面所有示例一样，我们监听的依然是 8080 端口。在这个例子里，我们把 $uri 和 $request_uri 的值输出到响应体中去。下面我们用不同的请求来测试一下这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/test'
uri = /test
request_uri = /test

$ curl 'http://localhost:8080/test?a=3&amp;b=4'
uri = /test
request_uri = /test?a=3&amp;b=4

$ curl 'http://localhost:8080/test/hello%20world?a=3&amp;b=4'
uri = /test/hello world
request_uri = /test/hello%20world?a=3&amp;b=4</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 arg_ 开头的所有变量，我们估且称之为 $arg_XXX 变量群。一个例子是 $arg_name，这个变量的值是当前请求名为 name 的 URI 参数的值，而且还是未解码的原始形式的值。我们来看一个比较完整的示例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        echo "name: $arg_name";
        echo "class: $arg_class";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>然后在命令行上使用各种参数组合去请求这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test'
    name: 
    class: 

    $ curl 'http://localhost:8080/test?name=Tom&amp;class=3'
    name: Tom
    class: 3

    $ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'
    name: hello%20world
    class: 9</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>其实 $arg_name 不仅可以匹配 name 参数，也可以匹配 NAME 参数，抑或是 Name，等等：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?NAME=Marry'
    name: Marry
    class: 

    $ curl 'http://localhost:8080/test?Name=Jimmy'
    name: Jimmy
    class:</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>Nginx 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式。</p>
<p>如果你想对 URI 参数值中的 %XX 这样的编码序列进行解码，可以使用第三方 ngx_set_misc 模块提供的 set_unescape_uri 配置指令：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    location /test {
        set_unescape_uri $name $arg_name;
        set_unescape_uri $class $arg_class;
        echo "name: $name";
        echo "class: $class";
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>现在我们再看一下效果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'
name: hello world
class: 9</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>空格果然被解码出来了！</p>
<p>从这个例子我们同时可以看到，这个 set_unescape_uri 指令也像 set 指令那样，拥有自动创建 Nginx 变量的功能。后面我们还会专门介绍到 ngx_set_misc 模块。</p>
<p>像 $arg_XXX 这种类型的变量拥有无穷无尽种可能的名字，所以它们并不对应任何存放值的容器。而且这种变量在 Nginx 核心中是经过特别处理的，第三方 Nginx 模块是不能提供这样充满魔法的内建变量的。</p>
<p>类似 $arg_XXX 的内建变量还有不少，比如用来取 cookie 值的 $cookie_XXX 变量群，用来取请求头的 $http_XXX 变量群，以及用来取响应头的 $sent_http_XXX 变量群。这里就不一一介绍了，感兴趣的读者可以参考 ngx_http_core 模块的官方文档。</p>
<p>需要指出的是，许多内建变量都是只读的，比如我们刚才介绍的 $uri 和 $request_uri. 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    $ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'
    name: hello world
    class: 9</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这个有问题的配置会让 Nginx 在启动的时候报出一条令人匪夷所思的错误：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[emerg] the duplicate "uri" variable in ...</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如果你尝试改写另外一些只读的内建变量，比如 $arg_XXX 变量，在某些 Nginx 的版本中甚至可能导致进程崩溃。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx变量使用方法详解(1)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-var-1.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-var-1,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>Nginx 的配置文件使用的就是一门微型的编程语言，许多真实世界里的 Nginx 配置文件其实就是一个一个的小程序。当然，是不是“图灵完全的”暂且不论，至少据我观察，它在设计上受 Perl 和 Bourne Shell 这两种语言的影响很大。在这一点上，相比 Apache 和 Lighttpd 等其他 Web 服务器的配置记法，不能不说算是 Nginx 的一大特色了。既然是编程语言，一般也就少不了“变量”这种东西（当然，Haskell 这样奇怪的函数式语言除外了）。</p>
<p>熟悉 Perl、Bourne Shell、C/C++ 等命令式编程语言的朋友肯定知道，变量说白了就是存放“值”的容器。而所谓“值”，在许多编程语言里，既可以是 3.14 这样的数值，也可以是 hello world 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。然而，在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。</p>
<p>比如我们的 nginx.conf 文件中有下面这一行配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>set $a "hello world";</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>我们使用了标准 ngx_rewrite 模块的 set 配置指令对变量 $a 进行了赋值操作。特别地，我们把字符串 hello world 赋给了它。</p>
<p>我们看到，Nginx 变量名前面有一个 $ 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 $ 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。</p>
<p>虽然 $ 这样的变量前缀修饰会让正统的 Java 和 C# 程序员不舒服，但这种表示方法的好处也是显而易见的，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>set $a hello;
set $b "$a, $a";</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这里我们通过已有的 Nginx 变量 $a 的值，来构造变量 $b 的值，于是这两条指令顺序执行完之后，$a 的值是 hello，而 $b 的值则是 hello, hello. 这种技术在 Perl 世界里被称为“变量插值”（variable interpolation），它让专门的字符串拼接运算符变得不再那么必要。我们在这里也不妨采用此术语。</p>
<p>我们来看一个比较完整的配置示例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen 8080;
location /test {
set $foo hello;
echo "foo: $foo";
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这个例子省略了 nginx.conf 配置文件中最外围的 http 配置块以及 events 配置块。使用 curl 这个 HTTP 客户端在命令行上请求这个 /test 接口，我们可以得到</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/test'
foo: hello</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这里我们使用第三方 ngx_echo 模块的 echo 配置指令将 $foo 变量的值作为当前请求的响应体输出。</p>
<p>我们看到，echo 配置指令的参数也支持“变量插值”。不过，需要说明的是，并非所有的配置指令都支持“变量插值”。事实上，指令参数是否允许“变量插值”，取决于该指令的实现模块。</p>
<p>如果我们想通过 echo 指令直接输出含有“美元符”（$）的字符串，那么有没有办法把特殊的 $ 字符给转义掉呢？答案是否定的（至少到目前最新的 Nginx 稳定版 1.0.10）。不过幸运的是，我们可以绕过这个限制，比如通过不支持“变量插值”的模块配置指令专门构造出取值为 $ 的 Nginx 变量，然后再在 echo 中使用这个变量。看下面这个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>geo $dollar {
default "$";
}
server {
listen 8080;
location /test {
echo "This is a dollar sign: $dollar";
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>测试结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/test'
This is a dollar sign: $</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这里用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 $dollar 赋予字符串 "$"，这样我们在下面需要使用美元符的地方，就直接引用我们的 $dollar 变量就可以了。其实 ngx_geo 模块最常规的用法是根据客户端的 IP 地址对指定的 Nginx 变量进行赋值，这里只是借用它以便“无条件地”对我们的 $dollar 变量赋予“美元符”这个值。</p>
<p>在“变量插值”的上下文中，还有一种特殊情况，即当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen 8080;
location /test {
set $first "hello ";
echo "${first}world";
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>这里，我们在 echo 配置指令的参数值中引用变量 $first 的时候，后面紧跟着 world 这个单词，所以如果直接写作 "$firstworld" 则 Nginx “变量插值”计算引擎会将之识别为引用了变量 $firstworld. 为了解决这个难题，Nginx 的字符串记法支持使用花括号在 $ 之后把变量名围起来，比如这里的 ${first}. 上面这个例子的输出是：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/test
hello world</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>set 指令（以及前面提到的 geo 指令）不仅有赋值的功能，它还有创建 Nginx 变量的副作用，即当作为赋值对象的变量尚不存在时，它会自动创建该变量。比如在上面这个例子中，如果 $a 这个变量尚未创建，则 set 指令会自动创建 $a 这个用户变量。如果我们不创建就直接使用它的值，则会报错。例如</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen 8080;
location /bad {
echo $foo;
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>此时 Nginx 服务器会拒绝加载配置:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[emerg] unknown "foo" variable</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>是的，我们甚至都无法启动服务！</p>
<p>有趣的是，Nginx 变量的创建和赋值操作发生在全然不同的时间阶段。Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；而赋值操作则只会发生在请求实际处理的时候。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。</p>
<p>Nginx 变量一旦创建，其变量名的可见范围就是整个 Nginx 配置，甚至可以跨越不同虚拟主机的 server 配置块。我们来看一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen 8080;
location /foo {
echo "foo = [$foo]";
}
location /bar {
set $foo 32;
echo "foo = [$foo]";
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>这里我们在 location /bar 中用 set 指令创建了变量 $foo，于是在整个配置文件中这个变量都是可见的，因此我们可以在 location /foo 中直接引用这个变量而不用担心 Nginx 会报错。</p>
<p>下面是在命令行上用 curl 工具访问这两个接口的结果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$ curl 'http://localhost:8080/foo'
foo = []

$ curl 'http://localhost:8080/bar'
foo = [32]

$ curl 'http://localhost:8080/foo'
foo = []</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p> </p>
<p>从这个例子我们可以看到，set 指令因为是在 location /bar 中使用的，所以赋值操作只会在访问 /bar 的请求中执行。而请求 /foo 接口时，我们总是得到空的 $foo 值，因为用户变量未赋值就输出的话，得到的便是空字符串。</p>
<p>从这个例子我们可以窥见的另一个重要特性是，Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰。比如前面我们请求了 /bar 接口后，$foo 变量被赋予了值 32，但它丝毫不会影响后续对 /foo 接口的请求所对应的 $foo 值（它仍然是空的！），因为各个请求都有自己独立的 $foo 变量的副本。</p>
<p>对于 Nginx 新手来说，最常见的错误之一，就是将 Nginx 变量理解成某种在请求之间全局共享的东西，或者说“全局变量”。而事实上，Nginx 变量的生命期是不可能跨越请求边界的。</p>
<p>文章转自：http://blog.sina.com.cn/s/blog_6d579ff40100wi7p.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx tcp代理-nginx案例]]></title>
      <url>/nginx/nginx/nginx-tcp-proxy.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-tcp-proxy,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx tcp代理功能由nginx_tcp_proxy_module模块提供，同时监测后端主机状态。该模块包括的模块有： ngx_tcp_module, ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module, ngx_tcp_upstream_ip_hash_module。</p>
<h3>1. 安装</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx.org/download/nginx-1.4.4.tar.gz
# tar zxvf nginx-1.4.4.tar.gz
# cd nginx-1.4.4
# ./configure --add-module=/path/to/nginx_tcp_proxy_module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3>2. 配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
    listen 80;
    location /status {
        check_status;
    }
}
tcp {
    upstream cluster_www_ttlsa_com {
        # simple round-robin
        server 127.0.0.1:1234;
        check interval=3000 rise=2 fall=5 timeout=1000;
        #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;
        #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
        #check_http_send "GET / HTTP/1.0\r\n\r\n";
        #check_http_expect_alive http_2xx http_3xx;
    }
    server {
        listen 8888;
        proxy_pass cluster_www_ttlsa_com;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>这会出现一个问题，就是tcp连接会掉线。原因在于当服务端关闭连接的时候，客户端不可能立刻发觉连接已经被关闭，需要等到当Nginx在执行check规则时认为服务端链接关闭，此时nginx会关闭与客户端的连接。</p>
<h3>3. 保持连接配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
    listen 80;
    location /status {
        check_status;
    }
}
tcp {
	timeout 1d;
    proxy_read_timeout 10d;
    proxy_send_timeout 10d;
    proxy_connect_timeout 30;
    upstream cluster_www_ttlsa_com {
        # simple round-robin
        server 127.0.0.1:1234;
        check interval=3000 rise=2 fall=5 timeout=1000;
        #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;
        #check interval=3000 rise=2 fall=5 timeout=1000 type=http;
        #check_http_send "GET / HTTP/1.0\r\n\r\n";
        #check_http_expect_alive http_2xx http_3xx;
    }
    server {
        listen 8888;
        proxy_pass cluster_www_ttlsa_com;
		so_keepalive on;
        tcp_nodelay on;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>nginx_tcp_proxy_module模块指令具体参见: http://yaoweibin.github.io/nginx_tcp_proxy_module/README.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx限速白名单配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-speed-white-list-configuration.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-speed-white-list-configuration,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>在《nginx限制连接数ngx_http_limit_conn_module模块》和《nginx限制请求数ngx_http_limit_req_module模块》中会对所有的IP进行限制。在某些情况下，我们不希望对某些IP进行限制，如自己的反代服务器IP，公司IP等等。这就需要白名单，将特定的IP加入到白名单中。下面来看看nginx白名单实现方法，需要结合geo和map指令来实现。geo和map指令使用方法参见下面文章。《nginx geo使用方法》和《nginx map使用方法》。不扯蛋了，看配置。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	geo $whiteiplist  {
		default 1;
		127.0.0.1 0;
		10.0.0.0/8 0;
		121.207.242.0/24 0;
	}

	map $whiteiplist  $limit {
		1 $binary_remote_addr;
		0 "";
	}

	limit_conn_zone $limit zone=limit:10m;

	server {
        listen       8080;
        server_name  test.ttlsa.com;

        location ^~ /ttlsa.com/ {
                limit_conn limit 4;
                limit_rate 200k;
                alias /data/www.ttlsa.com/data/download/;
        }
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>技术要点：<br>
1. geo指令定义一个白名单$whiteiplist, 默认值为1, 所有都受限制。 如果客户端IP与白名单列出的IP相匹配，则$whiteiplist值为0也就是不受限制。<br>
2. map指令是将$whiteiplist值为1的，也就是受限制的IP，映射为客户端IP。将$whiteiplist值为0的，也就是白名单IP，映射为空的字符串。<br>
3. limit_conn_zone和limit_req_zone指令对于键为空值的将会被忽略，从而实现对于列出来的IP不做限制。</p>
<p>测试方法：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ab -c 100 -n 300 http://test.ttlsa.com:8080/ttlsa.com/docs/pdf/nginx_guide.pdf</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如需转载请注明出处：http://www.ttlsa.com/html/3230.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx root&alias文件路径配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-root_alias-file-path-configuration.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-root_alias-file-path-configuration,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p><span>nginx指定文件路径有两种方式root和alias，这两者的用法区别，使用方法总结了下，方便大家在应用过程中，快速响应。root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</span></p>
<p>[root]<br>
语法：root path<br>
默认值：root html<br>
配置段：http、server、location、if</p>
<p>[alias]<br>
语法：alias path<br>
配置段：location</p>
<p>实例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~ ^/weblogs/ {
		root /data/weblogs/www.ttlsa.com;
		autoindex on;
		auth_basic            "Restricted";
		auth_basic_user_file  passwd/weblogs;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>如果一个请求的URI是/weblogs/httplogs/www.ttlsa.com-access.log时，web服务器将会返回服务器上的/data/weblogs/www.ttlsa.com/weblogs/httplogs/www.ttlsa.com-access.log的文件。<br>
[info]root会根据完整的URI请求来映射，也就是/path/uri。[/info]<br>
因此，前面的请求映射为path/weblogs/httplogs/www.ttlsa.com-access.log。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ^~ /binapp/ {  
		limit_conn limit 4;
		limit_rate 200k;
		internal;  
		alias /data/statics/bin/apps/;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。如果一个请求的URI是/binapp/a.ttlsa.com/favicon时，web服务器将会返回服务器上的/data/statics/bin/apps/a.ttlsa.com/favicon.jgp的文件。<br>
[warning]1. 使用alias时，目录名后面一定要加"/"。<br>
2. alias可以指定任何名称。<br>
3. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。<br>
4. alias只能位于location块中。[/warning]</p>
<p>如需转载请注明出处：  http://www.ttlsa.com/html/2907.html</p>
<p> </p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx重写规则指南-nginx案例]]></title>
      <url>/nginx/nginx/nginx-rewriting-rules-guide.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-rewriting-rules-guide,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>当运维遇到要重写情况时，往往是要程序员把重写规则写好后，发给你，你再到生产环境下配置。对于重写规则说到底就是正则匹配，做运维的岂能对正则表达式不了解的？最起码最基本的正则表达式会写。套用一句阿里的话(某网友说是阿里说的，不清楚到底是不是出自阿里)“不懂程序的运维，不是好运维；不懂运维的开发，不是好开发。”。 正则表达式也是一门语言哈。当你学习一门语言时，必然会遇到该门语言的正则表达式这章节的。 在这里推荐一本非常好的正则表达式书，包含常用的语言的正则写法如sed、perl、bash、awk、php、c#、java、javascript、python、ruby等等，《Regular Expressions Cookbook, 2nd Edition》，也有中文版的，大家可以到网络上找找。<br>
介绍nginx的重写模块，创建重写规则向导，便于快捷正确的创建新的重写规则，不求救于人。同时，如果想把apache转换成nginx，重写规则也是要改的咯。</p>
<h3><span><strong>一. rewrite模块介绍</strong></span></h3>
<p>nginx的重写模块是一个简单的正则表达式匹配与一个虚拟堆叠机结合。依赖于PCRE库，因此需要安装pcre。根据相关变量重定向和选择不同的配置，从一个location跳转到另一个location，不过这样的循环最多可以执行10次，超过后nginx将返回500错误。同时，重写模块包含set指令，来创建新的变量并设其值，这在有些情景下非常有用的，如记录条件标识、传递参数到其他location、记录做了什么等等。</p>
<h3><span><strong>二. rewrite模块指令</strong></span></h3>
<p>break<br>
语法：break<br>
默认值：none<br>
使用字段：server, location, if<br>
完成当前设置的重写规则，停止执行其他的重写规则。</p>
<p>if<br>
语法：if (condition) { … }<br>
默认值：none<br>
使用字段：server, location<br>
注意：尽量考虑使用trp_files代替。<br>
判断的条件可以有以下值：<br>
1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为false。<br>
2. 字符串比较：使用=或!=运算符<br>
3. 正则表达式匹配：使用~(区分大小写)和~*(不区分大小写)，取反运算!~和!~*。<br>
4. 文件是否存在：使用-f和!-f操作符<br>
5. 目录是否存在：使用-d和!-d操作符<br>
7. 文件、目录、符号链接是否存在：使用-e和!-e操作符<br>
8. 文件是否可执行：使用-x和!-x操作符</p>
<p>return<br>
语法：return code<br>
默认值：none<br>
使用字段：server, location, if<br>
停止处理并为客户端返回状态码。非标准的444状态码将关闭连接，不发送任何响应头。可以使用的状态码有：204，400，402-406，408，410, 411, 413, 416与500-504。如果状态码附带文字段落，该文本将被放置在响应主体。相反，如果状态码后面是一个URL，该URL将成为location头补值。没有状态码的URL将被视为一个302状态码。</p>
<p>rewrite<br>
语法：rewrite regex replacement flag<br>
默认值：none<br>
使用字段：server, location, if<br>
按照相关的正则表达式与字符串修改URI，指令按照在配置文件中出现的顺序执行。可以在重写指令后面添加标记。<br>
注意：如果替换的字符串以http://开头，请求将被重定向，并且不再执行多余的rewrite指令。<br>
尾部的标记(flag)可以是以下的值：<br>
last - 停止处理重写模块指令，之后搜索location与更改后的URI匹配。<br>
break - 完成重写指令。<br>
redirect - 返回302临时重定向，如果替换字段用http://开头则被使用。<br>
permanent - 返回301永久重定向。</p>
<p>rewrite_log<br>
语法：rewrite_log on | off<br>
默认值：rewrite_log off<br>
使用字段：server, location, if<br>
变量：无<br>
启用时将在error log中记录notice级别的重写日志。</p>
<p>set<br>
语法：set variable value<br>
默认值：none<br>
使用字段：server, location, if<br>
为给定的变量设置一个特定值。</p>
<p>uninitialized_variable_warn<br>
语法：uninitialized_variable_warn on|off<br>
默认值：uninitialized_variable_warn on<br>
使用字段：http, server, location, if<br>
控制是否记录未初始化变量的警告信息。</p>
<h3><span>三. 重写规则组成部分</span></h3>
<p>3.1 任何重写规则的第一部分都是一个正则表达式<br>
可以使用括号来捕获，后续可以根据位置来将其引用，位置变量值取决于捕获正则表达式中的顺序，$1引用第一个括号中的值，$2引用第二个括号中的值，以此类推。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>$1是两个小写字母组成的字符串，$2是由小写字母和0到9的数字组成的5个字符的字符串，$3将是个文件名，$4是png、jpg、gif中的其中一个。</p>
<p>3.2 重写规则的第二部分是URI<br>
请求被改写。该URI可能包含正则表达式中的捕获的位置参数或这个级别下的nginx任何配置变量。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/data?file=$3.$4</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果这个URI不匹配nginx配置的任何location，那么将给客户端返回301(永久重定向)或302(临时重定向)的状态码来表示重定向类型。该状态码可以通过第三个参数来明确指定。</p>
<p>3.3 重写规则的第三部分<br>
第三部分也就是尾部的标记(flag)。 last标记将导致重写后的URI搜索匹配nginx的其他location，最多可循环10次。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4 last;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>break指令可以当做自身指令。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>if ($bwhog) {
	limit_rate 300k;
	break;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>另一个停止重写模块处理指令是return， 来控制主HTTP模块处理请求。 这意味着，nginx直接返回信息给客户端，与error_page结合为客户端呈现格式化的HTML页面或激活不同的模块来完成请求。如果状态码附带文字段落，该文本将被放置在响应主体。相反，如果状态码后面是一个URL，该URL将成为location头补值。没有状态码的URL将被视为一个302状态码。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location = /image404.html {
	return 404 "image not found\n";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><span><strong>四.</strong> 实例</span></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	# 定义image日志格式
	log_format imagelog '[$time_local] ' $image_file ' ' $image_type ' ' $body_bytes_sent ' ' $status;
	# 开启重写日志
	rewrite_log on;

	server {
		root /home/www;

		location / {
				# 重写规则信息
				error_log logs/rewrite.log notice;  
				# 注意这里要用‘’单引号引起来，避免{}
				rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4;
				# 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行
				set $image_file $3;
				set $image_type $4;
		}

		location /data {
				# 指定针对图片的日志格式，来分析图片类型和大小
				access_log logs/images.log mian;
				root /data/images;
				# 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里
				try_files /$arg_file /image404.html;
		}
		location = /image404.html {
				# 图片不存在返回特定的信息
				return 404 "image not found\n";
		}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0013 seconds] -->
<p></p>
<h3><span><strong>五.</strong> 创建新的重新规则</span></h3>
<p>在接到要创建新的重写规则时，要弄清楚需求是什么样的，再决定怎么做。毕竟重写也是耗资源的有效率之分的。 下面的这些问题有些帮助的：<br>
1. 你的URL的模式是什么样的?<br>
2. 是否有一个以上的方法来实现？<br>
3. 是否需要捕获URL部分作为变量？<br>
4. 重定向到另一个web上可以看到我的规则？<br>
5. 是否要替换查询的字符串参数？</p>
<p>检查网站或应用程序布局，清楚URL模式。啰嗦一句：我一而再再而三的强调，运维不能与开发脱节，运维要参与到开发当中。如果有不止一种方法实现，创建一个永久重定向。同时，定义一个重写规范，来使网址清洁，还可以帮助网站更容易被找到。</p>
<p>实例1. 要将home目录重定向到主页面上，目录结构如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/
/home
/home/
/home/index
/home/index/
/index
/index.php
/index.php/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>重写规则如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>rewrite ^/(home(/index)?|index(\.php)?)/?$ $scheme://$host/ permanent;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>指定$scheme和$host变量，因为要做一个永久重定向并希望nginx使用相同的参数来构造URL。</p>
<p>实例2. 如果想分别记录各个部分的URL，可以使用正则表达式来捕获URI，然后，给变量分配指定位置变量，见上面的实例。</p>
<p>实例3. 当重写规则导致内部重定向或指示客户端调用该规则本身被定义的location时，必须采取特殊的动作来避免重写循环。如：在server配置段定义了一条规则带上last标志，在引用location时，必须使用break标志。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
	rewrite ^(/images)/(.*)\.(png|jpg|gif)$ $1/$3/$2.$3 last;
	location /images/ {
		rewrite ^(/images)/(.*)\.(png|jpg|gif)$ $1/$3/$2.$3 break;
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>实例4. 作为重写规则的一部分，传递新的查询字符串参数是使用重写规则的目标之一。 如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>rewrite ^/images/(.*)_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=$3? last;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>nginx重写规则说起来挺简单的，做起来就难，重点在于正则表达式，同时，还需要考虑到nginx执行顺序。有疑问的朋友，欢迎加入ttlsa群，一起讨论，联系方式在网站中有，也可以跟帖说明。</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx实现图片防盗链(referer指令)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-referer.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-referer,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>前几天讲了《nginx下载防盗链》，今天继续说下图片防盗链. 他们两个使用的指令不同，前者使用secure link,并且需要程序配合,但是效果非常好;后者不需要程序配合,根据图片来源来实现,但是只能先限制基本的图片盗用,无法防止图片采集.</p>
<h3><strong>nginx</strong> referer指令简介</h3>
<p>nginx模块ngx_http_referer_module通常用于阻挡来源非法的域名请求.我们应该牢记,伪装Referer头部是非常简单的事情，所以这个模块只能用于阻止大部分非法请求.我们应该记住，有些合法的请求是不会带referer来源头部的,所以有时候不要拒绝来源头部（referer）为空的请求.</p>
<h3>图片防盗链配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~* \.(gif|jpg|png|bmp)$ {
    valid_referers none blocked *.ttlsa.com server_names ~\.google\. ~\.baidu\.;
    if ($invalid_referer) {
        return 403;
        #rewrite ^/ http://www.ttlsa.com/403.jpg;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>以上所有来至ttlsa.com和域名中包含google和baidu的站点都可以访问到当前站点的图片,如果来源域名不在这个列表中，那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面,如果使用下面的rewrite，那么盗链的图片都会显示403.jpg。如果用户直接在浏览器输入你的图片地址,那么图片显示正常，因为它符合none这个规则.</p>
<h3>nginx防盗链指令</h3>
<p>语法: referer_hash_bucket_size size;<br>
默认值: referer_hash_bucket_size 64;<br>
配置段: server, location<br>
这个指令在nginx 1.0.5中开始出现.<br>
Sets the bucket size for the valid referers hash tables. The details of setting up hash tables are provided in a separate document.</p>
<p>语法:     referer_hash_max_size size;<br>
默认值:     referer_hash_max_size 2048;<br>
配置段:     server, location<br>
这个指令在nginx 1.0.5中开始出现.<br>
Sets the maximum size of the valid referers hash tables. The details of setting up hash tables are provided in a separate document.</p>
<p>语法: valid_referers none | blocked | server_names | string ...;<br>
默认值: —<br>
配置段: server, location<br>
指定合法的来源'referer', 他决定了内置变量$invalid_referer的值，如果referer头部包含在这个合法网址里面，这个变量被设置为0，否则设置为1.记住，不区分大小写的.</p>
<h3><strong>参数说明</strong></h3>
<p>none<br>
“Referer” 来源头部为空的情况<br>
blocked<br>
“Referer”来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都不以http://或者https://开头.<br>
server_names<br>
“Referer”来源头部包含当前的server_names（当前域名）<br>
arbitrary string<br>
任意字符串,定义服务器名或者可选的URI前缀.主机名可以使用*开头或者结尾，在检测来源头部这个过程中，来源域名中的主机端口将会被忽略掉<br>
regular expression<br>
正则表达式,~表示排除https://或http://开头的字符串.</p>
<h3><strong>最后</strong></h3>
<p>图片使用来源头部做防盗链是最合理的. 简单、实用。但是没有办法防采集。如果想做文件的防盗链请参考前面章节讲到的使用secure link文件防盗链文章.</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx正向代理-nginx案例]]></title>
      <url>/nginx/nginx/nginx-positive-proxy.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-positive-proxy,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>我们平时用的最多的最常见的是反向代理。反向代理想必都会配置的，有不会的可以到本博客里面搜索下，有相关文档。 那么nginx的正向代理是如何配置的呢？</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
	listen 8090;
	location / {
			resolver 218.85.157.99 218.85.152.99;
			resolver_timeout 30s;
			proxy_pass http://$host$request_uri;
	}
	access_log  /data/httplogs/proxy-$host-aceess.log;      
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>就这么简单哈。</p>
<p>测试：<br>
http://www.ttlsa.com:8090</p>
<p>resolver指令<br>
语法: resolver address ... [valid=time];<br>
默认值: —<br>
配置段: http, server, location<br>
配置DNS服务器IP地址。可以指定多个，以轮询方式请求。<br>
nginx会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的TTL字段的值，可以通过valid参数更改。</p>
<p>resolver_timeout指令<br>
语法: resolver_timeout time;<br>
默认值: resolver_timeout 30s;<br>
配置段: http, server, location<br>
解析超时时间。</p>
<p>如需转载请注明出处：http://www.ttlsa.com/html/3287.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+PHP 5.5-nginx案例]]></title>
      <url>/nginx/nginx/nginx-php-5_5.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-php-5_5,<br><a id="more"></a><br>
  <span><fieldset><legend>摘要</legend><p>PHP从一开始的php 5.2到现在的5.3/5.4/5.5.起草这篇文章的时候发现官方已经停止了5.3的开发,最后的版本定格到了5.3.27,只会修复一些bug，宣告了5.3寿终正寝了.并且建议大家升级到5.4或者5.5, 鉴于版本更新得如此之快,决定写一片nginx连接php5.5的文章.于是乎,本草文写完了.  1. 安装PHP 5.5.0       下载</p>
<div></div></fieldset></span>
							<div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>这两年IT更新换代的速度太快了,nginx从2年前的1.0版本到现在的1.5版本，各个版本共同开发。PHP从一开始的php 5.2到现在的5.3/5.4/5.5.起草这篇文章的时候发现官方已经停止了5.3的开发,最后的版本定格到了5.3.27,只会修复一些bug，宣告了5.3寿终正寝了.并且建议大家升级到5.4或者5.5, 鉴于版本更新得如此之快,决定写一片<strong>nginx连接php5.5</strong>的文章.于是乎,本草文写完了.</p>
<h3>1. <strong>安装PHP 5.5.0</strong></h3>
<ul>
<li> 下载</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>cd /usr/local/src/
wget http://www.php.net/get/php-5.5.0.tar.bz2/from/jp1.php.net/mirror</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p># 如果以上PHP不存在了,大家可以直接到官方下载. 如果还是找不到可以留言,我将会通过邮箱发送.</p>
<ul>
<li>安装依赖包</li>
</ul>
<p>确保安装之前有安装gd,png,curl,xml等等lib开发库。如果不确定，执行以下命令：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>yum install gcc make gd-devel libjpeg-devel libpng-devel libxml2-devel bzip2-devel libcurl-devel -y</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<ul>
<li>编译安装PHP 5.5.0</li>
</ul>
<p>以下参数支持,ftp,图片函数,pdo等支持,因为使用了php自带的mysqlnd，所以不需要额外安装mysql的lib库了.如果你是64位系统，参数后面加上--with-libdir=lib64，如果不是可以跳过。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>tar -xjf php-5.5.0.tar.bz2
cd php-5.5.0
./configure --prefix=/usr/local/php-5.5.0 --with-config-file-path=/usr/local/php-5.5.0/etc --with-bz2 --with-curl --enable-ftp --enable-sockets --disable-ipv6 --with-gd --with-jpeg-dir=/usr/local --with-png-dir=/usr/local --with-freetype-dir=/usr/local --enable-gd-native-ttf --with-iconv-dir=/usr/local --enable-mbstring --enable-calendar --with-gettext --with-libxml-dir=/usr/local --with-zlib --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-mysql=mysqlnd --enable-dom --enable-xml --enable-fpm --with-libdir=lib64
make
make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>备注：如果PHP不需要curl和ftp的支持,可以将以上的--with-curl --enable-ftp去掉. 如果你是专业的linux从业人员,你完全可以看着help来选择你的安装参数，如果你不是的话,我建议你直接复制黏贴我的配置参数.这样可以少走一些弯路.</p>
<ul>
<li>配置php</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>cp php.ini-production /usr/local/php-5.5.0/etc/php.ini
cp /usr/local/php-5.5.0/etc/php-fpm.conf.default /usr/local/php-5.5.0/etc/php-fpm.conf</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<ul>
<li>启动php-fpm</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/php-5.5.0/sbin/php-fpm</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>执行以上命令，如果没报错一般情况下表示启动正常,如果不放心,也可以通过端口判断是PHP否启动</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># netstat -lnt | grep 9000
tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3>2、安装配置nginx</h3>
<ul>
<li>安装nginx</li>
</ul>
<p>请看&lt;ttlsa教程系列之nginx - nginx安装&gt;</p>
<ul>
<li> 配置测试站点test.ttlsa.com</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>mkdir /data/logs/nginx/ # 用于存放nginx日志.请看2.3的配置文件
mkdir -p /data/site/test.ttlsa.com/ # 站点根目录
vim /data/site/test.ttlsa.com/info.php
<?php phpinfo();
></pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p><!--?php 	echo "test php"; 	?--><br>
保存退出</p>
<ul>
<li>nginx配置</li>
</ul>
<p>在nginx.conf的http断中加上如下内容：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen 80;
server_name test.ttlsa.com;
access_log /data/logs/nginx/test.ttlsa.com.access.log main;

index index.php index.html index.html;
root /data/site/test.ttlsa.com;

location /
{
try_files $uri $uri/ /index.php?$args;
}

location ~ .*\.(php)?$
{
expires -1s;
try_files $uri =404;
fastcgi_split_path_info ^(.+\.php)(/.+)$;
include fastcgi_params;
fastcgi_param PATH_INFO $fastcgi_path_info;
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
fastcgi_pass 127.0.0.1:9000;

}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<ul>
<li>配置讲解</li>
</ul>
<p>nginx将会连接回环地址9000端口执行PHP文件,需要使用tcp/ip协议,速度比较慢.建议大家换成使用socket方式连接。将fastcgi_pass 127.0.0.1:9000;改成fastcgi_pass unix:/var/run/phpfpm.sock;</p>
<ul>
<li>启动nginx</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.4.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>3. 访问测试</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://test.ttlsa.com/info.php
test php</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>出现如上内容,说明PHP安装完成。</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+video-thumbextractor生成视频缩略图-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-video-thumbextractor.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-video-thumbextractor,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3>前言</h3>
<p>这年头都看网络视频吧,优酷,搜狐,土豆,爱奇艺.打开页面都能看到视频的一个截图，这些图片怎么来的，难道是用暴风影音截图弄出来的?不是吧，一般是用服务器上的程序截图之后传到图片服务器上了。可以用php、java等等来生成视频缩略图，nginx也有这方面的功能，一起来探索一下。</p>
<h3>系统环境</h3>
<p>Linux:centos 5/6<br>
ImageMagick：yum安装<br>
LibJpeg： v8<br>
地址：http://www.ijg.org/files/<br>
nginx：1.4.2<br>
地址：http://nginx.org/en/download.html<br>
nginx-video-thumbextractor：v0.1.0 .<br>
地址：https://github.com/wandenberg/nginx-video-thumbextractor-module</p>
<h3>支持格式</h3>
<p>mp4, mov and flv.</p>
<h3>最小图片</h3>
<p>最小能生成16x16的图片</p>
<h3>软件安装</h3>
<p>安装ImageMagick</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># yum install ImageMagick* ImageMagick-*</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>安装libjpeg</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://www.ijg.org/files/jpegsrc.v8.tar.gz
# tar -xzvf jpegsrc.v8.tar.gz
# cd jpeg-8/
# ./configure --enable-static --enable-shared
# make
#make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>安装yasm</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget https://github.com/yasm/yasm/archive/master.zip
# unzip master.zip
#cd yasm-master
# ./configure
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>安装ffmpeg</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://ffmpeg.org/releases/ffmpeg-2.0.1.tar.gz
# tar -xzvf ffmpeg-2.0.1.tar.gz
# cd ffmpeg
# ./configure --prefix=/usr --disable-ffserver --disable-ffplay --enable-shared
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>安装nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget https://codeload.github.com/wandenberg/nginx-video-thumbextractor-module/zip/master -O nginx-video-thumbextractor-module-master.zip
# unzip nginx-video-thumbextractor-module-master.zip
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
＃cd nginx-1.4.2
# ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../nginx-video-thumbextractor-module-master --with-cc-opt='-I /usr/include/ImageMagick'
# make 
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>nginx配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {

        listen       80;
        server_name  test.ttlsa.com;
        access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;

        index index.html index.php index.html;
        root /data/site/test.ttlsa.com;

        location / {

        }

        location ~ /2687/(.*)
        {
                alias /data/site/test.ttlsa.com/2687/;
                video_thumbextractor;
                video_thumbextractor_video_filename    $1;
                video_thumbextractor_video_second      $arg_second;
                video_thumbextractor_image_width       $arg_width;
                video_thumbextractor_image_height      $arg_height;
        }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<h3></h3>
<h3>测试</h3>
<p>创建站点目录</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># mkdir /data/site/test.ttlsa.com/2687/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>上传文件到这个目录下，我传的是v_baofeng.mp4</p>
<p>访问<br>
下面三种访问方式都是正确的.second这个才是是必填的,否则会出现400错误.<br>
http://test.ttlsa.com/2687/v_baofeng.mp4?second=77&amp;width=400&amp;height=200</p>
<div><p>nginx视频缩略图-1</p></div>
<p>http://test.ttlsa.com/2687/v_baofeng.mp4?second=77&amp;width=300</p>
<div><p>nginx视频缩略图-2</p></div>
<p>http://test.ttlsa.com/2687/v_baofeng.mp4?second=77&amp;height=100</p>
<div><p>nginx视频缩略图-3</p></div>
<p>说明：second视频中的时间点，秒为单位。width生成的图片宽度，height生成图片高度。两个参数都设置会裁切图片，如果只设置一个那么会根据那个参数等了比例生成图片.</p>
<h3>指令</h3>
<p>video_thumbextractor</p>
<p>语法: video_thumbextractor<br>
配置段: location<br>
发行版本: 0.1.0<br>
开启缩略图功能</p>
<p>video_thumbextractor_video_filename<br>
语法: video_thumbextractor_video_filename filename<br>
默认值: none<br>
配置段: http<br>
发行版本: 0.1.0<br>
文件名,如果文件不存在会返回404</p>
<p>video_thumbextractor_video_second<br>
语法: video_thumbextractor_video_second second<br>
默认值: none<br>
配置段: http<br>
发行版本: 0.1.0<br>
取某一秒的关键帧,如果指定的时间超过了视频的长度，将会返回404.如果未指定这个值将会返回400错误.</p>
<p>video_thumbextractor_image_width<br>
语法: video_thumbextractor_image_width width<br>
默认值: 0<br>
配置段: http<br>
发行版本: 0.1.0<br>
生成图片的宽度，这是一个可选项.如果仅仅指定了宽度，那么图片高度会按原比例缩放</p>
<p>video_thumbextractor_image_height<br>
语法: video_thumbextractor_image_height height<br>
默认值: 0<br>
配置段: http<br>
发行版本: 0.1.0</p>
<p>生成图片的高度，这是一个可选项.如果仅仅指定了高度，那么图片宽度会按原比例缩放<br>
如果这两项都指定了，那么会裁切图片.到时候大家看到的图片可能就是残缺的.</p>
<h3>常见错误</h3>
<p>1、Wrong JPEG library version: library is 80, caller expects 62<br>
JPEG版本不匹配，需要安装v8版本。</p>
<p>安装过程麻烦了一点，但是配置和使用非常简单。用户上传视频到视频服务器上之后，使用这个方法就可以去到视频的缩略图了.是不是很简单</p>
<p>转载请注明出处：http://www.ttlsa.com/html/2687.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx上传模块—nginx upload module-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-upload-module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-upload-module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx上传模块</p>
<p>一. nginx upload module原理</p>
<p>官方文档： http://www.grid.net.ru/nginx/upload.en.html</p>
<p>Nginx upload module通过nginx服务来接受用户上传的文件，自动解析请求体中存储的所有文件上传到upload_store指定的目录下。这些文件信息从原始请求体中分离并根据nginx.conf中的配置重新组装好上传参数，交由upload_pass指定的段处理，从而允许处理任意上传文件。每个上传文件中的file字段值被一系列的upload_set_form_field指令值替换。每个上传文件的内容可以从$upload_tmp_path变量读取，或者可以将文件转移到目的目录下。上传的文件移除可以通过upload_cleanup指令控制。如果请求的方法不是POST，模块将返回405错误(405 Not Allowed)，该错误提示可以通过error_page指令处理。</p>
<p>具体的过程如下：</p>
<p>1. 用户访问能够选择上传文件的页面</p>
<p>2. 用户提交表单</p>
<p>3. 浏览器把文件和有关文件的信息作为请求的一部分发送给服务器</p>
<p>4. 服务器把文件保存到临时存储目录下upload_store</p>
<p>5. upload_pass指定的处理表单提交的php页面将文件从upload_store拷贝到持久存储位置</p>
<p>二.nginx upload module配置参数</p>
<p>upload_pass 指明后续处理的php地址。文件中的字段将被分离和取代，包含必要的信息处理上传文件。</p>
<p>upload_resumable 是否启动可恢复上传。</p>
<p>upload_store 指定上传文件存放地址(目录)。目录可以散列，在这种情况下，在nginx启动前，所有的子目录必须存在。</p>
<p>upload_state_store 指定保存上传文件可恢复上传的文件状态信息目录。目录可以散列，在这种情况下，在nginx启动前，所有的子目录必须存在。</p>
<p>upload_store_access 上传文件的访问权限，user:r是指用户可读</p>
<p>upload_pass_form_field 从表单原样转到后端的参数，可以正则表达式表示。：</p>
<p>$upload_field_name -- 原始文件中的字段的名称</p>
<p>upload_pass_form_field "^submit$|^description$";</p>
<p>意思是把submit，description这两个字段也原样通过upload_pass传递到后端php处理。如果希望把所有的表单字段都传给后端可以用upload_pass_form_field "^.*$";</p>
<p>upload_set_form_field 名称和值都可能包含以下特殊变量：</p>
<p>$upload_field_name 表单的name值</p>
<p>$upload_content_type 上传文件的类型</p>
<p>$upload_file_name 客户端上传的原始文件名称</p>
<p>$upload_tmp_path 文件上传后保存在服务端的位置</p>
<p>upload_aggregate_form_field 可以多使用的几个变量,文件接收完毕后生成的并传递到后端</p>
<p>$upload_file_md5 文件的MD5校验值</p>
<p>$upload_file_md5_uc 大写字母表示的MD5校验值</p>
<p>$upload_file_sha1 文件的SHA1校验值</p>
<p>$upload_file_sha1_uc 大写字母表示的SHA1校验值</p>
<p>$upload_file_crc32 16进制表示的文件CRC32值</p>
<p>$upload_file_size 文件大小</p>
<p>$upload_file_number 请求体中的文件序号</p>
<p>这些字段值是在文件成功上传后计算的。</p>
<p>upload_cleanup 如果出现400 404 499 500-505之类的错误，则删除上传的文件</p>
<p>upload_buffer_size 上传缓冲区大小</p>
<p>upload_max_part_header_len 指定头部分最大长度字节。</p>
<p>upload_max_file_size 指定上传文件最大大小，软限制。client_max_body_size硬限制。</p>
<p>upload_limit_rate 上传限速，如果设置为0则表示不限制。</p>
<p>upload_max_output_body_len 超过这个大小，将报403错(Request entity too large)。</p>
<p>upload_tame_arrays 指定文件字段名的方括号是否删除</p>
<p>upload_pass_args 是否转发参数。</p>
<p>三. nginx配置</p>
<p># wget http://www.nginx.org/download/nginx-1.2.2.tar.gz</p>
<p># wget http://www.grid.net.ru/nginx/download/nginx_upload_module-2.2.0.tar.gz</p>
<p># tar zxvf nginx_upload_module-2.2.0.tar.gz -c ../software/</p>
<p># tar zxvf nginx_upload_module-2.2.0.tar.gz -C ../software/</p>
<p># ./configure --prefix=/usr/local/nginx --add-module=../nginx_upload_module-2.2.0 --with-http_secure_link_module</p>
<p># make</p>
<p># make install</p>
<p># vi nginx.conf</p>
<p>user www-data;</p>
<p>worker_processes 20;</p>
<p>error_log logs/error.log notice;</p>
<p>working_directory /usr/local/nginx;</p>
<p>events {</p>
<p>worker_connections 1024;</p>
<p>}</p>
<p>http {</p>
<p>include mime.types;</p>
<p>default_type application/octet-stream;</p>
<p>root /www/web/upload;</p>
<p>server {</p>
<p>listen 80;</p>
<p>server_name 192.168.41.129;</p>
<p> </p>
<p>error_page 405 =200 @405; //处理405错误</p>
<p>location / {</p>
<p>index index.html index.htm index.php;</p>
<p>}</p>
<p>location @405</p>
<p>{</p>
<p>root /www/web/upload;</p>
<p>}</p>
<p>location ~ \.php$ {</p>
<p>try_files $uri /404.html;</p>
<p>fastcgi_pass 127.0.0.1:9000;</p>
<p>fastcgi_index index.php;</p>
<p>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</p>
<p>include /etc/nginx/fastcgi_params;</p>
<p>}</p>
<p>client_max_body_size 100m;</p>
<p># 上传页面提交到这个location</p>
<p>location /upload {</p>
<p># 文件上传以后转交给后端的php代码处理</p>
<p>upload_pass @test;</p>
<p># 上传文件的临时存储位置，目录是散列的，应该存在子目录0 1 2 3 4 5 6 7 8 9</p>
<p>upload_store /www/web/upload/tmp 1;</p>
<p>upload_store_access user:r;</p>
<p># 设置请求体的字段</p>
<p>upload_set_form_field "${upload_field_name}_name" $upload_file_name;</p>
<p>upload_set_form_field "${upload_field_name}_content_type" $upload_content_type;</p>
<p>upload_set_form_field "${upload_field_name}_path" $upload_tmp_path;</p>
<p># 指示后端关于上传文件的md5值和文件大小</p>
<p>upload_aggregate_form_field "${upload_field_name}_md5" $upload_file_md5;</p>
<p>upload_aggregate_form_field "${upload_field_name}_size" $upload_file_size;</p>
<p># 指示原样转到后端的参数，可以用正则表达式表示</p>
<p>upload_pass_form_field "^submit$|^description$";</p>
<p>upload_pass_args on;</p>
<p>}</p>
<p># 将请求转到后端的地址处理</p>
<p>location @test {</p>
<p>rewrite ^(.*)$ /test.php last;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>四. 上传界面</p>
<p># cat /www/web/upload/upload.html</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;title&gt;Test upload&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h2&gt;Select files to upload&lt;/h2&gt;</p>
<p>&lt;form enctype="multipart/form-data" action="/upload" method="post"&gt;</p>
<p>&lt;input type="file" name="file1"&gt;&lt;br&gt;</p>
<p>&lt;input type="file" name="file2"&gt;&lt;br&gt;</p>
<p>&lt;input type="file" name="file3"&gt;&lt;br&gt;</p>
<p>&lt;input type="file" name="file4"&gt;&lt;br&gt;</p>
<p>&lt;input type="file" name="file5"&gt;&lt;br&gt;</p>
<p>&lt;input type="file" name="file6"&gt;&lt;br&gt;</p>
<p>&lt;input type="submit" name="submit" value="Upload"&gt;</p>
<p>&lt;input type="hidden" name="test" value="value"&gt;</p>
<p>&lt;/form&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>五. upload_pass处理内容</p>
<p># cat test.php //这里只是简单的打印出来，便于先理解上传原理。请对着输出内容理解下nginx upload module配置参数。</p>
<p>&lt;?php</p>
<p>print_r($_POST);</p>
<p>?&gt;</p>
<p>对上传文件的处理请参考：http://cn.php.net/manual/en/features.file-upload.php</p>
<p>六. 测试</p>
<p>http://192.168.41.129/upload.html</p>
<p>输出内容如下所示：</p>
<p>Array</p>
<p>(</p>
<p>[file1_name] =&gt; Learning Perl, Sixth Edition.pdf</p>
<p>[file1_content_type] =&gt; application/pdf</p>
<p>[file1_path] =&gt; /www/web/upload/tmp/4/0000000014</p>
<p>[file1_md5] =&gt; 87032cc58109f5c6bb866d2684f9b48c</p>
<p>[file1_size] =&gt; 8927511</p>
<p>[file2_name] =&gt; Programming Perl, 4th Edition.pdf</p>
<p>[file2_content_type] =&gt; application/pdf</p>
<p>[file2_path] =&gt; /www/web/upload/tmp/5/0000000015</p>
<p>[file2_md5] =&gt; 82a52df177a8912c06af276581cfd5e4</p>
<p>[file2_size] =&gt; 21146356</p>
<p>[submit] =&gt; Upload</p>
<p>)</p>
<p>注意：需要修改php.ini以下参数</p>
<p>file_uploads on 是否允许通过http上传</p>
<p>upload_max_filesize 8m 允许上传文件的最大大小</p>
<p>post_max_size 8m 通过表单POST给php所能接收的最大值</p>
<p>另外nginx.conf中设置上传文件大小</p>
<p>upload_max_file_size 软限制</p>
<p>client_max_body_size 硬限制</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx防止高负载的解决方案(sysgurad模块)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-sysgurad.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-sysgurad,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>如果nginx被攻击或者访问量突然变大，nginx会因为负载变高或者内存不够用导致服务器宕机，最终导致站点无法访问。今天要谈到的解决方法来自淘宝开发的模块nginx-http-sysguard，主要用于当负载和内存达到一定的阀值之时，会执行相应的动作，比如直接返回503,504或者其他的.一直等到内存或者负载回到阀值的范围内，站点恢复可用。简单的说，这几个模块是让nginx有个缓冲时间，缓缓.</p>
<h3><strong>1. 安装nginx sysguard模块</strong></h3>
<p><span>1.1 下载文件</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx.org/download/nginx-1.4.2.tar.gz
# wget https://github.com/alibaba/nginx-http-sysguard/archive/master.zip \
-O nginx-http-sysguard-master.zip
# unzip nginx-http-sysguard-master.zip
# tar -xzvf nginx-1.4.2.tar.gz</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p><span>1.2 打sysgrard补丁</span><br>
这边没找到nginx-1.4.2对应的补丁，只有1.2.9和1.3.9的，索性试试1.3.9的吧，应该差不多.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd nginx-1.4.2
# patch -p1 &lt; ../nginx-http-sysguard-master/nginx_sysguard_1.3.9.patch</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>1.3 安装nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./configure --prefix=/usr/local/nginx-1.4.2 \
--with-http_stub_status_module --add-module=../nginx-http-sysguard
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3>2.<strong> sysguard指令</strong></h3>
<p>语法: sysguard [on | off]<br>
默认值: sysguard off<br>
配置段: http, server, location<br>
开关模块</p>
<p>语法: sysguard_load load=number [action=/url]<br>
默认值: none<br>
配置段: http, server, location<br>
指定负载阀值,当系统的负载超过这个值，所有的请求都会被重定向到action定义的uri请求中.如果没有定义URL action没有定义，那么服务器直接返回503</p>
<p>语法: sysguard_mem swapratio=ratio% [action=/url]<br>
默认值: none<br>
配置段: http, server, location<br>
定义交换分区使用的阀值，如果交换分区使用超过这个阀值，那么后续的请求全部被重定向到action定义的uri请求中.如果没有定义URL action没有定义，那么服务器直接返回503</p>
<p>语法: sysguard_interval time<br>
默认值: sysguard_interval 1s<br>
配置段: http, server, location<br>
定义系统信息更新的频率,默认1秒.</p>
<p>语法: sysguard_log_level info | notice | warn | error<br>
默认值: sysguard_log_level error<br>
配置段: http, server, location<br>
定义sysguard的日志级别</p>
<h3><strong>3.</strong> sysguard使用实例</h3>
<p><span>3.1 nginx配置</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen       80;
    server_name  www.ttlsa.com www.heytool.com;
    access_log  /data/logs/nginx/www.ttlsa.com.access.log  main;

    index index.html index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> index.html;
    root /data/site/www.ttlsa.com;

    sysguard on;
    # 为了方便测试，load阀值为0.01，平时大家一般都在5或10+
    sysguard_load load=0.01 action=/loadlimit; 
    sysguard_mem swapratio=20% action=/swaplimit;

    location / {

    }

    location /loadlimit {
        return 503;
    }

    location /swaplimit {
        return 503;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p><span>3.2 测试</span><br>
负载OK的情况下,访问nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># uptime 
 16:23:37 up 6 days,  8:04,  2 users,  load average: 0.00, 0.01, 0.05
# curl -I www.ttlsa.com
HTTP/1.1 403 Forbidden
Server: nginx
Date: Thu, 03 Oct 2013 16:27:13 GMT
Content-Type: text/html
Content-Length: 162
Connection: keep-alive</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>因为站点下没有文件，所以返回了403，实际上没关系.</p>
<p>负载超过阀值的情况下，访问nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># uptime 
 16:25:59 up 6 days,  8:06,  2 users,  load average: 0.05, 0.04, 0.05
# curl -I www.ttlsa.com
HTTP/1.1 503 Service Temporarily Unavailable
Server: nginx
Date: Thu, 03 Oct 2013 16:26:19 GMT
Content-Type: text/html
Content-Length: 206
Connection: keep-alive</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>swap超过阀值的功能我就不再测试了。大家回家可以自己动手测试一下.</p>
<h3>结束语</h3>
<p>在nginx是realserver的情况下，个人也比较推荐使用这种方法，如果服务器负载一旦爬高，一般要比较长的时间才能恢复到正常水平，在采用这个插件的情况下，负载达到阀值，nginx返回503，前段使用故障转移将请求发往其他服务器，这台服务器在无访问的情况下，便能很快的恢复到正常水平，并且能够立即投入工作。超过阀值的服务器处理请求速度也会大打折扣，使用这个模块，巧妙的将请求发送到了更快速的服务器上，在一定程度上避免了访问速度慢的问题. 前面说的是在集群环境下，在单点环境下，用不用大家斟酌一下。</p>
<p>参考文章：<br>
nginx-http-sysguard:https://github.com/alibaba/nginx-http-sysguard<br>
TCP Proxy:https://github.com/yaoweibin/nginx_tcp_proxy_module (相同功能软件)</p>
<p> </p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx secure_link下载防盗链-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-secure_link.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-secure_link,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>下载服务器上有众多的软件资源, 可是很多来源不是本站，是迅雷、flashget, 源源不断的带宽,防盗链绝对是当务之急. 使用来源判断根本不靠谱，只能防止一些小白站点的盗链，迅雷之类的下载工具完全无效，如果你是nginx的话，使用secure link完美解决这个问题，远离迅雷.本文仅用于下载服务器，不适用于图片防盗链.</p>
<h3>安装nginx</h3>
<p>默认情况下nginx不会安装secure_link模块,需要手动指定,配置参数如下</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre> # ./configure --with-http_secure_link_module \
 --prefix=/usr/local/nginx-1.4.2 --with-http_stub_status_module
 # make
 # make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3>配置nginx</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {

    listen       80;
    server_name  s1.down.ttlsa.com;
    access_log  /data/logs/nginx/s1.down.ttlsa.com.access.log  main;

    index index.html index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> index.html;
    root /data/site/s1.down.ttlsa.com;

    location / {
        secure_link $arg_st,$arg_e;
        secure_link_md5 ttlsa.com$uri$arg_e;

        if ($secure_link = "") {
            return 403;
        }

        if ($secure_link = "0") {
            return 403;
        }
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p> </p>
<h3>php下载页面</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><?php # 作用：生成nginx secure link链接
 # 站点：www.ttlsa.com
 # 作者：凉白开
 # 时间：2013-09-11
$secret = 'ttlsa.com'; # 密钥
 $path = '/web/nginx-1.4.2.tar.gz'; # 下载文件
 # 下载到期时间,time是当前时间,300表示300秒,也就是说从现在到300秒之内文件不过期
 $expire = time()+300;
# 用文件路径、密钥、过期时间生成加密串
 $md5 = base64_encode(md5($secret . $path . $expire, true));
 $md5 = strtr($md5, '+/', '-_');
 $md5 = str_replace('=', '', $md5);
# 加密后的下载地址
 echo '<a href=http://s1.down.ttlsa.com/web/nginx-1.4.2.tar.gz?st='.$md5.'&e='.$expire.'>nginx-1.4.2';
 echo '<br>http://s1.down.ttlsa.com/web/nginx-1.4.2.tar.gz?st='.$md5.'&e='.$expire;
 ></pre></div>
			 
		</div>
<!-- [Format Time: 0.0045 seconds] -->
<p> </p>
<h3>测试nginx防盗链</h3>
<p>打开http://test.ttlsa.com/down.php点击上面的连接下载<br>
下载地址如下：<br>
http://s1.down.ttlsa.com/web/nginx-1.4.2.tar.gz?st=LSVzmZllg68AJaBmeK3E8Q&amp;e=1378881984<br>
页面不要刷新，等到5分钟后在下载一次，你会发现点击下载会跳转到403页面。</p>
<h3>secure<strong> link 防盗链原理</strong></h3>
<ul>
<li>用户访问down.php</li>
</ul>
<ul>
<li>down.php根据secret密钥、过期时间、文件uri生成加密串</li>
</ul>
<ul>
<li>将加密串与过期时间作为参数跟到文件下载地址的后面</li>
</ul>
<ul>
<li>nginx下载服务器接收到了过期时间，也使用过期时间、配置里密钥、文件uri生成加密串</li>
</ul>
<ul>
<li>将用户传进来的加密串与自己生成的加密串进行对比，一致允许下载，不一致403</li>
</ul>
<p>整个过程实际上很简单，类似于用户密码验证. 尤为注意的一点是大家一定不要泄露了自己的密钥，否则别人就可以盗链了，除了泄露之外最好能经常更新密钥.</p>
<h3><strong>secure</strong> link 指令</h3>
<p>secure_link<br>
语法: secure_link md5_hash[,expiration_time]<br>
默认: none<br>
配置段: location<br>
variables: yes</p>
<p>这个指令由uri中的MD5哈希值和过期时间组成. md5哈希必须由base64加密的,过期时间为unix时间.如果不加过期时间,那么这个连接永远都不会过期.</p>
<p>secure_link_md5<br>
语法: secure_link_md5 secret_token_concatenated_with_protected_uri<br>
默认: none<br>
配置段: location<br>
variables: yes<br>
md5值对比结果,使用上面提供的uri、密钥、过期时间生成md5哈希值.如果它生成的md5哈希值与用户提交过来的哈希值一致，那么这个变量的值为1，否则为0</p>
<p>secure_link_secret<br>
语法:     secure_link_secret word<br>
默认:<br>
配置段:     location<br>
Reference:    secure_link_secret<br>
nginx 0.8.50之后的版本已经使用secure_link_md5取代,不在多说.</p>
<h3>注意事项</h3>
<ul>
<li>密钥防止泄露、以及经常更新密钥</li>
</ul>
<ul>
<li>下载服务器和php服务器的时间不能相差太大，否则容易出现文件一直都是过期状态.</li>
</ul>
<h3>最后</h3>
<p>secure link以及内置到了nginx，不需要额外安装第三方模块，有下载服务器的兄弟,我极力推荐你们使用它，除非你不在乎你的带宽.</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx显示随机首页模块(Random Index)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-random-index.html</url>
      <content type="html"><![CDATA[<p> nginx,nginx-modules-random-index,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong>前言</strong></h3>
<p>一般情况下,一个站点默认首页都是定义好的index.html、index.shtml、index.php等等,如果想站点下有很多页面想随机展示给用户浏览,那得程序上实现，显得尤为麻烦,如果你安装了nginx，那么使用nginx的random index即可达成这个功能，凡是以/结尾的请求，都会随机展示当前目录下的文件作为首页.</p>
<h3><strong>random</strong> index介绍</h3>
<p>ngx_http_random_index_module模块处理以'/'为后缀的请求,并且在当前目录下随机抽取一个页面作为首页.这个模块将在ngx_http_index_module模块之前执行. 默认情况下，这个模块没有安装，你需要在安装nginx的时候加上配置参数--with-http_random_index_module.</p>
<h3><strong>随机首页配置</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
 random_index on;
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>random index指令</strong></h3>
<p>语法: random_index on | off;<br>
默认值: random_index off;<br>
配置段: location<br>
启用或者禁用random index模块</p>
<p>转摘请注明出处：http://www.ttlsa.com/html/2956.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+perl模块的使用-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-perl_module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-perl_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>咱们上一次测试过了perl-fastcgi，这节也来讲讲nginx内置模块perl。转这文章之前我也专程做过性能对比，nginx内置perl模块性能比fastcgi更强，这个显而易见的事情，不过性能好不了太多，一个并发5800，一个并发6000多点。类似的组合有nginx + perl + fastcgi以及nginx + lua的性能也非常出色，喜欢的可以跳过去看看, 看nginx中内置perl模块的继续往下走.</p>
<p>如果对于一个绝大部分内容是静态的网站，只有极少数的地方需要动态显示，碰巧你又了解一点perl知识，那么nginx + perl的结合就能很好解决问题。要想nginx支持perl脚本，在编译nginx时候需要如下参数：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>./configure --with-http_perl_module</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>如果make时候出现如下类似错误：<br>
Can’t locate ExtUtils/Embed.pm in @INC (@INC contains: /usr/lib/perl5/5.10.0/i386-linux-thread-multi /usr/lib/perl5/5.10.0 /usr/local/lib/perl5/site_perl/5.10.0/i386-linux-thread-multi /usr/local/lib/perl5/site_perl/5.10.0 /usr/lib/perl5/vendor_perl/5.10.0/i386-linux-thread-multi /usr/lib/perl5/vendor_perl/5.10.0 /usr/lib/perl5/vendor_perl /usr/local/lib/perl5/site_perl .)</p>
<p>你的机器上可能需要安装perl-devel perl-ExtUtils-Embed，对于centos系统，直接使用yum搞定，例如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>yum -y install perl-devel perl-ExtUtils-Embed</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>nginx中使用perl有两种方法，一种是直接在配置文件写，还有一种是把perl脚本写在外部文件中，下面主要介绍一下第二种用法。</p>
<p>假设nginx的根目录为/usr/local/nginx，perl脚本存放的目录为nginx的根目录下的perl/lib下，脚本名字为test.pm，nginx配置为：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>#位于http配置中
	perl_modules  perl/lib;
	perl_require  test.pm;

#位于server配置中
		location /user/ {
			perl pkg_name::process;
		}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>上述配置是把所有来自http://servername/user/下的请求交由test.pm脚本中定义的process方法来处理。</p>
<p>test.pm脚本的内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>package pkg_name;

use Time::Local;
use nginx;

sub process {
    my $r = shift;

    $r-&gt;send_http_header('text/html; charset=utf-8');
    my @arr = split('/', $r-&gt;uri);
    my $username = @arr[2];

    if (!$username || ($username eq "")) {
		$username = "Anonymous";
    }

    $r-&gt;print('Hello, You name is : <strong>' . $username . '</strong>');
	$r-&gt;rflush();
	return;
}

1;
__END__</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>当你访问http://servername/user/netingcn，你应该可以在网页上看到：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>Hello, You name is : netingcn</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>另外：当使用 use nginx 时,会有如下的对象可以调用，可以看到上面 shift 一个对象到 $r 上,然后就可以用 $r 调用那些对象了:<br>
$r-&gt;args – 请求的参数 .<br>
$r-&gt;discard_request_body – 这个参数是让 Nginx 放弃 request 的 body 的内容.<br>
$r-&gt;filename – 返回合适的请求文件的名字<br>
$r-&gt;has_request_body(function) – 如果没有请求主体,返回0,但是如果请求主体存在,那么建立传递的函数并返回1,在程序的最后,nginx将调用指定的处理器.<br>
$r-&gt;header_in(header) – 查找请求头的信息<br>
$r-&gt;header_only – 如果我们只要返回一个响应的头<br>
$r-&gt;header_out(header, value) – 设置响应的头<br>
$r-&gt;internal_redirect(uri) – 使内部重定向到指定的URI,重定向仅在完成perl脚本后发生.可以使用 header_out(Location….的方法来让浏览器自己重定向<br>
$r-&gt;print(args, …) – 发送数据给客户端<br>
$r-&gt;request_body – 得到客户端提交过来的内容 （body 的参数,可能需要修改 nginx 的 client_body_buffer_size. ）<br>
$r-&gt;request_body_file —给客户的 body 存成文件,并返回文件名<br>
$r-&gt;request_method — 得到请求 HTTP method.<br>
$r-&gt;remote_addr – 得到客户端的 IP 地址.<br>
$r-&gt;rflush – 立即传送数据给客户端<br>
$r-&gt;sendfile(file [, displacement [, length ] ) – 传送给客户端指定文件的内容,可选的参数表明只传送数据的偏移量与长度,精确的传递仅在perl脚本执行完毕后生效.这可是所谓的高级功能啊<br>
$r-&gt;send_http_header(type) – 添加一个回应的 http 头的信息<br>
$r-&gt;sleep(milliseconds, handler) – 设置为请求在指定的时间使用指定的处理方法和停止处理,在此期间nginx将继续处理其他的请求,超过指定的时间后,nginx将运行安装的处理方法,注意你需要为处理方法通过一个reference,在处理器间转发数据你可以使用$r-&gt;variable().<br>
$r-&gt;status(code) – 设置 http 的响应码<br>
$r-&gt;unescape(text) – 使用 http 方法加密内容如 %XX<br>
$r-&gt;uri – 得到请求的 URL.<br>
$r-&gt;variable(name[, value]) – 设置变量的值<br>
运维生存时间整理： http://www.ttlsa.com/html/2445.html<br>
本文转：http://www.netingcn.com/nginx-perl.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx实现简体繁体字互转以及中文转拼音(ngx_set_cconv模块)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_set_cconv.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_set_cconv,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>谈到中文简体与繁体字互转，以及汉字转拼音，大家的第一反应就是使用程序来实现，比如php，java。最近一直在nginx第三方模块上晃荡，发现nginx可以实现简繁互转并且也同时实现了转拼音的功能，特意装上简单的测试一下。</p>
<p>备注：测试之前告知大家目前它只支持utf8编码.</p>
<p><strong>1.安装nginx模块</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>NDK地址：http://github.com/simpl-it/ngx_devel_kit
cconv地址：http://cconv.googlecode.com/files/cconv-0.6.2.tar.gz</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong>1.1 安装cconv</strong><br>
cconv的lib提供给nginx模块调用，实现繁体互转以及汉字转拼音的功能.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget http://cconv.googlecode.com/files/cconv-0.6.2.tar.gz
# tar -xzvf cconv-0.6.2.tar.gz
# cd cconv-0.6.2
# ./configure 
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>lib库默认安装到usr/local下,如果你是64系统执行如下命令</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ln -s /usr/local/lib/libcconv.so.0.0.0 /lib64/libcconv.so.0</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>32位执行</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ln -s /usr/local/lib/libcconv.so.0.0.0 /lib/libcconv.so.0</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><strong>1.2 安装nginx</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget https://github.com/simpl/ngx_devel_kit/archive/master.zip -O ngx_devel_kit-master.gzip
# wget https://github.com/liseen/set-cconv-nginx-module/archive/master.zip -O set-cconv-nginx-module-master.zip
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# unzip ngx_devel_kit-master.gzip
# unzip set-cconv-nginx-module-master.zip
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
# ./configure  --prefix=/usr/local/nginx-1.4.2 --with-ld-opt='-lcconv' \
--with-http_stub_status_module --add-module=../ngx_devel_kit-master \
--add-module=../set-cconv-nginx-module-master
# make -j2
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p><strong>2. 指令（Directives）</strong><br>
set_cconv_to_simp # 繁体转简体<br>
set_cconv_to_trad # 简体转繁体<br>
set_pinyin_to_normal # 汉字转拼音</p>
<p><strong>3. nginx配置</strong></p>
<p><span>3.1 配置location</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen       80;
    server_name  test.ttlsa.com;

    location /ttlsa2jianti {
        set $ttlsa "運維生存時間 - www.ttlsa.com";
        set_cconv_to_simp $ttlsa $ttlsa;
        echo $ttlsa;
    }

    location /ttlsa2fanti {
        set $ttlsa "运维生存时间 - www.ttlsa.com";
        set_cconv_to_trad $ttlsa $ttlsa;
        echo $ttlsa;
    }

    location /ttlsa2pinyin {
        set $ttlsa "运维生存时间 -  ｗｗｗ.ttlsa.com";
        set_pinyin_to_normal $ttlsa $ttlsa;
        echo $ttlsa;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p><span>3.2 访问测试</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://test.ttlsa.com/ttlsa2jianti
运维生存时间 - www.ttlsa.com

# curl http://test.ttlsa.com/ttlsa2fanti
運維生存時間 - www.ttlsa.com

# curl http://test.ttlsa.com/ttlsa2pinyin
yunweishengcunshijian -  www.ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>繁体与简体都相互转化了，也可以转成拼音，而且全角的字母也转成了半角.</p>
<p><strong>4. 注意事项</strong><br>
和程序一样，自定义变量不要使用程序内置的变量以及 $arg_XXX or $http_XXX。如下</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>set_cconv_to_simp $arg_user 'foo';</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这种方法不要使用，会出问题.</p>
<p><strong>5. 兼容性</strong><br>
以下版本通过测试<br>
*   0.8.x (last tested version is 0.8.38)<br>
*   0.7.x &gt;= 0.7.46 (last tested version is 0.7.65)<br>
*   0.5，0.6这些老版本不兼容<br>
*   1.4.2 没问题,目前我使用的是这个版本.</p>
<p>转载请注明来至运维生存时间：http://www.ttlsa.com/html/3281.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx流量带宽等请求状态统计( ngx_req_status)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_req_status.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_req_status,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong>介绍</strong></h3>
<p>ngx_req_status用来展示nginx请求状态信息，类似于apache的status，nginx自带的模块只能显示连接数等等信息，我们并不能知道到底有哪些请求、以及各url域名所消耗的带宽是多少。ngx_req_status提供了这些功能.</p>
<p>功能特性</p>
<ul>
<li>按域名、url、ip等等统计信息</li>
<li>统计总流量</li>
<li>统计当前带宽\峰值带宽</li>
<li>统计总请求数量</li>
</ul>
<h3><strong>1. 安装</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
 # wget "http://nginx.org/download/nginx-1.4.2.tar.gz"
 # tar -xzvf nginx-1.4.2.tar.gz
 # wget https://github.com/zls0424/ngx_req_status/archive/master.zip -O ngx_req_status.zip
 # unzip ngx_req_status.zip
 # cd nginx-1.4.2/
 # patch -p1 &lt; ../ngx_req_status-master/write_filter.patch
 # ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../ngx_req_status-master
 # make -j2
 # make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>2. 配置</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
 req_status_zone server_name $server_name 256k;
 req_status_zone server_addr $server_addr 256k;
 req_status_zone server_url  $server_name$uri 256k;
req_status server_name server_addr server_url;
server {
 server_name test.ttlsa.com;
 location /ttlsa-req-status {
 req_status_show on;
 }
 }
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h3><strong>4. 指令</strong></h3>
<p>req_status_zone<br>
语法: req_status_zone name string size<br>
默认值: None<br>
配置块: http<br>
定义请求状态ZONE,请求按照string分组来排列，例如：<br>
req_status_zone server_url  $server_name$uri 256k;<br>
域名+uri将会形成一条数据，可以看到所有url的带宽，流量，访问数</p>
<p>req_status<br>
语法: req_status zone1[ zone2]<br>
默认值: None<br>
配置块: http, server, location<br>
在location中启用请求状态，你可以指定更多zones。</p>
<p>req_status_show<br>
语法: req_status_show on<br>
默认值: None<br>
配置块: location<br>
展示数据</p>
<h3><strong>5. 测试访问</strong></h3>
<p>http://test.ttlsa.com/ttlsa-req-status<br>
如下图</p>
<div><p>req_status</p></div>
<p>如上有请求的信息，例如req-status这个页面，中流量是146KB，当前带宽是0，总请求数量是47，最大并非连接数是1.</p>
<h3><strong>6. 兼容性</strong></h3>
<p>以下版本都兼容<br>
1.4.2 我测试的<br>
1.3.x (last tested: 1.3.5)<br>
1.2.x<br>
1.1.x<br>
1.0.x (last tested: 1.0.2)</p>
<p>网站：运维生存时间   网址： http://www.ttlsa.com/nginx/nginx-modules-ngx_req_status/</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx实时记录请求状态信息( ngx_realtime_request_module)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_realtime_request_module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_realtime_request_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong>关于</strong></h3>
<p>ngx_realtime_request是nginx用来统计虚拟主机流量的模块, 首先和大家说下这个模块是基于域名的，将会记录这个域名的请求量、发送字节、返回http状态码的数量，特性如下：</p>
<ul>
<li>基于域名记录</li>
<li>记录请求数据量</li>
<li>记录发送、响应流量</li>
<li>记录返回各种http状态码统计数据</li>
</ul>
<h3><strong>1.  安装</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget "http://nginx.org/download/nginx-1.4.2.tar.gz"
# tar -xzvf nginx-1.4.2.tar.gz
# wget https://github.com/magicbear/ngx_realtime_request_module/archive/master.zip -O ngx_realtime_request.zip
# unzip ngx_realtime_request.zip
# cd nginx-1.4.2/
# ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../ngx_realtime_request_module-master
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>2.  指令(directives)</strong></h3>
<p>realtime_zonesize<br>
语法: realtime_zonesize size<br>
默认值: 4m<br>
配置块: http<br>
设置slab大小</p>
<p>realtime_request<br>
语法: realtime_request [on/off]<br>
默认值: none<br>
配置块: location<br>
开启统计</p>
<h3><strong>3.  配置实例</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
    realtime_zonesize  16m;

    server {
        server_name www.ttlsa.com
        location ~ /ttlsa-rt-status {
            realtime_request on;
        }
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>4. 测试</strong></h3>
<p>访问http://www.ttlsa.com几次，制造几个404和200等等</p>
<p>查看状态http://www.ttlsa.com/ttlsa-rt-status如下图</p>
<div><p>ngx_realtime_request</p></div>
<p>上图解释：</p>
<p>uptime：18 -&gt;nginx运行了18秒<br>
version:0.5 -&gt; 当前插件版本<br>
host：当前统计的域名,如果这台服务器有多个域名，会显示多行<br>
request：请求量8个<br>
recv：接收5294字节<br>
send：发送2043字节<br>
20x：响应了7次20x的状态码<br>
30x:返回了0次30x<br>
40x：返回了1次40xhttp状态码（我测试的404）<br>
50x：返回了0次50x</p>
<h3><strong>5. 兼容性</strong></h3>
<p>如下版本已做测试<br>
1.3.x (tested with 1.3.6 to 1.3.15).<br>
1.4.2 运维时间用这个版本做了测试</p>
<h3>6. 参考文章</h3>
<p>项目地址：https://github.com/magicbear/ngx_realtime_request_module<br>
参考文档：http://www.ttlsa.com/nginx/nginx-modules-ngx_realtime_request_module/</p>
<p>网站：<strong>运维生存时间 </strong></p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx + ngx_lua安装测试-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_lua.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_lua,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx lua模块淘宝开发的nginx第三方模块,它能将lua语言嵌入到nginx配置中,从而使用lua就极大增强了nginx的能力.nginx以高并发而知名,lua脚本轻便,两者的搭配堪称完美.接下来请看如何安装nginx + ngx_lua模块.以及最后来个简单的测试.</p>
<p>如果你是ubuntu系统,请看nginx+lua+redis构建高并发应用</p>
<p>系统环境：centos/redhat</p>
<p>安装前准备好如下软件包<br>
· nginx  地址：http://www.nginx.org<br>
· luajit 地址：http://luajit.org/download.html<br>
· HttpLuaModule 地址：http://wiki.nginx.org/HttpLuaModule</p>
<h3><strong>1. 下载安装LuaJIT</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src
# wget http://luajit.org/download/LuaJIT-2.0.2.tar.gz
# tar -xzvf LuaJIT-2.0.2.tar.gz
# cd LuaJIT-2.0.2
# make

出现如下内容表示编译成功
OK        Successfully built LuaJIT
make[1]: Leaving directory `/usr/local/src/LuaJIT-2.0.2/src'
==== Successfully built LuaJIT 2.0.2 ====

# make install
出现如下内容，表示安装成功
==== Successfully installed LuaJIT 2.0.2 to /usr/local ====</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h3><strong>2. 下载准备nginx lua模块</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src
# wget https://github.com/chaoslawful/lua-nginx-module/archive/v0.8.6.tar.gz
# tar -xzvf v0.8.6</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3><strong>3. 安装nginx</strong></h3>
<p>3.1 安装</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
//先导入环境变量,告诉nginx去哪里找luajit
# export LUAJIT_LIB=/usr/local/lib
# export LUAJIT_INC=/usr/local/include/luajit-2.0
# ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../lua-nginx-module-0.8.6
# make -j2
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>3.1 常见错误</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.4.2/sbin/nginx -v
./objs/nginx: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory
解决方法：
# ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>4. nginx lua配置</strong></h3>
<p>nginx配置文件加入如下配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~* ^/2328(/.*) {
      default_type 'text/plain';
      content_by_lua 'ngx.say("hello, ttlsa lua")';
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>5. 启动测试</strong></h3>
<p>5.1 启动nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.4.2/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>5.2 访问测试</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://test.ttlsa.com/2328/ 
hello, ttlsa lua //使用curl测试</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>nginx lua测试截图</p>
<div><p>nginx lua测试</p></div>
<p>nginx ngx_lua的安装到此结束<br>
转载请注明出处： http://www.ttlsa.com/html/2328.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx国人开发缩略图模块(ngx_image_thumb)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_image_thumb.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_image_thumb,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p><strong>关于</strong></p>
<p>ngx_image_thumb是nginx中用来生成缩略图的模块，生存缩略图的方法很多，之前也写过一篇 《nginx生成缩略图配置 - ttlsa教程系列之nginx》，在github上发现国人开发的一款模块，作者的文档写的很详细，我便照搬过来了。以后将做一个测试.</p>
<p>特性</p>
<p>本nginx模块主要功能是对请求的图片进行缩略/水印处理，支持文字水印和图片水印。支持自定义字体，文字大小，水印透明度，水印位置，判断原图是否是否大于指定尺寸才处理等等</p>
<p><strong>1. 编译方法</strong></p>
<p>编译前请确认您的系统已经安装了libcurl-dev libgd2-dev libpcre-dev 依赖库<br>
1.1 <span>Debian / Ubuntu 系统举例</span></p>
<p># 如果你没有安装GCC相关环境才需要执行<br>
$ sudo apt-get install build-essential m4 autoconf automake make<br>
$ sudo apt-get install libgd2-noxpm-dev libcurl4-openssl-dev libpcre3-dev</p>
<p><span>1.2 CentOS /RedHat / Fedora</span></p>
<p># 请确保已经安装了gcc automake autoconf m4<br>
$ sudo yum install gd-devel pcre-devel libcurl-devel</p>
<p><span>1.3 FreeBSD / NetBSD / OpenBSD</span></p>
<p># 不多说了，自己用port 把libcurl-dev libgd2-dev libpcre-dev 装上吧<br>
# 编译前请确保已经安装gcc automake autoconf m4</p>
<p><span>1.4 Windows</span></p>
<p># 也支持的，不过要修改的代码太多了，包括Nginx本身，用VC++来编译<br>
# 嫌麻烦可以用cygwin来编译。还是不建议你这么做了，用Unix/Linux操作系统吧。</p>
<p><strong>2. nginx / tengine 安装</strong></p>
<p>选Nginx还是Tengine,您自己看,两者选其一<br>
<span>2.1 下载Tengine</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre> # wget http://tengine.taobao.org/download/tengine-1.4.5.tar.gz
 # tar -zxvf tengine-1.4.5.tar.gz
 # cd tengine-1.4.5</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span>2.2 下载Nginx</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx.org/download/nginx-1.4.0.tar.gz
 # tar -zxvf nginx-1.4.0.tar.gz
 # cd nginx-1.4.0</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span>2.3 安装模块</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre> # wget https://github.com/3078825/nginx-image/archive/master.zip
 # unzip master.zip
 # ./configure --add-module=./nginx-image-master
 # make
 # make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><strong>3. 配置</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
 root html;
 #添加以下配置
 image on;
 image_output on;
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong>4. 参数</strong></p>
<p>image on/off 是否开启缩略图功能,默认关闭<br>
image_backend on/off 是否开启镜像服务，当开启该功能时，请求目录不存在的图片（判断原图），将自动从镜像服务器地址下载原图<br>
image_backend_server 镜像服务器地址<br>
image_output on/off 是否不生成图片而直接处理后输出 默认off<br>
image_jpeg_quality 75 生成JPEG图片的质量 默认值75<br>
image_water on/off 是否开启水印功能<br>
image_water_type 0/1 水印类型 0:图片水印 1:文字水印<br>
image_water_min 300 300 图片宽度 300 高度 300 的情况才添加水印<br>
image_water_pos 0-9 水印位置 默认值9 0为随机位置,1为顶端居左,2为顶端居中,3为顶端居右,4为中部居左,5为中部居中,6为中部居右,7为底端居左,8为底端居中,9为底端居右<br>
image_water_file 水印文件(jpg/png/gif),绝对路径或者相对路径的水印图片<br>
image_water_transparent 水印透明度,默认20<br>
image_water_text 水印文字 "Power By Vampire"<br>
image_water_font_size 水印大小 默认 5<br>
image_water_font 文字水印字体文件路径<br>
image_water_color 水印文字颜色,默认 #000000</p>
<p>调用说明</p>
<p>这里假设你的nginx 访问地址为 http://127.0.0.1/</p>
<p>并在nginx网站根目录存在一个 test.jpg 的图片</p>
<p>通过访问</p>
<p>http://127.0.0.1/test.jpg!c300x200.jpg 将会 生成/输出 test.jpg 300x200 的缩略图</p>
<p>其中 c 是生成图片缩略图的参数， 300 是生成缩略图的 宽度 200 是生成缩略图的 高度</p>
<p>一共可以生成四种不同类型的缩略图。</p>
<p>支持 jpeg / png / gif (Gif生成后变成静态图片)</p>
<p>C 参数按请求宽高比例从图片高度 10% 处开始截取图片，然后缩放/放大到指定尺寸（ 图片缩略图大小等于请求的宽高 ）</p>
<p>M 参数按请求宽高比例居中截图图片，然后缩放/放大到指定尺寸（ 图片缩略图大小等于请求的宽高 ）</p>
<p>T 参数按请求宽高比例按比例缩放/放大到指定尺寸（ 图片缩略图大小可能小于请求的宽高 )</p>
<p>W 参数按请求宽高比例缩放/放大到指定尺寸，空白处填充白色背景颜色（ 图片缩略图大小等于请求的宽高 ）</p>
<p><strong>5. 调用举例</strong></p>
<p>http://127.0.0.1/test.jpg!c300x300.jpg</p>
<p>http://127.0.0.1/test.jpg!t300x300.jpg</p>
<p>http://127.0.0.1/test.jpg!m300x300.jpg</p>
<p>http://127.0.0.1/test.jpg!w300x300.jpg</p>
<p>http://127.0.0.1/test.c300x300.jpg</p>
<p>http://127.0.0.1/test.t300x300.jpg</p>
<p>http://127.0.0.1/test.m300x300.jpg</p>
<p>http://127.0.0.1/test.w300x300.jpg</p>
<p><strong>6. 最后</strong></p>
<p>这款模块的缩略图是实时生成的，如果你的网站流量比较大，势必会造成nginx服务器负载过高，针对这个问题，你可以参考我们运维生存时间之前写的几篇文章，分别为存硬盘和redis. 《nginx实时生成缩略图到硬盘上》《srcache_nginx+redis构建缓存系统》</p>
<p>参考文章</p>
<p>项目地址：https://github.com/3078825/nginx-image/</p>
<p>网站 : 运维生存时间 网址：http://www.ttlsa.com/html/4170.html</p>
<div></div>
<div></div>
<div></div>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx实现大小写字母转换（ngx_http_lower_upper_case模块）-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_http_lower_upper_case.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_http_lower_upper_case,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>各种程序或脚本都有实现大小写字母互转的功能，今天讲讲ngx_http_lower_upper_case，功能很简单，至于可以用在什么环境大家可以根据自己的情况.多一种模块多一种解决方案.本模块将字符串转换为大小写然后赋值给变量. 用ttlsa群组的话来说"存在即合理"，软件存在性总有他存在的道理。</p>
<h3><strong>1. 安装nginx模块</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>--add-module=path/to/circle_gif/directory</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>具体方法就不再讲述了，可以参考运维生存时间的&lt;如何安装nginx第三方模块&gt;</p>
<h3><strong>2.upper/lower 指令</strong></h3>
<p>upper<br>
语法：upper $var string<br>
配置段: location<br>
小些转大写</p>
<p>lower<br>
语法：lower $var string<br>
配置段: location<br>
大写转小写</p>
<h3>3.<strong> nginx配置</strong></h3>
<p>location /ttlsa_upper_lower {<br>
upper $var1 "Hello,ttlsa.com";<br>
lower $var2 "HELLO,TTLSA.COM";<br>
echo $var1;<br>
echo $var2;<br>
}</p>
<h3><strong>4. 测试</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://test.ttlsa.com/ttlsa_upper_lower/
 HELLO,TTLSA.COM
 hello,ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>5.<strong> 参考地址</strong></h3>
<p>nginx模块地址：https://github.com/replay/ngx_http_lower_upper_case/archive/master.zip<br>
ngx_http_lower_upper_case地址：https://github.com/replay/ngx_http_lower_upper_case</p>
<p>站点：运维生存时间网址：http://www.ttlsa.com/html/3947.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx记录分析网站响应慢的请求(ngx_http_log_request_speed)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_http_log_request_speed.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_http_log_request_speed,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx模块ngx_http_log_request_speed可以用来找出网站哪些请求很慢，针对站点很多，文件以及请求很多想找出哪些请求比较慢的话，这个插件非常有效.作者的初衷是写给自己用的，用来找出站点中处理时间较长的请求, 这些请求是造成服务器高负载的很大根源. 日志记录之后，在使用perl脚本分析日志，即可知道哪些请求需要修正.</p>
<h3><strong>1. 模块安装</strong></h3>
<p>nginx第三方模块安装方法，我们ttlsa.com已经说过很多次了，我这边不在重复了。<br>
配置参数</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>./configure --prefix=/usr/local/nginx-1.4.1 --with-http_stub_status_module \
 --add-module=../ngx_http_log_request_speed</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h3><strong>2.</strong> 指令log_request_speed</h3>
<p>log_request_speed_filter<br>
语法: log_request_speed_filter [on|off]<br>
配置段: n/a<br>
context: location, server, http<br>
启动或禁用模块</p>
<p>log_request_speed_filter_timeout<br>
语法: log_request_speed_filter_timeout [num sec]<br>
默认: 5秒<br>
配置段: location, server, http<br>
这边并不是真正意义的超时,而是说当请求超过这边给定的时间，将会记录到nginx错误日志中. 默认值是5000微秒（5秒），如果一个请求小于5秒,这个请求不会被记录到日志中，但是如果超过5秒，那请求将会被记录到nginx的错误日志中</p>
<h3><strong>3. 使用实例</strong></h3>
<p><span>3.1 nginx配置</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http{
      log_request_speed_filter on;
      log_request_speed_filter_timeout 3;
      ...
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>错误日志中记录的慢请求如下</p>
<div><p>nginx慢请求日志</p></div>
<p><span>3.2 日志分析</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>cd /usr/local/nginx-1.4.1/logs
wget http://wiki.nginx.org/images/a/a8/Log_Analyzer.tar.gz
tar -xzvf Log_Analyzer.tar.gz
cd request_speed_log_analyzer
# cat ../error.log | grep 'process request'| ./analyzer.pl -r
POST /wp-admin/admin-ajax.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> HTTP/1.1 --- avg ms: 1182, value count: 2
GET /shmb/1145.html HTTP/1.1 --- avg ms: 2976, value count: 1 </pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>从日志中，我们发现这边有2条请求比较慢，最慢的是/shmb/1145.html ,而且还标示“THE WINNER”，作者你赢了。很幽默。</p>
<p><span>3.3 分析脚本语法</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./analyzer.pl -h 
-h : this help message # 显示帮助信息
-u : group by upstream # 按upstream分组
-o : group by host # 按主机分组
-r : group by request # 按请求分组，推荐这个</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h3><strong>4. nginx测试版本</strong></h3>
<p>目前作者只在0.6.35和0.7.64下测试，不保证其他环境下可以使用。我当前的测试版本是1.4.1，目前使用正常，在使用前请大家先测试一下。</p>
<h3><strong>5. 结束语</strong></h3>
<p>首先很感谢作者写的这个简单实用的nginx插件，这个插件的目的不仅仅是记录请求的响应时间，而且是用来找出响应慢的请求。如果你的服务器上有大量的站点，或者大量的程序文件，但是访问量不高，负载却很高，你想找出是哪个请求慢，我想这个插件非常适合你。</p>
<p>参考地址<br>
ngx_http_log_request_speed下载地址：http://wiki.nginx.org/images/7/78/Ngx_http_log_request_speed.tar.gz<br>
ngx_http_log_request_speed脚本地址：http://wiki.nginx.org/images/a/a8/Log_Analyzer.tar.gz</p>
<p>来源站点：运维生存时间网址：http://www.ttlsa.com/html/3244.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx修改upstream不重启的方法(ngx_http_dyups_module模块)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_http_dyups_module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_http_dyups_module,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>nginx很强大，第三方模块也不少,淘宝在nginx上很活跃，特别是章亦春，他参与的模块至少10+， 好了今天主角不是他，是一款动态配置upstream的模块，这个模块使用rest接口. 简单，方便，并且可以不需要重启nginx。但是有个问题比较明显，nginx重启之后，什么都没了.</p>
<h3>1. 安装ngx_http_dyups_module</h3>
<p>首先安装nginx动态upstream配置模块，如果你已经安装了nginx，那么轻参考ttlsa上的如何安装nginx第三方模块，会安装的请跳过.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget https://github.com/yzprofile/ngx_http_dyups_module/archive/master.zip \
-O  ngx_http_dyups_module-master.zip
# unzip ngx_http_dyups_module-master.zip
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
# ./configure --prefix=/usr/local/nginx-1.4.2 --with-http_stub_status_module 
\--add-module=../ngx_http_dyups_module-master/
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>2. 指令(Directives)</strong></h3>
<p>语法: dyups_interface<br>
默认: none<br>
配置段: location<br>
启用配置upstream的接口</p>
<p>语法: dyups_read_msg_timeout time<br>
默认: 1s<br>
配置段: main<br>
设置从共享内存中读取commands的超时时间，默认为1秒</p>
<p>语法: dyups_shm_zone_size size<br>
默认: 2MB<br>
配置段: main<br>
设置存储commands的共享内存<br>
This directive set the size of share memory which used to store the commands.</p>
<p>语法: dyups_upstream_conf path<br>
默认: none<br>
配置段: main<br>
这个指令用来指定upstream配置文件的路径,他会在启动的时候加载</p>
<p>语法: dyups_trylock on | off<br>
默认: off<br>
配置段: main<br>
是否启用锁，如果启用了它，同一时刻有人在修改，那么将会返回409.</p>
<h3><strong>3. restful接口</strong></h3>
<p>GET<br>
/detail 获取所有upstream名称以及upstream里面的servers信息<br>
/list 获取upstream列表<br>
/upstream/name 使用upstream名称获取upstream信息</p>
<p>POST<br>
/upstream/name 更新upstream<br>
body 配置内容;<br>
body server ip:port;</p>
<p>DELETE<br>
/upstream/name 删除upstream,name相应修改</p>
<p>3.1 调用接口响应http状态码</p>
<p>500: 需要reload nginx<br>
409: 重新调用一次接口，上个请求被锁了.<br>
204：调用list或者detail时出现，表示没有响应内容<br>
其他：你的命令错误，请修改<br>
注意：你需要第三方模块来生成新的配置文件到nginx配置目录. 作者也没有说什么第三方模块，这个插件很好，不能生成配置文件，让他显得尤为不足.</p>
<h3><strong>4. nginx配置</strong></h3>
<p>备注:以下配置有安装echo模块.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
    # 从upstream读取初始upstream配置
    dyups_upstream_conf  conf/upstream.conf;
    include conf/upstream.conf;

    # 默认主机
    server {
        listen   80;
        location / {
            proxy_pass http://$host;
        }
    }

    # 动态配置upstream的接口站点
    server {
        listen 81;
        location / {
            dyups_interface; # 这个指令表示这边是接口站点
        }
    }

    # upstream后面的realserver,2台801，,82
    server {
        listen 801;
        location / {
            echo 801; 
        }
    }

    server {
        listen 802;
        location / {
            echo 802;
        }
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>upstream.conf配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream ttlsa1 {
    server 127.0.0.1:801;
}

upstream ttlsa12 {
    server 127.0.0.1:802;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3>5. 使用方法演示</h3>
<p>5.1 添加upstream</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -d "server 127.0.0.1:801;server 127.0.0.1:802;" 127.0.0.1:81/upstream/ttlsa3
success</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>测试</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -H "host: ttlsa3" 127.0.0.1
801

# curl -H "host: ttlsa3" 127.0.0.1
802</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>可以看到通过host的ttlsa3可以访问到upstream配置的两台服务器。如果你发现curl几次都是一样的，那么轻多试几次。</p>
<p>5.2 查看upstream详细信息</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl 127.0.0.1:81/detail
ttlsa1
server 127.0.0.1:801

ttlsa2
server 127.0.0.1:802

ttlsa3
server 127.0.0.1:801
server 127.0.0.1:802</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>5.3 删除upstream</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -i -X DELETE 127.0.0.1:81/upstream/ttlsa1
success

# curl 127.0.0.1:81/detail
ttlsa2
server 127.0.0.1:802

ttlsa3
server 127.0.0.1:801
server 127.0.0.1:802</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>5.4 增加带ip_hash的upstream</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -d "ip_hash;server 127.0.0.1:801;server 127.0.0.1:802;" 127.0.0.1:81/upstream/ttlsa4
success

# curl 127.0.0.1:81/upstream/ttlsa4
server 127.0.0.1:801
server 127.0.0.1:802</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>为什么没有带ip_hash的信息，本身就无法显示，那我们在看看weight会不会显示出来</p>
<p>5.5 增加带weight的upstream</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -d "server 127.0.0.1:801;server 127.0.0.1:802 weight=2;" 127.0.0.1:81/upstream/ttlsa5
success

# curl 127.0.0.1:81/upstream/ttlsa5
server 127.0.0.1:801
server 127.0.0.1:801</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>还是不显示,虽然没显示，但是效果还是有的，大家自己去测试吧.</p>
<h3><strong>6. 注意事项</strong></h3>
<p>本模块不能和nginx_upstream_check_module一起使用，接下来的版本会支持。或者可以使用tenengine。淘宝真是不遗余力在推广他们的tenengine.</p>
<h3><strong>7. 结束语</strong></h3>
<p>ngx_http_dyups_module带的功能我很喜欢，但是最大的不足就是不能生成配置文件，所有内容都保存在内存中，希望以后的版本能够支持。有这个模块，shell脚本也可以修改upstream，不在需要重启nginx。</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx快速绘制圆形图（ngx_http_circle_gif_module模块）-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_http_circle_gif_module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_http_circle_gif_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx官网上有各式各样的第三方模块,今天来介绍一款叫做ngx_http_circle_gif_module。从字面意思来看，他是一个声称圆形图片的模块，实际上也是如此。此模块生成图片比直接在硬盘上读取要快很多，并且可以不用劳烦美工去设计。或者说不用麻烦同学用windows下的画图去话一个圆.功能很简单，指令也很简单。</p>
<h3><strong>安装模块参数</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>--add-module=path/to/circle_gif/directory</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>具体方法就不在讲述了，可以参考运维生存时间的《如何安装nginx第三方模块》</p>
<p><strong>circle_gif指令</strong><br>
circle_gif<br>
语法: circle_gif<br>
默认值: n/a<br>
配置段: location</p>
<p>circle_gif_min_radius<br>
语法: circle_min_radius<br>
默认值: 10<br>
配置段: location<br>
圆形的最小半径, 单位为像素</p>
<p>circle_gif_max_radius<br>
语法: circle_max_radius<br>
默认值: 20<br>
配置段: location<br>
圆形的最大半径,  单位为像素</p>
<p>circle_gif_step_radius<br>
语法: circle_step_radius<br>
默认值: 2<br>
配置段: location<br>
The "step" in between generated circle images</p>
<h3><strong>circle_gif配置</strong></h3>
<p>location /ttlsa_circles {<br>
circle_gif;<br>
}</p>
<h3><strong>circle_gif用法</strong></h3>
<p>&lt;背景颜色&gt;/&lt;前景色&gt;/&lt;半径&gt;.gif</p>
<p>例子<br>
http://test.ttlsa.com/ttlsa_circles/ffffff/000000/20.gif</p>
<p>ffffff：背景色是白色<br>
000000：前景色是黑色<br>
20：圆形半径为20</p>
<h3><strong>circle_gif效果图</strong></h3>
<div><p>circle_gif</p></div>
<p> </p>
<h3><strong>参考地址</strong></h3>
<p>nginx_circle_gif下载：https://github.com/evanmiller/nginx_circle_gif/</p>
<p>nginx_circle_gif文档：http://wiki.nginx.org/HttpCircleGifModule</p>
<p>站点：运维生存时间网址：http://www.ttlsa.com/html/3942.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx获取大文件MD5值(nginx模块ngx_file_md5)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_file_md5.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_file_md5,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>HTTP协议新增了Content-MD5 HTTP头，但是nginx并不支持这个功能，而且官方也明确表示不会增加这项功能，为什么呢？因为每次请求都需要读取整个文件来计算MD5值，以性能著称的nginx绝对不愿意干出违背软件宗旨的事情。但是有些应用中，需要验证文件的正确性，有些人通过下载当前文件，然后计算MD5值来比对当前文件是否正确。不仅仅浪费带宽资源也浪费了大把的时间。有需求就有解决方案，网友开发了file-md5模块。</p>
<h3>1. 下载模块file-md5</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    # cd /usr/local/src
    # wget https://github.com/cfsego/file-md5/archive/master.zip -O file-md5-master.zip
    # unzip file-md5-master.zip</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>2. 安装模块file-md5</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    # wget http://nginx.org/download/nginx-1.4.2.tar.gz
    # tar -xzf nginx-1.4.2.tar.gz
    # cd nginx-1.4.2
    # ./configure --prefix=/usr/local/nginx-1.4.2  --add-module=../file-md5-master
    # make
    # make isntall</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果你已经安装了nginx，仅需要增加file-md5模块即可，具体参考《nginx如何安装第三方模块》</p>
<h3>3. 配置file-md5</h3>
<p>3.1 MD5追加到http响应头中</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {
        listen       80;
        server_name  test.ttlsa.com;
        root /data/site/test.ttlsa.com;
    
        # for add content-md5 to http header
        location ~ /download
        {
                add_header    Content-MD5    $file_md5;
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>所有请求download的请求，都会在响应http头部增加Content-MD5，值为这个文件的MD5，看如下测试：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    # curl -I test.ttlsa.com/download/1.exe   
    HTTP/1.1 200 OK
    Server: nginx
    Date: Wed, 26 Feb 2014 03:00:05 GMT
    Content-Type: application/octet-stream
    Content-Length: 1535488
    Last-Modified: Mon, 24 Feb 2014 10:08:10 GMT
    Connection: keep-alive
    ETag: "530b1a0a-176e00"
    Content-MD5: 6adda4a06dbad3ac9b53a08f4ff9c4f8
    Accept-Ranges: bytes</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>大家可以看到Content-MD5: 6adda4a06dbad3ac9b53a08f4ff9c4f8，这个就是1.exe文件的MD5值.</p>
<p>3.2 直接响应MD5值到内容中</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {
        listen       80;
        server_name  test.ttlsa.com;
        root /data/site/test.ttlsa.com;

        # for add content-md5 to http header
        location ~ /download
        {
            if ( $arg_md5 ~* "true" ){
                echo $file_md5;
            }
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>这边直接使用echo输出MD5值（echo模块需要额外安装），只需在下载的文件后面加上参数&amp;md5=true即可得到MD5值，使用过程中，参数可以随心定义。下面来测试一下。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    # curl test.ttlsa.com/download/1.exe?md5=true   
    6adda4a06dbad3ac9b53a08f4ff9c4f8</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>直接得到md5值，与第一种方法得到同样的MD5。</p>
<h3>4. 最后</h3>
<p>使用nginx模块也是一种方法，这种方法有个不足支持，每个请求都需要从新计算一次MD5值。想减小他的压力，可以在nginx加缓存，或者借用memcache以及使用perl或者lua等模块，希望大家继续支持运维生存时间。</p>
<p>项目地址：https://github.com/cfsego/file-md5<br>
项目文档：https://github.com/cfsego/file-md5/blob/master/README<br>
网站：运维生存时间</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx安装配置+清缓存模块安装-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx_cache_purge.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx_cache_purge,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>经过一段时间的使用，发现nginx在并发与负载能力方面确实优于apache，现在已经将大部分站点从apache转到了nginx了。以下是nginx的一些简单的安装配置。</p>
<p>环境</p>
<p>操作系统：CentOS、RedHat</p>
<p>IP地址：192.168.1.202</p>
<h3><b>下载软件包</b></h3>
<p># mkdir /usr/local/src/tarbag</p>
<p># mkdir /usr/local/src/software</p>
<p># cd /usr/local/src/tarbag/</p>
<p>Nginx</p>
<p># wget http://www.nginx.org/download/nginx-1.0.6.tar.gz</p>
<p>Nginx cache purge模块(可选)</p>
<p># wget http://labs.frickle.com/files/ngx_cache_purge-1.3.tar.gz</p>
<h3><b>编译安装</b></h3>
<p># cd /usr/local/src/tarbag/</p>
<p># tar -xzvf nginx-1.0.6.tar.gz -C /usr/local/src/software</p>
<p># tar -xzvf ngx_cache_purge-1.3.tar.gz -C /usr/local/src/software</p>
<p># cd /usr/local/src/software/</p>
<p># ./configure \</p>
<p>--prefix=/usr/local/nginx-1.0.6 \  # 安装路径</p>
<p>--with-http_stub_status_module \ # 启用nginx状态模块</p>
<p>--with-http_ssl_module \ # 启用SSL模块</p>
<p>--with-http_realip_module \ # 启用realip模块（将用户IP转发给后端服务器）</p>
<p>--add-module=../ngx_cache_purge-1.3 # 添加缓存清除扩展模块</p>
<p># make</p>
<p># make install</p>
<p> </p>
<h3><b>内核参数优化</b></h3>
<p># vi sysctl.conf  增加以下配置</p>
<p>net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 1800</p>
<p>net.ipv4.ip_conntrack_max = 16777216　＃　如果使用默认参数,容易出现网络丢包</p>
<p>net.ipv4.netfilter.ip_conntrack_max = 16777216＃　如果使用默认参数,容易出现网络丢包</p>
<p>net.ipv4.tcp_max_syn_backlog = 65536</p>
<p>net.core.netdev_max_backlog =  32768</p>
<p>net.core.somaxconn = 32768</p>
<p>net.core.wmem_default = 8388608</p>
<p>net.core.rmem_default = 8388608</p>
<p>net.core.rmem_max = 16777216</p>
<p>net.core.wmem_max = 16777216</p>
<p>net.ipv4.tcp_timestamps = 0</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>net.ipv4.tcp_syn_retries =</p>
<p>net.ipv4.tcp_tw_recycle = 1</p>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>net.ipv4.tcp_mem = 94500000 915000000 927000000</p>
<p>net.ipv4.tcp_max_orphans = 3276800</p>
<p>net.ipv4.ip_local_port_range = 1024  65535</p>
<p>配置生效</p>
<p># sysctl –p</p>
<p>修改iptables启动脚本,在star()函数里面加上</p>
<p># vi /etc/init.d/iptables</p>
<p>/sbin/sysctl  -p</p>
<p> </p>
<h3><b>配置范例站点站点</b></h3>
<p>序号</p>
<p>域名</p>
<p>目录</p>
<p>1</p>
<p>www.heytool.com</p>
<p>/www/html/www.heytool.com</p>
<p>2</p>
<p>bbs.heytool.com</p>
<p>/www/html/bbs.heytool.com</p>
<p> </p>
<h3>修改nginx配置文件：</h3>
<p># vi nginx.conf</p>
<p>user  nobody nobody; # 运行nginx的所属组和所有者</p>
<p>worker_processes  2; # 开启两个nginx工作进程,一般几个CPU核心就写几</p>
<p>error_log  logs/error.log  notice; # 错误日志路径</p>
<p>pid        logs/nginx.pid; # pid路径</p>
<p>events {</p>
<p>worker_connections  1024; # 一个进程能同时处理1024个请求</p>
<p>}</p>
<p>http {</p>
<p>include       mime.types;</p>
<p>default_type  application/octet-stream;</p>
<p> </p>
<p>log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</p>
<p>'$status $body_bytes_sent "$http_referer" '</p>
<p>'"$http_user_agent" "$http_x_forwarded_for"';</p>
<p>access_log  logs/access.log  main; # 默认访问日志路径</p>
<p>sendfile        on;</p>
<p>keepalive_timeout  65; # keepalive超市时间</p>
<p># 开始配置一个域名,一个server配置段一般对应一个域名</p>
<p>server {</p>
<p>listen       80; #</p>
<p># 在本机所有ip上监听80,也可以写为192.168.1.202:80,这样的话,就只监听192.168.1.202上的80口</p>
<p>server_name  www.heytool.com; # 域名</p>
<p>root   /www/html/www.heytool.com; # 站点根目录（程序目录）</p>
<p>index  index.html index.htm; # 索引文件</p>
<p>location / {  # 可以有多个location</p>
<p>root   /www/html/www.heytool.com; # 站点根目录（程序目录）</p>
<p>}</p>
<p>error_page   500 502 503 504  /50x.html;</p>
<p># 定义错误页面,如果是500错误,则把站点根目录下的50x.html返回给用户</p>
<p>location = /50x.html {</p>
<p>root   /www/html/www.heytool.com;</p>
<p>}</p>
<p>}</p>
<p># 开始配置站点bbs.heytool.com</p>
<p>server {</p>
<p>listen       80;</p>
<p>server_name  bbs.heytool.com;</p>
<p>root   /www/html/bbs.heytool.com;</p>
<p>index  index.html index.htm; # 索引文件</p>
<p>location / {</p>
<p>root   /www/html/bbs.heytool.com;</p>
<p>}</p>
<p>error_page   500 502 503 504  /50x.html;</p>
<p>location = /50x.html {</p>
<p>root   /www/html/bbs.heytool.com;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Nginx启动关闭</p>
<p># /usr/local/nginx-1.0.6/sbin/nginx  //启动nginx</p>
<p># /usr/local/nginx-1.0.6/sbin/nginx –t //测试nginx配置文件的准确性</p>
<p># /usr/local/nginx-1.0.6/sbin/nginx –s reload //重载nginx</p>
<p># /usr/local/nginx-1.0.6/sbin/nginx –s stop //关闭nginx</p>
<p> </p>
<p><b>测试</b></p>
<p>创建测试站点</p>
<p># mkdir –p /www/html/www.heytool.com</p>
<p># mkdir –p /www/html/bbs.heytool.com</p>
<p># echo “www.heytool.com” &gt; /www/html/www.heytool.com/index.html</p>
<p><b>#</b> echo “bbs.heytool.com” &gt; /www/html/bbs.heytool.com/index.html</p>
<p> </p>
<h3><b>启动nginx</b></h3>
<p># /usr/local/nginx-1.0.6/sbin/nginx –t //看到ok和successful,说明配置文件没问题</p>
<p>nginx: the configuration file /usr/local/ nginx-1.0.6/conf/nginx.conf syntax is ok</p>
<p>nginx: configuration file /usr/local/ nginx-1.0.6/conf/nginx.conf test is successful</p>
<p># /usr/local/nginx-1.0.6/sbin/nginx</p>
<p> </p>
<h3>绑定hosts,测试</h3>
<p>把两个域名指向192.168.1.202</p>
<p>192.168.1.202     www.heytool.com</p>
<p>192.168.1.202     bbs.heytool.com</p>
<p>打开www.heytool.com,如下图：</p>
<p><b> </b></p>
<div><p>nginx</p></div>
<p><b><br>
</b></p>
<p>打开bbs.heytool.com,如下图：</p>
<div><p>nginx</p></div>
<p> </p>
<p>完毕！！！！</p>
<p>更多配置参考：http://www.docin.com/p-222277825.html</p>
<p>参考视频教程：http://www.kuaipan.cn/index.php?ac=file&amp;oid=29331332391763978</p>
<p>文章推荐：</p>
<p>Haproxy+keepalived实现sphinx高可用负载均衡</p>
<p>使用haproxy来实现sphinx负载均衡与健康监测</p>
<p>持久化存储系统ttserver的安装配置</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx统计响应的http状态码信息(ngx-http-status-code-counter)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-ngx-http-status-code-counter.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-ngx-http-status-code-counter,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><h3><strong>1. 介绍</strong></h3>
<p>ngx-http-status-code-counter是一个用来记录nginx响应状态码的统计信息，作者将这个模块与munin结合来分析网站的http状态，我们也可以将这个与nagios、zabbix或者其他监控系统想结合，有这个模块运维可以不再使用脚本去分析日志了。</p>
<h3><strong>2. 安装</strong></h3>
<p>nginx的安装方式不再多说，请参考运维生存时间早期的《nginx安装》,我这边使用nginx-1.4.2做的测试。作者仅在0.8.50版本上使用，模块比较简单，新版本一般都会兼容，不过大家使用之前最好做一个测试。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget https://github.com/kennon/ngx_http_status_code_counter/archive/master.zip
# unzip master
# cd nginx-1.4.2 
# ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../ngx_http_status_code_counter-master
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>3.配置NGINX</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># for http_code_status
location /ttlsa_http_code_status/
{
        show_status_code_count on;
}

location /ttlsa_http_code_status500/
{
        return 500;
}

location /ttlsa_http_code_status502/
{
        return 502;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>4. 测试</strong></h3>
<p>分别访问http://test.ttlsa.com/ttlsa_http_code_status502/和http://test.ttlsa.com/ttlsa_http_code_status500来制造一个500和502的状态码，以及随意访问一个页面制造404响应码，一切都是为了测试。<br>
测试输出内容如下图</p>
<div><p>ngx_http_status_code_counter</p></div>
<p><strong>5. 缺点</strong></p>
<p>缺点也很明显，所有的数据都保存在nginx内存中，一旦nginx reload或者重开，数据就为空。还有一个缺点便是它统计的数据是持续叠加的，没有时段区分，如果你想统计各个时段的http 响应代码，你需要定时重启nginx。</p>
<p><strong>5. 兼容性</strong><br>
兼容0.8.x，但是0.7.x为测试。我当前的版本是1.4.2运行OK</p>
<p><strong>6. 结束语</strong><br>
有这个功能，将nginx统计出来的http响应码放入监控系统中，便于排除系统故障。后续再贴出整合到监控系统的案例，请继续关注运维生存时间。</p>
<p>站点：运维生存时间 网址：http://www.ttlsa.com/nginx/nginx-modules-ngx-http-status-code-counter/</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx strip模块优化页面-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-nginx-strip.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-nginx-strip,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h2 style="text-align: center;"> nginx strip模块删除不必要的空格</h2>
<p>在nginx官方wiki的第三方模块中看到nginx strip模块,简单的看下功能，大意就是把网页中的空格，tab，换行删除以用来减少文件的大小，提高用户的访问速度，这个模块配合gzip效果更佳.</p>
<p><strong>mod_strip模块简介：</strong><br>
直接翻译官方的简介，mod_strip移除html文档中没必要的空行（包含空格，tab，换行）. mod_strip配合NginxHttpGzipModule来使用可以更好的减少文件大小以及减少页面下载时间,这个软件目前还在测试阶段，但是我用得非常OK.mod_strip速度非常快,而且仅仅需要非常少量的内存.</p>
<p><strong>1. mod_strip安装：</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget http://wiki.nginx.org/images/6/63/Mod_strip-0.1.tar.gz
# tar -xzvf Mod_strip-0.1.tar.gz
# cd nginx-1.4.2 //提前解压好的nginx
# ./configure --prefix=/usr/local/nginx-1.4.2 --add-module=../mod_strip
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong>2. mod_strip简单用法：</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
    strip on;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>strip指令：</p>
<p>语法: strip on|off<br>
默认: off<br>
可用配置段: main, http, server, location<br>
所有响应给用户的MIME类型为text/html将会使用该模块</p>
<p><strong>3.  mod_strip测试</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>nginx配置
location ~* ^/2322(/.*)
{
    strip on;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><em>3.1 换行：</em></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat newline.html 
line 1
line 2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>打开内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>line 1line 2 # 惊呆了，好好的两行怎么变成这样了</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><em>3.2 tab测试：</em></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat tab.html

<title>test strip</title>


<strong>        tab</strong>    <strong>tab2</strong>

</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>打开后内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><strong>tabtab2</strong></pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>直接上图:</p>
<div><p>strip替换tab</p></div>
<p><em>3.3 替换空格</em></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat space.html 
<b> space </b> <b> space2 </b></pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>打开后内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>space space2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>看截图：</p>
<div><p>strip替换空格</p></div>
<p>总结：什么玩意儿,这种模块也能上nginx官方模块，而且作者也承认了因为技术原因换行存在问题，很想看看作者的网站长什么样，使用nginx的strip模块还能work ok.如果真想优化这方面内容，推荐大家使用google的pagespeed模块.如果你是apache请看apache使用pagespeed加速.</p>
<p>转载请注明出处：nginx strip模块删除不必要的空格  http://www.ttlsa.com/html/2322.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用nginx sticky实现基于cookie的负载均衡-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-nginx-sticky-module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-nginx-sticky-module,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>在多台后台服务器的环境下，我们为了确保一个客户只和一台服务器通信，我们势必使用长连接。使用什么方式来实现这种连接呢，常见的有使用nginx自带的ip_hash来做，我想这绝对不是一个好的办法，如果前端是CDN，或者说一个局域网的客户同时访问服务器，导致出现服务器分配不均衡，以及不能保证每次访问都粘滞在同一台服务器。如果基于cookie会是一种什么情形，想想看, 每台电脑都会有不同的cookie，在保持长连接的同时还保证了服务器的压力均衡，nginx sticky值得推荐。</p>
<p>如果浏览器不支持cookie，那么sticky不生效，毕竟整个模块是给予cookie实现的.</p>
<h3>nginx sticky 模块工作流程图</h3>
<div><p>nginx sticky</p></div>
<h3>下载安装nginx sticky</h3>
<p>下载地址：http://code.google.com/p/nginx-sticky-module/downloads/list<br>
目前共有2个版本，一个是1.0，一个是1.1，1.0已经寿终正寝了.1.1增加了权重的参数.</p>
<p>安装nginx + sticky模块</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx-sticky-module.googlecode.com/files/nginx-sticky-module-1.1.tar.gz
# tar -xzvf nginx-sticky-module-1.1.tar.gz

# wget http://nginx.org/download/nginx-1.0.6.tar.gz
# tar -czvf nginx-1.0.6
# cd nginx-1.0.6
# ./configure --prefix=/usr/local/nginx-1.0.6 --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module --add-module=../nginx-sticky-module-1.1
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3>配置nginx sticky</h3>
<p>nginx 的upstream使用sticky,如下</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream cluster_test {
     sticky;
     server 192.168.100.209:80;
     server 192.168.100.225:80;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>配置虚拟主机（以下有配置的可以忽略掉）</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
        listen        80;
        server_name     test.ttlsa.com;
        index index.jsp;

        access_log /data/logs/nginx/test.ttlsa.com_access.log main;

        set $proxy_pass cluster_test;

        location /
        {
                proxy_pass http://$proxy_pass;
                include proxy.conf;
                add_header Cache-Control no-store;
        }

}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>备注：<br>
nginx和apache不同，nginx每次安装一个新的模块都需要重新编译一次，编译完成之后将nginx这一个文件拷贝到sbin下面即可.我这边全新安装一次,因为公司在两年前就选择了这个nginx版本,也没打算去换,所以大家可以把nginx换成自己最合适的一个版本,不用完全跟着文章来安装.</p>
<h3><strong>重启nginx</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.0.6/sbin/nginx -t
/usr/local/nginx-1.0.6/sbin/nginx -s reload</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>测试nginx sticky</strong></h3>
<p>我后端是两台tomcat服务器，每台服务器的JESSIONED值都有特殊的标志。比如209这台是s209,225这台是s225.打开页面,不管怎么刷新JESSIONED值都是不变.但是如果开启了sticky，可以看到JESSIONED值不会发生变化.死死的粘滞在其中一台服务器上.测试图如下：</p>
<p>使用sticky的情况下，不管怎么刷新都是下面图</p>
<div><p>nginx sticky 模块</p></div>
<p>不使用nginx sticky模块,多刷几次就变了（有时候刷一次，有时候多刷几次,看概率,不过肯定会变）,如下图</p>
<div><p>nginx sticky 模块</p></div>
<p>备注：每台后端真实服务器都会有一个唯一的route值,所以不管你真实服务器前端有几个装了sticky的nginx代理,他都是不会变化的. 这个cookie是会话方式的，所以你浏览器关闭了，服务器会给你重新分配一台服务器。</p>
<h3><strong>nginx sticky其他语法<br>
</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>sticky [name=route] [domain=.foo.bar] [path=/] [expires=1h] [hash=index|md5|sha1] [no_fallback];
name: 可以为任何的string字符,默认是route
domain：哪些域名下可以使用这个cookie
path：哪些路径对启用sticky,例如path/test,那么只有test这个目录才会使用sticky做负载均衡
expires：cookie过期时间，默认浏览器关闭就过期，也就是会话方式。
no_fallbackup：如果设置了这个，cookie对应的服务器宕机了，那么将会返回502（bad gateway 或者 proxy error），建议不启用</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h3>nginx sticky expires用法</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream cluster_test {
     sticky expires=1h;
     server 192.168.100.209:80;
     server 192.168.100.225:80;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>启用了过期，cookie如下截图,cookie1个小时才过期</p>
<div><p>nginx sticky expire用法</p></div>
<p>如下是不启用过期</p>
<div><p>nginx sticky 不启用expire</p></div>
<h3>nginx sticky使用注意事项</h3>
<p>nginx sticky模块不能与ip_hash同时使用</p>
<p>官方文档：http://code.google.com/p/nginx-sticky-module/wiki/Documentation</p>
<div></div>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx模块nginx-http-footer-filter研究使用-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-nginx-http-footer-filter.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-nginx-http-footer-filter,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx-http-footer-filter想必大家都觉得很陌生,那我们就来认识一下它吧,这是淘宝开发的nginx模块. 它用于nginx在响应请求文件底部追加内容. 今天抽空研究下这个插件，希望对大家有所帮助。为什么发现了这个插件，因为这几天公司需要在所有shtml文件后面追加一个js代码用来做统计（之前统计代码没加齐全），在寻求解决方法的过程中找到了它认识了它最后喜欢上了它，你可能以为我用这个插件去实现了我要的功能，其实在认识他之前我用shell脚本替换齐全了. 不过我还是决定研究测试一下nginx-http-footer-filter，或许以后的需求上能有帮助,更或许能帮上其他需要帮助的人.进入正题吧.</p>
<p><strong>1. nginx-http-footer-filter到底是做什么的？</strong><br>
说白了，就是在请求的页面底部插入你要插入的代码。</p>
<p><strong>2. 我们能用nginx-http-footer-filter来做什么？</strong><br>
1、统一追加js代码用于统计(我是这么想的)<br>
2、底部追加响应这个请求的realsver（后端真实服务器）信息,便于系统管理员排查故障.<br>
3、你管理着数量庞大的虚拟主机，在所有web后面追加你的广告代码，黑链什么的（很无耻）<br>
4、举一反三吧,自己想想能用来做什么吧.</p>
<p>淘宝用它来做什么？</p>
<p>打开淘宝首页，查看他源代码，拖到最下面,内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><!--city: fuzhou-->
<!--province: unknown-->
<!--hostname: -->
<!--hostname: home1.cn199--></pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>我们可以很清晰的看到，这边有省和地区还有主机名,也就是淘宝真实服务器的主机名,处理我这个请求的主机名为home1.cn199, city取到了fuzhou,provinece省份没取到，估计是它Geo的问题<br>
或者随便打开一个商品页面, 查看源代码,如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre></pre></div>
			 
		</div>
<!-- [Format Time: 0.0164 seconds] -->
<p>可以看到他这边给这页面追加了一个js代码,淘宝开发这个模块的用意想必大家都明白了，集思广益，或许大家还有更好的用处.<br>
<strong>3. 怎么安nginx-http-footer-filter</strong></p>
<p>3.1 下载地址：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>https://github.com/alibaba/nginx-http-footer-filter/tree/1.2.2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>3.2 安装nginx-footer模块<br>
之前已经安装过nginx，所以我选择覆盖nginx文件。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget https://codeload.github.com/alibaba/nginx-http-footer-filter/zip/1.2.2
# unzip 1.2.2

# http://nginx.org/download/nginx-1.4.1.tar.gz
# tar -xzvf nginx-1.4.1.tar.gz
# cd nginx-1.4.1
# ./configure --prefix=/usr/local/nginx-1.4.1 \
--with-http_stub_status_module --with-http_realip_module \
--add-module=../nginx-http-footer-filter-1.2.2
# make
# mv /usr/local/nginx-1.4.1/sbin/nginx /usr/local/nginx-1.4.1/sbin/old_nginx
# mv objs/nginx /usr/local/nginx-1.4.1/sbin/
# /usr/local/nginx-1.4.1/sbin/nginx -s stop
# /usr/local/nginx-1.4.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>3.3 验证模块是否安装成功</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.4.1/sbin/nginx -V
nginx version: nginx/1.4.1
built by gcc 4.4.7 20120313 (Red Hat 4.4.7-3) (GCC)
TLS SNI support enabled
configure arguments: --prefix=/usr/local/nginx-1.4.1 
--with-http_stub_status_module 
--with-http_realip_module  
--add-module=../nginx-http-footer-filter-1.2.2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p><strong>4. 怎么使用nginx-http-footer-filter模块</strong></p>
<p>4.1 配置location<br>
在location中使用footer "你的内容" 即可.看如下配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
        listen       173.255.219.122:80;
        server_name  test.ttlsa.com;
        access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;

        index index.html index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> index.html;
        root /data/site/test.ttlsa.com;
        location / {
           footer "<!-- $date_gmt -->";
           index index.html;
        }

        location =/html/2252.css {
           footer_types text/css;
           footer "/* host: $server_name - $date_local */";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>4.2 测试nginx-footer效果</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat 2252.shtml
<html>
    <head>
    <title>test</title>
    </head>
    <body>
        this is webpage
    </body>
</html></pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>访问站点test.ttlsa.com/html/2252.shtml</p>
<div><p>nginx追加底部代码</p></div>
<p>如图，我们可以看到文件最底部加上了&lt;!-- 1376063369 --&gt;,怎么变成了时间撮了,因为我这边是ssi的语法，如果你不知道什么是ssi，那么请参考文章什么是ssi.</p>
<p>[warning]他仅仅是在文件的最后一行追加,而不是&lt;body&gt;里面.这点大家要注意了.[/warning]</p>
<p>4.3 再来测试一下css文件</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat 2242.css
# this is css file</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如下是访问结果：<br>
# this is css file<br>
/* host: test.ttlsa.com - 1376064324 */</p>
<p>看图：</p>
<div><p>nginx footer追加底部代码css</p></div>
<p><strong>5. 我能写多个footer指令吗？</strong><br>
不行，以下我写了两个footer</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
    footer "12312321321";
    footer "<!-- $date_gmt -->";
    index index.html;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如下测试，提示footer指令重复了</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.4.1/sbin/nginx -t
nginx: [emerg] "footer" directive is duplicate in /usr/local/nginx-1.4.1/conf/vhost/test.ttlsa.com.conf:13
nginx: configuration file /usr/local/nginx-1.4.1/conf/nginx.conf test failed</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p><strong>6. 只能用ssi变量吗？</strong><br>
当然不是,随便你写，可以是ssi指令，也可以是nginx变量，也可以是任何无意义的字符串<br>
如下：<br>
footer "12312321321";<br>
footer "&lt;!--12312321321--&gt;";<br>
footer "&lt;!--$remote_addr--&gt;";</p>
<p>比如我想知道这个页面是哪台web服务器处理的,那么我在底部插入主机名即可.这样，有500错误，我便可以马上定位到具体的服务器了</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>footer "<!--$hostname-->";</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>返回结果如下：</p>
<div><p>nginx footer 追加底部代码nginx变量hostname</p></div>
<p><strong>7. 服务器返回500,404,403等错误, 是否还会追加内容到底部</strong></p>
<p>会,如果不追加,就无法通过返回的页面得知哪台web出现故障,这明显就不符合作者的初衷了</p>
<p>配置如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
    return 500;
    footer "<!--$hostname-->";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>结果如下：</p>
<div><p>nginx footer追加底部代码500错误</p></div>
<p><strong>8. 模块指令说明：</strong><br>
footer模块非常简单，就只有两个指令，具体说明如下<br>
footer字符串<br>
默认值: <code></code><br>
配置段: http, server, location<br>
这个定义了将什么内容追加到文件内容的底部</p>
<p>footer_types MIME类型<br>
默认值: footer_types: text/html<br>
配置段: http, server, location<br>
定义被追加底部文件的MIME返回类型,默认值是text/html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx生成缩略图配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-image_filter_module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-image_filter_module,<br><a id="more"></a><br>
  <span><fieldset><legend>摘要</legend><p>经过多方的考虑，决定使用方案C，使用nginx自带模块生成缩略图，模块：–with-http_image_filter_module.<br>
如下是我的安装参数：</p>
<p>./configure –prefix=/usr/local/nginx-1.4.1 –with-http_stub_status_module –with-http_realip_module –with-http_image_filter_module –with-debug</p>
<p>修改nginx.conf配置文件,或者放到你相应的server块中.</p>
<div></div></fieldset></span>
							<div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>为了手机端浏览到与手机分辨率相匹配的图片，提高app访问速度以及减少用户的手机流量，需要将图片生成缩略图，这边共有以下解决方案。<br>
A.    发布新闻生成多重缩略图 – 无法匹配到各种尺寸图片<br>
B.    当相应缩略图不存在，则使用php或者java等程序生成相应缩略图 – 需要程序员协助<br>
C.    使用nginx自带模块生成缩略图 – 运维即可完成<br>
D.    使用nginx＋lua生成缩略图</p>
<p>经过多方的考虑，决定使用方案C，使用nginx自带模块生成缩略图，模块：--with-http_image_filter_module.<br>
如下是我的安装参数：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>./configure --prefix=/usr/local/nginx-1.4.1 --with-http_stub_status_module \
--with-http_realip_module --with-http_image_filter_module --with-debug</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>修改nginx.conf配置文件,或者放到你相应的server块中.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre> location ~* /(\d+)\.(jpg)$ {
set $h $arg_h;   # 获取参数ｈ的值
set $w $arg_w;　# 获取参数w的值
#image_filter crop $h $w;
image_filter resize $h $w; #　根据给定的长宽生成缩略图
}

location ~* /(\d+)_(\d+)x(\d+)\.(jpg)$ {
if ( -e $document_root/$1.$4 ) {　# 判断原图是否存在
rewrite /(\d+)_(\d+)x(\d+)\.(jpg)$ /$1.$4?h=$2&amp;w=$3 last;
    }
return 404;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>例如图片：<br>
http://test.ttlsa.com/123_100x10.jpg<br>
1、    首先判断是否存在原图123.jpg,不存在直接返回404（如果原图都不存在，还生成缩略图干啥，对吧）<br>
2、    跳转到http://tset.ttlsa.com/123.jpg?h=100&amp;w=10，将参数高h和宽10带到url中。<br>
3、    Image_filter resize指令根据h和w参数生成相应缩略图。<br>
备注：长宽取小，例如原图是100*10,你传入的是10*2，那么他会给你生成10*1的图片.</p>
<p>生成缩略图只是image_filter功能中的一个，它一共支持4种参数：<br>
test:返回是否真的是图片<br>
size:返回图片长短尺寸,返回json格式数据<br>
corp:截取图片的一部分,从左上角开始截取,尺寸写小了,图片会被剪切<br>
resize:缩放图片,等比例缩放</p>
<p>nginx生成缩略图优缺点<br>
优点：<br>
1、    根据传入参数即可生成各种比例图片<br>
2、    不占用任何硬盘空间</p>
<p>缺点：<br>
1、消耗CPU,访问量大将会给服务器带来极大的负担.</p>
<p>几点建议：<br>
1、    生成缩略是个消耗cpu的操作，如果访问量比较大的站点，最好考虑使用程序生成缩略图到硬盘上，或者在前端加上cache或者使用CDN。</p>
<p>转载请注明出处：http://www.ttlsa.com/html/1612.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx空白图片(empty_gif模块)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-empty_gif.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-empty_gif,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>用过百度统计的兄弟有没有注意到百度使用1x1的空白图片传递统计参数，自己做异步统计的兄弟是否使用静态文件来传递参数。为什么使用空白图片呢，而不是自己存放一张小图呢，nginx里面的空白图片是保存在内存中的，速度绝对比硬盘上读取的快. 看下如何使用empty_gif生成响应1x1的空白图片吧.</p>
<p>或许哪天ttlsa自己要做统计，咱们也可以使用empty_gif来传递参数，说归说，肯定性还是比较小，能用第三方的统计就用第三方统计。好了，进入正题吧。</p>
<p>nginx默认内置ngx_http_empty_gif_module模块, 如何安装nginx我不在多讲.直接看下empty_gif的用法</p>
<h3><strong>nginx配置</strong></h3>
<p>nginx模块ngx_http_empty_gif_module会响应1x1的GIF图片.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location = /_.gif {
        empty_gif;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如下是我的nginx配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {

        listen       80;
        server_name  test.ttlsa.com;
        access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;

        index index.html index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> index.html;
        root /data/site/test.ttlsa.com;

        location ~* /3145/
        {
            empty_gif;
        }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h3><strong>测试empty_gif</strong></h3>
<p>访问test.ttlsa.com/3145/结果如下：</p>
<div><p>empty_gif nginx空白图片</p></div>
<h3><strong>empty_gif指令</strong></h3>
<p>语法:     empty_gif;<br>
默认:     —<br>
配置段:     location<br>
开启响应1x1空白图片</p>
<h3><strong>最后</strong></h3>
<p>empty_gif用得最多的地方还是统计,当然你觉得可以用的地方也是可以用，只要是你用得着，毕竟内存速度比硬盘要快非常多.</p>
<p> </p>
<p>转载请注明出处：http://www.ttlsa.com/html/3145.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx js、css多个请求合并为一个请求(concat模块)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-concat.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-concat,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3>模块介绍</h3>
<p>mod_concat模块由淘宝开发，目前已经包含在tengine中，并且淘宝已经在使用这个nginx模块。不过塔暂时没有包含在nginx中。这个模块类似于apache中的modconcat。如果需要使用它，需要使用两个"?"问号.</p>
<p>来个范例：<br>
http://example.com/??style1.css,style2.css,foo/style3.css<br>
以上将原先3个请求合并为1个请求</p>
<p>如果你担心文件被用户的浏览器缓存而没有及时更新，你依旧可以带上一个版本号的参数，如下：<br>
http://example.com/??style1.css,style2.css,foo/style3.css?v=102234</p>
<h3><strong>1. 安装nginx concat</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /usr/local/src/
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# wget https://github.com/alibaba/nginx-http-concat/archive/master.zip -O nginx-http-concat-master.zip
# unzip nginx-http-concat-master.zip
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
# ./configure --prefix=/usr/local/nginx-1.4.2 --with-http_stub_status_module　\
--add-module=../nginx-http-concat-master
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>2. 指令directives</strong></h3>
<p>concat on | off<br>
default: concat off<br>
context: http, server, location<br>
开启火关闭concat</p>
<p>concat_types MIME types<br>
default: concat_types: text/css application/x-javascript<br>
context: http, server, location<br>
Defines the MIME types which can be concatenated in a given context.<br>
在给定的配置段中可以被合并的MIME文件类型.</p>
<p>concat_unique on | off<br>
default: concat_unique on<br>
context: http, server, location<br>
是否只允许同类型文件（相同MIME文件）合并。例如，设置为off，那么js和css文件可以合并。默认情况下，这个值是on，意味着只有相同的类型文件才能合并。</p>
<p>如果希望js和css能够合并为一个请求，那么你必须设置concat_unique off，其他类型文件也可以用同样的方式合并.如下为OFF才可以的请求：<br>
http://example.com/static/??foo.css,bar/foobaz.js</p>
<p>concat_max_files numberp<br>
default: concat_max_files 10<br>
context: http, server, location<br>
定义一个给定的配置段里面允许合并文件的数量，默认最多10个.不过一定要注意，uri不要超过系统的规定的page size，在linux里面执行getconf PAGESIZE可以获取系统的限制.通常限制是4096字节。</p>
<p>concat_delimiter: string<br>
default: NONE<br>
context: http, server, locatione<br>
定义文件分隔符</p>
<p>concat_ignore_file_error: on | off<br>
default: off<br>
context: http, server, location<br>
是否忽略文件请求错误，例如404和403等</p>
<h3><strong>3. 配置nginx</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {

    listen       80;
    server_name  www.ttlsa.com;

    root /data/site/www.ttlsa.com;
    location /static/ {
        concat on;
        concat_max_files 20;
        concat_unique off;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h3>4.<strong> 测试nginx concat</strong></h3>
<p>我的站点有调用到static/ttlsa_concat.css和static/ttlsa_concat.js两个文件，为了提高站点访问速度，我决定使用nginx的concat模块将两个请求合并为一个。<br>
合并前<br>
www.ttlsa.com/static/css/ttsa_concat.css<br>
www.ttlsa.com/static/js/ttsa_concat.js</p>
<p>合并后<br>
http://www.ttlsa.com/static??js/ttlsa_concat.js,css/ttlsa_concat.css?ver=123<br>
测试之前，准备一下文件.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cd /data/site/www.ttlsa.com/static
# cat js/ttlsa_concat.js  
// this is js file ttlsa_concat.js
# cat js/a.js             
// this is js file a.js
# cat css/a.css
/** this is css a.css **/
# cat css/ttlsa_concat.css 
/** this is css ttlsa_concat.css **/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span>4.1 两个css合并</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://www.ttlsa.com/static/??css/ttlsa_concat.css,css/a.css
/** this is css ttlsa_concat.css **/
/** this is css a.css *</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span>4.2 两个js合并</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://www.ttlsa.com/static/??js/ttlsa_concat.js,js/a.js  
// this is js file ttlsa_concat.js
// this is js file a.js</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span>4.3 js与css合并</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://www.ttlsa.com/static/??js/ttlsa_concat.js,css/ttlsa_concat.css
// this is js file ttlsa_concat.js
/** this is css ttlsa_concat.css **/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span>4.4 带版本号参数</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://www.ttlsa.com/static/??css/ttlsa_concat.css,css/a.css?123
/** this is css ttlsa_concat.css **/
/** this is css a.css *</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>以上仅仅用了两个文件来测试，在具体应用中，大家可以使用多个，具体几个由你的nginx配置来控制. 在具体的环境中，都是以下方式来调用，以下方法摘自官方文档.<br>
<span>js：</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><script src="??bar1.js,bar22.css,subdir/bar3.js?v=3245"></script></pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>以上意思是将ba1.Js，bar22.css和subdir/bar3.js这三个请求合并为一个，并且版本号为3245.</p>
<p><span>css:</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><link rel="stylesheet" href="??foo1.css,foo2.css,subdir/foo3.css?v=2345"></pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这边也是一个道理,只不过只包含css.</p>
<h3>5.<strong> 结束语</strong></h3>
<p>减少web请求在一定程度上能减少web服务器的压力，简单的使用nginx concat模块便可以实现这个功能，不过需要前端设计师来使用。如果想减少web请求，又不想让前端设计师来插手的话，大家可以参考下google出的pagespeed模块</p>
<h3><strong>6. 参考文章</strong></h3>
<p>官方：http://wiki.nginx.org/HttpConcatModule</p>
<p>来源站点：运维生存时间   网址：http://www.ttlsa.com/html/3332.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx不记录特定日志(access_log_bypass_if)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-modules-access_log_bypass_if.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-modules-access_log_bypass_if,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>apache可以使用CustomLog [env=XXX]指定排除哪些日志不记录，nginx自身没有这个功能，但是在官方的第三方模块找到了ngx_log_if_module，它实现了类似env的功能.如果你想了解nginx更多nginx日志格式的资料，请参考咱们ttlsa《nginx日志配置》</p>
<p><strong>1. nginx第三方模块安装</strong></p>
<p>参考运维生存时间之前的文章《如何安装nginx第三方模块》</p>
<p><strong>2. 指令</strong><br>
语法: access_log_bypass_if (condition) [and]<br>
默认值: -<br>
Scope: main/srv/loc</p>
<p>"access_log_bypass_if" 定义的规则如果为真，那么相应的日志不会写入access log中. access_log_bypass_if你可以把它当做if来看待，access_log_bypass_if可以使用and逻辑运算.如果当前if有and，那么他和下一个if共同作用.</p>
<p> </p>
<p><strong>3. access_log_bypass_if配置</strong></p>
<p>如下是多个表达式的例子</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
 access_log_bypass_if ($status = 400);
 access_log_bypass_if ($host ~* 'ttlsa.com');
 access_log_bypass_if ($uri = 'status.nginx') and;
 access_log_bypass_if ($status = 200);
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>上面一共有4个表达式，前面两条分别独立，组后两条是and组合的。也就是说状态为400或者host为ttlsa.com或者（uri是status.nginx并且响应状态为200）的请求都不会记录到访问日志中.</p>
<p>当然，access_log_bypass_if会在多个地方出现，官方文档叫父配置块和子配置块，默认情况下子配置块会覆盖父配置块，并且不会继承父配置块的配置.<br>
如下例子</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
 access_log_bypass_if ($status = 400);
location / {
 access_log_bypass_if ($host ~* 'ttlsa.com');
 }
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>我们可以发现$status = 400根本就没有效果，因为他被location /里面的access_log_bypass_if覆盖了</p>
<p><strong>4. 参考地址</strong></p>
<p>官方地址：https://github.com/cfsego/ngx_log_if/</p>
<p> </p>
<p>站点：运维生存时间   网址：http://www.ttlsa.com/html/3887.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx动态IP黑白名单构建web防火墙(ngx_white_black_list)-nginx案例]]></title>
      <url>/nginx/nginx/nginx-module-ngx_white_black_list.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-module-ngx_white_black_list,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				<div>
<div>功能描述：</div>
<div>处在黑名单中的ip与网络，将无法访问web服务。</div>
<div>处在白名单中的ip，访问web服务时，将不受nginx所有安全模块的限制。</div>
<div>支持动态黑名单（需要与ngx_http_limit_req 配合）</div>
<div>具体详见下面的说明</div>
<div></div>
<div>文件配置方法说明</div>
<div></div>
<div><strong>一、定义黑名单或白名单方法：</strong></div>
<div>1. 配置格式</div>
<div>配置关键字 黑名单或白名单文件 存储空间</div>
<div>white_black_list_conf conf/white.list zone=white:2m;</div>
<div>  | | | |</div>
<div>  | | | --------------------------------------存储空间大小 这里是2m. 空间大小决定黑白名单的容量</div>
<div>  | | ---------------------------------------------------------------------------------------------存储空间名</div>
<div>  | ---------------------------------------------------------------黑名单或白名单配置文件路径</div>
<div>  ------------------------------------------------配置命令</div>
<div></div>
<div>2. 配置关键字 white_black_list_conf。</div>
<div>3. 只能在http{} 中使用</div>
<div>4. white_black_list_conf可以配置多个 只需 zone=value 其中的value不同就可</div>
<div>5. 配置示例：</div>
<div></div>
<div>http{</div>
<div>        ......</div>
<div>        white_black_list_conf conf/white.list zone=white:4m;</div>
<div>        white_black_list_conf conf/black.list zone=black:4m;</div>
<div>        ......</div>
<div>        server{</div>
<div>        .......</div>
<div>        }</div>
<div>        .......</div>
<div>}</div>
<div></div>
<div>二、黑白名单作用范围</div>
<div>1. 配置格式</div>
<div>配置关键字 on/off</div>
<div>配置关键字有：white_list 与 black_list 分别用来表示白名单与黑名单</div>
<div></div>
<div>2. 能在http{}、server{}、location{}下使用, 功能默认是关闭</div>
<div></div>
<div>3. 配置示例：</div>
<div>http{</div>
<div>        ......</div>
<div>        white_black_list_conf conf/white.list zone=white1:4m;</div>
<div>        white_black_list_conf conf/black.list zone=black1:4m;</div>
<div>        white_list white1 on; #白名单 white1 在整个http{} 中都开启</div>
<div>        black_list black1 on; #黑名单 black1 在整个http{} 中都开启</div>
<div>        server{</div>
<div>                .......</div>
<div>        }</div>
<div>        .......</div>
<div>}</div>
<div></div>
<div>http{</div>
<div>        ......</div>
<div>        white_black_list_conf conf/white.list zone=white2:4m;</div>
<div>        white_black_list_conf conf/black.list zone=black2:4m;</div>
<div>        server{</div>
<div>                .......</div>
<div>                white_list white2 on; #白名单 white1 在整个server{} 中都开启</div>
<div>                black_list black2 on; #黑名单 black1 在整个server{} 中都开启</div>
<div>                .......</div>
<div>        }</div>
<div>        .......</div>
<div>}</div>
<div></div>
<div></div>
<div>http{</div>
<div>        ......</div>
<div>        white_black_list_conf conf/white.list zone=white3:4m;</div>
<div>        white_black_list_conf conf/black.list zone=black3:4m;</div>
<div>        white_black_list_conf conf/black.list zone=black2:4m;</div>
<div>        white_black_list_conf conf/white.list zone=white2:4m;</div>
<div>        server{</div>
<div>                .......</div>
<div>                location /do {</div>
<div>                        ........</div>
<div>                        white_list white3 on; #白名单 white3 在location /do{} 中开启</div>
<div>                        black_list black3 on; #黑名单 black3 在location /do{} 中开启</div>
<div>                        ........</div>
<div>                }</div>
<div></div>
<div>                location /do1{</div>
<div>                        white_list white2 on; #白名单 white2 在整个server{} 中都开启</div>
<div>                        black_list black2 on; #黑名单 black2 在整个server{} 中都开启</div>
<div>                }</div>
<div>                .......</div>
<div>        }</div>
<div>        .......</div>
<div>}</div>
<div></div>
<div></div>
<div>http配置接口说明：</div>
<div>一、配置配置接口</div>
<div>http{</div>
<div>        .......</div>
<div>        server{</div>
<div>                ......</div>
<div>                location /sec_config{</div>
<div>                        sec_config on;</div>
<div>                }</div>
<div>                ......</div>
<div>        }</div>
<div>        .......</div>
<div>}</div>
<div></div>
<div></div>
<div>二、配置方法：</div>
<div>1. http://xxx/sec_config 查看黑白名单定义情况</div>
<div>返回结果如下</div>
<div>{</div>
<div>        "version":        "nginx/1.3.0",</div>
<div>        "code":        "0",</div>
<div>        "item":        {</div>
<div>                "conf_type":        "white_black_list_conf",</div>
<div>                "zone_name":        "white",</div>
<div>                "list_path":        "/home/john/nginx/conf/white.list"</div>
<div>        },</div>
<div>        "item":        {</div>
<div>                "conf_type":        "white_black_list_conf",</div>
<div>                "zone_name":        "black",</div>
<div>                "list_path":        "/home/john/nginx/conf/black.list"</div>
<div>        },</div>
<div>        "item":        {</div>
<div>                "conf_type":        "white_black_list_conf",</div>
<div>                "zone_name":        "ex",</div>
<div>                "list_path":        "/home/john/nginx/conf/status_ex"</div>
<div>        }</div>
<div>}</div>
<div></div>
<div>2. http://xxx/sec_config?zone_name=white 查看zone_name 为white 的 list_path中的具体内容</div>
<div></div>
<div>3. http://xxx/sec_config?zone_name=white&amp;add_item=192.168.141.23 向 zone_name 为white 中增加192.168.141.23</div>
<div></div>
<div>4. http://xxx/sec_config?zone_name=white&amp;delete_item=192.168.141.23 在 zone_name 为white 中删除192.168.141.23</div>
<div></div>
<div>查看配置方法2:</div>
<div>http://xxx/sec_config?for_each</div>
<div></div>
<div>三、黑白名单文件内容</div>
<div>conf/black.list 文件内容如下</div>
<div>2.2.2.2</div>
<div>192.168.141.1</div>
<div>3.3.3.3</div>
<div>4.4.4.5</div>
<div>2.3.4.4</div>
<div></div>
<div>四、动态黑名单</div>
<div>    要使用该功能必须对 ngx_http_limit_req_module.c 进行patch</div>
<div>    在ngx_http_limit_req_module.c中</div>
<div>    增加#include &lt;white_black_list.h&gt;</div>
<div>    并修改代码找到：</div>
<div>    "</div>
<div>    if (rc == NGX_BUSY) {</div>
<div>        ngx_log_error(lrcf-&gt;limit_log_level, r-&gt;connection-&gt;log, 0,</div>
<div>                      "limiting requests, excess: %ui.%03ui by zone \"%V\"",</div>
<div>                      excess / 1000, excess % 1000,</div>
<div>                      &amp;limit-&gt;shm_zone-&gt;shm.name);</div>
<div></div>
<div>        "</div>
<div>    在其下面增加：</div>
<div>    ngx_black_add_item_interface(r, 1);</div>
<div></div>
<div>        配备关键字：</div>
<div>                dyn_black</div>
<div></div>
<div>        格式：</div>
<div>                dyn_black $zone_name time;</div>
<div>        比如：</div>
<div>                dyn_black black 60; //禁止访问60秒，60秒后自动解除</div>
<div></div>
<div>        注意：</div>
<div>                必须要配置black_list</div>
<div></div>
<div>        配置示例：</div>
<div>                http{</div>
<div>                        ....</div>
<div>                        white_black_list_conf conf/black.list zone=black:4m;</div>
<div>                        limit_req_zone $binary_remote_addr zone=one:8m rate=4r/s;</div>
<div>                        ...</div>
<div>                        server {</div>
<div></div>
<div>                                location / {</div>
<div>                 black_list black on;</div>
<div>                 limit_req zone=one burst=6;</div>
<div>                 dyn_black black 60; //禁止访问60秒，60秒后自动解除</div>
<div>                 ...</div>
<div>                 }</div>
<div></div>
<div>                 location /xxx {</div>
<div>                 sec_config on;</div>
<div>                 }</div>
<div>                 ...</div>
<div>                        }</div>
<div>                        ...</div>
<div>                }</div>
<div></div>
<div>参考文章</div>
<div>项目地址：https://github.com/codehunte/ngx_white_black_list</div>
<div>项目文档：https://github.com/codehunte/ngx_white_black_list/blob/master/white_black_list.txt</div>
<div></div>
<div>网站：运维生存时间  网址：http://www.ttlsa.com/html/4145.html</div>
</div>
<div></div>
<div><span></span></div>			
</p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+fancy实现漂亮的索引目录-nginx案例]]></title>
      <url>/nginx/nginx/nginx-module-ngx-fancyindex.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-module-ngx-fancyindex,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3>前言</h3>
<p>nginx不仅仅作为web站点使用，也可以当做一个文件共享的使用，索引目录列表提供用户下载文件，apache的index功能很强大也很漂亮.咱们使用的nginx，说下nginx索引目录（nginx内置索引目录点我），他自带的功能很简单，而且不好看，如何做一个漂亮的索引列表.接下来看.</p>
<h3>安装环境</h3>
<p>系统：centos 6.3nginx:1.4.2<br>
fancy: http://wiki.nginx.org/NgxFancyIndex</p>
<h3>下载安装fancy</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://gitorious.org/ngx-fancyindex/ngx-fancyindex/archive-tarball/master
# tar -xzvf master
# wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
# ./configure --prefix=/usr/local/nginx-1.4.2  --add-module=../ngx-fancyindex-ngx-fancyindex
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p> </p>
<h3>fancy索引配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
listen       80;
 server_name  test.ttlsa.com;
 access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;
index index.html index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a> index.html;
 root /data/site/test.ttlsa.com;
location / {
}
 location ~ ^/2589(/.*)
 {
 fancyindex on;
 fancyindex_exact_size off;
 fancyindex_localtime on;
 fancyindex_footer "myfooter.shtml";
 }
 }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p> </p>
<p>看看nginx加了fancy的效果,如下图.</p>
<div><p>fancy+fancy</p></div>
<p> </p>
<p>对比一下nginx内置的index效果（上篇文章贴过来的图），如下</p>
<div><p>nginx auto_index索引效果图</p></div>
<p>参数解释：<br>
fancyindex on：开启fancy索引<br>
fancyindex_exact_size off:不使用精确的大小,使用四舍五入,1.9M会显示为2M这样.如果开启的话，单位为字节<br>
fancyindex_localtime on：使用本地时间<br>
fancyindex_footer "myfooter.shtml"：把当前路径下的myfooter.shtml内容作为底部.文件不存在底部会出现404<br>
myfooter.shtml内容如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><!-- footer START -->
 <div id="footer">
 <a id="gotop" href="#" onclick="MGJS.goTop();return false;">回到顶部</a>
 <a id="powered" href="http://wordpress.org/" target="_blank" rel="noopener">WordPress</a>
 <div id="copyright">
 版权所有 © 2011-2013 运维生存时间  </div>
 <div id="themeinfo">
 <a href="http://www.ttlsa.com/about/" target="_blank" rel="noopener">关于我们</a> | <a href="http://www.ttlsa.com/sitemap.html" target="_blank" rel="noopener">网站导航</a> | <a href="http://www.ttlsa.com/sitemap.xml" target="_blank" rel="noopener">网站地图</a> |<a rel="noopener" href="http://www.miibeian.gov.cn/" target="_blank">闽ICP备11007147号-1</a>
 </div>
 </div>
 <!-- footer END --></pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<h3>fancy指令使用：</h3>
<p>fancyindex<br>
语法: *fancyindex* [*on* | *off*]<br>
默认值: fancyindex off<br>
配置块: http, server, location<br>
描述: 开启/关闭目录索引功能</p>
<p>fancyindex_css_href</p>
<p>语法: *fancyindex_css_href uri*<br>
默认值: fancyindex_css_href ""<br>
配置块: http, server, location<br>
描述: 外置css路径，这个css将会替代掉现有的css样式。如果你会css，那你可以把索引列表做得更加漂亮.咱们ttlsa没有网页设计师,所以只能用自带的了^^</p>
<p>fancyindex_exact_size</p>
<p>语法: *fancyindex_exact_size* [*on* | *off*]<br>
默认值: fancyindex_exact_size on<br>
配置块: http, server, location<br>
描述: 定义如何显示文件的大小，默认是on，on：文件大小使用精确值，单位为字节.off:单位为KB,MB,GB，如果含有小数点，将会四舍五入。例如1.9MB，将会显示为2MB。</p>
<p>fancyindex_footer</p>
<p>语法: *fancyindex_footer path*<br>
默认值: fancyindex_footer ""<br>
配置块: http, server, location<br>
描述: 指定哪个文件嵌入到索引页面的底部，效果请看本文的第一张图片</p>
<p>fancyindex_header</p>
<p>语法: *fancyindex_header path*<br>
默认值: fancyindex_header ""<br>
配置块: http, server, location<br>
描述: 指定哪个文件嵌入到索引页面的头部.用法和fancyindex_footer类似</p>
<p>fancyindex_ignore</p>
<p>语法: *fancyindex_ignore string1 [string2 [... stringN]]*<br>
默认值: No default.<br>
配置块: http, server, location<br>
描述: 哪些文件/目录隐藏掉，如果你的nginx支持正则，那么可以使用正则表达式来过滤</p>
<p>例如我想隐藏dir打头的文件或目录以及文件filea.txt，配置如下：<br>
fancyindex_ignore "dir*" "filea.txt"<br>
效果如下：</p>
<p>对比图：</p>
<p>fancyindex_localtime</p>
<p>语法: *fancyindex_localtime* [*on* | *off*]<br>
默认值: fancyindex_localtime off<br>
配置块: http, server, location<br>
Description: 使用当地时间显示文件的创建时间，默认是off（GMT时间）</p>
<p>转载注明出处：http://www.ttlsa.com/html/2608.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx索引目录配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-module-auto_index.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-module-auto_index,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>为了简单共享文件，有些人使用svn，有些人使用ftp，但是更多得人使用索引(index)功能。apache得索引功能强大，并且也是最常见得，nginx得auto_index实现得目录索引偏少,而且功能非常简单。先来看看我们得效果图。</p>
<div><p>nginx auto_index索引效果图</p></div>
<p> </p>
<h3>nginx配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>        location ~ ^/2589(/.*)
        {
                autoindex on; //开启
                autoindex_localtime on;//开启显示功能
        }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3>auto_index指令</h3>
<table cellspacing="0">
<tbody>
<tr>
<td>语法:</td>
<td><code><strong>autoindex</strong> <code>on</code> | <code>off</code>;</code></td>
</tr>
<tr>
<td>配置段:</td>
<td>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>autoindex off;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->

</td>
</tr>
<tr>
<td>配置段:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
<p>启用/仅用nginx目录索引功能.</p>
<p> </p>
<div>
<table cellspacing="0">
<tbody>
<tr>
<td>语法:</td>
<td><code><strong>autoindex_exact_size</strong> <code>on</code> | <code>off</code>;</code></td>
</tr>
<tr>
<td>配置段</td>
<td>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>autoindex_exact_size on;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->

</td>
</tr>
<tr>
<td>配置段:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
</div>
<p>制定是否额外得显示文件得大小，单位为字节，mb,gb等等. 默认是打开得</p>
<p> </p>
<div>
<table cellspacing="0">
<tbody>
<tr>
<td>syntax:</td>
<td><code><strong>autoindex_localtime</strong> <code>on</code> | <code>off</code>;</code></td>
</tr>
<tr>
<td>配置段:</td>
<td>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>autoindex_localtime off;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->

</td>
</tr>
<tr>
<td>配置段:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
</div>
<p>指定是否显示目录或者文件得时间，默认是不显示</p>
<p>可以发现nginx的索引功能非常单一，比apache的差远了。有很多nginx的爱好者就看不过去了，开发了一个漂亮的索引插件,名叫fancy index. 请继续关注下节内容nginx+fancy实现漂亮的索引目录</p>
<p>转载请注明出处：http://www.ttlsa.com/html/2589.html</p>
<div></div>
<div></div>
<div></div>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+lua+redis构建高并发应用-nginx案例]]></title>
      <url>/nginx/nginx/nginx-lua-redis.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-lua-redis,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx+lua+redis构建高并发应用</p>
<p>ngx_lua将lua嵌入到nginx，让nginx执行lua脚本，高并发，非阻塞的处理各种请求。</p>
<p>url请求nginx服务器，然后lua查询redis，返回json数据。</p>
<p>备注：centos或者redhat系统请跳转到nginx + ngx_lua安装测试</p>
<h3>一.安装lua</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># apt-get install lua5.1
# apt-get install liblua5.1-dev
# apt-get install liblua5.1-socket2</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>二.安装nginx</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># apt-get install git-core
# git clone https://github.com/simpl/ngx_devel_kit.git
# git clone https://github.com/chaoslawful/lua-nginx-module.git
# git clone https://github.com/agentzh/redis2-nginx-module.git
# git clone https://github.com/agentzh/set-misc-nginx-module.git
# git clone https://github.com/agentzh/echo-nginx-module.git
# git clone https://github.com/catap/ngx_http_upstream_keepalive.git
# apt-get install libpcre3 libpcre3-dev libltdl-dev libssl-dev libjpeg62 libjpeg62-dev libpng12-0 libpng12-dev libxml2-dev libcurl4-openssl-dev libmcrypt-dev autoconf libxslt1-dev libgd2-noxpm-dev libgeoip-dev lib<a href="http://www.ttlsa.com/perl/" title="perl" target="_blank">perl</a>-dev -y
# wget http://nginx.org/download/nginx-1.0.8.tar.gz
# tar zxvf nginx-1.0.8.tar.gz
# cd nginx-1.0.8
# ./configure --prefix=/usr/local/nginx --with-debug --with-http_addition_module \
--with-http_dav_module --with-http_flv_module --with-http_geoip_module \
--with-http_gzip_static_module --with-http_image_filter_module --with-http_perl_module \
--with-http_random_index_module --with-http_realip_module --with-http_secure_link_module \
--with-http_stub_status_module --with-http_ssl_module --with-http_sub_module \
--with-http_xslt_module --with-ipv6 --with-sha1=/usr/include/openssl \
--with-md5=/usr/include/openssl --with-mail --with-mail_ssl_module \
--add-module=../ngx_devel_kit \
--add-module=../echo-nginx-module \
--add-module=../lua-nginx-module \
--add-module=../redis2-nginx-module \
--add-module=../ngx_http_upstream_keepalive \
--add-module=../set-misc-nginx-module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0015 seconds] -->
<p></p>
<h3>三.安装lua-redis-parser</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># git clone https://github.com/agentzh/lua-redis-parser.git
# export LUA_INCLUDE_DIR=/usr/include/lua5.1
# make CC=gcc
# make install CC=gcc</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>四.安装json</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://files.luaforge.net/releases/json/json/0.9.50/json4lua-0.9.50.zip
# unzip json4lua-0.9.50.zip
# cp json4lua-0.9.50/json/json.lua /usr/share/lua/5.1/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>五.安装redis-lua</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># git clone https://github.com/nrk/redis-lua.git
# cp redis-lua/src/redis.lua /usr/share/lua/5.1/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>六.配置</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>user www-data;
worker_processes 8;
worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;
error_log logs/error.log notice;
pid logs/nginx.pid;
worker_rlimit_nofile 60000;

events {
worker_connections 1024;
use epoll;

}

http {
include mime.types;
default_type application/octet-stream;
access_log logs/access.log;
sendfile on;
tcp_nopush on;
tcp_nodelay on;
keepalive_timeout 60;
types_hash_max_size 2048;
server_tokens off;
lua_code_cache on;

upstream redis_pool {
server 192.168.1.39:6379;
keepalive 1024 single; //定义连接池大小，当连接数达到此数后，后续的连接为短连接

}

server {
listen 80;
server_name 192.168.1.211;

location /get_redis{
#internal;
set_unescape_uri $key $arg_key;
redis2_query hgetall $key;
redis2_pass redis_pool;
}

location /json {
content_by_lua_file conf/fuck.lua;
}
}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0013 seconds] -->
<p># vim fuck.lua</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>local json = require("json")
local parser = require("redis.parser")
local res = ngx.location.capture("/get_redis",{
args = { key = ngx.var.arg_key }
})
if res.status == 200 then
reply = parser.parse_reply(res.body)
value = json.encode(reply)
ngx.say(value)
a = json.decode(value)
ngx.say(a[2])
end</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<h3>七.测试</h3>
<p># redis-cli -h 192.168.1.39</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>redis 192.168.1.39:6379&gt; HMSET ttlsa www www.ttlsa.com mail mail.ttlsa.com

OK</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p># curl 'http://192.168.1.211/json?key=ttlsa'</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>["www","www.ttlsa.com","mail","mail.ttlsa.com"]</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>www.ttlsa.com</p>
<p> </p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx 逻辑运算-nginx案例]]></title>
      <url>/nginx/nginx/nginx-logic.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-logic,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx的配置中不支持if条件的逻辑与&amp;&amp; 逻辑或|| 运算 ，而且不支持if的嵌套语法，否则会报下面的错误：nginx: [emerg] invalid condition。</p>
<p>我们可以用变量的方式来间接实现。</p>
<p>要实现的语句：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>if ($arg_unitid = 42012 &amp;&amp; $uri ~/thumb/){
 echo "www.ttlsa.com";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>如果按照这样来配置，就会报nginx: [emerg] invalid condition错误。</p>
<p>可以这么来实现，如下所示：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>set $flag 0;
if ($uri ~ ^/thumb/[0-9]+_160.jpg$){
 set $flag "${flag}1";
}
if ($arg_unitid = 42012){
 set $flag "${flag}1";
}
if ($flag = "011"){
 echo "www.ttlsa.com";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>转载请注明来自运维生存时间:  http://www.ttlsa.com/html/3876.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx日志切割-nginx案例]]></title>
      <url>/nginx/nginx/nginx-log-cutting.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-log-cutting,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p><span>nginx日志默认情况下统统写入到一个文件中，文件会变的越来越大，非常不方便查看分析。以日期来作为日志的切割是比较好的，通常我们是以每日来做统计的。下面来说说nginx日志切割。<br>
关于nginx相关日志配置参见：《nginx日志配置》一文。logrotate用法参见《logrotate日志管理工具》。</span></p>
<h3>1. 定义日志轮滚策略</h3>
<p># vim nginx-log-rotate</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/data/weblogs/*.log {
    nocompress
    daily
    copytruncate
    create
    notifempty
    rotate 7
    olddir /data/weblogs/old_log
    missingok
    dateext
    postrotate
        /bin/kill -HUP `cat /var/run/nginx.pid 2&gt; /dev/null` 2&gt; /dev/null || true
    endscript
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>[warning]/data/weblogs/*.log使用通配符时，/data/weblogs/目录下的所有匹配到的日志文件都将切割。如果要切割特定日志文件，就指定到该文件。[/warning]</p>
<h3>2. 设置计划任务</h3>
<p># vim /etc/crontab</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>59 23 * * * root ( /usr/sbin/logrotate -f /PATH/TO/nginx-log-rotate)</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>这样每天23点59分钟执行日志切割。</p>
<p>如需转载请注明出处： http://www.ttlsa.com/html/3166.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx location配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-location-configure.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-location-configure,<br><a id="more"></a><br>
  <span><fieldset><legend>摘要</legend><p>       今天讲下location的用法，部分内容是直接从网络上摘取的，这边做了一个整理，为了便于理解和学习，我这边做了一些例子。</p>
<p>语法规则： location [=|~|~*|^~] /uri/ { … }<br>
= 表示精确匹配,这个优先级也是最高的<br>
^~ 表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。</p>
<div></div></fieldset></span>
							<div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>今天讲下location的用法，部分内容是直接从网络上摘取的，这边做了一个整理，为了便于理解和学习，我这边做了一些例子。</p>
<p>语法规则： location [=|~|~*|^~] /uri/ { … }<br>
= 表示精确匹配,这个优先级也是最高的<br>
^~ 表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。<br>
~  表示区分大小写的正则匹配<br>
~* 表示不区分大小写的正则匹配(和上面的唯一区别就是大小写)<br>
!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则<br>
/ 通用匹配，任何请求都会匹配到，默认匹配.</p>
<p>下面讲讲这些语法的一些规则和优先级<br>
多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：</p>
<p>优先级=&gt;^~&gt;<br>
首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p>
<p>例子，有如下匹配规则：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
   echo "/"; //需要安装echo模块才行,这边大家可以改成各自的规则
}
location = / {
   echo "=/";
}
location = /nginx {
   echo "=/nginx";
}
location ~ \.(gif|jpg|png|js|css)$ {
   echo "small-gif/jpg/png";
}
location ~* \.png$ {
   echo "all-png";
}
location ^~ /static/ {
   echo "static";
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>以下是各种的访问情况</p>
<p>访问http://a.ttlsa.com/.因为/是完全匹配的<br>
如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://a.ttlsa.com/
 =/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>访问http://a.ttlsa.com/nginx,因为完全匹配了"=/nginx"</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://a.ttlsa.com/nginx
=/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>访问http://a.ttlsa.com/nginx,从第一个开始尝试匹配,最后匹配到了~* \.png$ .</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://a.ttlsa.com/xxx/1111.PNG （注意,这是大写）
all-png</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>访问http://a.ttlsa.com/static/1111.png,虽然static放在最后面,但是因为有^的缘故,他是最匹配的.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl http://a.ttlsa.com/static/1111.png
static</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>好了，最后给出我们先上环境的静态文件的匹配规则</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location ~* .*\.(js|css)?$
{
        expires 7d; //7天过期,后续讲解
        access_log off; //不保存日志
}

location ~* .*\.(png|jpg|gif|jpeg|bmp|ico)?$
{        
        expires 7d;
        access_log off;
}

location ~* .*\.(zip|rar|exe|msi|iso|gho|mp3|rmvb|mp4|wma|wmv|rm)?$
{
        deny all; //禁止这些文件下载，大家可以根据自己的环境来配置
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx限制请求数ngx_http_limit_req_module模块-nginx案例]]></title>
      <url>/nginx/nginx/nginx-limiting-the-number-of-requests-ngx_http_limit_req_module-module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-limiting-the-number-of-requests-ngx_http_limit_req_module-module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong><span>一. 前言</span></strong></h3>
<p>在《nginx限制连接数ngx_http_limit_conn_module模块》我们说到了ngx_http_limit_conn_module 模块，来限制连接数。那么请求数的限制该怎么做呢？这就需要通过ngx_http_limit_req_module 模块来实现，该模块可以通过定义的 键值来限制请求处理的频率。特别的，可以限制来自单个IP地址的请求处理频率。 限制的方法如同漏斗，每秒固定处理请求数，推迟过多请求。</p>
<h3><strong>二.</strong> ngx_http_limit_req_module模块指令</h3>
<p>limit_req_zone<br>
语法: limit_req_zone $variable zone=name:size rate=rate;<br>
默认值: none<br>
配置段: http<br>
设置一块共享内存限制域用来保存键值的状态参数。 特别是保存了当前超出请求的数量。 键的值就是指定的变量（空值不会被计算）。如</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>说明：区域名称为one，大小为10m，平均处理的请求频率不能超过每秒一次。<br>
键值是客户端IP。<br>
使用$binary_remote_addr变量， 可以将每条状态记录的大小减少到64个字节，这样1M的内存可以保存大约1万6千个64字节的记录。<br>
如果限制域的存储空间耗尽了，对于后续所有请求，服务器都会返回 503 (Service Temporarily Unavailable)错误。<br>
速度可以设置为每秒处理请求数和每分钟处理请求数，其值必须是整数，所以如果你需要指定每秒处理少于1个的请求，2秒处理一个请求，可以使用 “30r/m”。</p>
<p>limit_req_log_level<br>
语法: limit_req_log_level info | notice | warn | error;<br>
默认值: limit_req_log_level error;<br>
配置段: http, server, location<br>
设置你所希望的日志级别，当服务器因为频率过高拒绝或者延迟处理请求时可以记下相应级别的日志。 延迟记录的日志级别比拒绝的低一个级别；比如， 如果设置“limit_req_log_level notice”， 延迟的日志就是info级别。</p>
<p>limit_req_status<br>
语法: limit_req_status code;<br>
默认值: limit_req_status 503;<br>
配置段: http, server, location<br>
该指令在1.3.15版本引入。设置拒绝请求的响应状态码。</p>
<p>limit_req<br>
语法: limit_req zone=name [burst=number] [nodelay];<br>
默认值: —<br>
配置段: http, server, location<br>
设置对应的共享内存限制域和允许被处理的最大请求数阈值。 如果请求的频率超过了限制域配置的值，请求处理会被延迟，所以所有的请求都是以定义的频率被处理的。 超过频率限制的请求会被延迟，直到被延迟的请求数超过了定义的阈值，这时，这个请求会被终止，并返回503 (Service Temporarily Unavailable) 错误。这个阈值的默认值为0。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_req_zone $binary_remote_addr zone=ttlsa_com:10m rate=1r/s;
server {
    location /www.ttlsa.com/ {
        limit_req zone=ttlsa_com burst=5;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。<br>
如果不希望超过的请求被延迟，可以用nodelay参数,如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_req zone=ttlsa_com burst=5 nodelay;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3><strong>三. 完整实例配置</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	limit_req_zone $binary_remote_addr zone=ttlsa_com:10m rate=1r/s;

	server {
		location  ^~ /download/ {  
			limit_req zone=ttlsa_com burst=5;
			alias /data/www.ttlsa.com/download/;
        }
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>可能要对某些IP不做限制，需要使用到白名单。名单设置参见后续的文档，我会整理一份以供读者参考。请专注。</p>
<p>如需转载请注明出处：http://www.ttlsa.com/html/3185.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx限制连接数ngx_http_limit_conn_module模块-nginx案例]]></title>
      <url>/nginx/nginx/nginx-limited-connection-number-ngx_http_limit_conn_module-module.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-limited-connection-number-ngx_http_limit_conn_module-module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><h3><strong><span>一. 前言</span></strong></h3>
<p>我们经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个ip的连接数，并发数进行限制。下面说说ngx_http_limit_conn_module 模块来实现该需求。该模块可以根据定义的键来限制每个键值的连接数，如同一个IP来源的连接数。并不是所有的连接都会被该模块计数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。</p>
<h3>二. ngx_http_limit_conn_module指令解释</h3>
<p>limit_conn_zone<br>
语法: limit_conn_zone $variable zone=name:size;<br>
默认值: none<br>
配置段: http<br>
该指令描述会话状态存储区域。键的状态中保存了当前连接数，键的值可以是特定变量的任何非空值（空值将不会被考虑）。$variable定义键，zone=name定义区域名称，后面的limit_conn指令会用到的。size定义各个键共享内存空间大小。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_conn_zone $binary_remote_addr zone=addr:10m;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>注释：客户端的IP地址作为键。注意，这里使用的是$binary_remote_addr变量，而不是$remote_addr变量。<br>
$remote_addr变量的长度为7字节到15字节，而存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。<br>
$binary_remote_addr变量的长度是固定的4字节，存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。<br>
1M共享空间可以保存3.2万个32位的状态，1.6万个64位的状态。<br>
如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。<br>
limit_zone 指令和limit_conn_zone指令同等意思，已经被弃用，就不再做说明了。</p>
<p>limit_conn_log_level<br>
语法：limit_conn_log_level info | notice | warn | error<br>
默认值：error<br>
配置段：http, server, location<br>
当达到最大限制连接数后，记录日志的等级。</p>
<p>limit_conn<br>
语法：limit_conn zone_name number<br>
默认值：none<br>
配置段：http, server, location<br>
指定每个给定键值的最大同时连接数，当超过这个数字时被返回503 (Service Temporarily Unavailable)错误。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_conn_zone $binary_remote_addr zone=addr:10m;
server {
    location /www.ttlsa.com/ {
        limit_conn addr 1;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>同一IP同一时间只允许有一个连接。<br>
当多个 limit_conn 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数，同时也会限制单一虚拟服务器的总连接数：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
server {
    limit_conn perip 10;
    limit_conn perserver 100;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>[warning]limit_conn指令可以从上级继承下来。[/warning]</p>
<p>limit_conn_status<br>
语法: limit_conn_status code;<br>
默认值: limit_conn_status 503;<br>
配置段: http, server, location<br>
该指定在1.3.15版本引入的。指定当超过限制时，返回的状态码。默认是503。</p>
<p>limit_rate<br>
语法：limit_rate rate<br>
默认值：0<br>
配置段：http, server, location, if in location<br>
对每个连接的速率限制。参数rate的单位是字节/秒，设置为0将关闭限速。 按连接限速而不是按IP限制，因此如果某个客户端同时开启了两个连接，那么客户端的整体速率是这条指令设置值的2倍。</p>
<h3><strong>三. 完整实例配置</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	limit_conn_zone $binary_remote_addr zone=limit:10m;
	limit_conn_log_level info;

	server {
		location  ^~ /download/ {  
			limit_conn limit 4;
			limit_rate 200k;
			alias /data/www.ttlsa.com/download/;
                }
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h3><strong>四. 使用注意事项</strong></h3>
<p>事务都具有两面性的。ngx_http_limit_conn_module 模块虽说可以解决当前面临的并发问题，但是会引入另外一些问题的。如前端如果有做LVS或反代，而我们后端启用了该模块功能，那不是非常多503错误了？这样的话，可以在前端启用该模块，要么就是设置白名单，白名单设置参见后续的文档，我会整理一份以供读者参考。<br>
可以与ngx_http_limit_req_module 模块结合起来使用，以达到最好效果。《nginx限制请求数ngx_http_limit_req_module模块》。</p>
<p>如需转载请注明出处：http://www.ttlsa.com/html/3180.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+keepalived+proxy_cache 配置高可用nginx群集和高速缓存-nginx案例]]></title>
      <url>/nginx/nginx/nginx-keepalived-proxy_cache.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-keepalived-proxy_cache,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>环境：<br>
CentOS release 5.8 192.168.10.108 cat</p>
<p>CentOS release 5.5 912.168.200.208<br>
主调度器：192.168.10.108 192.169.10.251</p>
<p>备调度器：192.168.200.208 192.168.200.148</p>
<p>real ip :<br>
192.169.10.251<br>
192.168.200.148</p>
<p>vip : 192.168.10.104</p>
<p> </p>
<p>一、在主备服务器上部署nginx</p>
<p>1、下载</p>
<p>wget http://nginx.org/download/nginx-1.0.11.tar.gz</p>
<p>wget http://labs.frickle.com/files/ngx_cache_purge-1.4.tar.gz</p>
<p> </p>
<p>2、安装</p>
<p>yum -y install zlib-devel pcre-devel openssl-devel  # 安装依赖</p>
<p>tar –xvf ngx_cache_purge-1.4.tar.gz</p>
<p>tar –xvf nginx-1.0.11.tar.gz<br>
cd nginx-1.0.11/</p>
<p>./configure --prefix=/usr/local/nginx --add-module=../ngx_cache_purge-1.4 --with-http_stub_status_module --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module</p>
<p>Make &amp;&amp; make install</p>
<p> </p>
<p>vi /usr/local/nginx/conf/nginx.conf</p>
<p>user nobody;<br>
worker_processes 8;</p>
<p>#error_log logs/error.log error;<br>
error_log /data/logs/error.log crit;</p>
<p>#error_log logs/error.log notice;<br>
#error_log logs/error.log info;</p>
<p>#pid logs/nginx.pid;<br>
events {<br>
worker_connections 1024;<br>
}<br>
http {<br>
include mime.types;<br>
default_type application/octet-stream;</p>
<p>charset utf-8;<br>
server_names_hash_bucket_size 128;<br>
client_header_buffer_size 32k;<br>
large_client_header_buffers 4 32k;<br>
client_max_body_size 300m;<br>
tcp_nopush on;<br>
tcp_nodelay on;<br>
client_body_buffer_size 512k;<br>
proxy_connect_timeout 5;<br>
proxy_read_timeout 60;<br>
proxy_send_timeout 5;<br>
proxy_buffer_size 16k;<br>
proxy_buffers 4 64k;<br>
proxy_busy_buffers_size 128k;<br>
proxy_temp_file_write_size 128k;<br>
#log_format main '$remote_addr - $remote_user [$time_local] "$request" '<br>
# '$status $body_bytes_sent "$http_referer" '<br>
# '"$http_user_agent" "$http_x_forwarded_for"';</p>
<p>#access_log logs/access.log main;</p>
<p>sendfile on;</p>
<p>#keepalive_timeout 65;<br>
gzip on;<br>
gzip_min_length 1k;<br>
gzip_buffers 4 16k;<br>
gzip_http_version 1.1;<br>
gzip_comp_level 2;<br>
gzip_types text/plain application/x-javascript text/css application/xml;<br>
gzip_vary on;<br>
proxy_temp_path /data/proxy_temp_dir;<br>
proxy_cache_path /data/proxy_cache_dir levels=1:2 keys_zone=cache_one:50m inactive=1m max_size=2g;<br>
upstream real_server_pool{<br>
server 192.168.200.148:80 weight=1 max_fails=2 fail_timeout=30s;<br>
server 192.168.10.251:80 weight=1 max_fails=2 fail_timeout=30s;<br>
}</p>
<p>#tcp_nopush on;</p>
<p>#keepalive_timeout 0;<br>
keepalive_timeout 65;</p>
<p>#gzip on;</p>
<p>server {<br>
listen 80;<br>
server_name localhost;</p>
<p>#charset koi8-r;</p>
<p>#access_log logs/host.access.log main;</p>
<p>location / {<br>
root html;</p>
<p>index index.html index.htm;</p>
<p>proxy_next_upstream http_502 http_504 error timeout invalid_header;<br>
proxy_cache cache_one;<br>
proxy_cache_valid 200 304 12h;<br>
proxy_cache_key $host$uri$is_args$args;<br>
proxy_set_header Host $host;<br>
proxy_set_header X-Forwarded-For $remote_addr;<br>
proxy_pass http://real_server_pool;<br>
expires 1d;</p>
<p> </p>
<p>}</p>
<p>#error_page 404 /404.html;</p>
<p># redirect server error pages to the static page /50x.html<br>
#<br>
error_page 500 502 503 504 /50x.html;<br>
location = /50x.html {<br>
root html;<br>
}</p>
<p># proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>
#<br>
#location ~ \.php$ {<br>
# proxy_pass http://127.0.0.1;<br>
#}<br>
location ~ .*\.(php|jsp|cgi)?$<br>
{<br>
proxy_set_header Host $host;<br>
proxy_set_header X-Forwarded-For $remote_addr;<br>
proxy_pass http://real_server_pool;<br>
}<br>
log_format access '$remote_addr - $remote_user [$time_local] "$request"'<br>
'$status $body_bytes_sent "$http_referer" '<br>
'"$http_user_agent" $http_x_forwarded_for';<br>
access_log /data/logs/access.log access;<br>
}</p>
<p> </p>
<p># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>
#<br>
#location ~ \.php$ {<br>
# root html;<br>
# fastcgi_pass 127.0.0.1:9000;<br>
# fastcgi_index index.php;<br>
# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;<br>
# include fastcgi_params;<br>
#}</p>
<p># deny access to .htaccess files, if Apache's document root<br>
# concurs with nginx's one<br>
#<br>
#location ~ /\.ht {<br>
# deny all;<br>
#}<br>
}<br>
# another virtual host using mix of IP-, name-, and port-based configuration<br>
#<br>
#server {<br>
# listen 8000;<br>
# listen somename:8080;<br>
# server_name somename alias another.alias;</p>
<p># location / {<br>
# root html;<br>
# index index.html index.htm;<br>
# }<br>
#}<br>
# HTTPS server<br>
#<br>
#server {<br>
# listen 443;<br>
# server_name localhost;</p>
<p># ssl on;<br>
# ssl_certificate cert.pem;<br>
# ssl_certificate_key cert.key;</p>
<p># ssl_session_timeout 5m;</p>
<p># ssl_protocols SSLv2 SSLv3 TLSv1;<br>
# ssl_ciphers HIGH:!aNULL:!MD5;<br>
# ssl_prefer_server_ciphers on;</p>
<p># location / {<br>
# root html;<br>
# index index.html index.htm;<br>
# }<br>
#}</p>
<p> </p>
<p>备用调度器的nginx配置文件和主调度器的配置文件一样。</p>
<p>启动nginx</p>
<p>/usr/local/nginx/sbin/nginx</p>
<p> </p>
<p>二、安装keepalived（在nginx的mater和backup都安装）</p>
<p> </p>
<p>1、  下载</p>
<p>wget http://www.keepalived.org/software/keepalived-1.1.19.tar.gz</p>
<p> </p>
<p>2、  安装</p>
<p>tar zxvf keepalived-1.1.19.tar.gz<br>
cd keepalived-1.1.19<br>
./configure --prefix=/usr/local/keepalived<br>
make<br>
make install</p>
<p>cp /usr/local/keepalived/sbin/keepalived /usr/sbin/<br>
cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/<br>
cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/<br>
mkdir /etc/keepalived</p>
<p> </p>
<p>vi /etc/keepalived/keepalived.conf</p>
<p>vrrp_instance VI_INET1 {<br>
state MASTER<br>
interface eth0<br>
virtual_router_id 53<br>
priority 100<br>
advert_int 1<br>
authentication {<br>
auth_type pass<br>
auth_pass 1111<br>
}<br>
virtual_ipaddress {<br>
192.168.10.104/24<br>
}<br>
}<br>
virtual_server 192.168.10.104 80 {<br>
delay_loop 6<br>
lb_algo rr<br>
lb_kind NAT<br>
nat_mask 255.255.255.0<br>
persistence_timeout 50<br>
protocol TCP<br>
real_server 192.168.10.251 80 {<br>
weight 3<br>
TCP_CHECK {<br>
connect_timeout 10<br>
nb_get_retry 3</p>
<p>delay_before_retry 3<br>
connect_port 80<br>
}<br>
}<br>
real_server 192.168.200.148 80 {<br>
weight 3<br>
TCP_CHECK {<br>
connect_timeout 10<br>
nb_get_retry 3<br>
delay_before_retry 3<br>
connect_port 80<br>
}<br>
}</p>
<p>}</p>
<p>4、配置备用调度器的keepalived,只需要将state MASTER 改为state BACKUP,降低priority 100 的值:</p>
<p>state MASTER ---&gt; state BACKUP</p>
<p>priority 100 ---&gt;  priority 99 （此值必须低于主的）</p>
<p>主备启动</p>
<p>/etc/init.d/keepalived start</p>
<p> </p>
<p>三、测试</p>
<p>建立虚拟主机（自己测试啊    O(∩_∩)O~）</p>
<p> </p>
<p> </p>
<p> </p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx安装-nginx案例]]></title>
      <url>/nginx/nginx/nginx-install-on-linux.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-install-on-linux<br><a id="more"></a><br>
  <span><fieldset><legend>摘要</legend><p>当今nginx的劲头越来越猛，记得2011年版本才1.0.6,现在已经更新到了1.5.1,nginx的更新速度越来越快。一直想记录一系列的nginx教程，处于各种原因没去做.今年抽出时间完成平时工作上用到的nginx.后续将会以视频教程的方式来做。当然，还是文章先出，下一篇文章将会讲nginx虚拟主机配置。有什么建议，望大家留言。</p>
<div></div></fieldset></span>
							<div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>当今nginx的劲头越来越猛，记得2011年版本才1.0.6,现在已经更新到了1.5.1,nginx的更新速度越来越快。一直想记录一系列的nginx教程，处于各种原因没去做.今年抽出时间完成平时工作上用到的nginx.后续将会以视频教程的方式来做。当然，还是文章先出，下一篇文章将会讲nginx虚拟主机配置。有什么建议，望大家留言。</p>
<h3>1、必要软件准备</h3>
<ul>
<li>安装pcre</li>
</ul>
<p>为了支持rewrite功能，我们需要安装pcre</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># yum install pcre* //如过你已经装了，请跳过这一步</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<ul>
<li>安装openssl</li>
</ul>
<p>需要ssl的支持，如果不需要ssl支持，请跳过这一步</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># yum install openssl*</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>2、<strong>安装nginx</strong></h3>
<p>执行如下命令：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./configure --prefix=/usr/local/nginx-1.5.1 \
--with-http_ssl_module --with-http_spdy_module \
--with-http_stub_status_module --with-pcre</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>--with-http_stub_status_module：支持nginx状态查询<br>
--with-http_ssl_module：支持https<br>
--with-http_spdy_module：支持google的spdy,想了解请百度spdy,这个必须有ssl的支持<br>
--with-pcre：为了支持rewrite重写功能，必须制定pcre</p>
<p>最后输出如下内容，表示configure OK了。<br>
.....</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>checking for zlib library ... found
 creating objs/Makefile
Configuration summary
 + using system PCRE library
 + using system OpenSSL library
 + md5: using OpenSSL library
 + sha1: using OpenSSL library
 + using system zlib library
nginx path prefix: "/usr/local/nginx-1.5.1"
 nginx binary file: "/usr/local/nginx-1.5.1/sbin/nginx"
 nginx configuration prefix: "/usr/local/nginx-1.5.1/conf"
 nginx configuration file: "/usr/local/nginx-1.5.1/conf/nginx.conf"
 nginx pid file: "/usr/local/nginx-1.5.1/logs/nginx.pid"
 nginx error log file: "/usr/local/nginx-1.5.1/logs/error.log"
 nginx http access log file: "/usr/local/nginx-1.5.1/logs/access.log"
 nginx http client request body temporary files: "client_body_temp"
 nginx http proxy temporary files: "proxy_temp"
 nginx http fastcgi temporary files: "fastcgi_temp"
 nginx http uwsgi temporary files: "uwsgi_temp"
 nginx http scgi temporary files: "scgi_temp"
# make //确定你的服务器有安装make，如果没有安装请执行yum install make
 # make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<h3>3、启动、关闭、重置nginx</h3>
<p>启动：直接执行以下命令,nginx就启动了,不需要改任何配置文件,nginx配置多域名虚拟主机请参考后续文章.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.5.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>试试访问：我这边不贴图，直接使用curl命令来读取web信息</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[root@ns conf]# curl -s http://localhost | grep nginx.com
nginx.com.</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>关闭：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.5.1/sbin/nginx -s stop</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>重置：当你有修改配置文件的时候，只需要reload以下即可</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.5.1/sbin/nginx -s reload</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>整个nginx的安装就到这里结束了。</p>
<p>转载请注明出处：http://www.ttlsa.com/html/1548.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CDN下nginx获取用户真实IP地址-nginx案例]]></title>
      <url>/nginx/nginx/nginx-get-user-real-ip.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-get-user-real-ip,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>随着nginx的迅速崛起，越来越多公司将apache更换成nginx. 同时也越来越多人使用nginx作为负载均衡, 并且代理前面可能还加上了CDN加速，但是随之也遇到一个问题：nginx如何获取用户的真实IP地址,如果后端是apache,请跳转到&lt;apache获取用户真实IP地址&gt;，如果是后端真实服务器是nginx，那么继续往下看。</p>
<p>实例环境：<br>
用户IP 120.22.11.11<br>
CDN前端 61.22.22.22<br>
CDN中转 121.207.33.33<br>
公司NGINX前端代理 192.168.50.121（外网121.207.231.22）</p>
<p><strong>1、使用CDN自定义IP头来获取</strong></p>
<p>假如说你的CDN厂商使用nginx,那么在nginx上将$remote_addr赋值给你指定的头,方法如下:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>proxy_set_header remote-user-ip $remote_addr;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>//如上,后端将会收到remote_user_ip的http头，有些人可能会挑错了，说我设置的头不是remote-user-ip吗,怎么写成了remote_user_ip,是不是作者写错了.请参考文章：&lt;nginx反向代理proxy_set_header自定义header头无效&gt;</p>
<p>后端PHP代码getRemoteUserIP.php</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><?php $ip = getenv("HTTP_REMOTE_USER_IP");
    echo $ip;    
></pre></div>
			 
		</div>
<!-- [Format Time: 0.0048 seconds] -->
<p>访问getRemoteUserIP.php,结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>120.22.11.11 //取到了真实的用户IP,如果CDN能给定义这个头的话,那这个方法最佳</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><strong>2、通过HTTP_X_FORWARDED_FOR获取IP地址</strong></p>
<p>一般情况下CDN服务器都会传送HTTP_X_FORWARDED_FOR头,这是一个ip串,后端的真实服务器获取HTTP_X_FORWARDED_FOR头,截取字符串第一个不为unkown的IP作为用户真实IP地址, 例如：</p>
<p>120.22.11.11,61.22.22.22,121.207.33.33,192.168.50.121（用户IP,CDN前端IP,CDN中转,公司NGINX代理）</p>
<p>getFor.php</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><?php $ip = getenv("HTTP_X_FORWARDED_FOR");
    echo $ip;
></pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>访问getFor.php结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>120.22.11.11,61.22.22.22,121.207.33.33,192.168.50.121</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果你是php程序员,你获取第一个不为unknow的ip地址,这边就是120.22.11.11.</p>
<p><strong>3.使用nginx自带模块realip获取用户IP地址</strong><br>
安装nginx之时加上realip模块，我的参数如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    ./configure --prefix=/usr/local/nginx-1.4.1 --with-http_realip_module</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>真实服务器nginx配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    server {
        listen       80;
        server_name  www.ttlsa.com;
        access_log  /data/logs/nginx/www.ttlsa.com.access.log  main;

        index index.php index.html index.html;
        root /data/site/www.ttlsa.com;

        location /
        {
                root /data/site/www.ttlsa.com;
        }
        location = /getRealip.php
        {
                set_real_ip_from  192.168.50.0/24;
                set_real_ip_from  61.22.22.22;
                set_real_ip_from  121.207.33.33;
                set_real_ip_from 127.0.0.1;
                real_ip_header    X-Forwarded-For;
                real_ip_recursive on;
                fastcgi_pass  unix:/var/run/phpfpm.sock;
                fastcgi_index index.php;
                include fastcgi.conf;
        }
    }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0013 seconds] -->
<p>getRealip.php内容</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    <?php $ip =  $_SERVER['REMOTE_ADDR'];
        echo $ip;    
    ></pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>访问www.ttlsa.com/getRealip.php,返回：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    120.22.11.11</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果注释 real_ip_recursive on或者 real_ip_recursive off<br>
访问www.ttlsa.com/getRealip.php,返回：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>121.207.33.33</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>很不幸,获取到了中继的IP,real_ip_recursive的效果看明白了吧.</p>
<p>set_real_ip_from：真实服务器上一级代理的IP地址或者IP段,可以写多行<br>
real_ip_header：从哪个header头检索出要的IP地址<br>
real_ip_recursive：递归排除IP地址,ip串从右到左开始排除set_real_ip_from里面出现的IP,如果出现了未出现这些ip段的IP，那么这个IP将被认为是用户的IP。例如我这边的例子，真实服务器获取到的IP地址串如下：<br>
120.22.11.11,61.22.22.22,121.207.33.33,192.168.50.121<br>
在real_ip_recursive on的情况下<br>
61.22.22.22,121.207.33.33,192.168.50.121都出现在set_real_ip_from中,仅仅120.22.11.11没出现,那么他就被认为是用户的ip地址，并且赋值到remote_addr变量</p>
<p>在real_ip_recursive off或者不设置的情况下<br>
192.168.50.121出现在set_real_ip_from中,排除掉，接下来的ip地址便认为是用户的ip地址</p>
<p>如果仅仅如下配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>    set_real_ip_from   192.168.50.0/24;
    set_real_ip_from 127.0.0.1;
    real_ip_header    X-Forwarded-For;
    real_ip_recursive on;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>访问结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>   121.207.33.33</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><strong>4、三种在CDN环境下获取用户IP方法总结</strong><br>
4.1 CDN自定义header头<br>
优点：获取到最真实的用户IP地址,用户绝对不可能伪装IP<br>
缺点：需要CDN厂商提供</p>
<p>4.2 获取forwarded-for头<br>
优点：可以获取到用户的IP地址<br>
缺点：程序需要改动,以及用户IP有可能是伪装的</p>
<p>4.3 使用realip获取<br>
优点：程序不需要改动，直接使用remote_addr即可获取IP地址<br>
缺点：ip地址有可能被伪装，而且需要知道所有CDN节点的ip地址或者ip段</p>
<p> </p>
<p>转载请注出处：CDN下nginx获取用户真实IP地址 http://www.ttlsa.com/html/2235.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx针对爬虫进行限速配置-nginx案例]]></title>
      <url>/nginx/nginx/nginx-for-the-crawler-to-limit-configuration.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-for-the-crawler-to-limit-configuration,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p><span>网络爬虫一方面可以给网站带来一定的流量，便于搜索引擎收录，利于用户搜素，同时也会给服务器带来一定的压力，在网络爬虫对网站内容进行收录时，会引起服务器负载高涨。有没有什么方法既不阻止网络爬虫对网站内容进行收录，同时对其连接数和请求数进行一定的限制呢？</span></p>
<p><strong>先来普及下robots.txt协议：</strong><br>
robots.txt（也称为爬虫协议、爬虫规则、机器人协议等）是放置在网站根目录中的.TXT文件，是搜索引擎蜘蛛程序默认访问网站第一要访问的文件，如果 搜索引擎蜘蛛程序找到这个文件，它就会根据这个文件的内容，来确定它访问权限的范围。robots.txt将告诉搜索引擎蜘蛛程序网站哪些页面时可以访问，哪些不可以。Robots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。因其不是命令，故需要搜索引擎自觉遵守。<br>
[warning]robots.txt必须放置在一个站点的根目录下，而且文件名必须全部小写,一词不差。[/warning]</p>
<p><strong>robots.txt写法：</strong><br>
User-agent: * 这里的*代表的所有的搜索引擎种类，*是一个通配符<br>
Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的内容<br>
Disallow: /require/ 这里定义是禁止爬寻require目录下面的内容</p>
<p>使用robots.txt可以来控制某些内容不被爬虫收录，保证网站敏感数据和用户信息不被侵犯。</p>
<p><strong>对爬虫进行限速处理实现方法如下：</strong><br>
相关内容参见：<br>
《nginx限制连接数ngx_http_limit_conn_module模块》<br>
《nginx限制请求数ngx_http_limit_req_module模块》<br>
《nginx map使用方法》</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	map $http_user_agent $agent {
		default "";
		~curl $http_user_agent;
		~*apachebench $http_user_agent;
		~*spider $http_user_agent;
		~*bot  $http_user_agent;
		~*slurp $http_user_agent;
	}
	limit_conn_zone $agent zone=conn_ttlsa_com:10m;
	limit_req_zone $agent zone=req_ttlsa_com:10m rate=1r/s;

	server {
		listen       8080;
        server_name  test.ttlsa.com;
		root /data/webroot/www.ttlsa.com/

        location   / {  
            limit_req zone=conn_ttlsa_com burst=5;
			limit_conn req_ttlsa_com 1;
            limit_rate 500k;
        }
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p><strong>测试：</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ab -c 10 -n 300 http://test.ttlsa.com:8080/www.ttlsa.com.html</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如需转载请注明出处：http://www.ttlsa.com/html/3257.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx实时生成缩略图到硬盘上-nginx案例]]></title>
      <url>/nginx/nginx/nginx-create-image-on-disk.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-create-image-on-disk,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>现在随着各终端的出现(手机，ipad等平板),以及各种终端的手机分辨率和尺寸都不同，现在手机用户流量都是宝,网上出现了各种各样的生成缩略图功能的架构，有使用php实时生成缩略图的，也有用nginx + lua实现的，上节我也讲到了使用nginx生成缩略图，但是用户每次访问都需要生成一次，会给cpu和硬盘带来比较大的压力，今天带来了另外一种方式，这次使用nginx将原图生成缩略图到硬盘上.看我的配置</p>
<p>1. 首先建好cache目录</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># mkdir /data/site_cache/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>2. 修改nginx配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>        location ~* ^/resize {
                root /data/site_cache/$server_name;
                set $width 150;
                set $height 100;
                set $dimens "";

                if ($uri ~* "^/resize_(\d+)x(\d+)/(.*)" ) {
                        set $width $1;
                        set $height $2;
                        set $image_path $3;
                        set $demins "_$1x$2";
                }

                if ($uri ~* "^/resize/(.*)" ) {
                        set $image_path $1;
                }

                set $image_uri image_resize/$image_path?width=$width&amp;height=$height;

                if (!-f $request_filename) {
                        proxy_pass http://127.0.0.1/$image_uri;
                        break;
                }
                proxy_store /data/site_cache/$server_name/resize$demins/$image_path;
                proxy_store_access user:rw group:rw all:r;
                proxy_set_header Host $host;
                expires      30d;
                access_log off;
        }

        location /image_resize {
                alias /data/site/$server_name/;
                image_filter resize $arg_width $arg_height;
                image_filter_jpeg_quality 75;
                access_log off;
        }</pre></div>
			 
		</div>
<!-- [Format Time: 0.0018 seconds] -->
<p>生成缩略图流程如下：<br>
1、原图在www.ttlsa.com/image/1.jpg。我需要一份100x100的缩略图。<br>
2、请求www.ttlsa.com/resize_100x100/image/1.jpg.<br>
3、这个请求进入了location ~* ^/resize,接着判断image_path这个目录下是否存在这张图片,如果存在直接放回给用户,<br>
4、不存在那么跳转到http://www.ttlsa.com/image_resize/image/1.jpg?width=100&amp;height=100;<br>
5、location /image_resize根据传入的width和height执行缩略功能,并且设置图像质量为75<br>
6、接着生成文件到/data/site_cache/www.ttlsa.com/resize_100x100/image/1.jpg<br>
7、并且返回图片给用户<br>
8、nginx生成缩略图到硬盘上的功能到这里就结束了<br>
转载请注明出处： http://www.ttlsa.com/html/2355.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx配置虚拟主机-nginx案例]]></title>
      <url>/nginx/nginx/nginx-configure-vhosts.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-configure-vhosts,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>本节主要讲解如果使用<strong>nginx配置多个虚拟主机</strong>,也就是我们通常说的配置域名.接下来我们配置两个域名a.ttlsa.com，b.ttlsa.com。</p>
<p>如果你还不会安装nginx的话，请看第一节内容：ttlsa教程系列之nginx – nginx安装(1)</p>
<h3><strong>准备站点</strong></h3>
<p>我们站点统一放到/data/site下，每个站点根目录名称都和域名相同,具体如下。<br>
新建a.ttlsa.com的站点根目录</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># mkdir -p /data/site/a.ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<ul>
<li>新建a站的首页index.html</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat /data/site/a.ttlsa.com/index.html
this is a.ttlsa.com!</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<ul>
<li>新建b.ttlsa.com站点根目录</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># mkdir -p /data/site/b.ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<ul>
<li>新建b站首页index.html,内容如this is b.ttlsa.com！</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat /data/site/b.ttlsa.com/index.html
this is b.ttlsa.com!</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<ul>
<li>新建日志文件目录</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># mkdir -p /data/logs/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们统一讲日志存放到/data/logs下,这边是存放nginx日志,所以nginx日志保持在当前的nginx目录下.日志统一存放相对来说比较规范（如果你不习惯,你可以按自己的方式来做）</p>
<h3>配置nginx虚拟主机</h3>
<ul>
<li>增加nginx主配置文件nginx.conf</li>
</ul>
<p>先配置nginx日志格式，在nginx.conf找到如下内容，并且将#注释标志去掉</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
# '$status $body_bytes_sent "$http_referer" '
# '"$http_user_agent" "$http_x_forwarded_for"';</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<ul>
<li>配置nginx主配置文件</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># vim /usr/local/nginx-1.5.1/conf/nginx.conf
server{
server_name a.ttlsa.com;
listen 80;
root /data/site/a.ttlsa.com;

access_log /data/logs/nginx/a.ttlsa.com-access.log main;
location /
{

}
}

server{
server_name b.ttlsa.com;
listen 80;
root /data/site/b.ttlsa.com;

access_log /data/logs/nginx/b.ttlsa.com-access.log main;
location /
{

}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<ul>
<li>配置讲解</li>
</ul>
<p>server{}：配置虚拟主机必须有这个段。</p>
<p>server_name：虚拟主机的域名，可以写多个域名，类似于别名，比如说你可以配置成<br>
server_name b.ttlsa.com c.ttlsa.com d.ttlsa.com，这样的话，访问任何一个域名，内容都是一样的<br>
listen 80，监听ip和端口，这边仅仅只有端口，表示当前服务器所有ip的80端口，如果只想监听127.0.0.1的80，写法如下：<br>
listen 127.0.0.1:80<br>
root /data/site/b.ttlsa.com：站点根目录，你网站文件存放的地方。注：站点目录和域名尽量一样，养成一个好习惯<br>
access_log /data/logs/nginx/b.ttlsa.com-access.log main：访问日志<br>
location /{} 默认uri,location具体内容后续讲解,大家关注一下.</p>
<h3>重启并打开站点</h3>
<p>nginx -t 检查nginx配置是否ok，命令如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.5.1/sbin/nginx -t
nginx: the configuration file /usr/local/nginx-1.5.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx-1.5.1/conf/nginx.conf test is successful</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>如果看到以上两行ok和successful就表示配置问题，那接下来我们启动nginx</p>
<p>启动nginx</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /usr/local/nginx-1.5.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>访问a.ttlsa.com、b.ttlsa.com（我这边DNS已经解析到了192.168.1.201，在测试的情况下，我们可以通过版本hosts即可），绑定host方法如下：<br>
讲如下内容增加到C:\Windows\System32\Drivers\etc\hosts</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>192.168.1.201 a.ttlsa.com
192.168.1.201 b.ttlsa.com</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>以上是windows绑定hosts方式，如下是linux方式</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>echo "192.168.1.201 a.ttlsa.com
192.168.1.201 b.ttlsa.com" &gt;&gt; /etc/hosts</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>使用浏览器访问这两个站点。我这边使用curl来访问。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[root@ns conf]# curl http://a.ttlsa.com
this is a.ttlsa.com! //a站点内容
[root@ns conf]# curl http://b.ttlsa.com
this is b.ttlsa.com! //b站点内容</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h3><strong>其他指令</strong></h3>
<ul>
<li>关闭nginx</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.5.1/sbin/nginx -s stop</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<ul>
<li>重启nginx</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>/usr/local/nginx-1.5.1/sbin/nginx -s reload //修改配置之后reload,实际上严格意义来说这不是</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>转载请注明出处：http://www.ttlsa.com/html/1571.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx 编译参数详解-nginx案例]]></title>
      <url>/nginx/nginx/nginx-configure-descriptions.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-configure-descriptions,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>标题是不是很欠揍,个人认为确实值得一看,如果你不了解nginx，或者你刚学nginx，或者已经使用nginx一段时间了。但是nginx很多参数你还没去了解，nginx有很多你不知道的用处。不废话，上内容。内容是从网络上摘抄的。</p>
<div>内容有些多，一眼看来难免头昏脑胀，但坚持看完，相信你一定会有所收获。</div>
<div>nginx参数：</div>
<div>--prefix= 指向安装目录</div>
<div>--sbin-path 指向（执行）程序文件（nginx）</div>
<div>--conf-path= 指向配置文件（nginx.conf）</div>
<div>--error-log-path= 指向错误日志目录</div>
<div>--pid-path= 指向pid文件（nginx.pid）</div>
<div>--lock-path= 指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）</div>
<div>--user= 指定程序运行时的非特权用户</div>
<div>--group= 指定程序运行时的非特权用户组</div>
<div>--builddir= 指向编译目录</div>
<div>--with-rtsig_module 启用rtsig模块支持（实时信号）</div>
<div>--with-select_module 启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：--without-select_module</div>
<div>--with-poll_module 启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）</div>
<div>--with-file-aio 启用file aio支持（一种APL文件传输格式）</div>
<div>--with-ipv6 启用ipv6支持</div>
<div>--with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）</div>
<div>--with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）</div>
<div>--with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）</div>
<div>--with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）</div>
<div>--with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）</div>
<div>--with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）</div>
<div>--with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）</div>
<div>--with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启</div>
<div>--with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）</div>
<div>--with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）</div>
<div>--with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）</div>
<div>--with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）</div>
<div>--with-http_degradation_module  <wbr>启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）</div>
<div>--with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）</div>
<div>--without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向--服务器端到客户端，并且只有一个字节的编码可以被重新编码）</div>
<div>--without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）</div>
<div>--without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）</div>
<div>--without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）</div>
<div>--without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）</div>
<div>--without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）</div>
<div>--without-http_autoindex_module 禁用disable ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）</div>
<div>--without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）</div>
<div>--without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）</div>
<div>--without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）</div>
<div>--without-http_referer_module 禁用disable ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）</div>
<div>--without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）</div>
<div>--without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）</div>
<div>--without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。</div>
<div>--without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）</div>
<div>--without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计 更容易实现。）</div>
<div>--without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）</div>
<div>-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）</div>
<div>--without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）</div>
<div>--without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）</div>
<div>--without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则$modern_browser等于modern_browser_value指令分配的值；如 果浏览器为old，则$ancient_browser等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 $msie等于1）</div>
<div>--without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）</div>
<div>--with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）</div>
<div>--with-perl_modules_path= 设定perl模块路径</div>
<div>--with-perl= 设定perl库文件路径</div>
<div>--http-log-path= 设定access log路径</div>
<div>--http-client-body-temp-path= 设定http客户端请求临时文件路径</div>
<div>--http-proxy-temp-path= 设定http代理临时文件路径</div>
<div>--http-fastcgi-temp-path= 设定http fastcgi临时文件路径</div>
<div>--http-uwsgi-temp-path= 设定http uwsgi临时文件路径</div>
<div>--http-scgi-temp-path= 设定http scgi临时文件路径</div>
<div>-without-http 禁用http server功能</div>
<div>--without-http-cache 禁用http cache功能</div>
<div>--with-mail 启用POP3/IMAP4/SMTP代理模块支持</div>
<div>--with-mail_ssl_module 启用ngx_mail_ssl_module支持</div>
<div>--without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标 准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于 支持使用客户端远程管理在服务器上的电子邮件）</div>
<div>--without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上， 使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）</div>
<div>--without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）</div>
<div>--with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）</div>
<div>--with-cpp_test_module 启用ngx_cpp_test_module支持</div>
<div>--add-module= 启用外部模块支持</div>
<div>--with-cc= 指向C编译器路径</div>
<div>--with-cpp= 指向C预处理路径</div>
<div>--with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/local/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）</div>
<div>--with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/local/lib”。）</div>
<div>--with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64</div>
<div>--without-pcre 禁用pcre库</div>
<div>--with-pcre 启用pcre库</div>
<div>--with-pcre= 指向pcre库文件目录</div>
<div>--with-pcre-opt= 在编译时为pcre库设置附加参数</div>
<div>--with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）</div>
<div>--with-md5-opt= 在编译时为md5库设置附加参数</div>
<div>--with-md5-asm 使用md5汇编源</div>
<div>--with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）</div>
<div>--with-sha1-opt= 在编译时为sha1库设置附加参数</div>
<div>--with-sha1-asm 使用sha1汇编源</div>
<div>--with-zlib= 指向zlib库目录</div>
<div>--with-zlib-opt= 在编译时为zlib设置附加参数</div>
<div>--with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro</div>
<div>--with-libatomic 为原子内存的更新操作的实现提供一个架构</div>
<div>--with-libatomic= 指向libatomic_ops安装目录</div>
<div>--with-openssl= 指向openssl安装目录</div>
<div>--with-openssl-opt 在编译时为openssl设置附加参数</div>
<div>--with-debug 启用debug日志</div>
<div></div>
<div>转自：http://blog.sina.com.cn/s/blog_68c25adf01014037.html</div>
<div>站点：运维生存时间  网址：http://www.ttlsa.com/html/3596.html</div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 战斗准备 —— 优化指南-nginx案例]]></title>
      <url>/nginx/nginx/nginx-battle-ready-optimization-guide.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-battle-ready-optimization-guide,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				<div>
<p>大多数的Nginx安装指南告诉你如下基础知识——通过apt-get安装，修改这里或那里的几行配置，好了，你已经有了一个Web服务器了！而且，在大多数情况下，一个常规安装的nginx对你的网站来说已经能很好地工作了。然而，如果你真的想挤压出nginx的性能，你必须更深入一些。在本指南中，我将解释Nginx的那些设置可以微调，以优化处理大量客户端时的性能。需要注意一点，这不是一个全面的微调指南。这是一个简单的预览——那些可以通过微调来提高性能设置的概述。你的情况可能不同。</p>
<h2>基本的 (优化过的)配置</h2>
<p>我们将修改的唯一文件是<strong>nginx.conf</strong>，其中包含Nginx不同模块的所有设置。你应该能够在服务器的<strong>/etc/nginx</strong>目录中找到nginx.conf。首先，我们将谈论一些全局设置，然后按文件中的模块挨个来，谈一下哪些设置能够让你在大量客户端访问时拥有良好的性能，为什么它们会提高性能。本文的结尾有一个完整的配置文件。</p>
<h2>高层的配置</h2>
<p>nginx.conf文件中，Nginx中有少数的几个高级配置在模块部分之上。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>user www-data;
pid /var/run/nginx.pid;
worker_processes auto;
worker_rlimit_nofile 100000;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->

</div>
<p><strong>user</strong>和<strong>pid</strong>应该按默认设置 - 我们不会更改这些内容，因为更改与否没有什么不同。</p>
<p><strong>worker_processes </strong>定义了nginx对外提供web服务时的worder进程数。最优值取决于许多因素，包括（但不限于）CPU核的数量、存储数据的硬盘数量及负载模式。不能确定的时候，将其设置为可用的CPU内核数将是一个好的开始（设置为“auto”将尝试自动检测它）。</p>
<p><strong>worker_rlimit_nofile </strong>更改worker进程的最大打开文件数限制。如果没设置的话，这个值为操作系统的限制。设置后你的操作系统和Nginx可以处理比“ulimit -a”更多的文件，所以把这个值设高，这样nginx就不会有“too many open files”问题了。</p>
<h2>Events模块</h2>
<p>events模块中包含nginx中所有处理连接的设置。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>events {
worker_connections 2048;
multi_accept on;
use epoll;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p><strong>worker_connections</strong>设置可由一个worker进程同时打开的最大连接数。如果设置了上面提到的worker_rlimit_nofile，我们可以将这个值设得很高。</p>
<p>记住，最大客户数也由系统的可用socket连接数限制（~ 64K），所以设置不切实际的高没什么好处。</p>
<p><strong>multi_accept </strong>告诉nginx收到一个新连接通知后接受尽可能多的连接。</p>
<p><strong>use</strong> 设置用于复用客户端线程的轮询方法。如果你使用Linux 2.6+，你应该使用epoll。如果你使用*BSD，你应该使用kqueue。想知道更多有关事件轮询？看下维基百科吧（注意，想了解一切的话可能需要neckbeard和操作系统的课程基础）</p>
<p>（值得注意的是如果你不知道Nginx该使用哪种轮询方法的话，它会选择一个最适合你操作系统的）</p>
<h2>HTTP 模块</h2>
<p>HTTP模块控制着nginx http处理的所有核心特性。因为这里只有很少的配置，所以我们只节选配置的一小部分。所有这些设置都应该在http模块中，甚至你不会特别的注意到这段设置。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
server_tokens off;
sendfile on;
 tcp_nopush on;
tcp_nodelay on;
...
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p><strong>server_tokens </strong>并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。<strong>sendfile</strong>可以让sendfile()发挥作用。sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile)</p>
<p><strong>tcp_nopush</strong> 告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送</p>
<p><strong>tcp_nodelay</strong> 告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>access_log off;
error_log /var/log/nginx/error.log crit;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p><strong>access_log</strong>设置nginx是否将存储访问日志。关闭这个选项可以让读取磁盘IO操作更快(aka,YOLO)<strong>error_log </strong>告诉nginx只能记录严重的错误</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>keepalive_timeout 10;
client_header_timeout 10;
client_body_timeout 10;
reset_timedout_connection on;
send_timeout 10;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p><strong>keepalive_timeout</strong> 给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接。我们将它设置低些可以让ngnix持续工作的时间更长。client_header_timeout 和<strong>client_body_timeout</strong> 设置请求头和请求体(各自)的超时时间。我们也可以把这个设置低些。</p>
<p>reset_timeout_connection告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。</p>
<p>send_timeout 指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_conn_zone $binary_remote_addr zone=addr:5m;
limit_conn addr 100;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p>limit_conn_zone设置用于保存各种key（比如当前连接数）的共享内存的参数。5m就是5兆字节，这个值应该被设置的足够大以存储（32K*5）32byte状态或者（16K*5）64byte状态。limit_conn为给定的key设置最大连接数。这里key是addr，我们设置的值是100，也就是说我们允许每一个IP地址最多同时打开有100个连接。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>include /etc/nginx/mime.types;
default_type text/html;
charset UTF-8;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->

</div>
<p>include只是一个在当前文件中包含另一个文件内容的指令。这里我们使用它来加载稍后会用到的一系列的MIME类型。default_type设置文件使用的默认的MIME-type。</p>
<p>charset设置我们的头文件中的默认的字符集</p>
<p>以下两点对于性能的提升在伟大的WebMasters StackExchange中有解释。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>gzip on;
gzip_disable "msie6";
# gzip_static on;
gzip_proxied any;
gzip_min_length 1000;
gzip_comp_level 4;
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->

</div>
<p>gzip是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。</p>
<p>gzip_disable为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。</p>
<p>gzip_static告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。</p>
<p>gzip_proxied允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。</p>
<p>gzip_min_length设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。</p>
<p>gzip_comp_level设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。</p>
<p>gzip_type设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。</p>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cache informations about file descriptors, frequently accessed files
# can boost performance, but you need to test those values
open_file_cache max=100000 inactive=20s;
open_file_cache_valid 30s;
open_file_cache_min_uses 2;
open_file_cache_errors on;
##
# Virtual Host Configs
# aka our settings for specific servers
##
include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->

</div>
<p>open_file_cache打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。</p>
<p><strong>open_file_cache_valid</strong> 在open_file_cache中指定检测正确信息的间隔时间。</p>
<p><strong>open_file_cache_min_uses</strong> 定义了open_file_cache中指令参数不活动时间期间里最小的文件数。</p>
<p><strong>open_file_cache_errors</strong>指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。</p>
<h2>一个完整的配置</h2>
<div>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>user www-data;
pid /var/run/nginx.pid;
worker_processes auto;
worker_rlimit_nofile 100000;
events {
 worker_connections 2048;
 multi_accept on;
 use epoll;
}
http {
  server_tokens off;
 sendfile on;
tcp_nopush on;
 tcp_nodelay on;
 access_log off;
 error_log /var/log/nginx/error.log crit;
 keepalive_timeout 10;
 client_header_timeout 10;
 client_body_timeout 10;
reset_timedout_connection on;
 send_timeout 10;
 limit_conn_zone $binary_remote_addr zone=addr:5m;
 limit_conn addr 100;
 include /etc/nginx/mime.types;
 default_type text/html;
charset UTF-8;
gzip on;
 gzip_disable "msie6";
gzip_proxied any;
gzip_min_length 1000;
gzip_comp_level 6;
 gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
 open_file_cache max=100000 inactive=20s;
open_file_cache_valid 30s;
open_file_cache_min_uses 2;
open_file_cache_errors on;
 include /etc/nginx/conf.d/*.conf;
 include /etc/nginx/sites-enabled/*;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0018 seconds] -->

</div>
<p>编辑完配置后，确认重启nginx使设置生效。</p>
<h2>后记</h2>
<p>就这样！你的Web服务器现在已经就绪，之前困扰你的众多访问者的问题来吧。这并不是加速网站的唯一途径，很快我会写更多介绍其他加速网站方法的文章的。</p>
</div>
<div>
<p>本文地址：http://www.oschina.net/translate/nginx-setup<br>
原文地址：http://blog.zachorr.com/nginx-setup/</p>
</div>
<div><span></span></div>			
</p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 与 Lua-nginx案例]]></title>
      <url>/nginx/nginx/nginx-and-lua.html</url>
      <content type="html"><![CDATA[<p>nginx,nginx-and-lua,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>这几个月里，我们逐步把Lua集成到Mixlr的前端Nginx配置中。<br>
Lua是一个可以嵌入到Nginx配置文件中的动态脚本语言，从而可以在Nginx请求处理的任何阶段执行各种Lua代码。刚开始我们只是用Lua 把请求路由到后端服务器，但是它对我们架构的作用超出了我们的预期。下面就讲讲我们所做的工作。<br>
<span><strong>强制搜索引擎只索引mixlr.com</strong></span><br>
Google把子域名当作完全独立的网站，我们不希望爬虫抓取子域名的页面，降低我们的Page rank。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /robots.txt {
 rewrite_by_lua '
 if ngx.var.http_host ~= "mixlr.com" then
 return ngx.exec("/robots_disallow.txt");
 end
 ';
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如果对robots.txt的请求不是mixlr.com域名的话，则内部重写到robots_diallow.txt，虽然标准的重写指令也可以实现这个需求，但是 Lua的实现更容易理解和维护。</p>
<p><strong><span>根据程序逻辑设置响应头</span></strong><br>
Lua提供了比Nginx默认配置规则更加灵活的设置方式。 在下面的例子中，我们要保证正确设置响应头，这样浏览器如果发送了指定请求头后，就可以 无限期缓存静态文件，是的用户只需下载一次即可。<br>
这个重写规则使得任何静态文件，如果请求参数中包含时间戳值，那么就设置相应的Expires和Cache-Control响应头。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
  header_filter_by_lua '
    if ngx.var.query_string and ngx.re.match( ngx.var.query_string, "^([0-9]{10})$" ) then
      ngx.header["Expires"] = ngx.http_time( ngx.time() + 31536000 ); 
      ngx.header["Cache-Control"] = "max-age=31536000";
    end
  ';

  try_files $uri @dynamic;}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><span><strong>删除jQuery JSONP请求的时间戳参数</strong></span><br>
很多外部客户端请求JSONP接口时，都会包含一个时间戳类似的参数，从而导致Nginx proxy缓存无法命中（因为无法忽略指定的HTTP参数）。下面的 规则删除了时间戳参数，使得Nginx可以缓存upstream server的响应内容，减轻后端服务器的负载。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
  rewrite_by_lua '
    if ngx.var.args ~= nil then
      -- /some_request?_=1346491660 becomes /some_request
      local fixed_args, count = ngx.re.sub( ngx.var.args, "&amp;?_=[0-9]+", "" );
      if count &gt; 0 then
        return ngx.exec(ngx.var.uri, fixed_args);
      end
    end
  ';}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong><span>把后端的慢请求日志记录到Nginx的错误日志</span></strong><br>
如果后端请求响应很慢，可以把它记录到Nginx的错误日志，以备后续追查。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
  log_by_lua '
    if tonumber(ngx.var.upstream_response_time) &gt;= 1 then
      ngx.log(ngx.WARN, "[SLOW] Ngx upstream response time: " .. ngx.var.upstream_response_time .. "s from " .. ngx.var.upstream_addr);
    end
  ';}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p><span><strong>基于Redis的实时IP封禁</strong></span><br>
某些情况下，需要阻止流氓爬虫的抓取，这可以通过专门的封禁设备去做，但是通过Lua，也可以实现简单版本的封禁。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>lua_shared_dict banned_ips 1m; 

location / {
  access_by_lua '
    local banned_ips = ngx.shared.banned_ips;
    local updated_at = banned_ips:get("updated_at");

    -- only update banned_ips from Redis once every ten seconds:
    if updated_at == nil or updated_at &lt; ( ngx.now() - 10 ) then
      local redis = require "resty.redis";
      local red = redis:new();
      red:set_timeout(200);

      local ok, err = red:connect("your-redis-hostname", 6379);
      if not ok then
        ngx.log(ngx.WARN, "Redis connection error retrieving banned_ips: " .. err);
      else
        local updated_banned_ips, err = red:smembers("banned_ips");
        if err then
          ngx.log(ngx.WARN, "Redis read error retrieving banned_ips: " .. err);
        else
          -- replace the locally stored banned_ips with the updated values:
          banned_ips:flush_all();
          for index, banned_ip in ipairs(updated_banned_ips) do
            banned_ips:set(banned_ip, true);
          end
          banned_ips:set("updated_at", ngx.now());
        end
      end
    end

    if banned_ips:get(ngx.var.remote_addr) then
      ngx.log(ngx.WARN, "Banned IP detected and refused access: " .. ngx.var.remote_addr);
      return ngx.exit(ngx.HTTP_FORBIDDEN);
    end
  ';}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>现在就可以阻止特定IP的访问：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>ruby&gt; $redis.sadd("banned_ips", "200.1.35.4")</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>Nginx进程每隔10秒从Redis获取一次最新的禁止IP名单。需要注意的是，如果架构中使用了Haproxy这样类似的负载均衡服务器时， 需要把$remote_addr设置为正确的远端IP地址。<br>
这个方法还可以用于HTTP User-Agent字段的检查，要求满足指定条件。</p>
<p><strong><span>使用Nginx输出CSRF(form_authenticity_token)</span></strong><br>
Mixlr大量使用页面缓存，由此引入的一个问题是如何给每个页面输出会话级别的CSRF token。我们通过Nginx的子请求，从upstream web server 获取token，然后利用Nginx的SSI(server-side include)功能输出到页面中。这样既解决了CSRF攻击问题，也保证了cache能被正常利用。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /csrf_token_endpoint {
  internal;
   
  include /opt/nginx/conf/proxy.conf;
  proxy_pass "http://upstream";}

location @dynamic {
  ssi on;
  set $csrf_token '';

  rewrite_by_lua '
    -- Using a subrequest, we our upstream servers for the CSRF token for this session:
    local csrf_capture = ngx.location.capture("/csrf_token_endpoint");
    if csrf_capture.status == 200 then
      ngx.var.csrf_token = csrf_capture.body;

      -- if this is a new session, ensure it sticks by passing through the new session_id
      -- to both the subsequent upstream request, and the response:
      if not ngx.var.cookie_session then
        local match = ngx.re.match(csrf_capture.header["Set-Cookie"], "session=([a-zA-Z0-9_+=/+]+);");
        if match then
          ngx.req.set_header("Cookie", "session=" .. match[1]);
          ngx.header["Set-Cookie"] = csrf_capture.header["Set-Cookie"]; 
        end
      end
    else
      ngx.log(ngx.WARN, "No CSRF token returned from upstream, ignoring.");
    end
  ';

  try_files /maintenance.html /rails_cache$uri @thin;}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>CSRF token生成 app/metal/csrf_token_endpoint.rb:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>class CsrfTokenEndpoint
  def self.call(env)
    if env["PATH_INFO"] =~ /^\/csrf_token_endpoint/
      session = env["rack.session"] || {}

      token = session[:_csrf_token]
      if token.nil?
        token = SecureRandom.base64(32)
        session[:_csrf_token] = token
      end

      [ 200, { "Content-Type" =&gt; "text/plain" }, [ token ] ]
    else      
      [404, {"Content-Type" =&gt; "text/html"}, ["Not Found"]]
    end
  endend</pre></div>
			 
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>我们的模版文件示例:<br>
&lt;meta name="csrf-param" value="authenticity_token"/&gt;<br>
&lt;meta name="csrf-token" value="&lt;!--# echo var="csrf_token" default="" encoding="none" --&gt;"/&gt;<br>
Again you could make use of lua_shared_dict to store in memory the CSRF token for a particular session. This minimises the number of trips made to /csrf_token_endpoint.<br>
原文链接：http://devblog.mixlr.com/2012/09/01/nginx-lua/</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存-nginx案例]]></title>
      <url>/nginx/nginx/memc_nginx_srcache_nginx_memcached-to-construct-transparent-caching-dynamic-pages.html</url>
      <content type="html"><![CDATA[<p>nginx,memc_nginx_srcache_nginx_memcached-to-construct-transparent-caching-dynamic-pages,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>在上一节《nginx+memcached构建页面缓存应用》http://www.ttlsa.com/html/2418.html中，说道nginx只负责从memcached服务器中读取数据，要往memcached写入数据还得需要后台的应用程序来完成。使用memc-nginx和srcache-nginx模块就可以主动的向memcached添加缓存，对应用程序来说是透明的。大大的提高动态页面访问速度。第一次访问创建缓存，后续访问在缓存过期时间内，直接从memcached返回，不需要再次经过php-fpm处理。</p>
<p>nginx_memc模块与nginx_srcache模块配合使用，来提供缓存服务器后端的操作，在技术上，任何提供REST接口的模块都可以与nginx_srcache配合使用来获取和存储缓存子请求。</p>
<p>使用memcached作为后端缓存，需要注意memcached存储大小的限制，不得超过1M。为了使用更宽松的后端存储服务，建议使用redis等，参见《srcache_nginx+redis构建缓存系统》。</p>
<p>1. memc-nginx-module模块指令说明：<br>
memc_pass<br>
语法：memc_pass address:port or socket；<br>
默认值：none<br>
配置段：http, server, location, if<br>
指定memcached服务器地址。</p>
<p>memc_cmds_allowed<br>
语法：memc_cmds_allowed &lt;cmd&gt;...<br>
默认值： none<br>
配置段：http, server, location, if<br>
列出允许访问的memcached命令。默认情况下，所有的memcached命令都可以访问。</p>
<p>memc_flags_to_last_modified<br>
语法：memc_flags_to_last_modified on|off<br>
默认值：off<br>
配置段：http, server, location, if<br>
读取memcached标识，并将其设置为Last-Modified头部值。对于有条件的get，nginx返回304未修改响应，以便节省带宽。</p>
<p>memc_connect_timeout<br>
语法：memc_connect_timeout &lt;time&gt;<br>
默认值：60s<br>
配置段: http, server, location<br>
与memcached服务器建立连接的超时时间。不得超过597 hours。</p>
<p>memc_send_timeout<br>
语法：memc_send_timeout &lt;time&gt;<br>
默认值：60s<br>
配置段：http, server, location<br>
设置发送请求到memcached服务器的超时时间。不得超过597 hours。</p>
<p>memc_read_timeout<br>
语法：memc_read_timeout &lt;time&gt;<br>
默认值：60s<br>
配置段：http, server, location<br>
定义从memcached服务器读取响应超时时间。不得超过597 hours。</p>
<p>memc_buffer_size<br>
语法：memc_buffer_size &lt;size&gt;<br>
默认值：4k/8k<br>
配置段：http, server, location<br>
读取从memcached服务器接收到响应的缓冲大小。</p>
<p>2. memcached支持的命令<br>
memcached存储命令set、add、replace、prepend、append，以$memc_key作为键。$memc_exptime定义过期时间，默认值为0。$memc_flags作为标识，默认值为0，来建立相应的memcached查询。<br>
如果$memc_value没有定义，那么请求的请求体将作为该值，除了incr和decr命令外。注意：如果$memc_value定义为空的字符串，那么该空字符串仍然被当做该值。<br>
2.1 get $memc_key<br>
使用键来检索值。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
set $memc_cmd 'get';
set $memc_key 'my_key';
memc_pass 127.0.0.1:11211;
add_header X-Memc-Flags $memc_flags;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>如果该键被找到，响应体为该键值，返回200。否则范围404 Not Found。如果发生错误或客户端错误或服务端错误，则返回502。标识码设置到$memc_flags变量。通常使用add_header指令来添加到响应头部。</p>
<p>2.2 set $memc_key $memc_flags $memc_exptime $memc_value<br>
将请求体作为memcached值。如果另外指定值可以通过$memc_value变量来指定。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
    set $memc_cmd 'set';
    set $memc_key 'my_key';
    set $memc_flags 12345;
    set $memc_exptime 24;
    memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>或</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
    set $memc_cmd 'set';
    set $memc_key 'my_key';
    set $memc_flags 12345;
    set $memc_exptime 24;
    set $memc_value 'my_value';
    memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>返回201，说明创建memcached缓存存储成功。返回200说明NOT_STORED。返回404说明NOT_FOUND。返回502说明发生错误或客户端错误或服务端错误。<br>
memcached原始响应是响应体，404 NOT FOUND除外。</p>
<p>2.3 add $memc_key $memc_flags $memc_exptime $memc_value<br>
和set命令相似</p>
<p>2.4 prepend $memc_key $memc_flags $memc_exptime $memc_value<br>
和set命令相似</p>
<p>2.5 delete $memc_key<br>
删除该键值</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo
set $memc_cmd delete;
set $memc_key my_key;

memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>返回200说明删除成功。返回404说明NOT_FOUND。返回502说明发生错误或客户端错误或服务端错误。</p>
<p>2.6 delete $memc_key $memc_exptime<br>
和delete命令相似。</p>
<p>2.7 incr $memc_key $memc_value<br>
给指定的$memc_key对应的$memc_value增量。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
set $memc_key my_key;
set $memc_value 2;
memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>每次访问/foo将导致my_key的值加2。<br>
返回200说明成功。返回404说明键Not Found。返回502说明发生错误或客户端错误或服务端错误。</p>
<p>2.8 decr $memc_key $memc_value<br>
与incr相似。</p>
<p>2.9 flush_all<br>
刷新memcached上所有的键。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
set $memc_cmd flush_all;
memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>2.10 flush_all $memc_exptime<br>
与flush_all相似。</p>
<p>2.11 stats<br>
输出memcached统计信息。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
set $memc_cmd stats;
memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>2.12 version<br>
返回memcached版本信息。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location /foo {
set $memc_cmd version;
memc_pass 127.0.0.1:11211;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>3. srcache-nginx-module模块指令说明：<br>
srcache_fetch<br>
语法：srcache_fetch &lt;method&gt; &lt;uri&gt; &lt;args&gt;?<br>
默认值：no<br>
配置段：http, server, location, location if<br>
查询缓存。返回200说明缓存命中，直接从缓存响应客户端请求。非200需要后端程序处理。</p>
<p>srcache_fetch_skip<br>
语法：srcache_fetch_skip &lt;flag&gt;<br>
默认值：srcache_fetch_skip 0<br>
配置段：http, server, location, location if<br>
&lt;flag&gt;支持nginx变量。当这个参数值不为空和不等于0，则从缓存取数据过程被无条件跳过。</p>
<p>srcache_store<br>
语法：srcache_store &lt;method&gt; &lt;uri&gt; &lt;args&gt;?<br>
默认值：no<br>
配置段：http, server, location, location if<br>
将当前请求的响应存入缓存。可以使用srcache_store_skip和srcache_store_max_size指令禁用缓存。不管是响应状态行，响应头，响应体都会被缓存。默认情况下，下列特殊响应头不会被缓存：<br>
Connection<br>
Keep-Alive<br>
Proxy-Authenticate<br>
Proxy-Authorization<br>
TE<br>
Trailers<br>
Transfer-Encoding<br>
Upgrade<br>
Set-Cookie<br>
可以使用srcache_store_pass_header、srcache_store_hide_header指令来控制哪些头要缓存哪些不要。<br>
注意：即使所有的响应数据被立即发送，当前的nginx请求生命周期未必完成，直到srcache_store子请求完成。这意味着服务器端延迟关闭TCP连接，或下一个请求服务发送同一个TCP连接。</p>
<p>srcache_store_max_size<br>
语法：srcache_store_max_size &lt;size&gt;<br>
默认值：srcache_store_max_size 0<br>
配置段：http, server, location, location if<br>
当响应体超过该值，将不会缓存。<br>
当后端缓存存储有对缓存数据做硬限制，这个指令非常有用。比如memcached服务器，上限是1M。<br>
默认值0，不限制。</p>
<p>srcache_store_skip<br>
语法：srcache_store_skip &lt;flag&gt;<br>
默认值：srcache_store_skip 0<br>
配置段：http, server, location, location if<br>
&lt;flag&gt;支持nginx变量。当这个参数值不为空和不等于0，则从存入缓存过程被无条件跳过。</p>
<p>srcache_store_statuses<br>
语法：srcache_store_statuses &lt;status1&gt; &lt;status2&gt; ..<br>
默认值：srcache_store_statuses 200 301 302<br>
配置段：http, server, location, location if<br>
该指令控制那些状态码响应被缓存。</p>
<p>srcache_header_buffer_size<br>
语法：srcache_header_buffer_size &lt;size&gt;<br>
默认值：srcache_header_buffer_size 4k/8k<br>
配置段：http, server, location, location if<br>
在序列化响应头时控制头缓冲大小。默认大小为页面大小，通常为4k或8k，取决于具体平台。<br>
注意：该大小是以每个头的，因此，需要足够大来容纳最大响应头。</p>
<p>srcache_store_hide_header<br>
语法：srcache_store_hide_header &lt;header&gt;<br>
默认值：no<br>
配置段：http, server, location, location if<br>
默认情况下，除了以下头缓存所有响应头：<br>
Connection<br>
Keep-Alive<br>
Proxy-Authenticate<br>
Proxy-Authorization<br>
TE<br>
Trailers<br>
Transfer-Encoding<br>
Upgrade<br>
Set-Cookie<br>
可以隐藏多个响应头，不区分大小写。如<br>
srcache_store_hide_header X-Foo;<br>
srcache_store_hide_header Last-Modified;</p>
<p>srcache_store_pass_header<br>
语法：srcache_store_pass_header &lt;header&gt;<br>
默认值：no<br>
配置段：http, server, location, location if<br>
默认情况下，除了以下头缓存所有响应头：<br>
Connection<br>
Keep-Alive<br>
Proxy-Authenticate<br>
Proxy-Authorization<br>
TE<br>
Trailers<br>
Transfer-Encoding<br>
Upgrade<br>
Set-Cookie<br>
可以缓存多个响应头，不区分大小写。如<br>
srcache_store_pass_header Set-Cookie;<br>
srcache_store_pass_header Proxy-Autenticate;</p>
<p>srcache_methods<br>
语法：srcache_methods &lt;method&gt;...<br>
默认值：srcache_methods GET HEAD<br>
配置段：http, server, location</p>
<p>srcache_ignore_content_encoding<br>
语法：srcache_ignore_content_encoding on|off<br>
默认值: srcache_ignore_content_encoding off<br>
配置段：http, server, location, location if<br>
内容是否编码。<br>
建议后端服务器禁用gzip/deflate压缩。在nginx.conf配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>proxy_set_header Accept-Encoding "";</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>srcache_request_cache_control<br>
语法：srcache_request_cache_control on|off<br>
默认值：srcache_request_cache_control off<br>
配置段：http, server, location<br>
当该指令为on时，请求头Cache-Control和Pragma按照下面的方法处理：<br>
1. srcache_fetch查询缓存操作时，当请求头Cache-Control: no-cache 、 Pragma: no-cache 将跳过。<br>
2. srcache_store存入缓存操作时，当请求头Cache-Control: no-store将跳过。<br>
当该指令为off时，将禁用此功能，对于繁忙的站点依赖缓存加速被认为是最安全的。</p>
<p>srcache_response_cache_control<br>
语法：srcache_response_cache_control on|off<br>
默认值：srcache_response_cache_control on<br>
配置段：http, server, location<br>
当该指令为on时，响应头Cache-Control和Expires按照下面的方法处理：<br>
Cache-Control: private skips srcache_store,<br>
Cache-Control: no-store skips srcache_store,<br>
Cache-Control: no-cache skips srcache_store,<br>
Cache-Control: max-age=0 skips srcache_store,<br>
Expires: &lt;date-no-more-recently-than-now&gt; skips srcache_store.<br>
该指令优先级比srcache_store_no_store，srcache_store_no_cache，srcache_store_private高。</p>
<p>srcache_store_no_store<br>
语法：srcache_store_no_store on|off<br>
默认值：srcache_store_no_store off<br>
配置段：http, server, location<br>
开启该指令，将强制响应头Cache-Control: no-store。默认为关闭。</p>
<p>srcache_store_no_cache<br>
语法：srcache_store_no_cache on|off<br>
默认值：srcache_store_no_cache off<br>
配置段：http, server, location<br>
开启该指令，将强制响应头Cache-Control: no-cache。默认为关闭。</p>
<p>srcache_store_private<br>
语法：srcache_store_private on|off<br>
默认值：srcache_store_private off<br>
配置段：http, server, location<br>
开启该指令，将强制响应头Cache-Control: private。默认为关闭。</p>
<p>srcache_default_expire<br>
语法：srcache_default_expire &lt;time&gt;<br>
默认值：srcache_default_expire 60s<br>
配置段：http, server, location, location if<br>
控制默认过期时间。当响应头既没有Cache-Control: max-age=N也没有指定Expires时，允许的$srcache_expire变量值。<br>
该值必须小于597hours。</p>
<p>srcache_max_expire<br>
语法：srcache_max_expire &lt;time&gt;<br>
默认值：srcache_max_expire 0<br>
配置段：http, server, location, location if<br>
控制最大缓存时间，此设置优先级高于其他计算方法。<br>
该值必须小于597hours。<br>
默认为0，不限制。</p>
<p>4. srcache-nginx-module变量<br>
$srcache_expire<br>
当前的响应存入缓存的过期时间。按照下面的方法计算：<br>
1. 当响应头Cache-Control: max-age=N被指定，那么N将作为过期时间。<br>
2. 如果响应头Expires被指定，那么该值与当前时间差作为过期时间。<br>
3. 当既没有指定Cache-Control: max-age=N也没有指定Expires，那么使用 srcache_default_expire 指定的值。<br>
如果超过srcache_max_expire指令值，那么此变量最终值为srcache_max_expire。</p>
<p>$srcache_fetch_status<br>
获取缓存的三种状态值：HIT, MISS, BYPASS。</p>
<p>$srcache_store_status<br>
存入缓存的两种状态值：STORE ，BYPASS。</p>
<p>5. 安装nginx_memc和nginx_srcache模块</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget https://github.com/agentzh/memc-nginx-module/archive/master.zip
# wget https://github.com/agentzh/srcache-nginx-module/archive/master.zip
# ./configure --prefix=/usr/local/nginx-1.2.5 \
--add-module=../srcache-nginx-module
--add-module=../memc-nginx-module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>6. 配置</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream memcacheds {
        server 10.1.240.166:22222;
}
server  {
        listen       8090;
        server_name  test.ttlsa.com;
        index index.html index.htm index.php;
        root  /data/wwwroot/www.ttlsa.com/webroot;

        location /memc {
                internal;
                memc_connect_timeout 100ms;
                memc_send_timeout 100ms;
                memc_read_timeout 100ms;
                set $memc_key $query_string;
                set $memc_exptime 120;
                memc_pass memcacheds;
                }

        location ~ .*\.php?$
        {
                if ($uri ~ /ttlsa/){
                        set $ttlsa_key $request_uri;
                        srcache_fetch GET /memc $ttlsa_key;
                        srcache_store PUT /memc $ttlsa_key;
                        add_header X-Cached-From $srcache_fetch_status;
                        add_header X-Cached-Store $srcache_store_status;
                }
                include fastcgi_params;
                fastcgi_pass  127.0.0.1:10081;
                fastcgi_index index.php;
                fastcgi_connect_timeout 60;
                fastcgi_send_timeout 180;
                fastcgi_read_timeout 180;
                fastcgi_buffer_size 128k;
                fastcgi_buffers 4 256k;
                fastcgi_busy_buffers_size 256k;
                fastcgi_temp_file_write_size 256k;
                fastcgi_intercept_errors on;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p>7. 测试<br>
7.1 第一次访问（404 Not found 创建缓存）</p>
<p></p>
<p>7.2 后续访问（直接从缓存中响应）</p>
<p></p>
<p>第一次访问创建缓存，后续访问在缓存过期时间内，直接从memcached返回，不需要再次经过php-fpm处理。大大提升动态页面访问速度。</p>
<p>《memc_nginx+srcache_nginx+memcached遇到的问题》<br>
如需转载请注明出处：http://www.ttlsa.com/html/2460.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx本地缓存模块ngx_slowfs_cache-nginx案例]]></title>
      <url>/nginx/nginx/local-nginx-cache-module-ngx_slowfs_cache.html</url>
      <content type="html"><![CDATA[<p>nginx,local-nginx-cache-module-ngx_slowfs_cache,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx proxy反向代理本身就支持缓存的，但是如果没有使用到nginx反向代理的话，就需要使用ngx_slowfs_cache模块来实现本地站点静态文件缓存，同时还为低速的存储设备创建快速缓存。</p>
<p>1. 安装ngx_slowfs_cache和ngx_cache_purge模块</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://labs.frickle.com/files/ngx_slowfs_cache-1.10.tar.gz
# wget http://labs.frickle.com/files/ngx_cache_purge-2.1.tar.gz
# tar zxvf ngx_slowfs_cache-1.10.tar.gz
# tar zxvf ngx_cache_purge-2.1.tar.gz
# cd nginx-1.2.5
# ./configure --prefix=/usr/local/nginx-1.2.5 \
--with-http_stub_status_module --with-http_realip_module \
--add-module=../ngx_slowfs_cache-1.10 \
--add-module=../ngx_cache_purge-2.1
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>2. 使用</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
    slowfs_cache_path /data/cache/proxy_cache_dir  levels=1:2   keys_zone=fastcache:4096m inactive=1d max_size=20g;
    slowfs_temp_path  /data/cache/proxy_temp_dir 1 2;

    server {
	    location ~ /purge(/.*) {
            allow               127.0.0.1;
            allow               10.0.0.0/8;
            deny                all;
            slowfs_cache_purge  fastcache $1;
        }

        location ~* \.(gif|jpg|jpeg|css|js|bmp|png)$ {
            slowfs_cache        fastcache;
            slowfs_cache_key    $uri;
            slowfs_cache_valid  1d;
            add_header X-Cache '$slowfs_cache_status from $host';
            expires  max;
        }

    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>说明：slowfs_cache_path和slowfs_temp_path需要在同一分区。 slowfs_cache_path指定缓存文件的目录级数，缓存区名称为fastcache，内存缓存空间为4096m，1天没有被访问的内容自动清除，硬盘缓存空间为20g。slowfs_cache_purge为清除缓存。<br>
要注意location执行顺序。nginx purge更新缓存404错误 一例参见http://www.ttlsa.com/html/1084.html</p>
<p>3. 模块指令说明<br>
slowfs_cache<br>
语法：slowfs_cache zone_name<br>
默认值：none<br>
配置段：http, server, location<br>
定义使用的缓存区。要与slowfs_cache_path指令定义的一致。</p>
<p>slowfs_cache_key<br>
语法: slowfs_cache_key key<br>
默认值: none<br>
配置段: http, server, location<br>
设置缓存的键</p>
<p>slowfs_cache_purge<br>
语法: slowfs_cache_purge zone_name key<br>
默认值: none<br>
配置段: location<br>
根据指定的key从缓存中清除也存在的缓存</p>
<p>slowfs_cache_path<br>
语法: slowfs_cache_path path [levels] keys_zone=zone_name:zone_size [inactive] [max_size]<br>
默认值: none<br>
配置段: http<br>
设置缓存区和缓存结构</p>
<p>slowfs_temp_path<br>
语法: slowfs_temp_path path [level1] [level2] [level3]<br>
默认值: /tmp 1 2<br>
配置段: http<br>
设置临时区。文件在移到缓存区时的临时存储地。</p>
<p>slowfs_cache_min_uses<br>
语法: slowfs_cache_min_uses number<br>
默认值: 1<br>
配置段: http, server, location<br>
设置文件被访问多少次后复制到缓存</p>
<p>slowfs_cache_valid<br>
语法: slowfs_cache_valid [reply_code] time<br>
默认值: none<br>
配置段: http, server, location<br>
设置缓存时间</p>
<p>slowfs_big_file_size<br>
语法: slowfs_big_file_size size<br>
默认值: 128k<br>
配置段: http, server, location<br>
设置大文件阀值，避免服务中断</p>
<p>$slowfs_cache_status变量：<br>
表示缓存文件的可用性，值有MISS, HIT, EXPIRED</p>
<p>4. 测试</p>
<p><br>
5. 清缓存</p>
<p><br>
对于文件可以这么来做缓存。那么对于要经过php处理过的该怎么缓存呢？ 请看下篇。<br>
如需转载请注明出处：http://www.ttlsa.com/html/2390.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lnmp架构下php安全配置分享-nginx案例]]></title>
      <url>/nginx/nginx/lnmp-safe-config.html</url>
      <content type="html"><![CDATA[<p>nginx,lnmp-safe-config,<br><a id="more"></a><br>
  <div> 
<!-- GG-Mobi-ad -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-0956732394986573" data-ad-slot="4502371869" data-ad-format="auto"></ins>
</div>
	
				</p><p>以往的lamp网站向着lnmp发展, 笔者工作环境使用lnmp多年, 在这里很高兴和大家分享一下多年的lnmp网站的php安全配置，至于lamp安全后续与大家分享，其实内容上八成相同，这边着重讲php安全配置，看内容.</p>
<h3>1. 使用open_basedir限制虚拟主机跨目录访问</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[HOST=www.ttlsa.com]
open_basedir=/data/site/www.ttlsa.com/:/tmp/

[HOST=test.ttlsa.com]
open_basedir=/data/site/test.ttlsa.com/:/tmp/</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>如上配置的意思是www.ttlsa.com下的php程序被限制在open_basedir配置的两个目录下, 不可以访问到其他目录。如果没有做以上的配置，那么test.ttlsa.com与www.ttlsa.com的程序可以互相访问.<br>
如果其中一个站点有漏洞被黑客植入了webshell，那么他可以通过这个站点拿下同一台服务器的其他站点，最后挂木马.</p>
<p>[warning]注意：目录最后一定要加上/. 比如你写/tmp，你的站点同时存在/tmp123等等以/tmp开头的目录，那么黑客也可以访问到这些目录，另外, php5.3以上支持这个写法，5.2不支持。[/warning]</p>
<h3>2. 禁用不安全PHP函数</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>disable_functions = show_source,system,shell_exec,passthru,exec,popen,proc_open,proc_get_status,phpinfo</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>禁止php执行以上php函数,以上php程序可以执行linux命令, 比如可以执行ping、netstat、mysql等等.如果你的系统有提权bug,后果你懂得.</p>
<h3>3. 关注软件安全资讯</h3>
<p>积极关注linux内核、php安全等信息并及时采取错误</p>
<h3>4. php用户只读</h3>
<p>这个方法是我最推崇的方法，但是执行之前一定要和php工程师商量. 为什么？例如站点www.ttlsa.com根目录用户与组为nobody，而运行php的用户和组为phpuser。目录权限为755，文件权限为644. 如此，php为只读，无法写入任何文件到站点目录下。也就是说用户不能上传文件，即使有漏洞, 黑客也传不了后门, 更不可能挂木马.  这么干之前告知程序员将文件缓存改为nosql内存缓存（例如memcached、redis等），上传的文件通过接口传到其他服务器（静态服务器）。</p>
<p>[warning]备注：程序生成本地缓存是个非常糟糕的习惯，使用文件缓存速度缓慢、浪费磁盘空间、最重要一点是一般情况下服务器无法横向扩展.[/warning]</p>
<h3>5. 关闭php错误日志</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>display_errors = On
改为
display_errors = Off</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>程序一旦出现错误，详细错误信息便立刻展示到用户眼前，其中包含路径、有的甚至是数据库账号密码. 注入渗透密码基本上都是通过这个报错来猜取。生产环境上强烈关闭它</p>
<h3>6. php上传分离</h3>
<p>将文件上传到远程服务器，例如nfs等。当然也可以调用你们写好的php接口. 即使有上传漏洞，那么文件也被传到了静态服务器上。木马等文件根本无法执行.</p>
<p>举个例子：<br>
php站点www.ttlsa.com，目录/data/site/www.ttlsa.com<br>
静态文件站点static.ttlsa.com，目录/data/site/static.ttlsa.com</p>
<p>文件直接被传到了/data/site/static.ttlsa.com，上传的文件无法通过www.ttlsa.com来访问，只能使用static.ttlsa.com访问，但是static.ttlsa.com不支持php.</p>
<h3>7. 关闭php信息</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>expose_php = On
改为
expose_php = Off</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>不轻易透露自己php版本信息，防止黑客针对这个版本的php发动攻击.</p>
<h3>8. 禁止动态加载链接库</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>disable_dl = On;
改为
enable_dl = Off;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p></p>
<h3>9. 禁用打开远程url</h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>allow_url_fopen = On
改为
allow_url_fopen = Off</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>其实这点算不上真正的安全, 并不会导致web被入侵等问题,但是这个非常影响性能, 笔者认为它属于狭义的安全问题.</p>
<p>以下方法将无法获取远程url内容</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$data = file_get_contents("http://www.baidu.com/")；</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>以下方法可以获取本地文件内容</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$data = file_get_contents("1.txt");</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果你的站点访问量不大、数据库也运行良好，但是web服务器负载出奇的高，请你直接检查下是否有这个方法。笔者遇到过太多这个问题，目前生产环境已全线禁用，如果php工程师需要获取远程web的内容，建议他们使用curl.</p>
<p>php curl如何使用请查看我之前的文章《PHP使用curl替代file_get_contents》，以及php下curl与file_get_contents性能对比.</p>
<h3>10.结束</h3>
<p>今天lnmp站点的php安全暂时讲到这里,有问题后续将继续补充.</p>
<p> </p>
<p>转载请注明出处:http://www.ttlsa.com/html/2279.html</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何安装nginx第三方模块-nginx案例]]></title>
      <url>/nginx/nginx/how-to-install-nginx-third-modules.html</url>
      <content type="html"><![CDATA[<p>nginx,how-to-install-nginx-third-modules,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx文件非常小但是性能非常的高效,这方面完胜apache,nginx文件小的一个原因之一是nginx自带的功能相对较少,好在nginx允许第三方模块,第三方模块使得nginx越发的强大. 在安装模块方面,nginx显得没有apache安装模块方便，当然也没有php安装扩展方便.在原生的nginx,他不可以动态加载模块,所以当你安装第三方模块的时候需要覆盖nginx文件.接下来看看如何安装nginx第三模块吧.</p>
<p>nginx第三方模块安装方法：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>./configure --prefix=/你的安装目录  --add-module=/第三方模块目录</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>以安装pagespeed模块实例</p>
<p>在未安装nginx的情况下安装nginx第三方模块</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./configure --prefix=/usr/local/nginx-1.4.1 \
--with-http_stub_status_module \
--with-http_ssl_module --with-http_realip_module \
--with-http_image_filter_module \
--add-module=../ngx_pagespeed-master --add-module=/第三方模块目录
# make
# make install
# /usr/local/nginx-1.4.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>在已安装nginx情况下安装nginx模块</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># ./configure --prefix=/usr/local/nginx-1.4.1 \
 --with-http_stub_status_module \
 --with-http_ssl_module --with-http_realip_module \
 --with-http_image_filter_module \
 --add-module=../ngx_pagespeed-master
# make
# /usr/local/nginx-1.4.1/sbin/nginx -s stop
# cp objs/nginx /usr/local/nginx/sbin/nginx
# /usr/local/nginx-1.4.1/sbin/nginx</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>相比之下仅仅多了一步覆盖nginx文件.</p>
<p>总结,安装nginx安装第三方模块实际上是使用--add-module重新安装一次nginx，不要make install而是直接把编译目录下objs/nginx文件直接覆盖老的nginx文件.如果你需要安装多个nginx第三方模块,你只需要多指定几个相应的--add-module即可.</p>
<p>[warning]备注：重新编译的时候，记得一定要把以前编译过的模块一同加到configure参数里面.[/warning]</p>
<p>nginx提供了非常多的nginx第三方模块提供安装,地址http://wiki.nginx.org/3rdPartyModules</p>
<p>第三方模块地址更新了：https://www.nginx.com/resources/wiki/modules/</p>
<div></div>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[隐藏Nginx版本号的安全性与方法-nginx案例]]></title>
      <url>/nginx/nginx/hidden-nginx-version.html</url>
      <content type="html"><![CDATA[<p>nginx,hidden-nginx-version,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>搭建好nginx或者apache，为了安全起见我们都会隐藏他们的版本号，这边讲的是nginx的版本号，如果你也想隐藏apache的版本号，那请点前面的链接。请看nginx版本号信息隐藏文章。</p>
<p>Nginx默认是显示版本号的，如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>[root@bkjz ~]# curl -I www.nginx.org</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>HTTP/1.1 200 OK
Server: nginx/0.8.44
Date: Tue, 13 Jul 2010 14:05:11 GMT
Content-Type: text/html
Content-Length: 8284
Last-Modified: Tue, 13 Jul 2010 12:00:13 GMT
Connection: keep-alive
Keep-Alive: timeout=15
Accept-Ranges: bytes</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p><strong>这样就给人家看到你的服务器nginx版本是0.8.44，前些时间暴出了一些Nginx版本漏洞，就是说有些版本有漏洞，而有些版本没有。这样暴露出来的版本号就容易变成攻击者可利用的信息。所以，从安全的角度来说，隐藏版本号会相对安全些！</strong></p>
<p>那nginx版本号可以隐藏不？其实可以的，看下面的步骤：</p>
<p> </p>
<p>1、进入nginx配置文件的目录（此目录根据安装时决定），用vim编辑打开</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># vim nginx.conf</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>在http {—}里加上<strong>server_tokens off;</strong> 如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
……省略
sendfile on;
tcp_nopush on;
keepalive_timeout 60;
tcp_nodelay on;
server_tokens off;
…….省略
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>2、编辑php-fpm配置文件，如fastcgi.conf或fcgi.conf（这个配置文件名也可以自定义的，根据具体文件名修改）：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>找到：
fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;
改为：
fastcgi_param SERVER_SOFTWARE nginx;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>3、重新加载nginx配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># /etc/init.d/nginx reload</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>这样就完全对外隐藏了nginx版本号了，就是出现404、501等页面也不会显示nginx版本。</p>
<p>下面测试一下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl -I www.abc.net
HTTP/1.1 200 OK
Server: nginx
Date: Tue, 13 Jul 2010 14:26:56 GMT
Content-Type: text/html; charset=UTF-8
Connection: keep-alive
Vary: Accept-Encoding</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[srcache_nginx+redis构建缓存系统-nginx案例]]></title>
      <url>/nginx/nginx/construction-of-srcache_nginx_redis-caching-system.html</url>
      <content type="html"><![CDATA[<p>nginx,construction-of-srcache_nginx_redis-caching-system,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>在《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》一文中，我们使用到memcached来作为缓存载体。想必大家都知道memcached有存储大小的限制，不得超过1M。 本文将使用redis来作为缓存载体。nginx的srcache_nginx模块指令参数解释参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》。</p>
<h3><strong>1. nginx模块</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>--add-module=../modules/ngx_devel_kit-0.2.18 
--add-module=../modules/set-misc-nginx-module-0.22rc8 
--add-module=../modules/srcache-nginx-module-0.22 
--add-module=../modules/redis-nginx-module-0.3.6 
--add-module=../modules/redis2-nginx-module-0.10</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>nginx模块安装参见ttlsa.com中相关文档。</p>
<h3><strong>2. redis安装配置</strong></h3>
<p>安装步骤参见：http://www.ttlsa.com/html/1646.html<br>
配置参数解释参见：http://www.ttlsa.com/html/1226.html<br>
配置实例：<br>
# vim redis.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>daemonize yes
pidfile /var/run/redis-6379.pid
port 6379
bind 127.0.0.1
timeout 0
tcp-keepalive 0
loglevel notice
logfile stdout
databases 16
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
slave-serve-stale-data yes
slave-read-only yes
repl-disable-tcp-nodelay no
slave-priority 100
maxmemory 8096mb
maxmemory-policy volatile-ttl
appendonly no
appen<a href="http://www.ttlsa.com/dfs/" title="dfs" target="_blank">dfs</a>ync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
<a href="http://www.ttlsa.com/monitor/lua/" title="lua" target="_blank">lua</a>-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-entries 512
list-max-ziplist-value 64
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes</pre></div>
			 
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p>由于只把redis当做缓存使用，因此没有启用持久化。</p>
<h3><strong>3. nginx配置</strong></h3>
<p># vim nginx.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http
{
        include       mime.types;
        default_type  application/octet-stream;

        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                                        '"$status" $body_bytes_sent "$http_referer" '
                                        '"$http_user_agent" "$http_x_forwarded_for" '
                                        '"$gzip_ratio" $request_time $bytes_sent $request_length';

        log_format srcache_log '$remote_addr - $remote_user [$time_local] "$request" '
                                '"$status" $body_bytes_sent $request_time $bytes_sent $request_length '
                                '[$upstream_response_time] [$srcache_fetch_status] [$srcache_store_status] [$srcache_expire]';

        set_real_ip_from 10.0.0.0/8;
        real_ip_header X-Forwarded-For;

        include          vhosts/test.ttlsa.com.conf;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p># vim vhosts/test.ttlsa.com.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream redis {
        server 127.0.0.1:6379;
        keepalive 512;
}

server
       {
        listen       80;
        server_name  test.ttlsa.com;
        index index.html index.htm index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;
        root  /data/test.ttlsa.com/webroot;

        location ~ .*\.php {
                srcache_store_private on;
                srcache_methods GET;
                srcache_response_cache_control off;

                if ($uri ~ /ttlsa.com/pp.php$){
                        set $key $request_uri;
                        set_escape_uri $escaped_key $key;
                        srcache_fetch GET /redis $key;
                        srcache_default_expire 172800;
                        srcache_store PUT /redis2 key=$escaped_key&amp;exptime=$srcache_expire;

                        #add_header X-Cached-From $srcache_fetch_status;
                        #set_md5 $md5key $key;
                        #add_header X-md5-key $md5key;
                        #add_header X-Cached-Store $srcache_store_status;
                        #add_header X-Key $key;
                        #add_header X-Query_String $query_string;
                        #add_header X-expire $srcache_expire;

						access_log /data/httplogs/test.ttlsa.com-photo-access.log srcache_log;
                }

                include fastcgi_params;
                fastcgi_pass  127.0.0.1:9000;
                fastcgi_index index.php;
                fastcgi_connect_timeout 60;
                fastcgi_send_timeout 180;
                fastcgi_read_timeout 180;
                fastcgi_buffer_size 128k;
                fastcgi_buffers 4 256k;
                fastcgi_busy_buffers_size 256k;
                fastcgi_temp_file_write_size 256k;
                fastcgi_intercept_errors on;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_param PATH_INFO $fastcgi_path_info;
         }

        location = /redis {
                internal;
                set_md5 $redis_key $args;
                redis_pass redis;
        }

        location = /redis2 {
                internal;

                set_unescape_uri $exptime $arg_exptime;
                set_unescape_uri $key $arg_key;
                set_md5 $key;

                redis2_query set $key $echo_request_body;
                redis2_query expire $key $exptime;
                redis2_pass redis;
        }

        error_log  /data/httplogs/test.ttlsa.com-error.log;
        access_log  /data/httplogs/test.ttlsa.com-aceess.log main;

}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0030 seconds] -->
<p></p>
<h3><strong>4. 测试</strong></h3>
<p>没有做缓存状态：<br>
<br>
有做缓存状态：<br>
</p>
<h3><strong>5. 响应头状态</strong></h3>
<p>第一次请求：<br>
<br>
再次请求：<br>
</p>
<h3><strong>6. 查看redis是否缓存以及过期时间</strong></h3>
<p></p>
<p>如需转载请注明出处： http://www.ttlsa.com/html/3156.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx+memcached构建页面缓存应用-nginx案例]]></title>
      <url>/nginx/nginx/application-of-nginx_memcached-to-construct-the-page-cache.html</url>
      <content type="html"><![CDATA[<p>nginx,application-of-nginx_memcached-to-construct-the-page-cache,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>nginx的memcached_module模块可以直接从memcached服务器中读取内容后输出，后续的请求不再经过应用程序处理，如php-fpm、django，大大的提升动态页面的速度。nginx只负责从memcached服务器中读取数据，要往memcached写入数据还得需要后台的应用程序来完成，主动的将要缓存的页面缓存到memcached中，可以通过404重定向到后端去处理的。<br>
ngx_http_memcached_module可以操作任何兼用memcached协议的软件。如ttserver、membase等。</p>
<p>结构图如下：</p>
<p></p>
<p>memcached的key可以通过memcached_key变量来设置，如以$uri。如果命中，那么直接输出内容，没有命中就意味着nginx需要从应用程序请求页面。同时，我们还希望该应用程序将键值对写入到memcached，以便下一个请求可以直接从memcached获取。<br>
如果键值不存在，nginx将报告not found错误。最好的方法是使用error_page指定和location请求处理。同时包含"Bad Gateway"错误和"Gateway Timeout"错误，如：error_page 404 502 504 = @app;。<br>
注意：需要设置default_type，否则可能会显示不正常。</p>
<p>1. 模块指令说明：<br>
memcached_bind<br>
语法: memcached_bind address | off;<br>
默认值: none<br>
配置段: http, server, location<br>
指定从哪个IP来连接memcached服务器</p>
<p>memcached_buffer_size<br>
语法: memcached_buffer_size size;<br>
默认值: 4k|8k;<br>
配置段: http, server, location<br>
读取从memcached服务器接收到响应的缓冲大小。尽快的将响应同步传给客户端。</p>
<p>memcached_connect_timeout<br>
语法：memcached_connect_timeout time;<br>
默认值：60s;<br>
配置段：http, server, location<br>
与memcached服务器建立连接的超时时间。通常不超过75s。</p>
<p>memcached_gzip_flag<br>
语法：memcached_gzip_flag flag;<br>
默认值：none<br>
配置段：http, server, location<br>
测试memcached服务器响应标志。如果设置了，将在响应头部添加了Content-Encoding：gzip。</p>
<p>memcached_next_upstream<br>
语法: memcached_next_upstream error | timeout | invalid_response | not_found | off ...;<br>
默认值： error timeout;<br>
配置段: http, server, location<br>
指定在哪些状态下请求将转发到另外的负载均衡服务器上，仅当memcached_pass有两个或两个以上时使用。</p>
<p>memcached_pass<br>
语法：memcached_pass address:port or socket；<br>
默认值：none<br>
配置段：location, if in location<br>
指定memcached服务器地址。使用变量$memcached_key为key查询值，如果没有相应的值则返回error_page 404。</p>
<p>memcached_read_timeout<br>
语法：memcached_read_timeout time;<br>
默认值：60s;<br>
配置段：http, server, location<br>
定义从memcached服务器读取响应超时时间。</p>
<p>memcached_send_timeout<br>
语法：memcached_send_timeout<br>
默认值：60s<br>
配置段：http, server, location<br>
设置发送请求到memcached服务器的超时时间。</p>
<p>$memcached_key变量：<br>
memcached key的值。</p>
<p>2. nginx memcached的增强版ngx_http_enhanced_memcached_module<br>
基于nginx memcached 模块的，添加的新特性有：<br>
1. 自定义HTTP头，如Content-Type, Last-Modified。<br>
2. hash键可超过250个字符，memcached受限。<br>
3. 通过HTTP请求将数据存储到memcached。<br>
4. 通过HTTP请求从memcached删除数据。<br>
5. 通过HTTP请求清除所有memcached缓存数据。<br>
6. 通过HTTP请求获取memcached状态数据。<br>
7. 键名空间管理，来部分刷新缓存。<br>
8. 缓存通过If-Modified-Since头和内容Last-Modified来回复304Not Modified请求。</p>
<p>3. 应用实例<br>
nginx配置实例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>upstream memcacheds {
        server 10.1.240.166:22222;
}
server  {
        listen       8080;
        server_name  nm.ttlsa.com;
        index index.html index.htm index.php;
        root  /data/wwwroot/test.ttlsa.com/webroot;

        location /images/ {
                set $memcached_key $request_uri;
                add_header X-mem-key  $memcached_key;
                memcached_pass  memcacheds;
                default_type text/html;
                error_page 404 502 504 = @app;
        }

        location @app {
                rewrite ^/.* /nm_ttlsa.php?key=$request_uri;
        }

        location ~ .*\.php?$
        {
                include fastcgi_params;
                fastcgi_pass  127.0.0.1:10081;
                fastcgi_index index.php;
                fastcgi_connect_timeout 60;
                fastcgi_send_timeout 180;
                fastcgi_read_timeout 180;
                fastcgi_buffer_size 128k;
                fastcgi_buffers 4 256k;
                fastcgi_busy_buffers_size 256k;
                fastcgi_temp_file_write_size 256k;
                fastcgi_intercept_errors on;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0017 seconds] -->
<p>nm_ttlsa.php实例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre><?php $fn = dirname(__FILE__)  . $_SERVER['REQUEST_URI'];
if(file_exists($fn)) {
	$data = file_get_contents($fn);
	$m = new Memcached();
	$servers = array(
					array('10.1.240.166', 22222)
				);
	$m->addServers($servers);

	$r=$m-&gt;set($_GET['key'],$data); 
	header('Content-Length: '.filesize($fn)."\r\n");
	header('Content-Type: image/gif'."\r\n");
	header('X-cache: MISS'."\r\n");
	print $data;
}else{
	header('Location: http://www.ttlsa.com'."\r\n");
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>4. 测试<br>
第一次访问：（需要经过php处理）</p>
<p></p>
<p>再次访问：（直接从memcached读取）</p>
<p></p>
<p>哈，这个实例并不好。<br>
1. 地球人都知道memcached不是持久化的，如果是永久性的图片应用，选用可以持久化存储方案合适，如riak、membase、ttserver、mongodb GridFS等等。<br>
2. 如果是用户头像的应用，用memcached来做缓存也不合适。因为用户更改头像又得刷新缓存，鉴于此，一步到位的用ttserver或mongodb GridFS来做用户头像的存储岂不是更好么。<br>
ttserver+nginx构建高并发高可用性应用参见：http://www.ttlsa.com/html/1429.html<br>
这个实例改改或许可以用来在线迁移图片到key-value存储的过渡方案。</p>
<p>nginx的memc-nginx和srcache-nginx模块可以主动的向memcached添加缓存。后续整理后再发布出来。参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》http://www.ttlsa.com/html/2460.html</p>
<p>如需转载请注明出处： http://www.ttlsa.com/html/2418.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[确保nginx安全的10个技巧-nginx案例]]></title>
      <url>/nginx/nginx/10-tips-to-ensure-the-security-of-nginx.html</url>
      <content type="html"><![CDATA[<p>nginx,10-tips-to-ensure-the-security-of-nginx,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>Nginx是当今最流行的Web服务器之一。它为世界上7%的web流量提供服务而且正在以惊人的速度增长。它是个让人惊奇的服务器，我愿意部署它。<br>
下面是一个常见安全陷阱和解决方案的列表，它可以辅助来确保你的Nginx部署是安全的。</p>
<p><strong>1. 在配置文件中小心使用"if"</strong><br>
它是重写模块的一部分，不应该在任何地方使用。<br>
“if”声明是重写模块评估指令强制性的部分。换个说法，Nginx的配置一般来说是声明式的。在有些情况下，由于用户的需求，他们试图在一些非重写指令内使用“if”，这导致我们现在遇到的情况。大多数情况下都能正常工作，但…看上面提到的。</p>
<p>看起来唯一正确的解决方案是在非重写的指令内完全禁用“if”。这将更改现有的许多配置，所以还没有完成。IfIsEvil：http://wiki.nginx.org/IfIsEvil</p>
<p><strong>2. 将每个~ .php$请求转递给PHP</strong><br>
我们上周发布了这个流行指令的潜在安全漏洞介绍。即使文件名为hello.php.jpeg它也会匹配~ .php$这个正则而执行文件。<br>
现在有两个解决上述问题的好方法。我觉得确保你不轻易执行任意代码的混合方法很有必要。<br>
2.1 如果没找到文件时使用try_files和only(在所有的动态执行情况下都应该注意) 将它转递给运行PHP的FCGI进程。<br>
2.2 确认php.ini文件中cgi.fix_pathinfo设置为0 (cgi.fix_pathinfo=0) 。这样确保PHP检查文件全名(当它在文件结尾没有发现.php它将忽略)<br>
2.3 修复正则表达式匹配不正确文件的问题。现在正则表达式认为任何文件都包含".php"。在站点后加“if”确保只有正确的文件才能运行。将/location ~ .php$和location ~ ..*/.*.php$都设置为return 403;</p>
<p><strong>3. 禁用autoindex模块</strong><br>
这个可能在你使用的Nginx版本中已经更改了，如果没有的话只需在配置文件的location块中增加autoindex off;声明即可。</p>
<p><strong>4. 禁用服务器上的ssi (服务器端引用)</strong><br>
这个可以通过在location块中添加ssi off; 。</p>
<p><strong>5. 关闭服务器标记</strong><br>
如果开启的话（默认情况下）所有的错误页面都会显示服务器的版本和信息。将server_tokens off;声明添加到Nginx配置文件来解决这个问题。</p>
<p><strong>6. 在配置文件中设置自定义缓存以限制缓冲区溢出攻击的可能性</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>client_body_buffer_size 1K;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p><strong>7. 将timeout设低来防止DOS攻击</strong><br>
所有这些声明都可以放到主配置文件中。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>client_body_timeout 10;
client_header_timeout 10;
keepalive_timeout 5 5;
send_timeout 10;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong>8. 限制用户连接数来预防DOS攻击</strong></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>limit_zone slimits $binary_remote_addr 5m;
limit_conn slimits 5;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p><strong>9. 试着避免使用HTTP认证</strong><br>
HTTP认证默认使用crypt，它的哈希并不安全。如果你要用的话就用MD5（这也不是个好选择但负载方面比crypt好） 。</p>
<p><strong>10. 保持与最新的Nginx安全更新</strong><br>
转自：http://www.levigross.com/post/4488812448/10-tips-for-securing-nginx</p>
<p>个人觉得在防止DDOS攻击这方面，上面提到的第七第八没太大用处，特别是第八点，很扰乱用户体验度的。</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx日志配置-nginx案例]]></title>
      <url>/nginx/linux/the-nginx-log-configuration.html</url>
      <content type="html"><![CDATA[<p>linux,the-nginx-log-configuration,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>日志对于统计排错来说非常有利的。本文总结了nginx日志相关的配置如access_log、log_format、open_log_file_cache、log_not_found、log_subrequest、rewrite_log、error_log。<br>
nginx有一个非常灵活的日志记录模式。每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令来定义。ngx_http_log_module是用来定义请求日志格式的。</p>
<h3><strong>1.</strong> access_log指令</h3>
<p>语法: access_log path [format [buffer=size [flush=time]]];<br>
access_log path format gzip[=level] [buffer=size] [flush=time];<br>
access_log syslog:server=address[,parameter=value] [format];<br>
access_log off;<br>
默认值: access_log logs/access.log combined;<br>
配置段: http, server, location, if in location, limit_except<br>
gzip压缩等级。<br>
buffer设置内存缓存区大小。<br>
flush保存在缓存区中的最长时间。<br>
不记录日志：access_log off;<br>
使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined;</p>
<h3><strong>2.</strong> log_format指令</h3>
<p>语法: log_format name string …;<br>
默认值: log_format combined “…”;<br>
配置段: http</p>
<p>name表示格式名称，string表示等义的格式。log_format有一个默认的无需设置的combined日志格式，相当于apache的combined日志格式，如下所示：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>log_format  combined  '$remote_addr - $remote_user  [$time_local]  '
                                   ' "$request"  $status  $body_bytes_sent  '
                                   ' "$http_referer"  "$http_user_agent" ';</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>如果nginx位于负载均衡器，squid，nginx反向代理之后，web服务器无法直接获取到客户端真实的IP地址了。 $remote_addr获取反向代理的IP地址。反向代理服务器在转发请求的http头信息中，可以增加X-Forwarded-For信息，用来记录 客户端IP地址和客户端请求的服务器地址。PS: 获取用户真实IP 参见http://www.ttlsa.com/html/2235.html如下所示：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>log_format  porxy  '$http_x_forwarded_for - $remote_user  [$time_local]  '
                             ' "$request"  $status $body_bytes_sent '
                             ' "$http_referer"  "$http_user_agent" ';</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>日志格式允许包含的变量注释如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>$remote_addr, $http_x_forwarded_for 记录客户端IP地址
$remote_user 记录客户端用户名称
$request 记录请求的URL和HTTP协议
$status 记录请求状态
$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。
$bytes_sent 发送给客户端的总字节数。
$connection 连接的序列号。
$connection_requests 当前通过一个连接获得的请求数量。
$msec 日志写入时间。单位为秒，精度是毫秒。
$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。
$http_referer 记录从哪个页面链接访问过来的
$http_user_agent 记录客户端浏览器相关信息
$request_length 请求的长度（包括请求行，请求头和请求正文）。
$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。
$time_iso8601 ISO8601标准格式下的本地时间。
$time_local 通用日志格式下的本地时间。</pre></div>
			 
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<div>
<div>[warning]发送给客户端的响应头拥有“sent_http_”前缀。 比如$sent_http_content_range。[/warning]</div>
</div>
<p>实例如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>http {
	log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                                        '"$status" $body_bytes_sent "$http_referer" '
                                        '"$http_user_agent" "$http_x_forwarded_for" '
                                        '"$gzip_ratio" $request_time $bytes_sent $request_length';

	log_format srcache_log '$remote_addr - $remote_user [$time_local] "$request" '
                                '"$status" $body_bytes_sent $request_time $bytes_sent $request_length '
                                '[$upstream_response_time] [$srcache_fetch_status] [$srcache_store_status] [$srcache_expire]';

	open_log_file_cache max=1000 inactive=60s;

	server {
		server_name ~^(www\.)?(.+)$;
		access_log logs/$2-access.log main;
		error_log logs/$2-error.log;

		location /srcache {
			access_log logs/access-srcache.log srcache_log;
		}
	}
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<h3><strong>3. open_log_file_cache指令</strong></h3>
<p>语法: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];<br>
open_log_file_cache off;<br>
默认值: open_log_file_cache off;<br>
配置段: http, server, location</p>
<p>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)，格式如下：<br>
参数注释如下：<br>
max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。<br>
inactive:设置存活时间，默认是10s<br>
min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次<br>
valid:设置检查频率，默认60s<br>
off：禁用缓存<br>
实例如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h3><strong>4.</strong> log_not_found指令</h3>
<p>语法: log_not_found on | off;<br>
默认值: log_not_found on;<br>
配置段: http, server, location<br>
是否在error_log中记录不存在的错误。默认是。</p>
<h3><strong>5.</strong> log_subrequest指令</h3>
<p>语法: log_subrequest on | off;<br>
默认值: log_subrequest off;<br>
配置段: http, server, location<br>
是否在access_log中记录子请求的访问日志。默认不记录。</p>
<h3><strong>6. rewrite_log</strong>指<strong>令</strong></h3>
<p>由ngx_http_rewrite_module模块提供的。用来记录重写日志的。对于调试重写规则建议开启。 Nginx重写规则指南<br>
语法: rewrite_log on | off;<br>
默认值: rewrite_log off;<br>
配置段: http, server, location, if<br>
启用时将在error log中记录notice级别的重写日志。</p>
<h3><strong>7.</strong> error_log指令</h3>
<p>语法: error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice | warn | error | crit | alert | emerg];<br>
默认值: error_log logs/error.log error;<br>
配置段: main, http, server, location<br>
配置错误日志。</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx替换网站响应内容（ngx_http_sub_module）-nginx案例]]></title>
      <url>/nginx/linux/nginx-modules-ngx_http_sub_module.html</url>
      <content type="html"><![CDATA[<p>linux,nginx-modules-ngx_http_sub_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>ngx_http_sub_module模块是一个过滤器，它修改网站响应内容中的字符串，比如你想把响应内容中的‘ttlsa’全部替换成‘运维生存时间’，这个模块已经内置在nginx中，但是默认未安装，需要安装需要加上配置参数：--with-http_sub_module</p>
<h3><strong>1. 安装nginx</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
#  --prefix=/usr/local/nginx-1.4.2 --with-http_stub_status_module　--with-http_sub_module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果你已经安装了nginx，只需要额外追加这个模块，请看如何安装nginx第三方模块</p>
<h3><strong>2. 指令（Directives）</strong></h3>
<p>语法:     sub_filter string replacement;<br>
默认值:     —<br>
配置段:     http, server, location<br>
设置需要使用说明字符串替换说明字符串.string是要被替换的字符串，replacement是新的字符串，它里面可以带变量。</p>
<p>语法:     sub_filter_last_modified on | off;<br>
默认值: sub_filter_last_modified off;<br>
配置段:     http, server, location<br>
这个指令在nginx 1.5.1中添加，我这个版本没有，可以忽略掉.<br>
Allows preserving the “Last-Modified” header field from the original response during replacement to facilitate response caching.<br>
By default, the header field is removed as contents of the response are modified during processing.</p>
<p>语法: sub_filter_once on | off;<br>
默认值: sub_filter_once on;<br>
配置段: http, server, location<br>
字符串替换一次还是多次替换，默认替换一次，例如你要替换响应内容中的ttlsa为运维生存时间，如果有多个ttlsa出现，那么只会替换第一个，如果off，那么所有的ttlsa都会 被替换</p>
<p>语法: sub_filter_types mime-type ...;<br>
默认值: sub_filter_types text/html;<br>
配置段: http, server, location<br>
指定需要被替换的MIME类型,默认为“text/html”，如果制定为*，那么所有的</p>
<h3><strong>3. nginx替换字符串实例</strong></h3>
<p><span>3.1 配置</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen       80;
    server_name  www.ttlsa.com;

    root /data/site/www.ttlsa.com;    

    location / {
        sub_filter  ttlsa '运维生存时间';
        sub_filter_types text/html;
        sub_filter_once on;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h3><strong>3.2 测试</strong></h3>
<p>内容如下</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat /data/site/www.ttlsa.com/2013/10/20131001_sub1.html 
welcome to tTlsa!
TTLSA TEAM!</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>访问结果</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl www.ttlsa.com/2013/10/20131001_sub1.html           
welcome to 运维生存时间!
TTLSA TEAM!</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们可以看到它替换是不区分大小写的，而且ttlsa只被替换了一次。我把sub_filter_once on改成off试试。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
    sub_filter  ttlsa '运维生存时间';
    sub_filter_once off;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>接着测试</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl www.ttlsa.com/2013/10/20131001_sub1.html            
welcome to 运维生存时间!
运维生存时间 TEAM!</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>我们可以看到ttlsa都被替换掉了.</p>
<p>例如你想在&lt;/head&gt;后追加一段js，配置如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>location / {
    sub_filter       '<script language="javascript" src="%24script"></script>';
    sub_filter_once on;
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0044 seconds] -->
<p>这边我就不再做测试了,大家可以测试一下.</p>
<h3><strong>4. 结束语</strong></h3>
<p>这个nginx替换响应内容的模块安装使用尤为简单，应用的地方相对较少，在nginx中也是一个可选模块。假如站点出现什么敏感字，想修改很耗时间，不妨试试这个模块.或者想临时在站点中加上一个通用js或者css之类的文件，也可以使用这个模块.至于要在哪里，大家看看自己的需求.</p>
<p>转载请注明来至运维生存时间：http://www.ttlsa.com/html/3289.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx向响应内容中追加内容（ngx_http_addition_module模块）-nginx案例]]></title>
      <url>/nginx/linux/nginx-modules-ngx_http_addition_module.html</url>
      <content type="html"><![CDATA[<p>linux,nginx-modules-ngx_http_addition_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>ngx_http_addition_module在响应之前或者之后追加文本内容，比如想在站点底部追加一个js或者css，可以使用这个模块来实现，这个模块和淘宝开发的nginx footer模块有点类似,但是还是有不同. 这个模块需要依赖子请求，nginx footer依赖nginx写死的配置.</p>
<h3><strong>1. 安装nginx</strong></h3>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># wget http://nginx.org/download/nginx-1.4.2.tar.gz
# tar -xzvf nginx-1.4.2.tar.gz
# cd nginx-1.4.2
#  --prefix=/usr/local/nginx-1.4.2 --with-http_stub_status_module　--with-http_addition_module
# make
# make install</pre></div>
			 
		</div>
<!-- [Format Time: 0.0001 seconds] -->
<p>如果你已经安装了nginx，只想增加模块，请参考ttlsa以前的文章如何安装nginx第三方模块</p>
<h3><strong>2.</strong> 指令(Directives)</h3>
<p>语法:     add_before_body uri;<br>
默认值:     —<br>
配置段:     http, server, location<br>
发起一个子请求，请求给定的uri，并且将内容追加到主题响应的内容之前。</p>
<p>语法:     add_after_body uri;<br>
默认值:     —<br>
配置段:     http, server, location<br>
发起一个子请求，请求给定的uri，并且将内容追加到主题响应的内容之后。</p>
<p>syntax: addition_types mime-type ...;<br>
default: addition_types text/html;<br>
context: http, server, location<br>
这个指令在0.7.9开始支持，指定需要被追加内容的MIME类型,默认为“text/html”，如果制定为*，那么所有的</p>
<h3><strong>3.</strong> nginx配置addition</h3>
<p><span>3.1 配置nginx.conf</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre>server {
    listen       80;
    server_name  www.ttlsa.com;

    root /data/site/www.ttlsa.com;    

    location / {
        add_before_body /2013/10/header.html;
        add_after_body  /2013/10/footer.html;
    }
}</pre></div>
			 
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p><span>3.2 测试</span><br>
以下三个文件，对应请求的主体文件和add_before_body、add_after_body对应的内容</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># cat /data/site/test.ttlsa.com/2013/10/20131001_add.html 
<html>
<head>
<title>I am title</title>
</head>
<body>
ngx_http_addition_module
</body>
</html>

# cat /data/site/test.ttlsa.com/2013/10/header.html 
I am header!

# cat /data/site/test.ttlsa.com/2013/10/footer.html 
footer - ttlsa</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>访问结果如下，可以看到20131001_add.html的顶部和底部分别嵌入了子请求header.html和footer的内容。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div>
		
			<div><pre># curl test.ttlsa.com/2013/10/20131001_add.html           
I am header!
<html>
<head>
<title>I am title</title>
</head>
<body>
ngx_http_addition_module
</body>
</html>
footer - ttlsa</pre></div>
			 
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h3>4.<strong> 结束语</strong></h3>
<p>addition模块与上节上节nginx sub替换响应内容模块应用场景有点相同，具体怎么使用，大家结合实际情况来使用.欢迎大家继续访问运维生存时间.</p>
<p>转载请注明来自运维生存时间：http://www.ttlsa.com/html/3294.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx访问控制allow、deny（ngx_http_access_module）-nginx案例]]></title>
      <url>/nginx/linux/nginx-modules-ngx_http_access_module.html</url>
      <content type="html"><![CDATA[<p>linux,nginx-modules-ngx_http_access_module,<br><a id="more"></a><br>
  <div><!--<a href="/go/jjim" rel="external nofollow" target="_blank"><img src="/wp-content/uploads/2017/12/jujin_im.jpg" alt="又拍云upyun" /></a>-->
 
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-0956732394986573" data-ad-slot="2895550264"></ins>
 
</div>
	
				</p><p>单看nginx模块名<code>ngx_http_access_module</code>,很多人一定很陌生，但是deny和allow相比没一个人不知道的，实际上deny和allow指令属于ngx_http_access_module.我们想控制某个uri或者一个路径不让人访问，在nginx就得靠它了。</p>
<p>nginx的访问控制模块语法很简单，至少比apache好理解，apache的allow和deny的顺序让很多初学者抓头.好了具体看下这个插件的使用方法吧。</p>
<h3><strong>1、安装模块</strong></h3>
<p>这个模块内置在了nginx中，除非你安装中使用了--without-http_access_module。如果你还没安装过nginx，那么请参考下ttlsa之前写的nginx安装.</p>
<h3><strong>2、指令</strong></h3>
<p>allow<br>
语法:     allow address | CIDR | unix: | all;<br>
默认值:     —<br>
配置段:     http, server, location, limit_except</p>
<p>允许某个ip或者一个ip段访问.如果指定unix:,那将允许socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。</p>
<p>deny<br>
语法:     deny address | CIDR | unix: | all;<br>
默认值:     —<br>
配置段:     http, server, location, limit_except</p>
<p>禁止某个ip或者一个ip段访问.如果指定unix:,那将禁止socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。</p>
<h3><strong>3. allow、deny实例</strong></h3>
<p>location / {<br>
deny  192.168.1.1;<br>
allow 192.168.1.0/24;<br>
allow 10.1.1.0/16;<br>
allow 2001:0db8::/32;<br>
deny  all;<br>
}</p>
<p>从上到下的顺序，类似iptables。匹配到了便跳出。如上的例子先禁止了192.16.1.1，接下来允许了3个网段，其中包含了一个ipv6，最后未匹配的IP全部禁止访问.  在实际生产环境中，我们也会使用nginx 的geo模块配合使用，有兴趣的请参考ttlsa相关文章nginx geo使用方法.</p>
<h3><strong>4. 结束语</strong></h3>
<p>nginx访问控制模块要数nginx里面最简单的指令，只要记住你想禁止谁访问就deny加上IP，想允许则加上allow ip，想禁止或者允许所有，那么allow all或者deny all即可.</p>
<p>站点:运维生存时间  网址：http://www.ttlsa.com/html/3585.html</p>
<div><span></span></div>			
<p></p>
]]></content>
      
        <categories>
            
            <category> nginx案例 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/stream_processing-nginx中文手册]]></title>
      <url>/ngx/stream/stream_processing.html</url>
      <content type="html"><![CDATA[<p>stream,stream_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理TCP-UDP会话"><a href="#nginx如何处理TCP-UDP会话" class="headerlink" title="nginx如何处理TCP / UDP会话"></a>nginx如何处理TCP / UDP会话</h2><p>  来自客户端的TCP / UDP会话在称为<strong>阶段的</strong>连续步骤中处理： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_zone_sync_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_zone_sync_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_zone_sync_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-zone-sync-module"><a href="#Module-ngx-stream-zone-sync-module" class="headerlink" title="Module ngx_stream_zone_sync_module"></a>Module ngx_stream_zone_sync_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#zone_sync">zone_sync</a> <br>     <a href="#zone_sync_buffers">zone_sync_buffers</a> <br>     <a href="#zone_sync_connect_retry_interval">zone_sync_connect_retry_interval</a> <br>     <a href="#zone_sync_connect_timeout">zone_sync_connect_timeout</a> <br>     <a href="#zone_sync_interval">zone_sync_interval</a> <br>     <a href="#zone_sync_recv_buffer_size">zone_sync_recv_buffer_size</a> <br>     <a href="#zone_sync_server">zone_sync_server</a> <br>     <a href="#zone_sync_ssl">zone_sync_ssl</a> <br>     <a href="#zone_sync_ssl_certificate">zone_sync_ssl_certificate</a> <br>     <a href="#zone_sync_ssl_certificate_key">zone_sync_ssl_certificate_key</a> <br>     <a href="#zone_sync_ssl_ciphers">zone_sync_ssl_ciphers</a> <br>     <a href="#zone_sync_ssl_crl">zone_sync_ssl_crl</a> <br>     <a href="#zone_sync_ssl_name">zone_sync_ssl_name</a> <br>     <a href="#zone_sync_ssl_password_file">zone_sync_ssl_password_file</a> <br>     <a href="#zone_sync_ssl_protocols">zone_sync_ssl_protocols</a> <br>     <a href="#zone_sync_ssl_server_name">zone_sync_ssl_server_name</a> <br>     <a href="#zone_sync_ssl_trusted_certificate">zone_sync_ssl_trusted_certificate</a> <br>     <a href="#zone_sync_ssl_verify">zone_sync_ssl_verify</a> <br>     <a href="#zone_sync_ssl_verify_depth">zone_sync_ssl_verify_depth</a> <br>     <a href="#zone_sync_timeout">zone_sync_timeout</a> <br> <a href="#stream_zone_sync_status">API endpoints</a> <br> <a href="#controlling_cluster_node">Starting, stopping, removing a cluster node</a> <br></td>

<p>   <code>ngx_stream_zone_sync_module</code>模块（1.13.8）为在集群节点之间同步<a href="ngx_stream_upstream_module.html#zone">共享内存区域的</a>内容提供必要的支持。  要为特定区域启用同步，相应的模块必须支持此功能。  目前，可以在<a href="http/ngx_http_keyval_module.html">http</a>和<a href="stream/ngx_stream_keyval_module.html">流中</a>同步HTTP <a href="http/ngx_http_upstream_module.html#sticky">粘性</a>会话，有关<a href="http/ngx_http_limit_req_module.html">过多HTTP请求的</a>信息和键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  最小配置： </p>
<pre class="notranslate">http {
    ...

    upstream backend {
       server backend1.example.com:8080;
       server backend2.example.com:8081;

       sticky learn
              create=$upstream_cookie_examplecookie
              lookup=$cookie_examplecookie
              zone=client_sessions:1m **sync** ;
    }

    ...
}

stream {
    ...


    server {
        zone_sync;

        listen 127.0.0.1:8090;

        # cluster of 2 nodes
        zone_sync_server a.example.com;
        zone_sync_server b.example.com;

    }
</pre>

<p>  启用了SSL并且由DNS定义的集群成员的更复杂配置： </p>
<pre class="notranslate">...

stream {
    ...

    resolver 127.0.0.1 valid=10s;

    server {
        zone_sync;

        # the name resolves to multiple addresses that correspond to cluster nodes
        zone_sync_server cluster.example.com resolve;

        listen 127.0.0.1:4433 ssl;

        ssl_certificate     localhost.crt;
        ssl_certificate_key localhost.key;

        zone_sync_ssl on;

        zone_sync_ssl_certificate     localhost.crt;
        zone_sync_ssl_certificate_key localhost.key;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  启用集群节点之间的共享内存区域同步。  使用<a href="#zone_sync_server">zone_sync_server</a>指令定义集群节点。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_buffers 256 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置用于推送区域内容的每个区域缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_connect_retry_interval*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_connect_retry_interval 1s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义到另一个群集节点的连接尝试之间的间隔。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_connect_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义与另一个群集节点建立连接的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_interval*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_interval 1s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义在共享内存区域中轮询更新的时间间隔。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_recv_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_recv_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置用于解析传入的同步消息流的每连接接收缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_server*address*</code> [ <code>resolve</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  定义群集节点的<code>*address*</code> 。  可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  解析为多个IP地址的域名一次定义多个节点。 </p>
<p>   <code>resolve</code>参数指示nginx监视与节点域名对应的IP地址的更改，并自动修改配置，而无需重新启动nginx。 </p>
<p>  群集节点可以动态指定为带有<code>resolve</code>参数的单个<code>zone_sync_server</code>指令，也可以静态指定为一系列不带参数的指令。 </p>
<blockquote>
<p>  每个群集节点只应指定一次。 </p>
<p>  所有群集节点都应使用相同的配置。 </p>
</blockquote>
<p>  为了使<code>resolve</code>参数起作用，必须在<a href="ngx_stream_core_module.html#stream">流</a>块中指定<a href="ngx_stream_core_module.html#resolver">解析器</a>指令。  例： </p>
<pre class="notranslate">stream {
    resolver 10.0.0.1;

    server {
        zone_sync;
        zone_sync_server cluster.example.com resolve;
        ...
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用S​​SL / TLS协议以连接到另一个群集服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对另一个群集服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对另一个群集服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定用于连接到另一个群集服务器的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#zone_sync_ssl_verify">验证</a>另一个群集服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_name host from zone_sync_server;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  允许覆盖用于<a href="#zone_sync_ssl_verify">验证</a>群集服务器证书的服务器名称，并在与群集服务器建立连接时<a href="#zone_sync_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#zone_sync_server">zone_sync_server</a>地址的主机部分，如果指定了<a href="#resolve">resolve</a>参数，则使用已解析的IP地址。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议以连接到另一个群集服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  在与另一个群集服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#zone_sync_ssl_verify">验证</a>另一个群集服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用或禁用其他群集服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在另一个群集服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone_sync_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">zone_sync_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置与另一个群集节点连接时两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<h4 id="API端点"><a href="#API端点" class="headerlink" title="API端点"></a>API端点</h4><p>  节点的同步状态可通过API的<a href="http/ngx_http_api_module.html#stream_zone_sync_">/ stream / zone_sync /</a> endpoint获得，它返回<a href="http/ngx_http_api_module.html#def_nginx_stream_zone_sync">以下</a>度量标准。 </p>
<h4 id="启动，停止，删除群集节点"><a href="#启动，停止，删除群集节点" class="headerlink" title="启动，停止，删除群集节点"></a>启动，停止，删除群集节点</h4><p>  要启动新节点，请使用新节点的IP地址更新群集主机名的DNS记录并启动实例。  新节点将从DNS或静态配置中发现其他节点，并将开始向它们发送更新。  其他节点最终将使用DNS发现新节点并开始向其推送更新。  在静态配置的情况下，需要重新加载其他节点以便将更新发送到新节点。 </p>
<p>  要停止节点，请将<code>QUIT</code>信号发送到实例。  该节点将完成区域同步并正常关闭打开的连接。 </p>
<p>  要删除节点，请更新群集主机名的DNS记录，并删除该节点的IP地址。  所有其他节点最终将发现节点已被删除，关闭与节点的连接，并且将不再尝试连接到节点。  移除节点后，可以如上所述停止节点。  在静态配置的情况下，需要重新加载其他节点以便停止向已删除节点发送更新。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-module"><a href="#Module-ngx-stream-upstream-module" class="headerlink" title="Module ngx_stream_upstream_module"></a>Module ngx_stream_upstream_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream">upstream</a> <br>     <a href="#server">server</a> <br>     <a href="#zone">zone</a> <br>     <a href="#state">state</a> <br>     <a href="#hash">hash</a> <br>     <a href="#least_conn">least_conn</a> <br>     <a href="#least_time">least_time</a> <br>     <a href="#random">random</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_upstream_module</code>模块（1.9.0）用于定义可由<a href="ngx_stream_proxy_module.html#proxy_pass">proxy_pass</a>指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream **backend** {
    hash $remote_addr consistent;

    server backend1.example.com:12345  weight=5;
    server backend2.example.com:12345;
    server unix:/tmp/backend3;

    server backup1.example.com:12345   backup;
    server backup2.example.com:12345   backup;
}

server {
    listen 12346;
    proxy_pass **backend** ;
}
</pre>



<p>  具有定期<a href="ngx_stream_upstream_hc_module.html">运行状况检查的</a>动态可配置组可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分： </p>
<pre class="notranslate">resolver 10.0.0.1;

upstream **dynamic** {
    zone upstream_dynamic 64k;

    server backend1.example.com:12345 weight=5;
    server backend2.example.com:12345 fail_timeout=5s slow_start=30s;
    server 192.0.2.1:12345            max_fails=3;
    server backend3.example.com:12345 resolve;
    server backend4.example.com       service=http resolve;

    server backup1.example.com:12345  backup;
    server backup2.example.com:12345  backup;
}

server {
    listen 12346;
    proxy_pass **dynamic** ;
    health_check;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  定义一组服务器。  服务器可以侦听不同的端口。  此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com:12345 weight=5;
    server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend2;
    server backend3.example.com:12345 resolve;

    server backup1.example.com:12345  backup;
}
</pre>



<p>  默认情况下，使用加权循环平衡方法在服务器之间分配连接。  在上面的示例中，每个7个连接将按如下方式分发：5个连接到<code>backend1.example.com:12345</code>并且每个连接到第二个和第三个服务器。  如果在与服务器通信期间发生错误，则连接将传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。  如果与所有服务器的通信失败，则将关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server*address*</code> [ <code>*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义服务器的<code>*address*</code>和其他<code>*parameters*</code> 。  可以将地址指定为具有强制端口的域名或IP地址，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  解析为多个IP地址的域名一次定义多个服务器。 </p>
<p>  可以定义以下参数： </p>
<blockquote>
<p>  在1.11.5版之前，此参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
<ul>
<li>指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; -   以及服务器被视为不可用的时间段。 </li>
</ul>
</blockquote>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<p>  要使此参数起作用，必须在<a href="ngx_stream_core_module.html#stream">流</a>块中指定<a href="ngx_stream_core_module.html#resolver">解析程序</a>指令。  例： </p>
<pre class="notranslate">stream {
    resolver 10.0.0.1;

    upstream u {
        zone ...;
        ...
        server example.com:12345 resolve;
    }
}
</pre>



<p>  如果服务名称不包含点（“ <code>.</code> ”），则构造符合<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC</a>的名称，并将TCP协议添加到服务前缀。  例如，要查找<code>_http._tcp.backend.example.com</code> SRV记录，必须指定该指令： </p>
<pre class="notranslate">server backend.example.com service=http resolve;
</pre>

<p>  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。  例如，要查找<code>_http._tcp.backend.example.com</code>和<code>server1.backend.example.com</code> SRV记录，必须指定指令： </p>
<pre class="notranslate">server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</pre>



<p>  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。  如果为服务器指定了<a href="#backup">backup</a>参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
<blockquote>
<p>  该参数不能与<a href="#hash">散列</a>负载平衡方法一起使用。 </p>
<p>  如果组中只有一个服务器，则忽略<code>max_fails</code> ， <code>fail_timeout</code>和<code>slow_start</code>参数，并且永远不会将此类服务器视为不可用。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone*name*</code> [ <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义共享内存区域的<code>*name*</code>和<code>*size*</code> ，该区域保持组工作进程之间共享的组配置和运行时状态。  几个组可能共享同一个区域。  在这种情况下，仅指定一次<code>*size*</code>就足够了。 </p>
<p>  此外，作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。  可通过<a href="http/ngx_http_api_module.html">API</a>模块（1.13.3）访问该配置。 </p>
<blockquote>
<p>  在1.13.3版之前，只能通过<a href="http/ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a>处理的特殊位置访问配置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**state*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  指定保持动态可配置组状态的<code>*file*</code> 。 </p>
<p>  例子： </p>
<pre class="notranslate">state /var/lib/nginx/state/servers.conf; # path for Linux
state /var/db/nginx/state/servers.conf;  # path for FreeBSD
</pre>



<p>  该状态目前仅限于具有其参数的服务器列表。  解析配置时会读取文件，每次<a href="http/ngx_http_api_module.html#stream_upstreams_stream_upstream_name_servers_">更改</a>上游配置时都会更新该文件。  应避免直接更改文件内容。  该指令不能与<a href="#server">server</a>指令一起使用。 </p>
<blockquote>
<p>   <a href="control.html#reconfiguration">配置重新加载</a>或<a href="control.html#upgrade">二进制升级</a>期间所做的更改可能会丢失。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hash*key*</code> [ <code>consistent</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<code>*key*</code> 。   <code>*key*</code>可以包含文本，变量及其组合（1.11.2）。  用法示例： </p>
<pre class="notranslate">hash $remote_addr;
</pre>

<p>  请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached" target="_blank" rel="noopener">Cache :: Memcached</a> Perl库兼容。 </p>
<p>  如果指定了<code>consistent</code>参数，则将使用<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="noopener">ketama</a>一致性哈希方法。  该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。  这有助于为缓存服务器实现更高的缓存命中率。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached::Fast" target="_blank" rel="noopener">Cache :: Memcached :: Fast</a> Perl库兼容，并将<code>*ketama_points*</code>参数设置为160。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_conn** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中将连接传递到具有最少活动连接的服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_time** connect</code> |    <code>first_byte</code> |    <code>last_byte</code>    [ <code>inflight</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中连接以最少的平均时间和最少的活动连接传递到服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p>  如果指定了<code>connect</code>参数，则使用<a href="#var_upstream_connect_time">连接</a>到上游服务器的时间。  如果指定了<code>first_byte</code>参数，则使用接收数据的<a href="#var_upstream_first_byte_time">第一个字节</a>的时间。  如果指定了<code>last_byte</code>则使用接收<a href="#var_upstream_session_time">最后一个</a>数据<a href="#var_upstream_session_time">字节</a>的时间。  如果指定了<code>inflight</code>参数（1.11.6），则还会考虑不完整的连接。 </p>
<blockquote>
<p>  在1.11.6版之前，默认情况下会考虑不完整的连接。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random** [ two</code> [ <code>*method*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.1版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将连接传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p>  可选的<code>two</code>参数指示nginx随机选择<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="noopener">两个</a>服务器，然后使用指定的<code>method</code>选择服务器。  默认方法是<code>least_conn</code> ，它将连接传递给具有最少活动连接数的服务器。 </p>
<p>   <code>least_time</code>方法将连接传递给平均时间最短且活动连接数最少的服务器。  如果指定了<code>least_time=connect</code>参数，则使用<a href="#var_upstream_connect_time">连接</a>到上游服务器的时间。  如果指定了<code>least_time=first_byte</code>参数，则使用接收数据的<a href="#var_upstream_first_byte_time">第一个字节</a>的时间。  如果指定了<code>least_time=last_byte</code>则使用接收<a href="#var_upstream_session_time">最后一个</a>数据<a href="#var_upstream_session_time">字节</a>的时间。 </p>
<blockquote>
<p>   <code>least_time</code>方法可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅</a>的一部分。 </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_upstream_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-upstream-hc-module"><a href="#Module-ngx-stream-upstream-hc-module" class="headerlink" title="Module ngx_stream_upstream_hc_module"></a>Module ngx_stream_upstream_hc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#health_check">health_check</a> <br>     <a href="#health_check_timeout">health_check_timeout</a> <br>     <a href="#match">match</a> <br></td>

<p>   <code>ngx_stream_upstream_hc_module</code>模块（1.9.0）允许对<a href="ngx_stream_upstream_module.html#upstream">组</a>中的服务器启用定期运行状况检查。  服务器组必须驻留在<a href="ngx_stream_upstream_module.html#zone">共享内存中</a> 。 </p>
<p>  如果运行状况检查失败，则服务器将被视为运行状况不佳。  如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。  客户端连接不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream tcp {
    zone upstream_tcp 64k;

    server backend1.example.com:12345 weight=5;
    server backend2.example.com:12345 fail_timeout=5s slow_start=30s;
    server 192.0.2.1:12345            max_fails=3;

    server backup1.example.com:12345  backup;
    server backup2.example.com:12345  backup;
}

server {
    listen     12346;
    proxy_pass tcp;
    health_check;
}
</pre>

<p>  使用此配置，nginx将检查每五秒钟与<code>tcp</code>组中每个服务器建立TCP连接的能力。  当无法建立与服务器的连接时，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
<p>  可以为UDP协议配置运行状况检查： </p>
<pre class="notranslate">upstream dns_upstream {

    zone   dns_zone 64k;

    server dns1.example.com:53;
    server dns2.example.com:53;
    server dns3.example.com:53;
}

server {
    listen       53 udp;
    proxy_pass   dns_upstream;
    health_check udp;
}
</pre>

<p>  在这种情况下，预期缺少ICMP“ <code>Destination Unreachable</code> ”消息以回复发送的字符串“ <code>nginx health check</code> ”。 </p>
<p>  还可以配置运行状况检查以测试从服务器获取的数据。  测试使用<a href="#match">match</a>伪指令单独配置，并在<a href="#health_check">health_check</a>指令的<code>match</code>参数中引用。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check** [ *parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  启用对<a href="ngx_stream_upstream_module.html#upstream">组中</a>服务器的定期运行状况检查。 </p>
<p>  支持以下可选参数： </p>
<blockquote>
<p>  在1.11.7版之前，默认情况下，UDP运行状况检查需要带有<a href="#match_send">send</a>和<a href="#match_expect">expect</a>参数的<a href="#hc_match">匹配</a>块。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">health_check_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  覆盖<a href="ngx_stream_proxy_module.html#proxy_timeout">运行</a>状况检查的<a href="ngx_stream_proxy_module.html#proxy_timeout">proxy_timeout</a>值。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**match*name*</code>  { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  定义用于验证服务器对运行状况检查的响应的命名测试集。 </p>
<p>  可以配置以下参数： </p>
<p>   <code>send</code>和<code>expect</code>参数都可以包含十六进制文字，前缀为“ <code>\x</code> ”，后跟两个十六进制数字，例如“ <code>\x80</code> ”（1.9.12）。 </p>
<p>  在下列情况下通过健康检查 </p>
<ul>
<li>TCP连接成功建立; -    <code>send</code>参数中的<code>*string*</code> （如果已指定）已发送; -   如果指定，从服务器获取的数据与<code>expect</code>参数中的字符串或正则表达式匹配; -   经过的时间不超过<a href="#health_check_timeout">health_check_timeout</a>指令中指定的值。 </li>
</ul>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    zone     upstream_backend 10m;
    server   127.0.0.1:12345;
}

match http {
    send     "GET / HTTP/1.0\r\nHost: localhost\r\n\r\n";
    expect ~ "200 OK";
}

server {
    listen       12346;
    proxy_pass   backend;
    health_check match=http;
}
</pre>





<blockquote>
<p>  仅检查从服务器获得的第一个<a href="ngx_stream_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a>字节数据。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_preread_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_preread_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_preread_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-preread-module"><a href="#Module-ngx-stream-ssl-preread-module" class="headerlink" title="Module ngx_stream_ssl_preread_module"></a>Module ngx_stream_ssl_preread_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl_preread">ssl_preread</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_ssl_preread_module</code>模块（1.11.5）允许从<a href="https://tools.ietf.org/html/rfc5246#section-7.4.1.2" target="_blank" rel="noopener">ClientHello</a>消息中提取信息而不终止SSL / TLS，例如，通过<a href="https://tools.ietf.org/html/rfc6066#section-3" target="_blank" rel="noopener">SNI</a>请求的服务器名称或在<a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">ALPN中</a>通告的协议。  默认情况下不构建此模块，应使用<code>--with-stream_ssl_preread_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  根据服务器名称选择上游： </p>
<pre class="notranslate">map $ssl_preread_server_name $name {
    backend.example.com      backend;
    default                  backend2;
}

upstream backend {
    server 192.168.0.1:12345;
    server 192.168.0.2:12345;
}

upstream backend2 {
    server 192.168.0.3:12345;
    server 192.168.0.4:12345;
}

server {
    listen      12346;
    proxy_pass  $name;
    ssl_preread on;
}
</pre>



<p>  根据协议选择上游： </p>
<pre class="notranslate">map $ssl_preread_alpn_protocols $proxy {
    ~\bh2\b           127.0.0.1:8001;
    ~\bhttp/1.1\b     127.0.0.1:8002;
    ~\bxmpp-client\b  127.0.0.1:8003;
}

server {
    listen      9000;
    proxy_pass  $proxy;
    ssl_preread on;
}
</pre>



<p>  根据SSL协议版本选择上游： </p>
<pre class="notranslate">map $ssl_preread_protocol $upstream {
    ""        ssh.example.com:22;
    "TLSv1.2" new.example.com:443;
    default   tls.example.com:443;
}

# ssh and https on the same port
server {
    listen      192.168.0.1:443;
    proxy_pass  $upstream;
    ssl_preread on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prereadon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_preread off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许在<a href="stream_processing.html#preread_phase">预读</a>阶段从ClientHello消息中提取信息。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_ssl_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_ssl_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-ssl-module"><a href="#Module-ngx-stream-ssl-module" class="headerlink" title="Module ngx_stream_ssl_module"></a>Module ngx_stream_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_handshake_timeout">ssl_handshake_timeout</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_ssl_module</code>模块（1.9.0）为流代理服务器提供必要的支持，以使用SSL / TLS协议。  默认情况下不构建此模块，应使用<code>--with-stream_ssl_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

stream {

    ...

    server {
        listen              12345 ssl;

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              12345 ssl;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> ，该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_handshake_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_handshake_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定SSL握手完成的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">stream {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        listen 127.0.0.1:12345;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        listen 127.0.0.1:12346;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache** off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client** on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  启用客户端证书验证。  验证结果存储在<a href="#var_ssl_client_verify">$ ssl_client_verify</a>变量中。  如果在客户端证书验证期间发生错误或客户端未提供所需证书，则会关闭连接。 </p>
<p>   <code>optional</code>参数请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数请求客户端证书，但不要求它由可信CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="#var_ssl_client_cert">$ ssl_client_cert</a>变量访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  设置客户端证书链中的验证深度。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_ssl_module</code>模块支持自1.11.2以来的变量。 </p>
<pre class="notranslate">AES128-SHA:AES256-SHA:0x00ff
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。  对于旧版本，该变量仅适用于新会话，仅列出已知密码。 </p>
</blockquote>
<pre class="notranslate">0x001d:prime256v1:secp521r1:secp384r1
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。  对于旧版本，变量值将为空字符串。 </p>
<p>  该变量仅适用于新会话。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-split-clients-module"><a href="#Module-ngx-stream-split-clients-module" class="headerlink" title="Module ngx_stream_split_clients_module"></a>Module ngx_stream_split_clients_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#split_clients">split_clients</a> <br></td>

<p>   <code>ngx_stream_split_clients_module</code>模块（1.11.3）创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    ...
    split_clients "${remote_addr}AAA" $upstream {
                  0.5%                feature_test1;
                  2.0%                feature_test2;
                  *                   production;
    }

    server {
        ...
        proxy_pass $upstream;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**split_clients**  *string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  为A / B测试创建变量，例如： </p>
<pre class="notranslate">split_clients "${remote_addr}AAA" $variant {
               0.5%               .one;
               2.0%               .two;
               *                  "";
}
</pre>

<p>  使用MurmurHash2对原始字符串的值进行哈希处理。  在给出的示例中，从0到21474835（0.5％）的哈希值对应于<code>$variant</code>变量的值<code>&quot;.one&quot;</code> ，从21474836到107374180（2％）的哈希值对应于值<code>&quot;.two&quot;</code>和哈希值从107374181到4294967295的值对应于值<code>&quot;&quot;</code> （空字符串）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_return_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_return_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_return_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-return-module"><a href="#Module-ngx-stream-return-module" class="headerlink" title="Module ngx_stream_return_module"></a>Module ngx_stream_return_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#return">return</a> <br></td>

<p>   <code>ngx_stream_return_module</code>模块（1.11.2）允许向客户端发送指定值，然后关闭连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 12345;
    return $time_iso8601;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**return*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  指定要发送到客户端的<code>*value*</code> 。  该值可以包含文本，变量及其组合。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_realip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_realip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-realip-module"><a href="#Module-ngx-stream-realip-module" class="headerlink" title="Module ngx_stream_realip_module"></a>Module ngx_stream_realip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#set_real_ip_from">set_real_ip_from</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_realip_module</code>模块用于将客户端地址和端口更改为PROXY协议头（1.11.4）中发送的端口和端口。  必须先通过在<code>listen</code>指令中设置<a href="ngx_stream_core_module.html#proxy_protocol">proxy_protocol</a>参数来启用PROXY协议。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-stream_realip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">listen 12345 proxy_protocol;

set_real_ip_from  192.168.1.0/24;
set_real_ip_from  192.168.2.1;
set_real_ip_from  2001:0db8::/32;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set_real_ip_from**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义已知可发送正确替换地址的可信地址。  如果指定了特殊值<code>unix:</code>则所有UNIX域套接字都将受信任。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_proxy_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_proxy_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-proxy-module"><a href="#Module-ngx-stream-proxy-module" class="headerlink" title="Module ngx_stream_proxy_module"></a>Module ngx_stream_proxy_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#proxy_bind">proxy_bind</a> <br>     <a href="#proxy_buffer_size">proxy_buffer_size</a> <br>     <a href="#proxy_connect_timeout">proxy_connect_timeout</a> <br>     <a href="#proxy_download_rate">proxy_download_rate</a> <br>     <a href="#proxy_next_upstream">proxy_next_upstream</a> <br>     <a href="#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> <br>     <a href="#proxy_next_upstream_tries">proxy_next_upstream_tries</a> <br>     <a href="#proxy_pass">proxy_pass</a> <br>     <a href="#proxy_protocol">proxy_protocol</a> <br>     <a href="#proxy_requests">proxy_requests</a> <br>     <a href="#proxy_responses">proxy_responses</a> <br>     <a href="#proxy_socket_keepalive">proxy_socket_keepalive</a> <br>     <a href="#proxy_ssl">proxy_ssl</a> <br>     <a href="#proxy_ssl_certificate">proxy_ssl_certificate</a> <br>     <a href="#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> <br>     <a href="#proxy_ssl_ciphers">proxy_ssl_ciphers</a> <br>     <a href="#proxy_ssl_crl">proxy_ssl_crl</a> <br>     <a href="#proxy_ssl_name">proxy_ssl_name</a> <br>     <a href="#proxy_ssl_password_file">proxy_ssl_password_file</a> <br>     <a href="#proxy_ssl_protocols">proxy_ssl_protocols</a> <br>     <a href="#proxy_ssl_server_name">proxy_ssl_server_name</a> <br>     <a href="#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> <br>     <a href="#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> <br>     <a href="#proxy_ssl_verify">proxy_ssl_verify</a> <br>     <a href="#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> <br>     <a href="#proxy_timeout">proxy_timeout</a> <br>     <a href="#proxy_upload_rate">proxy_upload_rate</a> <br></td>

<p>   <code>ngx_stream_proxy_module</code>模块（1.9.0）允许通过TCP，UDP（1.9.13）和UNIX域套接字代理数据流。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 127.0.0.1:12345;
    proxy_pass 127.0.0.1:8080;
}

server {
    listen 12345;
    proxy_connect_timeout 1s;
    proxy_timeout 1m;
    proxy_pass example.com:12345;
}

server {
    listen 53 udp reuseport;
    proxy_timeout 20s;
    proxy_pass dns.example.com:53;
}

server {
    listen [::1]:12345;
    proxy_pass unix:/tmp/stream.socket;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  使与代理服务器的传出连接源自指定的本地IP <code>*address*</code> 。  参数值可以包含变量（1.11.2）。  特殊值<code>off</code>取消了从先前配置级别继承的<code>proxy_bind</code>指令的效果，允许系统自动分配本地IP地址。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">proxy_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.4版本中。 </p>
<p>  设置用于从代理服务器读取数据的缓冲区的<code>*size*</code> 。  还设置用于从客户端读取数据的缓冲区的<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义与代理服务器建立连接的超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_download_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_download_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.3版本中。 </p>
<p>  限制从代理服务器读取数据的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  每个连接设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstreamon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  当无法建立与代理服务器的连接时，确定是否将客户端连接传递给下一个服务器。 </p>
<p>  将连接传递到下一个服务器可能会受到<a href="#proxy_next_upstream_tries">尝试次数</a>和<a href="#proxy_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  限制将连接传递给<a href="#proxy_next_upstream">下一个服务器所</a>允许的时间。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  限制将连接传递到<a href="#proxy_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置代理服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">proxy_pass localhost:12345;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">proxy_pass unix:/tmp/stream.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_stream_upstream_module.html">服务器组</a> 。 </p>
<p>  也可以使用变量（1.11.3）指定地址： </p>
<pre class="notranslate">proxy_pass $upstream;
</pre>

<p>  在这种情况下，在所描述的<a href="ngx_stream_upstream_module.html">服务器组中</a>搜索服务器名称，并且如果未找到，则使用<a href="ngx_stream_core_module.html#resolver">解析器</a>来确定服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_protocolon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_protocol off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  启用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a>以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_requests 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.7版中。 </p>
<p>  设置客户端与现有UDP流会话之间的绑定被删除的客户端数据报的数量。  在收到指定数量的数据报后，来自同一客户端的下一个数据报将启动一个新会话。  当所有客户端数据报都传输到代理服务器并且收到预期的<a href="#proxy_responses">响应</a>数时，或者当它达到<a href="#proxy_timeout">超时</a>时，会话终止。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_responses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.13版本中。 </p>
<p>  如果使用<a href="ngx_stream_core_module.html#udp">UDP</a>协议，则设置代理服务器响应客户端数据报所需的数据报数。  该号码用作会话终止的提示。  默认情况下，数据报的数量不受限制。 </p>
<p>  如果指定零值，则不期望响应。  但是，如果收到响应且会话仍未完成，则将处理响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到代理服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用S​​SL / TLS协议以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对代理服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对代理服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定与代理服务器的连接的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_name host from proxy_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许覆盖用于<a href="#proxy_ssl_verify">验证</a>代理服务器证书的服务器名称，并在与代理服务器建立连接时<a href="#proxy_ssl_server_name">通过SNI传递</a> 。  也可以使用变量（1.11.3）指定服务器名称。 </p>
<p>  默认情况下，使用<a href="#proxy_pass">proxy_pass</a>地址的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议以连接到代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在与代理服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  确定在使用代理服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  启用或禁用代理服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  在代理服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_timeout 10m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_upload_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_upload_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.3版本中。 </p>
<p>  限制从客户端读取数据的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据连接设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_map_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_map_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-map-module"><a href="#Module-ngx-stream-map-module" class="headerlink" title="Module ngx_stream_map_module"></a>Module ngx_stream_map_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#map">map</a> <br>     <a href="#map_hash_bucket_size">map_hash_bucket_size</a> <br>     <a href="#map_hash_max_size">map_hash_max_size</a> <br></td>

<p>   <code>ngx_stream_map_module</code>模块（1.11.2）创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">map $remote_addr $limit {
    127.0.0.1    "";
    default      $binary_remote_addr;
}

limit_conn_zone $limit zone=addr:10m;
limit_conn addr 1;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map**  *string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使是大量“ <code>map</code> ”变量的声明也不会给连接处理增加任何额外成本。 </p>
</blockquote>
<p>  地图块内的参数指定源和结果值之间的映射。 </p>
<p>  源值指定为字符串或正则表达式。 </p>
<p>  字符串匹配忽略大小写。 </p>
<p>  正则表达式应该从“ <code>~</code> ”符号开始，用于区分大小写的匹配，或者从“ <code>~*</code> ”符号开始，用于不区分大小写的匹配。  正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p>  如果源值与下面描述的特殊参数名称之一匹配，则应使用“ <code>\</code> ”符号作为前缀。 </p>
<p>  结果值可以包含文本，变量及其组合。 </p>
<p>  还支持以下特殊参数： </p>
<pre class="notranslate">*.example.com 1;
example.*     1;
</pre>

<pre class="notranslate">example.com   1;
*.example.com 1;
</pre>

<pre class="notranslate">.example.com  1;
</pre>



<p>  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
<ol>
<li>没有掩码的字符串值 1.   带有前缀掩码的最长字符串值，例如“ <code>*.example.com</code> ” 1.   带有后缀掩码的最长字符串值，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） 1.   默认值 </li>
</ol>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_bucket_size 32|64|128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的存储区大小。  默认值取决于处理器的缓存行大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_log_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_log_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-log-module"><a href="#Module-ngx-stream-log-module" class="headerlink" title="Module ngx_stream_log_module"></a>Module ngx_stream_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#access_log">access_log</a> <br>     <a href="#log_format">log_format</a> <br>     <a href="#open_log_file_cache">open_log_file_cache</a> <br></td>

<p>   <code>ngx_stream_log_module</code>模块（1.11.4）以指定的格式写入会话日志。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">log_format basic '$remote_addr [$time_local] '
                 '$protocol $status $bytes_sent $bytes_received '
                 '$session_time';

access_log /spool/logs/nginx-access.log basic buffer=32k;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**access_log**  *path*</code>    <code>*format*</code>    [ <code>buffer</code> = <code>*size*</code> ]    [ <code>gzip[= &lt;code class=&quot;notranslate&quot;&gt;*level*</code> ] ]    [ <code>flush</code> = <code>*time*</code> ]    [ <code>if</code> = <code>*condition*</code> ]; <br> <code>**access_logoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">access_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置缓冲日志写入的路径， <a href="#log_format">格式</a>和配置。  可以在同一级别指定多个日志。  可以通过在第一个参数中指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  特殊值<code>off</code>取消当前级别的所有<code>access_log</code>指令。 </p>
<p>  如果使用<code>buffer</code>或<code>gzip</code>参数，则将缓冲对log的写入。 </p>
<blockquote>
<p>  缓冲区大小不得超过磁盘文件的原子写入大小。  对于FreeBSD，这个大小是无限的。 </p>
</blockquote>
<p>  启用缓冲后，数据将写入文件： </p>
<ul>
<li>如果下一个日志行不适合缓冲区; -   如果缓冲的数据早于<code>flush</code>参数指定的数据; -   当工作进程<a href="control.html">重新打开</a>日志文件或正在关闭时。 </li>
</ul>
<p>  如果使用<code>gzip</code>参数，则在写入文件之前将压缩缓冲的数据。  压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。  默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ <code>zcat</code> ”解压缩或读取。 </p>
<p>  例： </p>
<pre class="notranslate">access_log /path/to/log.gz basic gzip flush=5m;
</pre>





<blockquote>
<p>  要使gzip压缩起作用，必须使用zlib库构建nginx。 </p>
</blockquote>
<p>  文件路径可以包含变量，但是这样的日志有一些约束： </p>
<ul>
<li>工作进程使用其凭据的<a href="ngx_core_module.html#user">用户</a>应具有在具有此类日志的目录中创建文件的权限; -   缓冲写入不起作用; -   每个日志写入都会打开和关闭该文件。  但是，由于常用文件的描述符可以存储在<a href="#open_log_file_cache">缓存中</a> ，因此写入旧文件可以在<a href="#open_log_file_cache">open_log_file_cache</a>指令的<code>valid</code>参数指定的时间内继续写入 </li>
</ul>
<p>   <code>if</code>参数启用条件记录。  如果<code>*condition*</code>计算为“0”或空字符串，则不会记录会话。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**log_format**  *name*</code>    [ <code>escape</code> = <code>default</code> | <code>json</code> | <code>none</code> ]    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定日志格式，例如： </p>
<pre class="notranslate">log_format proxy '$remote_addr [$time_local] '
                 '$protocol $status $bytes_sent $bytes_received '
                 '$session_time "$upstream_addr" '
                 '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';
</pre>



<p>   <code>escape</code>参数（1.11.8）允许设置在变量中转义的<code>json</code>或<code>default</code>字符，默认情况下，使用<code>default</code>转义。   <code>none</code>参数（1.13.10）禁用转义。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**open_log_file_cachemax</code> = <code>*N*</code>[ <code>inactive</code> = <code>*time*</code> ][ <code>min_uses</code> = <code>*N*</code> ][ <code>valid</code> = <code>*time*</code> ]; <br> <code>**open_log_file_cacheoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">open_log_file_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。  该指令具有以下参数： </p>
<p>  用法示例： </p>
<pre class="notranslate">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-limit-conn-module"><a href="#Module-ngx-stream-limit-conn-module" class="headerlink" title="Module ngx_stream_limit_conn_module"></a>Module ngx_stream_limit_conn_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_conn">limit_conn</a> <br>     <a href="#limit_conn_log_level">limit_conn_log_level</a> <br>     <a href="#limit_conn_zone">limit_conn_zone</a> <br></td>

<p>   <code>ngx_stream_limit_conn_module</code>模块（1.9.3）用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    limit_conn_zone $binary_remote_addr zone=addr:10m;

    ...

    server {

        ...

        limit_conn           addr 1;
        limit_conn_log_level error;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn*zone*</code> <code>*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置共享内存区域和给定键值的最大允许连接数。  超过此限制时，服务器将关闭连接。  例如，指令 </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    ...
    limit_conn addr 1;
}
</pre>

<p>  每次只允许一个IP地址连接一个。 </p>
<p>  如果指定了几个<code>limit_conn</code>指令，则将应用任何已配置的限制。 </p>
<p>  当且仅当当前级别没有<code>limit_conn</code>指令时，指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_zone**  *key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态包括当前的连接数。   <code>*key*</code>可以包含文本，变量及其组合（1.11.2）。  不计算具有空键值的连接。  用法示例： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;
</pre>

<p>  这里，密钥是<code>$binary_remote_addr</code>变量设置的客户端IP地址。   <code>$binary_remote_addr</code>的大小为IPv4地址的4个字节或IPv6地址的16个字节。  存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。  一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。  如果区域存储耗尽，服务器将关闭连接。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_keyval_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_keyval_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-keyval-module"><a href="#Module-ngx-stream-keyval-module" class="headerlink" title="Module ngx_stream_keyval_module"></a>Module ngx_stream_keyval_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#keyval">keyval</a> <br>     <a href="#keyval_zone">keyval_zone</a> <br></td>

<p>   <code>ngx_stream_keyval_module</code>模块（1.13.7）创建的变量的值取自<a href="http/ngx_http_api_module.html#stream_keyvals_">API</a>管理的键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    server {
        ...
        location /api {
            api write=on;
        }
    }
}

stream {

    keyval_zone zone=one:32k state=one.keyval;
    keyval      $ssl_server_name $name zone=one;

    server {
        listen              12345 ssl;
        proxy_pass          $name;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval**  *key*</code>    <code>*$variable*</code>    <code>zone</code> = <code>*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  创建一个新的<code>*$variable*</code>其值由<code>*key*</code>数据库中的键查找。  字符串匹配忽略大小写。  数据库存储在<code>zone</code>参数指定的共享内存区域中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval_zone** zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>state</code> = <code>*file*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置保留键值数据库的共享内存区域的<code>*name*</code>和<code>*size*</code> 。  键值对由<a href="http/ngx_http_api_module.html#stream_keyvals_">API</a>管理。 </p>
<p>  可选的<code>state</code>参数指定一个<code>*file*</code> ，该<code>*file*</code>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p>  可选的<code>timeout</code>参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p>  可选的<code>sync</code>参数（1.15.0）可以<a href="ngx_stream_zone_sync_module.html#zone_sync">同步</a>共享内存区域。  同步需要设置<a href="#keyval_timeout">超时</a>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_js_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_js_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-js-module"><a href="#Module-ngx-stream-js-module" class="headerlink" title="Module ngx_stream_js_module"></a>Module ngx_stream_js_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#js_access">js_access</a> <br>     <a href="#js_filter">js_filter</a> <br>     <a href="#js_include">js_include</a> <br>     <a href="#js_preread">js_preread</a> <br>     <a href="#js_set">js_set</a> <br> <a href="#properties">Session Object Properties</a> <br></td>

<p>   <code>ngx_stream_js_module</code>模块用于在<a href="njs/index.html">njs中</a>实现处理程序 - 这是JavaScript语言的一个子集。 </p>
<p>  默认情况下不构建此模块。  可<a href="njs/install.html">在此处</a>下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><blockquote>
<p>  此示例适用于njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>及更高版本。  对于njs 0.2.3及更早版本，请使用<a href="njs/examples.html#legacy">此</a>示例。 </p>
</blockquote>
<pre class="notranslate">load_module modules/ngx_stream_js_module.so;
...

stream {
    js_include stream.js;

    js_set $bar bar;
    js_set $req_line req_line;

    server {
        listen 12345;

        js_preread preread;
        return     $req_line;
    }

    server {
        listen 12346;

        js_access  access;
        proxy_pass 127.0.0.1:8000;
        js_filter  header_inject;
    }
}

http {
    server {
        listen 8000;
        location / {
            return 200 $http_foo\n;
        }
    }
}
</pre>



<p>   <code>stream.js</code>文件： </p>
<pre class="notranslate">var line = '';

function bar(s) {
    var v = s.variables;
    s.log("hello from bar() handler!");
    return "bar-var" + v.remote_port + "; pid=" + v.pid;
}

function preread(s) {
    s.on('upload', function (data, flags) {
        var n = data.indexOf('\n');
        if (n != -1) {
            line = data.substr(0, n);
            s.done();
        }
    });
}

function req_line(s) {
    return line;
}

// Read HTTP request line.
// Collect bytes in 'req' until
// request line is read.
// Injects HTTP header into a client's request

var my_header =  'Foo: foo';
function header_inject(s) {
    var req = '';
    s.on('upload', function(data, flags) {
        req += data;
        var n = req.search('\n');
        if (n != -1) {
            var rest = req.substr(n + 1);
            req = req.substr(0, n + 1);
            s.send(req + my_header + '\r\n' + rest, flags);
            s.off('upload');
        }
    });
}

function access(s) {
    if (s.remoteAddress.match('^192.*')) {
        s.abort();
        return;
    }

    s.allow();
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_access*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置将在<a href="stream_processing.html#access_phase">访问</a>阶段调用的njs函数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_filter*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置数据过滤器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_include*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定在njs中实现服务器和变量处理程序的文件。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_preread*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  设置将在<a href="stream_processing.html#preread_phase">预读</a>阶段调用的njs函数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_set*$variable*</code> <code>*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  为指定的变量设置njs函数。 </p>
<h4 id="会话对象属性"><a href="#会话对象属性" class="headerlink" title="会话对象属性"></a>会话对象属性</h4><p>  每个流njs处理程序接收一个参数，即流会话<a href="njs/reference.html#stream">对象</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geo_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geo_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geo-module"><a href="#Module-ngx-stream-geo-module" class="headerlink" title="Module ngx_stream_geo_module"></a>Module ngx_stream_geo_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geo">geo</a> <br></td>

<p>   <code>ngx_stream_geo_module</code>模块（1.11.3）使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">geo $geo {
    default        0;

    127.0.0.1      2;
    192.168.1.0/24 1;
    10.1.0.0/16    1;

    ::1            2;
    2001:0db8::/32 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geo** [ *$address*</code> ] <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  描述指定变量的值对客户端IP地址的依赖性。  默认情况下，地址取自<code>$remote_addr</code>变量，但也可以从另一个变量中获取，例如： </p>
<pre class="notranslate">geo $arg_remote_addr $geo {
    ...;
}
</pre>





<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使存在大量已声明的“ <code>geo</code> ”变量也不会导致连接处理的任何额外成本。 </p>
</blockquote>
<p>  如果变量的值不表示有效的IP地址，则使用“ <code>255.255.255.255</code> ”地址。 </p>
<p>  地址被指定为CIDR表示法中的前缀（包括单个地址）或作为范围。 </p>
<p>  还支持以下特殊参数： </p>
<p>  例： </p>
<pre class="notranslate">geo $country {
    default        ZZ;
    include        conf/geo.conf;
    delete         127.0.0.0/16;

    127.0.0.0/24   US;
    127.0.0.1/32   RU;
    10.1.0.0/16    RU;
    192.168.1.0/24 UK;
}
</pre>



<p>   <code>conf/geo.conf</code>文件可以包含以下行： </p>
<pre class="notranslate">10.2.0.0/16    RU;
192.168.2.0/24 RU;
</pre>



<p>  使用最具体匹配的值。  例如，对于127.0.0.1地址，将选择值“ <code>RU</code> ”，而不是“ <code>US</code> ”。 </p>
<p>  范围示例： </p>
<pre class="notranslate">geo $country {
    ranges;
    default                   ZZ;
    127.0.0.0-127.0.0.0       US;
    127.0.0.1-127.0.0.1       RU;
    127.0.0.1-127.0.0.255     US;
    10.1.0.0-10.1.255.255     RU;
    192.168.1.0-192.168.1.255 UK;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_geoip_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_geoip_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-geoip-module"><a href="#Module-ngx-stream-geoip-module" class="headerlink" title="Module ngx_stream_geoip_module"></a>Module ngx_stream_geoip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geoip_country">geoip_country</a> <br>     <a href="#geoip_city">geoip_city</a> <br>     <a href="#geoip_org">geoip_org</a> <br></td>

<p>   <code>ngx_stream_geoip_module</code>模块（1.11.3）使用预编译的<a href="http://www.maxmind.com" target="_blank" rel="noopener">MaxMind</a>数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p>  使用支持IPv6的数据库时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-stream_geoip_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.maxmind.com/app/c" target="_blank" rel="noopener">MaxMind GeoIP</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">stream {
    geoip_country         GeoIP.dat;
    geoip_city            GeoLiteCity.dat;

    map $geoip_city_continent_code $nearest_server {
        default        example.com;
        EU          eu.example.com;
        NA          na.example.com;
        AS          as.example.com;
    }
   ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_country*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家/地区的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_city*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。  使用此数据库时，以下变量可用： </p>
<blockquote>
<p>  此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_org*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定组织的数据库。  使用此数据库时，以下变量可用： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_core_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_core_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-core-module"><a href="#Module-ngx-stream-core-module" class="headerlink" title="Module ngx_stream_core_module"></a>Module ngx_stream_core_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#listen">listen</a> <br>     <a href="#preread_buffer_size">preread_buffer_size</a> <br>     <a href="#preread_timeout">preread_timeout</a> <br>     <a href="#proxy_protocol_timeout">proxy_protocol_timeout</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#server">server</a> <br>     <a href="#stream">stream</a> <br>     <a href="#tcp_nodelay">tcp_nodelay</a> <br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a> <br>     <a href="#variables_hash_max_size">variables_hash_max_size</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_stream_core_module</code>模块自版本1.9.0起可用。  默认情况下不构建此模块，应使用<code>--with-stream</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">worker_processes auto;

error_log /var/log/nginx/error.log info;

events {
    worker_connections  1024;
}

stream {
    upstream backend {
        hash $remote_addr consistent;

        server backend1.example.com:12345 weight=5;
        server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
        server unix:/tmp/backend3;
    }

    upstream dns {
       server 192.168.0.1:53535;
       server dns.example.com:53;
    }

    server {
        listen 12345;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass backend;
    }

    server {
        listen 127.0.0.1:53 udp reuseport;
        proxy_timeout 20s;
        proxy_pass dns;
    }

    server {
        listen [::1]:12345;
        proxy_pass unix:/tmp/stream.socket;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**listen**  *address*</code> : <code>*port*</code>    [ <code>ssl</code> ]    [ <code>udp</code> ]    [ <code>proxy_protocol</code> ]    [ <code>backlog</code> = <code>*number*</code> ]    [ <code>rcvbuf</code> = <code>*size*</code> ]    [ <code>sndbuf</code> = <code>*size*</code> ]    [ <code>bind</code> ]    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]    [ <code>reuseport</code> ]    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置服务器将接受连接的套接字的<code>*address*</code>和<code>*port*</code> 。  可以仅指定端口。  地址也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:12345;
listen *:12345;
listen 12345;     # same as *:12345
listen localhost:12345;
</pre>

<p>   IPv6地址在方括号中指定： </p>
<pre class="notranslate">listen [::1]:12345;
listen [::]:12345;
</pre>

<p>   UNIX域套接字使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>   <code>ssl</code>参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
<p>   <code>udp</code>参数配置一个侦听套接字以处理数据报（1.9.13）。 </p>
<p>   <code>proxy_protocol</code>参数（1.11.4）允许指定此端口上接受的所有连接都应使用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a> 。 </p>
<blockquote>
<p>  自版本1.13.11起支持PROXY协议版本2。 </p>
</blockquote>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
<blockquote>
<p>  不恰当地使用此选项可能会产生安全<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">隐患</a> 。 </p>
</blockquote>
<pre class="notranslate">so_keepalive=30m::10</pre>



<p>  不同的服务器必须侦听不同的<code>*address*</code> ： <code>*port*</code>对。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**preread_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">preread_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.5版中。 </p>
<p>  指定<a href="stream_processing.html#preread_phase">预读</a>缓冲区的<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**preread_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">preread_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.5版中。 </p>
<p>  指定<a href="stream_processing.html#preread_phase">预读</a>阶段的<code>*timeout*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_protocol_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_protocol_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.4版中。 </p>
<p>  指定读取PROXY协议标头以完成的<code>*timeout*</code> 。  如果在此时间内未传输整个标头，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver**  *address*</code> …    [ <code>valid</code> = <code>*time*</code> ]    [ <code>ipv6</code> = <code>on</code> | <code>off</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.3版中。 </p>
<p>  将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<p>  默认情况下，nginx将在解析时查找IPv4和IPv6地址。  如果不需要查找IPv6地址，可以指定<code>ipv6=off</code>参数。 </p>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在1.11.3版之前，该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.3版中。 </p>
<p>  设置名称解析的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>



<blockquote>
<p>  在1.11.3版之前，该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  设置服务器的配置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**stream** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供指定流服务器指令的配置文件上下文。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**tcp_nodelayon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">tcp_nodelay on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.9.4版本中。 </p>
<p>  启用或禁用<code>TCP_NODELAY</code>选项的使用。  为客户端和代理服务器连接启用该选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**variables_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">variables_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  该指令出现在1.11.2版中。 </p>
<p>  设置变量哈希表的桶大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**variables_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">variables_hash_max_size 1024;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> <br>                </td></p>
<p>  该指令出现在1.11.2版中。 </p>
<p>  设置变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_stream_core_module</code>模块支持自1.11.2以来的变量。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  计算此变量的值通常需要一次系统调用。  为避免系统调用， <a href="#listen">listen</a>指令必须指定地址并使用<code>bind</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stream/ngx_stream_access_module-nginx中文手册]]></title>
      <url>/ngx/stream/ngx_stream_access_module.html</url>
      <content type="html"><![CDATA[<p>stream,ngx_stream_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-stream-access-module"><a href="#Module-ngx-stream-access-module" class="headerlink" title="Module ngx_stream_access_module"></a>Module ngx_stream_access_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#allow">allow</a> <br>     <a href="#deny">deny</a> <br></td>

<p>   <code>ngx_stream_access_module</code>模块（1.9.2）允许限制对某些客户端地址的访问。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    ...
    deny  192.168.1.1;
    allow 192.168.1.0/24;
    allow 10.1.1.0/16;
    allow 2001:0db8::/32;
    deny  all;
}
</pre>



<p>  按顺序检查规则，直到找到第一个匹配项。  在此示例中，仅允许IPv4网络<code>10.1.1.0/16</code>和<code>192.168.1.0/24</code>不包括地址<code>192.168.1.1</code> ）和IPv6网络<code>2001:0db8::/32</code> 。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**allow**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  允许访问指定的网络或地址。  如果指定了特殊值<code>unix:</code>则允许访问所有UNIX域套接字。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**deny**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>stream</code> , <code>server</code> <br>                </td></p>
<p>  拒绝访问指定的网络或地址。  如果指定了特殊值<code>unix:</code>则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/install-nginx中文手册]]></title>
      <url>/ngx/njs/install.html</url>
      <content type="html"><![CDATA[<p>njs,install<br><a id="more"></a></p>
<h2 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h2><td align="left" class="notranslate"> <a href="#install_package">Installing as a Linux package</a> <br> <a href="#install_sources">Building from the sources</a> <br></td>

<h4 id="作为Linux软件包安装"><a href="#作为Linux软件包安装" class="headerlink" title="作为Linux软件包安装"></a>作为Linux软件包安装</h4><p>  对于Linux，可以使用njs模块<a href="linux_packages.html#dynmodules">包</a> ： </p>
<ul>
<li><code>nginx-module-njs</code> -  njs <a href="ngx_core_module.html#load_module">动态</a>模块 -    <code>nginx-module-njs-dbg</code> - <code>nginx-module-njs</code>包的调试符号 </li>
</ul>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p>  可以使用以下命令克隆具有njs源的<a href="http://hg.nginx.org/njs" target="_blank" rel="noopener">存储库</a> :(需要<a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>客户端）： </p>
<pre class="notranslate">hg clone http://hg.nginx.org/njs
</pre>

<p>  然后应使用<code>--add-module</code>配置参数编译<code>--add-module</code> ： </p>
<pre class="notranslate">./configure --add-module= `*path-to-njs*` /nginx
</pre>

<p>  模块也可以构建为<a href="ngx_core_module.html#load_module">动态</a> ： </p>
<pre class="notranslate">./configure --add-dynamic-module= `*path-to-njs*` /nginx
</pre>



<p>  要仅构建njs命令行<a href="cli.html">实用程序</a> ，请运行<code>./configure</code>并从njs根目录<code>make njs</code>命令。  该实用程序以<code>./build/njs</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/index-nginx中文手册]]></title>
      <url>/ngx/njs/index.html</url>
      <content type="html"><![CDATA[<p>njs,index<br><a id="more"></a></p>
<h2 id="njs脚本语言"><a href="#njs脚本语言" class="headerlink" title="njs脚本语言"></a>njs脚本语言</h2><p>   njs是JavaScript语言的一个子集，允许扩展nginx功能。   njs是根据<a href="http://www.ecma-international.org/ecma-262/5.1/" target="_blank" rel="noopener">ECMAScript 5.1</a> （严格模式）创建的，带有一些<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript 6</a>及更高版本的扩展。  合规性仍在<a href="compatibility.html">不断发展</a> 。 </p>
<ul>
<li><a href="install.html">下载并安装</a> -    <a href="changes.html">变化</a> -    <a href="reference.html">参考</a> -    <a href="examples.html">例子</a> -    <a href="compatibility.html">兼容性</a> -    <a href="cli.html">命令行界面</a> </li>
</ul>
<ul>
<li><a href="http/ngx_http_js_module.html">ngx_http_js_module</a> -    <a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a> </li>
</ul>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><ul>
<li>在请求到达上游服务器之前，njs中的复杂访问控制和安全性检查 -   操纵响应标头 -   编写灵活的异步内容处理程序和过滤器<br>有关更多njs用例，请参阅<a href="examples.html">示例</a>和<a href="https://www.nginx.com/blog/tag/nginx-javascript-module/" target="_blank" rel="noopener">博客文章</a> 。 </li>
</ul>
<h4 id="基本HTTP示例"><a href="#基本HTTP示例" class="headerlink" title="基本HTTP示例"></a>基本HTTP示例</h4><p>  要在nginx中使用njs： </p>
<ul>
<li><a href="install.html">安装</a> njs脚本语言 </li><li id="hello_world">  创建一个njs脚本文件，例如<code>hello_world.js</code> 。  有关njs属性和方法的列表，请参见<a href="reference.html">参考</a> 。 <blockquote class="example"><pre class="notranslate">function hello(r) {<br>r.return(200, “Hello world!”);<br>}<br></pre></blockquote></li><li>  在<code>nginx.conf</code>文件中，启用<a href="http/ngx_http_js_module.html">ngx_http_js_module</a>模块并使用<code>hello_world.js</code>脚本文件指定<a href="http/ngx_http_js_module.html#js_include">js_include</a>指令： <blockquote class="example"><pre class="notranslate">load_module modules/ngx_http_js_module.so;</pre></blockquote></li>
</ul>
<p>events {}</p>
<p>http {<br>    js_include hello_world.js;</p>
<pre><code>server {
    listen 8000;

    location / {
        js_content hello;
    }
}
</code></pre><p>}</p>
<p></p>
<pre class="notranslate">load_module modules/ngx_http_js_module.so;

events {}

http {
    js_include hello_world.js;

    server {
        listen 8000;

        location / {
            js_content hello;
        }
    }
}

</pre>

<p>  还有一个独立的<a href="cli.html">命令行</a>实用程序，可以独立于nginx用于njs开发和调试。 </p>
<h4 id="在2018年的nginx-conf上发表演讲"><a href="#在2018年的nginx-conf上发表演讲" class="headerlink" title="在2018年的nginx.conf上发表演讲"></a>在2018年的nginx.conf上发表演讲</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[njs/examples-nginx中文手册]]></title>
      <url>/ngx/njs/examples.html</url>
      <content type="html"><![CDATA[<p>njs,examples<br><a id="more"></a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><td align="left" class="notranslate"> <a href="#helloword">Hello World</a> <br> <a href="#urldecode">URL Decoding</a> <br> <a href="#urlencode">URL Encoding</a> <br> <a href="#redirect">Internal Redirect</a> <br> <a href="#fast_response">Returning Fastest Response from Proxy</a> <br> <a href="#jwt">Creating HS JWT</a> <br> <a href="#subrequest">Accessing API from a Subrequest</a> <br> <a href="#secure_link">Creating secure_link Hash</a> <br> <a href="#legacy">Legacy Examples</a> <br>     <a href="#legacy_stream">Injecting HTTP header using stream proxy</a> <br></td>

<h4 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">load_module modules/ngx_http_js_module.so;

events {}

http {
    js_include hello_world.js;

    server {
        listen 8000;

        location / {
            js_content hello;
        }
    }
}

</pre>



<p>   <code>hello_world.js</code> ： </p>
<pre class="notranslate">function hello(r) {
    r.return(200, "Hello world!");
}
</pre>



<h4 id="网址解码"><a href="#网址解码" class="headerlink" title="网址解码"></a>网址解码</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include urldecode.js;

js_set $decoded_foo decoded_foo;
</pre>



<p>   <code>urldecode.js</code> ： </p>
<pre class="notranslate">function decoded_foo(r) {
    return decodeURIComponent(r.args.foo);
}
</pre>



<h4 id="网址编码"><a href="#网址编码" class="headerlink" title="网址编码"></a>网址编码</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include urlencode.js;

js_set $encoded_foo encoded_foo;
...

location / {
    proxy_pass http://example.com?foo=$encoded_foo;
}
</pre>



<p>   <code>urlencode.js</code> ： </p>
<pre class="notranslate">function encoded_foo(r) {
    return encodeURIComponent('foo &amp; bar?');
}
</pre>



<h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include redirect.js;

location /redirect {
    js_content redirect;
}

location @named {
    return 200 named;
}
</pre>



<p>   <code>redirect.js</code> ： </p>
<pre class="notranslate">function redirect(r) {
    r.internalRedirect('@named');
}
</pre>



<h4 id="从代理返回最快的响应"><a href="#从代理返回最快的响应" class="headerlink" title="从代理返回最快的响应"></a>从代理返回最快的响应</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include fastresponse.js;

location /start {
    js_content content;
}

location /foo {
    proxy_pass http://backend1;
}

location /bar {
    proxy_pass http://backend2;
}
</pre>



<p>   <code>fastresponse.js</code> ： </p>
<pre class="notranslate">function content(r) {
    var n = 0;

    function done(res) {
        if (n++ == 0) {
            r.return(res.status, res.responseBody);
        }
    }

    r.subrequest('/foo', r.variables.args, done);
    r.subrequest('/bar', r.variables.args, done);
}
</pre>



<h4 id="创建HS-JWT"><a href="#创建HS-JWT" class="headerlink" title="创建HS JWT"></a>创建HS JWT</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include hs_jwt.js;

js_set $jwt jwt;
</pre>



<p>   <code>hs_jwt.js</code> ： </p>
<pre class="notranslate">function create_hs256_jwt(claims, key, valid) {
    var header = { "typ" : "JWT", "alg" : "HS256", "exp" : Date.now() + valid };

    var s = JSON.stringify(header).toBytes().toString('base64url') + '.'
            + JSON.stringify(claims).toBytes().toString('base64url');

    var h = require('crypto').createHmac('sha256', key);

    return s + '.' + h.update(s).digest().toString('base64url');
}

function jwt(r) {
    var claims = {
        "iss" : "nginx",
        "sub" : "alice",
        "foo" : 123,
        "bar" : "qq",
        "zyx" : false
    };

    return create_hs256_jwt(claims, 'foo', 600);
}
</pre>



<h4 id="从子请求访问API"><a href="#从子请求访问API" class="headerlink" title="从子请求访问API"></a>从子请求访问API</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include subrequest.js;

keyval_zone zone=foo:10m;
...

location /keyval {
    js_content set_keyval;
}

location /version {
    js_content version;
}

location /api {
    api write=on;
}
</pre>



<p>   <code>subrequest.js</code> ： </p>
<pre class="notranslate">function set_keyval(r) {
    r.subrequest('/api/3/http/keyvals/foo',
        { method: 'POST',
          body: JSON.stringify({ foo: 789, bar: "ss dd 00" })},

        function(res) {
            if (res.status &gt;= 300) {
                r.return(res.status, res.responseBody);
                return;
            }
            r.return(500);
        });
}

function version(r) {
    r.subrequest('/api/3/nginx', { method: 'GET' }, function(res) {
        if (res.status != 200) {
            r.return(res.status);
            return;
        }

        var json = JSON.parse(res.responseBody);
        r.return(200, json.version);
    });
}
</pre>



<h4 id="创建secure-link哈希"><a href="#创建secure-link哈希" class="headerlink" title="创建secure_link哈希"></a>创建secure_link哈希</h4><p>   <code>nginx.conf</code> ： </p>
<pre class="notranslate">js_include hash.js;

js_set $new_foo create_secure_link;
...

location / {
    secure_link $cookie_foo;
    secure_link_md5 "$uri mykey";
    ...
}

location @login {
    add_header Set-Cookie "foo=$new_foo; Max-Age=60";
    return 302 /;
}
</pre>



<p>   <code>hash.js</code> ： </p>
<pre class="notranslate">function create_secure_link(r) {
    return require('crypto').createHash('md5')
                            .update(r.uri).update(" mykey")
                            .digest('base64url');
}
</pre>



<h4 id="遗留的例子"><a href="#遗留的例子" class="headerlink" title="遗留的例子"></a>遗留的例子</h4><h4 id="使用流代理注入HTTP标头"><a href="#使用流代理注入HTTP标头" class="headerlink" title="使用流代理注入HTTP标头"></a>使用流代理注入HTTP标头</h4><p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，流配置<a href="stream/ngx_stream_js_module.html#example">示例</a>已更改。  对于njs 0.2.3及更早版本，请使用此配置示例： </p>
<pre class="notranslate">load_module modules/ngx_stream_js_module.so;
...

stream {
    js_include stream.js;

    js_set $foo foo;
    js_set $bar bar;

    server {
        listen 12345;

        js_preread qux;
        return     $foo;
    }

    server {
        listen 12346;

        js_access  xyz;
        proxy_pass 127.0.0.1:8000;
        js_filter  baz;
    }
}

http {
    server {
        listen 8000;
        location / {
            return 200 $http_foo\n;
        }
    }
}
</pre>



<p>   <code>stream.js</code>文件： </p>
<pre class="notranslate">var req = '';
var matched = 0;
var line = '';

function qux(s) {
    var n = s.buffer.indexOf('\n');
    if (n == -1) {
        return s.AGAIN;
    }

    line = s.buffer.substr(0, n);
}

function foo(s) {
    return line;
}

function bar(s) {
    var v = s.variables;
    s.log("hello from bar() handler!");
    return "foo-var" + v.remote_port + "; pid=" + v.pid;
}

// The filter processes one buffer per call.
// The buffer is available in s.buffer both for
// reading and writing.  Called for both directions.

function baz(s) {
    if (s.fromUpstream || matched) {
        return;
    }

    // Disable certain addresses.

    if (s.remoteAddress.match('^192.*')) {
        return s.ERROR;
    }

    // Read HTTP request line.
    // Collect bytes in 'req' until request
    // line is read.  Clear current buffer to
    // disable output.

    req = req + s.buffer;
    s.buffer = '';

    var n = req.search('\n');

    if (n != -1) {
        // Inject a new HTTP header.
        var rest = req.substr(n + 1);
        req = req.substr(0, n + 1);

        var addr = s.remoteAddress;

        s.log('req:' + req);
        s.log('rest:' + rest);

        // Output the result and skip further
        // processing.

        s.buffer = req + 'Foo: addr_' + addr + '\r\n' + rest;
        matched = 1;
    }
}

function xyz(s) {
    if (s.remoteAddress.match('^192.*')) {
        return s.ABORT;
    }
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_ssl_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_ssl_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-ssl-module"><a href="#Module-ngx-mail-ssl-module" class="headerlink" title="Module ngx_mail_ssl_module"></a>Module ngx_mail_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl">ssl</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br>     <a href="#starttls">starttls</a> <br></td>

<p>   <code>ngx_mail_ssl_module</code>模块为邮件代理服务器提供必要的支持，以使用SSL / TLS协议。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-mail_ssl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

mail {

    ...

    server {
        listen              993 ssl;

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令在1.15.0版本中已过时。  应该使用<a href="ngx_mail_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              993 ssl;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同证书的单独证书链。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<blockquote>
<p>  以前版本的nginx默认使用<a href="http/configuring_https_servers.html#compatibility">不同的</a>密码。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.7.2版本中。 </p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.3版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">mail {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        server_name mail1.example.com;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        server_name mail2.example.com;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数（ <code>TLSv1.2</code> ）仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache** off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client** on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用客户端证书验证。  验证结果在<a href="ngx_mail_auth_http_module.html#auth_http">验证</a>请求的“Auth-SSL-Verify”标头中传递。 </p>
<p>   <code>optional</code>参数请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数请求客户端证书，但不要求它由可信CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="ngx_mail_auth_http_module.html#auth_http_pass_client_cert">发送</a>到身份验证服务器的请求访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  设置客户端证书链中的验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**starttls**   &lt;code class=&quot;notranslate&quot;&gt;on</code> |  <code>off</code> |  <code>only</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">starttls off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_smtp_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_smtp_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_smtp_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-smtp-module"><a href="#Module-ngx-mail-smtp-module" class="headerlink" title="Module ngx_mail_smtp_module"></a>Module ngx_mail_smtp_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#smtp_auth">smtp_auth</a> <br>     <a href="#smtp_capabilities">smtp_capabilities</a> <br>     <a href="#smtp_client_buffer">smtp_client_buffer</a> <br>     <a href="#smtp_greeting_delay">smtp_greeting_delay</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_auth login plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为SMTP客户端设置允许的<a href="https://tools.ietf.org/html/rfc2554" target="_blank" rel="noopener">SASL身份验证</a>方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置传递给客户端以响应<code>EHLO</code>命令的SMTP协议扩展列表。   <a href="#smtp_auth">smtp_auth</a>指令和<a href="https://tools.ietf.org/html/rfc3207" target="_blank" rel="noopener">STARTTLS</a>中指定的身份验证方法将根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的MTA支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/mail-parameters" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_client_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_client_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于读取SMTP命令的缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**smtp_greeting_delay*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">smtp_greeting_delay 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  允许在发送SMTP问候语之前设置延迟，以便在发送SMTP命令之前拒绝未能等待问候语的客户端。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_proxy_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_proxy_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-proxy-module"><a href="#Module-ngx-mail-proxy-module" class="headerlink" title="Module ngx_mail_proxy_module"></a>Module ngx_mail_proxy_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#proxy_buffer">proxy_buffer</a> <br>     <a href="#proxy_pass_error_message">proxy_pass_error_message</a> <br>     <a href="#proxy_timeout">proxy_timeout</a> <br>     <a href="#xclient">xclient</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于代理的缓冲区的大小。  默认情况下，缓冲区大小等于一个内存页面。  根据平台，它是4K或8K。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_error_messageon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_error_message off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  指示是否将后端身份验证期间获取的错误消息传递给客户端。 </p>
<p>  通常，如果nginx中的身份验证成功，则后端无法返回错误。  如果它仍然返回错误，则表示发生了一些内部错误。  在这种情况下，后端消息可以包含不应向客户端显示的信息。  但是，对于某些POP3服务器，使用正确密码的错误进行响应是正常行为。  例如，CommuniGatePro通过定期输出<a href="http://www.stalker.com/CommuniGatePro/POP.html#Alerts" target="_blank" rel="noopener">身份验证错误</a>通知用户<a href="http://www.stalker.com/CommuniGatePro/Alerts.html#Quota" target="_blank" rel="noopener">邮箱溢出</a>或其他事件。  在这种情况下应该启用该指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_timeout 24h;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端或代理服务器连接上两次连续读取或写入操作之间的<code>*timeout*</code> 。  如果在此时间内没有传输数据，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xclienton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xclient on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  连接到SMTP后端时，启用或禁用带有客户端参数的<a href="http://www.postfix.org/XCLIENT_README.html" target="_blank" rel="noopener">XCLIENT</a>命令的传递。 </p>
<p>  使用<code>XCLIENT</code> ，MTA能够将客户端信息写入日志，并根据此数据应用各种限制。 </p>
<p>  如果启用了<code>XCLIENT</code> ，则nginx在连接到后端时会传递以下命令： </p>
<ul>
<li><code>EHLO</code>与<a href="ngx_mail_core_module.html#server_name">服务器名称</a> -  <code>XCLIENT</code>  -    <code>EHLO</code>或<code>HELO</code> ，由客户通过 </li>
</ul>
<p>  如果客户端IP地址<a href="ngx_mail_core_module.html#resolver">找到</a>的名称指向同一地址，则会在<code>XCLIENT</code>命令的<code>NAME</code>参数中传递该<code>NAME</code> 。  如果找不到名称，指向不同的地址，或未指定<a href="ngx_mail_core_module.html#resolver">解析器</a> ，则在<code>NAME</code>参数中传递<code>[UNAVAILABLE]</code> 。  如果在解析过程中发生错误，则使用<code>[TEMPUNAVAIL]</code>值。 </p>
<p>  如果禁用了<code>XCLIENT</code> ，那么如果客户端已通过<code>EHLO</code> ，则nginx在连接到后端时传递带有<a href="ngx_mail_core_module.html#server_name">服务器名称</a>的<code>EHLO</code>命令，否则传递带有服务器名称的<code>HELO</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_pop3_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_pop3_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_pop3_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-pop3-module"><a href="#Module-ngx-mail-pop3-module" class="headerlink" title="Module ngx_mail_pop3_module"></a>Module ngx_mail_pop3_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#pop3_auth">pop3_auth</a> <br>     <a href="#pop3_capabilities">pop3_capabilities</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pop3_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pop3_auth plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为POP3客户端设置允许的身份验证方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pop3_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pop3_capabilities TOP USER UIDL;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置为响应<code>CAPA</code>命令而传递给客户端的<a href="https://tools.ietf.org/html/rfc2449" target="_blank" rel="noopener">POP3协议</a>扩展列表。   <a href="#pop3_auth">pop3_auth</a>指令（ <a href="https://tools.ietf.org/html/rfc2449" target="_blank" rel="noopener">SASL</a>扩展名）和<a href="https://tools.ietf.org/html/rfc2595" target="_blank" rel="noopener">STLS</a>中指定的身份验证方法将根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的POP3后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/pop3-extension-mechanism" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_imap_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_imap_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_imap_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-imap-module"><a href="#Module-ngx-mail-imap-module" class="headerlink" title="Module ngx_mail_imap_module"></a>Module ngx_mail_imap_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#imap_auth">imap_auth</a> <br>     <a href="#imap_capabilities">imap_capabilities</a> <br>     <a href="#imap_client_buffer">imap_client_buffer</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_auth*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_auth plain;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  为IMAP客户端设置允许的身份验证方法。  支持的方法是： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_capabilities*extension*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_capabilities IMAP4 IMAP4rev1 UIDPLUS;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置传递给客户端以响应<code>CAPABILITY</code>命令的<a href="https://tools.ietf.org/html/rfc3501" target="_blank" rel="noopener">IMAP协议</a>扩展列表。   <a href="#imap_auth">imap_auth</a>指令和<a href="https://tools.ietf.org/html/rfc2595" target="_blank" rel="noopener">STARTTLS</a>中指定的身份验证方法会根据<a href="ngx_mail_ssl_module.html#starttls">starttls</a>指令值自动添加到此列表中。 </p>
<p>  指定客户端所代理的IMAP后端支持的扩展是有意义的（如果这些扩展与身份验证后使用的命令相关，当nginx透明地代理客户端连接到后端时）。 </p>
<p>  目前的标准化扩展列表发布在<a href="http://www.iana.org/assignments/imap4-capabilities" target="_blank" rel="noopener">www.iana.org</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**imap_client_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">imap_client_buffer 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置用于读取IMAP命令的缓冲区的<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_core_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_core_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-core-module"><a href="#Module-ngx-mail-core-module" class="headerlink" title="Module ngx_mail_core_module"></a>Module ngx_mail_core_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#listen">listen</a> <br>     <a href="#mail">mail</a> <br>     <a href="#protocol">protocol</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#server">server</a> <br>     <a href="#server_name">server_name</a> <br>     <a href="#timeout">timeout</a> <br></td>

<p>  默认情况下不构建此模块，应使用<code>--with-mail</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">worker_processes 1;

error_log /var/log/nginx/error.log info;

events {
    worker_connections  1024;
}

mail {
    server_name       mail.example.com;
    auth_http         localhost:9000/cgi-bin/nginxauth.cgi;

    imap_capabilities IMAP4rev1 UIDPLUS IDLE LITERAL+ QUOTA;

    pop3_auth         plain apop cram-md5;
    pop3_capabilities LAST TOP USER PIPELINING UIDL;

    smtp_auth         login plain cram-md5;
    smtp_capabilities "SIZE 10485760" ENHANCEDSTATUSCODES 8BITMIME DSN;
    xclient           off;

    server {
        listen   25;
        protocol smtp;
    }
    server {
        listen   110;
        protocol pop3;
        proxy_pass_error_message on;
    }
    server {
        listen   143;
        protocol imap;
    }
    server {
        listen   587;
        protocol smtp;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**listen**  *address*</code> : <code>*port*</code>    [ <code>ssl</code> ]    [ <code>backlog</code> = <code>*number*</code> ]    [ <code>rcvbuf</code> = <code>*size*</code> ]    [ <code>sndbuf</code> = <code>*size*</code> ]    [ <code>bind</code> ]    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置服务器将接受请求的套接字的<code>*address*</code>和<code>*port*</code> 。  可以仅指定端口。  地址也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:110;
listen *:110;
listen 110;     # same as *:110
listen localhost:110;
</pre>

<p>   IPv6地址（0.7.58）在方括号中指定： </p>
<pre class="notranslate">listen [::1]:110;
listen [::]:110;
</pre>

<p>   UNIX域套接字（1.3.5）使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>  不同的服务器必须侦听不同的<code>*address*</code> ： <code>*port*</code>对。 </p>
<p>   <code>ssl</code>参数允许指定此端口上接受的所有连接都应在SSL模式下工作。 </p>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。 </p>
<pre class="notranslate">so_keepalive=30m::10</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mail** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供指定邮件服务器指令的配置文件上下文。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**protocol**   &lt;code class=&quot;notranslate&quot;&gt;imap</code> |  <code>pop3</code> |  <code>smtp</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  设置代理服务器的协议。  支持的协议是<a href="ngx_mail_imap_module.html">IMAP</a> ， <a href="ngx_mail_pop3_module.html">POP3</a>和<a href="ngx_mail_smtp_module.html">SMTP</a> 。 </p>
<p>  如果未设置该指令，则可以根据<a href="#listen">listen</a>指令中指定的已知端口自动检测协议： </p>
<ul>
<li><code>imap</code> ：143,993 -    <code>pop3</code> ：110,995 -    <code>smtp</code> ：25,587,465 </li>
</ul>
<p>  可以使用<a href="configure.html">配置</a>参数<code>--without-mail_imap_module</code> ， <code>--without-mail_pop3_module</code>和<code>--without-mail_smtp_module</code>禁用不必要的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver*address*</code> …[ <code>valid</code> = <code>*time*</code> ]; <br> <code>**resolveroff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  配置用于查找客户端主机名的名称服务器以将其传递给<a href="ngx_mail_auth_http_module.html">身份验证服务器</a> ，并在代理SMTP时配置<a href="ngx_mail_proxy_module.html#xclient">XCLIENT</a>命令。  例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<blockquote>
<p>  在1.1.7版之前，只能配置一个名称服务器。  从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。 </p>
</blockquote>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。 </p>
</blockquote>
<p>  特殊值<code>off</code>禁用解析。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**resolver_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">resolver_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置DNS操作的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> <br>                </td></p>
<p>  设置服务器的配置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">server_name hostname;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置使用的服务器名称： </p>
<ul>
<li>在初始POP3 / SMTP服务器问候语中; -   在SASL CRAM-MD5认证期间的盐; -   如果启用了<a href="ngx_mail_proxy_module.html#xclient">XCLIENT</a>命令的传递，则在连接到SMTP后端时在<code>EHLO</code>命令中。 </li>
</ul>
<p>  如果未指定该指令，则使用计算机的主机名。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置代理到后端开始之前使用的超时。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mail/ngx_mail_auth_http_module-nginx中文手册]]></title>
      <url>/ngx/mail/ngx_mail_auth_http_module.html</url>
      <content type="html"><![CDATA[<p>mail,ngx_mail_auth_http_module<br><a id="more"></a></p>
<h2 id="Module-ngx-mail-auth-http-module"><a href="#Module-ngx-mail-auth-http-module" class="headerlink" title="Module ngx_mail_auth_http_module"></a>Module ngx_mail_auth_http_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#auth_http">auth_http</a> <br>     <a href="#auth_http_header">auth_http_header</a> <br>     <a href="#auth_http_pass_client_cert">auth_http_pass_client_cert</a> <br>     <a href="#auth_http_timeout">auth_http_timeout</a> <br> <a href="#protocol">Protocol</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置HTTP身份验证服务器的URL。  该协议<a href="#protocol">如下所述</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_header*header*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  将指定的标头附加到发送到身份验证服务器的请求。  此标头可用作共享密钥，以验证请求是否来自nginx。  例如： </p>
<pre class="notranslate">auth_http_header X-Auth-Key "secret_string";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_pass_client_certon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_http_pass_client_cert off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  将具有PEM格式（urlencoded）的<a href="ngx_mail_ssl_module.html#ssl_verify_client">客户端</a>证书的“Auth-SSL-Cert”标头附加到发送到身份验证服务器的请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_http_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_http_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>mail</code> , <code>server</code> <br>                </td></p>
<p>  设置与身份验证服务器通信的超时。 </p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>   HTTP协议用于与身份验证服务器通信。  响应正文中的数据将被忽略，信息仅在标题中传递。 </p>
<p>  请求和响应的示例： </p>
<p>  请求： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: plain # plain/apop/cram-md5/external
Auth-User: user
Auth-Pass: password
Auth-Protocol: imap # imap/pop3/smtp
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
</pre>

<p>  反应良好： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: OK
Auth-Server: 198.51.100.1
Auth-Port: 143
</pre>

<p>  不好的回应： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: Invalid login or password
Auth-Wait: 3
</pre>



<p>  如果没有“Auth-Wait”标头，将返回错误并关闭连接。  当前实现为每次身份验证尝试分配内存。  仅在会话结束时释放内存。  因此，必须限制单个会话中无效身份验证尝试的次数 - 服务器必须在10-20次尝试后响应而不使用“Auth-Wait”标头（尝试号码在“Auth-Login-Attempt”标头中传递） 。 </p>
<p>  使用APOP或CRAM-MD5时，请求 - 响应将如下所示： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: apop
Auth-User: user
Auth-Salt: &lt;238188073.1163692009@mail.example.com&gt;
Auth-Pass: auth_response
Auth-Protocol: imap
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
</pre>

<p>  反应良好： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: OK
Auth-Server: 198.51.100.1
Auth-Port: 143
Auth-Pass: plain-text-pass
</pre>



<p>  如果响应中存在“Auth-User”标头，它将覆盖用于通过后端进行身份验证的用户名。 </p>
<p>  对于SMTP，响应还考虑了“Auth-Error-Code”标头 - 如果存在，则在发生错误时用作响应代码。  否则，535 5.7.0代码将添加到“Auth-Status”标头中。 </p>
<p>  例如，如果从身份验证服务器收到以下响应： </p>
<pre class="notranslate">HTTP/1.0 200 OK
Auth-Status: Temporary server problem, try again later
Auth-Error-Code: 451 4.3.0
Auth-Wait: 3
</pre>

<p>  然后SMTP客户端将收到错误 </p>
<pre class="notranslate">451 4.3.0 Temporary server problem, try again later
</pre>



<p>  如果代理SMTP不需要身份验证，请求将如下所示： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: none
Auth-User:
Auth-Pass:
Auth-Protocol: smtp
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Client-Host: client.example.org
Auth-SMTP-Helo: client.example.org
Auth-SMTP-From: MAIL FROM: &lt;&gt;
Auth-SMTP-To: RCPT TO: &lt;postmaster@mail.example.com&gt;
</pre>



<p>  对于SSL / TLS客户端连接（1.7.11），添加了“Auth-SSL”标头，“Auth-SSL-Verify”将包含客户端证书验证的结果（如果已<a href="ngx_mail_ssl_module.html#ssl_verify_client">启用）</a> ：“ <code>SUCCESS</code> ”，“ <code>FAILED:</code>如果证书不存在，则“和” <code>NONE</code> “。 </p>
<blockquote>
<p>  在1.11.7版之前，“ <code>FAILED</code> ”结果不包含<code>*reason*</code>字符串。 </p>
</blockquote>
<p>  当客户端证书存在时，其详细信息将在以下请求标头中传递：“Auth-SSL-Subject”，“Auth-SSL-Issuer”，“Auth-SSL-Serial”和“Auth-SSL-Fingerprint”。  如果启用了<a href="#auth_http_pass_client_cert">auth_http_pass_client_cert</a> ，则证书本身将在“Auth-SSL-Cert”标头中传递。  请求如下： </p>
<pre class="notranslate">GET /auth HTTP/1.0
Host: localhost
Auth-Method: plain
Auth-User: user
Auth-Pass: password
Auth-Protocol: imap
Auth-Login-Attempt: 1
Client-IP: 192.0.2.42
Auth-SSL: on
Auth-SSL-Verify: SUCCESS
Auth-SSL-Subject: /CN=example.com
Auth-SSL-Issuer: /CN=example.com
Auth-SSL-Serial: C07AD56B846B5BFF
Auth-SSL-Fingerprint: 29d6a80a123d13355ed16b4b04605e29cb55a5ad
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/websocket-nginx中文手册]]></title>
      <url>/ngx/http/websocket.html</url>
      <content type="html"><![CDATA[<p>http,websocket<br><a id="more"></a></p>
<h2 id="WebSocket代理"><a href="#WebSocket代理" class="headerlink" title="WebSocket代理"></a>WebSocket代理</h2><p>  要将客户端和服务器之间的连接从HTTP / 1.1转换为WebSocket，请使用HTTP / 1.1中提供的<a href="https://tools.ietf.org/html/rfc2616#section-14.42" target="_blank" rel="noopener">协议交换</a>机制。 </p>
<p>  然而，有一个微妙之处：由于“升级”是<a href="https://tools.ietf.org/html/rfc2616#section-13.5.1" target="_blank" rel="noopener">逐跳</a>标头，因此它不会从客户端传递到代理服务器。  使用正向代理，客户端可以使用<code>CONNECT</code>方法来规避此问题。  但是，这不适用于反向代理，因为客户端不知道任何代理服务器，并且需要在代理服务器上进行特殊处理。 </p>
<p>  从版本1.3.13开始，nginx实现了特殊的操作模式，如果代理服务器返回带有代码101（交换协议）的响应，则允许在客户端和代理服务器之间建立隧道，并且客户端要求通过请求中的“升级”标头。 </p>
<p>  如上所述，包括“升级”和“连接”的逐跳头不会从客户端传递到代理服务器，因此为了让代理服务器知道客户端将协议切换到WebSocket的意图，这些头必须明确传递： </p>
<pre class="notranslate">location /chat/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
</pre>

<p>  一个更复杂的示例，其中对代理服务器的请求中的“连接”头字段的值取决于客户端请求头中是否存在“升级”字段： </p>
<pre class="notranslate">http {
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    server {
        ...

        location /chat/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
</pre>



<p>  默认情况下，如果代理服务器在60秒内未传输任何数据，则将关闭连接。  使用<a href="ngx_http_proxy_module.html#proxy_read_timeout">proxy_read_timeout</a>指令可以增加此超时。  或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/server_names-nginx中文手册]]></title>
      <url>/ngx/http/server_names.html</url>
      <content type="html"><![CDATA[<p>http,server_names<br><a id="more"></a></p>
<h2 id="服务器名称"><a href="#服务器名称" class="headerlink" title="服务器名称"></a>服务器名称</h2><td align="left" class="notranslate"> <a href="#wildcard_names">Wildcard names</a> <br> <a href="#regex_names">Regular expressions names</a> <br> <a href="#miscellaneous_names">Miscellaneous names</a> <br> <a href="#idn">Internationalized names</a> <br> <a href="#optimization">Optimization</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>  服务器名称使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令定义，并确定用于给定请求的<a href="ngx_http_core_module.html#server">服务器</a>块。  另请参阅“ <a href="request_processing.html">nginx如何处理请求</a> ”。  可以使用确切名称，通配符名称或正则表达式来定义它们： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org;
    ...
}

server {
    listen       80;
    server_name  *.example.org;
    ...
}

server {
    listen       80;
    server_name  mail.*;
    ...
}

server {
    listen       80;
    server_name  ~^(?&lt;user&gt;.+)\.example\.net$;
    ...
}
</pre>



<p>  按名称搜索虚拟服务器时，如果name匹配多个指定的变体，例如通配符名称和正则表达式匹配，则将按以下优先顺序选择第一个匹配的变体： </p>
<ol>
<li>确切的名字 1.   最长的通配符名称以星号开头，例如“ <code>*.example.org</code> ” 1.   最长的通配符名称以星号结尾，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） </li>
</ol>
<h4 id="通配符名称"><a href="#通配符名称" class="headerlink" title="通配符名称"></a>通配符名称</h4><p>  通配符名称可能仅在名称的开头或结尾包含星号，并且仅在点边框上包含星号。  名称“ <code>www.*.example.org</code> ”和“ <code>w*.example.org</code> ”无效。  但是，可以使用正则表达式指定这些名称，例如“ <code>~^www\..+\.example\.org$</code> ”和“ <code>~^w.*\.example\.org$</code> ”。  星号可以匹配多个名称部分。  名称“ <code>*.example.org</code> ”不仅匹配<code>www.example.org</code>还匹配<code>www.sub.example.org</code> 。 </p>
<p>   “ <code>.example.org</code> ”形式的特殊通配符名称可用于匹配确切名称“ <code>example.org</code> ”和通配符名称“ <code>*.example.org</code> ”。 </p>
<h4 id="正则表达式名称"><a href="#正则表达式名称" class="headerlink" title="正则表达式名称"></a>正则表达式名称</h4><p>   nginx使用的正则表达式与Perl编程语言（PCRE）使用的正则表达式兼容。  要使用正则表达式，服务器名称必须以波浪号开头： </p>
<pre class="notranslate">server_name  ~^www\d+\.example\.net$;
</pre>

<p>  否则它将被视为一个确切的名称，或者如果表达式包含星号，则视为通配符名称（并且很可能是无效的名称）。  不要忘记设置“ <code>^</code> ”和“ <code>$</code> ”锚点。  它们在语法上不是必需的，但在逻辑上是必需的。  另请注意，域名点应使用反斜杠进行转义。  应引用包含字符“ <code>{</code> ”和“ <code>}</code> ”的正则表达式： </p>
<pre class="notranslate">server_name  "~^(?&lt;name&gt;\w\d **{** 1,3 **}** +)\.example\.net$";
</pre>

<p>  否则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">directive "server_name" is not terminated by ";" in ...
</pre>

<p>  命名的正则表达式捕获稍后可以用作变量： </p>
<pre class="notranslate">server {
    server_name   ~^(www\.)?( **?&lt;domain&gt;** .+)$;

    location / {
        root   /sites/ **$domain** ;
    }
}
</pre>

<p>   PCRE库使用以下语法支持命名捕获： </p>
<blockquote>
<table width="100%"><tbody><td class="notranslate"> <code>?&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; </td><td class="notranslate">Perl 5.10 compatible syntax, supported since PCRE-7.0</td><br><td class="notranslate"> <code>?&#39; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> ‘ </td><td class="notranslate">Perl 5.10 compatible syntax, supported since PCRE-7.0</td><br><td class="notranslate"> <code>?P&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; </td><td class="notranslate">Python compatible syntax, supported since PCRE-4.0</td><br></tbody></table>



</blockquote>
<pre class="notranslate">pcre_compile() failed: unrecognized character after (?&lt; in ...
</pre>

<p>  这意味着PCRE库已经过时了，应该尝试使用语法“ <code>?P&amp;lt; &lt;code class=&quot;notranslate&quot;&gt;*name*</code> &gt; ”。  捕获也可以以数字形式使用： </p>
<pre class="notranslate">server {
    server_name   ~^(www\.)?(.+)$;

    location / {
        root   /sites/ **$2** ;
    }
}
</pre>

<p>  但是，这种用法应限于简单的情况（如上所述），因为数字参考可以很容易地被覆盖。 </p>
<h4 id="杂项名称"><a href="#杂项名称" class="headerlink" title="杂项名称"></a>杂项名称</h4><p>  有一些服务器名称是专门处理的。 </p>
<p>  如果需要处理没有默认<a href="ngx_http_core_module.html#server">服务器</a>块中“Host”头字段的<a href="ngx_http_core_module.html#server">请求</a> ，则应指定一个空名称： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org  "";
    ...
}
</pre>



<p>  如果<a href="ngx_http_core_module.html#server">服务器</a>块中未定义<a href="ngx_http_core_module.html#server_name">server_name</a> ，则nginx使用空名称作为服务器名称。 </p>
<blockquote>
<p>  在这种情况下，最高为0.8.48的nginx版本使用机器的主机名作为服务器名称。 </p>
</blockquote>
<p>  如果服务器名称定义为“ <code>$hostname</code> ”（0.9.4），则使用计算机的主机名。 </p>
<p>  如果有人使用IP地址而不是服务器名称发出请求，则“主机”请求标头字段将包含IP地址，并且可以使用IP地址作为服务器名称来处理请求： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org
                 www.example.org
                 ""
                 **192.168.1.1**
                 ;
    ...
}
</pre>



<p>  在catch-all服务器示例中，可以看到奇怪的名称“ <code>_</code> ”： </p>
<pre class="notranslate">server {
    listen       80  default_server;
    server_name  _;
    return       444;
}
</pre>

<p>  这个名称没有什么特别之处，它只是无数域名之一，永远不会与任何真实姓名相交。  也可以使用诸如“ <code>--</code> ”和“ <code>!@#</code> ”之类的其他无效名称。 </p>
<p>   nginx版本高达0.6.25支持特殊名称“ <code>*</code> ”，它被错误地解释为一个包罗万象的名称。  它从不作为全能或通配符服务器名称运行。  相反，它提供了<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>指令现在提供的功能。  现在不推荐使用特殊名称“ <code>*</code> ”，并且应使用<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>指令。  请注意，无法使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令指定catch-all名称或缺省服务器。  这是<a href="ngx_http_core_module.html#listen">listen</a>指令的属性，而不是<a href="ngx_http_core_module.html#server_name">server_name</a>指令的属性。  另请参阅“ <a href="request_processing.html">nginx如何处理请求</a> ”。  可以定义侦听端口<em>：80和</em>：8080的服务器，并指示一个端口将是端口<em>的默认服务器：8080，而另一个将是端口</em>的默认值：80： </p>
<pre class="notranslate">server {
    listen       80;
    listen       8080  default_server;
    server_name  example.net;
    ...
}

server {
    listen       80  default_server;
    listen       8080;
    server_name  example.org;
    ...
}
</pre>



<h4 id="国际化名称"><a href="#国际化名称" class="headerlink" title="国际化名称"></a>国际化名称</h4><p>  应使用<a href="ngx_http_core_module.html#server_name">server_name</a>指令中的ASCII（Punycode）表示来指定国际化域名（ <a href="https://en.wikipedia.org/wiki/Internationalized_domain_name" target="_blank" rel="noopener">IDN</a> ）： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  xn--e1afmkfd.xn--80akhbyknj4f;  # пример.испытание
    ...
}
</pre>



<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>  确切名称，以星号开头的通配符名称以及以星号结尾的通配符名称存储在绑定到侦听端口的三个哈希表中。  散列表的大小在配置阶段进行了优化，因此可以找到最少CPU缓存未命中的名称。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p>  首先搜索确切的名称哈希表。  如果未找到名称，则搜索带有以星号开头的通配符名称的哈希表。  如果在那里找不到名称，则搜索带有以星号结尾的通配符名称的哈希表。 </p>
<p>  搜索通配符名称哈希表比搜索确切名称哈希表要慢，因为域名部分会搜索名称。  请注意，特殊通配符形式“ <code>.example.org</code> ”存储在通配符名称哈希表中，而不是存储在精确名称哈希表中。 </p>
<p>  正则表达式是按顺序测试的，因此是最慢的方法，并且是不可伸缩的。 </p>
<p>  出于这些原因，最好在可能的情况下使用确切的名称。  例如，如果服务器的最常请求名称是<code>example.org</code>和<code>www.example.org</code> ，则明确定义它们会更有效： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org  www.example.org  *.example.org;
    ...
}
</pre>

<p>  而不是使用简化形式： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  .example.org;
    ...
}
</pre>



<p>  如果定义了大量服务器名称，或者定义了异常长的服务器名称，则可能需要在<em>http</em>级别调整<a href="ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>和<a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a>指令。   <a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a>指令的默认值可能等于32或64，或其他值，具体取决于CPU缓存行大小。  如果默认值为32且服务器名称定义为“ <code>too.long.server.name.example.org</code> ”，则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">could not build the server_names_hash,
you should increase server_names_hash_bucket_size: 32
</pre>

<p>  在这种情况下，指令值应该增加到下一个2的幂： </p>
<pre class="notranslate">http {
    server_names_hash_bucket_size  64;
    ...
</pre>

<p>  如果定义了大量服务器名称，则会显示另一条错误消息： </p>
<pre class="notranslate">could not build the server_names_hash,
you should increase either server_names_hash_max_size: 512
or server_names_hash_bucket_size: 32
</pre>

<p>  在这种情况下，首先尝试将<a href="ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>设置为接近服务器名称数的数字。  只有当这没有帮助时，或者如果nginx的开始时间长得令人无法接受，请尝试增加<a href="ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> 。 </p>
<p>  如果服务器是监听端口的唯一服务器，则nginx根本不会测试服务器名称（并且不会为监听端口构建哈希表）。  但是，有一个例外。  如果服务器名称是带捕获的正则表达式，则nginx必须执行表达式才能获取捕获。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>自0.9.4以来一直支持特殊服务器名称“ <code>$hostname</code> ”。 -   默认服务器名称值是自0.8.48以来的空名称“”。 -   自0.8.25起，支持命名正则表达式服务器名称捕获。 -   自0.7.40起支持正则表达式服务器名称捕获。 -   自0.7.12起，支持空服务器名称“”。 -   支持使用通配符服务器名称或正则表达式作为自0.6.25以来的第一个服务器名称。 -   自0.6.7起支持正则表达式服务器名称。 -   自0.6.0以来一直支持通配符表单<code>example.*</code> 。 -   从0.3.18开始支持特殊格式<code>.example.org</code> 。 -   自0.1.13起支持通配符<code>*.example.org</code> 。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/request_processing-nginx中文手册]]></title>
      <url>/ngx/http/request_processing.html</url>
      <content type="html"><![CDATA[<p>http,request_processing<br><a id="more"></a></p>
<h2 id="nginx如何处理请求"><a href="#nginx如何处理请求" class="headerlink" title="nginx如何处理请求"></a>nginx如何处理请求</h2><td align="left" class="notranslate"> <a href="#how_to_prevent_undefined_server_names">How to prevent processing requests with undefined server names</a> <br> <a href="#mixed_name_ip_based_servers">Mixed name-based and IP-based virtual servers</a> <br> <a href="#simple_php_site_configuration">A simple PHP site configuration</a> <br></td>

<h4 id="基于名称的虚拟服务器"><a href="#基于名称的虚拟服务器" class="headerlink" title="基于名称的虚拟服务器"></a>基于名称的虚拟服务器</h4><p>   nginx首先决定哪个<em>服务器</em>应该处理请求。  让我们从一个简单的配置开始，其中所有三个虚拟服务器都在端口*：80上侦听： </p>
<pre class="notranslate">server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
</pre>



<p>  在此配置中，nginx仅测试请求的标头字段“Host”，以确定请求应路由到哪个服务器。  如果其值与任何服务器名称都不匹配，或者请求根本不包含此标头字段，则nginx会将请求路由到此端口的默认服务器。  在上面的配置中，默认服务器是第一个 - 这是nginx的标准默认行为。  也可以使用<a href="ngx_http_core_module.html#listen">listen</a>指令中的<code>default_server</code>参数明确设置哪个服务器应该是默认的： </p>
<pre class="notranslate">server {
    listen      80 **default_server** ;
    server_name example.net www.example.net;
    ...
}
</pre>



<blockquote>
<p>   <code>default_server</code>参数自版本0.8.21起可用。  在早期版本中，应使用<code>default</code>参数。 </p>
</blockquote>
<p>  请注意，默认服务器是侦听端口的属性，而不是服务器名称的属性。  稍后会详细介绍。 </p>
<h4 id="如何使用未定义的服务器名称防止处理请求"><a href="#如何使用未定义的服务器名称防止处理请求" class="headerlink" title="如何使用未定义的服务器名称防止处理请求"></a>如何使用未定义的服务器名称防止处理请求</h4><p>  如果不允许没有“Host”头字段的请求，则可以定义只删除请求的服务器： </p>
<pre class="notranslate">server {
    listen      80;
    server_name "";
    return      444;
}
</pre>

<p>  这里，服务器名称设置为一个空字符串，它将匹配没有“Host”头字段的请求，并返回一个特殊的nginx非标准代码444来关闭连接。 </p>
<blockquote>
<p>  从版本0.8.48开始，这是服务器名称的默认设置，因此可以省略<code>server_name &quot;&quot;</code> 。  在早期版本中，计算机的<em>主机名</em>用作默认服务器名称。 </p>
</blockquote>
<h4 id="基于名称的混合和基于IP的虚拟服务器"><a href="#基于名称的混合和基于IP的虚拟服务器" class="headerlink" title="基于名称的混合和基于IP的虚拟服务器"></a>基于名称的混合和基于IP的虚拟服务器</h4><p>  让我们看一个更复杂的配置，其中一些虚拟服务器监听不同的地址： </p>
<pre class="notranslate">server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80;
    server_name example.com www.example.com;
    ...
}
</pre>

<p>  在此配置中，nginx首先根据<a href="ngx_http_core_module.html#server">服务器</a>块的<a href="ngx_http_core_module.html#listen">listen</a>指令测试请求的IP地址和端口。  然后，它针对与IP地址和端口匹配的<a href="ngx_http_core_module.html#server">服务器</a>块的<a href="ngx_http_core_module.html#server_name">server_name</a>条目测试请求的“Host”头字段。  如果未找到服务器名称，则默认服务器将处理该请求。  例如，在192.168.1.1:80端口上收到的<code>www.example.com</code>请求将由192.168.1.1:80端口的默认服务器处理，即由第一台服务器处理，因为没有<code>www.example.com</code>为此端口定义。 </p>
<p>  如前所述，默认服务器是监听端口的属性，可以为不同的端口定义不同的默认服务器： </p>
<pre class="notranslate">server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80 **default_server** ;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80 **default_server** ;
    server_name example.com www.example.com;
    ...
}
</pre>



<h4 id="一个简单的PHP站点配置"><a href="#一个简单的PHP站点配置" class="headerlink" title="一个简单的PHP站点配置"></a>一个简单的PHP站点配置</h4><p>  现在让我们看看nginx如何选择一个<em>位置</em>来处理一个典型的简单PHP站点的请求： </p>
<pre class="notranslate">server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
</pre>



<p>   nginx首先搜索由文字字符串给出的最具体的前缀位置，而不管列出的顺序如何。  在上面的配置中，唯一的前缀位置是“ <code>/</code> ”，因为它匹配任何请求，它将被用作最后的手段。  然后nginx按照配置文件中列出的顺序检查正则表达式给出的位置。  第一个匹配表达式将停止搜索，nginx将使用此位置。  如果没有正则表达式与请求匹配，则nginx使用先前找到的最具体的前缀位置。 </p>
<p>  请注意，所有类型的位置仅测试不带参数的请求行的URI部分。  这样做是因为查询字符串中的参数可以通过多种方式给出，例如： </p>
<pre class="notranslate">/index.php?user=john&amp;page=1
/index.php?page=1&amp;user=john
</pre>

<p>  此外，任何人都可以在查询字符串中请求任何内容 </p>
<pre class="notranslate">/index.php?page=1&amp;something+else&amp;user=john
</pre>



<p>  现在让我们看看如何在上面的配置中处理请求： </p>
<ul>
<li>请求“ <code>/logo.gif</code> ”首先与前缀位置“ <code>/</code> ”匹配，然后由正则表达式“ <code>\.(gif|jpg|png)$</code> ”匹配，因此，它由后一个位置处理。  使用指令“ <code>root /data/www</code> ”将请求映射到文件<code>/data/www/logo.gif</code> ，并将文件发送到客户端。 -   请求“ <code>/index.php</code> ”也首先与前缀位置“ <code>/</code> ”匹配，然后由正则表达式“ <code>\.(php)$</code> ”匹配。  因此，它由后一个位置处理，请求被传递给侦听localhost：9000的FastCGI服务器。   <a href="ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a>指令将FastCGI参数<code>SCRIPT_FILENAME</code>为“ <code>/data/www/index.php</code>服务器执行该文件。  变量<code>$document_root</code>等于<a href="ngx_http_core_module.html#root">root</a>指令的值，变量<code>$fastcgi_script_name</code>等于请求URI，即“ <code>/index.php</code> ”。 -   请求“ <code>/about.html</code> ”仅与前缀位置“ <code>/</code> ”匹配，因此，它在此位置处理。  使用指令“ <code>root /data/www</code> ”将请求映射到文件<code>/data/www/about.html</code> ，并将文件发送到客户端。 -   处理请求“ <code>/</code> ”更复杂。  它仅与前缀位置“ <code>/</code> ”匹配，因此，它由此位置处理。  然后<a href="ngx_http_index_module.html#index">索引</a>指令根据其参数和“ <code>root /data/www</code> ”指令测试索引文件是否存在。  如果文件<code>/data/www/index.html</code>不存在，并且文件<code>/data/www/index.php</code>存在，则该指令执行内部重定向到“ <code>/index.php</code> ”，并且nginx再次搜索位置如果请求是由客户发送的。  正如我们之前看到的，重定向的请求最终将由FastCGI服务器处理。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_xslt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_xslt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_xslt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-xslt-module"><a href="#Module-ngx-http-xslt-module" class="headerlink" title="Module ngx_http_xslt_module"></a>Module ngx_http_xslt_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#xml_entities">xml_entities</a> <br>     <a href="#xslt_last_modified">xslt_last_modified</a> <br>     <a href="#xslt_param">xslt_param</a> <br>     <a href="#xslt_string_param">xslt_string_param</a> <br>     <a href="#xslt_stylesheet">xslt_stylesheet</a> <br>     <a href="#xslt_types">xslt_types</a> <br></td>

<p>   <code>ngx_http_xslt_module</code> （0.7.8+）是一个使用一个或多个XSLT样式表转换XML响应的过滤器。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_xslt_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://xmlsoft.org" target="_blank" rel="noopener">libxml2</a>和<a href="http://xmlsoft.org/XSLT/" target="_blank" rel="noopener">libxslt</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    xml_entities    /site/dtd/entities.dtd;
    xslt_stylesheet /site/xslt/one.xslt param=value;
    xslt_stylesheet /site/xslt/two.xslt;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xml_entities*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定声明字符实体的DTD文件。  此文件在配置阶段编译。  由于技术原因，模块无法使用已处理XML中声明的外部子集，因此将忽略该模块并使用特殊定义的文件。  此文件不应描述XML结构。  仅声明所需的字符实体就足够了，例如： </p>
<pre class="notranslate">&lt;!ENTITY nbsp "&amp;#xa0;"&gt;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xslt_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在XSLT转换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在转换期间修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_param*parameter*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.18版中。 </p>
<p>  定义XSLT样式表的参数。  该<code>*value*</code>被视为XPath表达式。  该<code>*value*</code>可以包含变量。  要将字符串值传递给样式表，可以使用<a href="#xslt_string_param">xslt_string_param</a>指令。 </p>
<p>  可能有几个<code>xslt_param</code>指令。  当且仅当在当前级别上没有定义<code>xslt_param</code>和<a href="#xslt_string_param">xslt_string_param</a>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_string_param*parameter*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.18版中。 </p>
<p>  定义XSLT样式表的字符串参数。  不解释<code>*value*</code>中的XPath表达式。  该<code>*value*</code>可以包含变量。 </p>
<p>  可能有几个<code>xslt_string_param</code>指令。  当且仅当在当前级别上没有定义<a href="#xslt_param">xslt_param</a>和<code>xslt_string_param</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_stylesheet**  *stylesheet*</code>    [ <code>*parameter*</code> = <code>*value*</code> …];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义XSLT样式表及其可选参数。  样式表在配置阶段编译。 </p>
<p>  参数既可以单独指定，也可以使用“ <code>:</code> ”分隔符分组在一行中。  如果参数包含“ <code>:</code> ”字符，则应将其转义为“ <code>%3A</code> ”。  此外， <code>libxslt</code>要求将包含非字母数字字符的参数括在单引号或双引号中，例如： </p>
<pre class="notranslate">param1='http%3A//www.example.com':param2=value2
</pre>



<p>  参数描述可以包含变量，例如，整行参数可以从单个变量中获取： </p>
<pre class="notranslate">location / {
    xslt_stylesheet /site/xslt/one.xslt
                    $arg_xslt_params
                    param1='$value1':param2=value2
                    param3=value3;
}
</pre>



<p>  可以指定多个样式表。  它们将按指定的顺序依次应用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**xslt_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">xslt_types text/xml;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/xml</code> ”之外，还启用具有指定MIME类型的响应中的转换。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。  如果转换结果是HTML响应，则其MIME类型将更改为“ <code>text/html</code> ”。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_v2_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_v2_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_v2_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-v2-module"><a href="#Module-ngx-http-v2-module" class="headerlink" title="Module ngx_http_v2_module"></a>Module ngx_http_v2_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#http2_body_preread_size">http2_body_preread_size</a> <br>     <a href="#http2_chunk_size">http2_chunk_size</a> <br>     <a href="#http2_idle_timeout">http2_idle_timeout</a> <br>     <a href="#http2_max_concurrent_pushes">http2_max_concurrent_pushes</a> <br>     <a href="#http2_max_concurrent_streams">http2_max_concurrent_streams</a> <br>     <a href="#http2_max_field_size">http2_max_field_size</a> <br>     <a href="#http2_max_header_size">http2_max_header_size</a> <br>     <a href="#http2_max_requests">http2_max_requests</a> <br>     <a href="#http2_push">http2_push</a> <br>     <a href="#http2_push_preload">http2_push_preload</a> <br>     <a href="#http2_recv_buffer_size">http2_recv_buffer_size</a> <br>     <a href="#http2_recv_timeout">http2_recv_timeout</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_v2_module</code>模块（1.9.5）提供对<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">HTTP / 2的</a>支持并取代<a href="ngx_http_spdy_module.html">ngx_http_spdy_module</a>模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_v2_module</code>配置参数启用它。 </p>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  在版本1.9.14之前，无论<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>和<a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 443 ssl http2;

    ssl_certificate server.crt;
    ssl_certificate_key server.key;
}
</pre>

<p>  请注意，通过TLS接受HTTP / 2连接需要“应用程序层协议协商”（ALPN）TLS扩展支持，该支持仅在<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>版本1.0.2之后可用。  为此目的使用“下一协议协商”（NPN）TLS扩展（自OpenSSL版本1.0.1起可用）不能保证有效。 </p>
<p>  另请注意，如果<a href="ngx_http_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a>指令设置为值“ <code>on</code> ”，则应将<a href="ngx_http_ssl_module.html#ssl_ciphers">密码</a>配置为符合<a href="https://tools.ietf.org/html/rfc7540#appendix-A" target="_blank" rel="noopener">RFC 7540，附录A</a>黑名单并由客户端支持。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_body_preread_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_body_preread_size 64k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.0版本中。 </p>
<p>  设置在开始处理请求主体之前可以保存请求主体的每个请求的缓冲区<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_chunk_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_chunk_size 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置响应主体被切片到的块的最大大小。  值太低会导致更高的开销。  由于<a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener">HOL阻塞，</a>太高的值会损害优先级。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_idle_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_idle_timeout 3m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置关闭连接之前的不活动超时。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_concurrent_pushes*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_concurrent_pushes 10;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  限制连接中的最大并发<a href="#http2_push">推送</a>请求数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_concurrent_streams*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_concurrent_streams 128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置连接中的最大并发HTTP / 2流数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_field_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_field_size 4k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  限制<a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK</a>压缩请求标头字段的最大大小。  该限制同样适用于名称和价值。  请注意，如果应用了霍夫曼编码，则解压缩的名称和值字符串的实际大小可能会更大。  对于大多数请求，默认限制应该足够。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_header_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_header_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  在<a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK</a>解压缩后限制整个请求标头列表的最大大小。  对于大多数请求，默认限制应该足够。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_max_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_max_requests 1000;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置可通过一个HTTP / 2连接提供的最大请求数（包括<a href="#http2_push">推送</a>请求），之后下一个客户端请求将导致连接关闭以及建立新连接的需要。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_push*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_push off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  先发制人地将请求发送（ <a href="https://tools.ietf.org/html/rfc7540#section-8.2" target="_blank" rel="noopener">推送</a> ）到指定的<code>*uri*</code>以及对原始请求的响应。  仅处理具有绝对路径的相对URI，例如： </p>
<pre class="notranslate">http2_push /static/css/main.css;
</pre>

<p>   <code>*uri*</code>值可以包含变量。 </p>
<p>  可以在同一配置级别指定多个<code>http2_push</code>指令。   <code>off</code>参数取消了从先前配置级别继承的<code>http2_push</code>指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_push_preloadon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_push_preload off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.9版中。 </p>
<p>  允许将“链接”响应头字段中指定的<a href="https://www.w3.org/TR/preload/#server-push-http-2" target="_blank" rel="noopener">预加载链接</a>自动转换为<a href="https://tools.ietf.org/html/rfc7540#section-8.2" target="_blank" rel="noopener">推送</a>请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_recv_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_recv_buffer_size 256k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置每个<a href="ngx_core_module.html#worker_processes">工作者</a>输入缓冲区的大小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**http2_recv_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">http2_recv_timeout 30s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置从客户端获取更多数据的超时，然后关闭连接。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_v2_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_uwsgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_uwsgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_uwsgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-uwsgi-module"><a href="#Module-ngx-http-uwsgi-module" class="headerlink" title="Module ngx_http_uwsgi_module"></a>Module ngx_http_uwsgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#uwsgi_bind">uwsgi_bind</a> <br>     <a href="#uwsgi_buffer_size">uwsgi_buffer_size</a> <br>     <a href="#uwsgi_buffering">uwsgi_buffering</a> <br>     <a href="#uwsgi_buffers">uwsgi_buffers</a> <br>     <a href="#uwsgi_busy_buffers_size">uwsgi_busy_buffers_size</a> <br>     <a href="#uwsgi_cache">uwsgi_cache</a> <br>     <a href="#uwsgi_cache_background_update">uwsgi_cache_background_update</a> <br>     <a href="#uwsgi_cache_bypass">uwsgi_cache_bypass</a> <br>     <a href="#uwsgi_cache_key">uwsgi_cache_key</a> <br>     <a href="#uwsgi_cache_lock">uwsgi_cache_lock</a> <br>     <a href="#uwsgi_cache_lock_age">uwsgi_cache_lock_age</a> <br>     <a href="#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a> <br>     <a href="#uwsgi_cache_max_range_offset">uwsgi_cache_max_range_offset</a> <br>     <a href="#uwsgi_cache_methods">uwsgi_cache_methods</a> <br>     <a href="#uwsgi_cache_min_uses">uwsgi_cache_min_uses</a> <br>     <a href="#uwsgi_cache_path">uwsgi_cache_path</a> <br>     <a href="#uwsgi_cache_purge">uwsgi_cache_purge</a> <br>     <a href="#uwsgi_cache_revalidate">uwsgi_cache_revalidate</a> <br>     <a href="#uwsgi_cache_use_stale">uwsgi_cache_use_stale</a> <br>     <a href="#uwsgi_cache_valid">uwsgi_cache_valid</a> <br>     <a href="#uwsgi_connect_timeout">uwsgi_connect_timeout</a> <br>     <a href="#uwsgi_force_ranges">uwsgi_force_ranges</a> <br>     <a href="#uwsgi_hide_header">uwsgi_hide_header</a> <br>     <a href="#uwsgi_ignore_client_abort">uwsgi_ignore_client_abort</a> <br>     <a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a> <br>     <a href="#uwsgi_intercept_errors">uwsgi_intercept_errors</a> <br>     <a href="#uwsgi_limit_rate">uwsgi_limit_rate</a> <br>     <a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a> <br>     <a href="#uwsgi_modifier1">uwsgi_modifier1</a> <br>     <a href="#uwsgi_modifier2">uwsgi_modifier2</a> <br>     <a href="#uwsgi_next_upstream">uwsgi_next_upstream</a> <br>     <a href="#uwsgi_next_upstream_timeout">uwsgi_next_upstream_timeout</a> <br>     <a href="#uwsgi_next_upstream_tries">uwsgi_next_upstream_tries</a> <br>     <a href="#uwsgi_no_cache">uwsgi_no_cache</a> <br>     <a href="#uwsgi_param">uwsgi_param</a> <br>     <a href="#uwsgi_pass">uwsgi_pass</a> <br>     <a href="#uwsgi_pass_header">uwsgi_pass_header</a> <br>     <a href="#uwsgi_pass_request_body">uwsgi_pass_request_body</a> <br>     <a href="#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a> <br>     <a href="#uwsgi_read_timeout">uwsgi_read_timeout</a> <br>     <a href="#uwsgi_request_buffering">uwsgi_request_buffering</a> <br>     <a href="#uwsgi_send_timeout">uwsgi_send_timeout</a> <br>     <a href="#uwsgi_socket_keepalive">uwsgi_socket_keepalive</a> <br>     <a href="#uwsgi_ssl_certificate">uwsgi_ssl_certificate</a> <br>     <a href="#uwsgi_ssl_certificate_key">uwsgi_ssl_certificate_key</a> <br>     <a href="#uwsgi_ssl_ciphers">uwsgi_ssl_ciphers</a> <br>     <a href="#uwsgi_ssl_crl">uwsgi_ssl_crl</a> <br>     <a href="#uwsgi_ssl_name">uwsgi_ssl_name</a> <br>     <a href="#uwsgi_ssl_password_file">uwsgi_ssl_password_file</a> <br>     <a href="#uwsgi_ssl_protocols">uwsgi_ssl_protocols</a> <br>     <a href="#uwsgi_ssl_server_name">uwsgi_ssl_server_name</a> <br>     <a href="#uwsgi_ssl_session_reuse">uwsgi_ssl_session_reuse</a> <br>     <a href="#uwsgi_ssl_trusted_certificate">uwsgi_ssl_trusted_certificate</a> <br>     <a href="#uwsgi_ssl_verify">uwsgi_ssl_verify</a> <br>     <a href="#uwsgi_ssl_verify_depth">uwsgi_ssl_verify_depth</a> <br>     <a href="#uwsgi_store">uwsgi_store</a> <br>     <a href="#uwsgi_store_access">uwsgi_store_access</a> <br>     <a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a> <br>     <a href="#uwsgi_temp_path">uwsgi_temp_path</a> <br></td>

<p>   <code>ngx_http_uwsgi_module</code>模块允许将请求传递给uwsgi服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    include    uwsgi_params;
    uwsgi_pass localhost:9000;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到uwsgi服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>uwsgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到uwsgi服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">uwsgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自uwsgi服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从uwsgi服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用缓冲来自uwsgi服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从uwsgi服务器接收响应，并将其保存到<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#uwsgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a>和<a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从uwsgi服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从uwsgi服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用<a href="#uwsgi_buffering">缓冲</a>来自uwsgi服务器的响应时，限制可能忙于向客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>受<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的两个缓冲区<code>*size*</code>的限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#uwsgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">uwsgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
uwsgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#uwsgi_no_cache">uwsgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">uwsgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给<a href="#uwsgi_cache_key">uwsgi</a>服务器，一次只允许一个请求填充根据<a href="#uwsgi_cache_key">uwsgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存此元素的缓存锁定，直到<a href="#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给uwsgi服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给uwsgi服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#uwsgi_cache_lock">uwsgi_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给uwsgi服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给uwsgi服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_methods** GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#uwsgi_no_cache">uwsgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_path**  *path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#uwsgi_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">uwsgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#uwsgi_temp_path">uwsgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#uwsgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#uwsgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#uwsgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">uwsgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        uwsgi_pass        backend;
        uwsgi_cache       cache_zone;
        uwsgi_cache_key   $uri;
        uwsgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_use_stale** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与uwsgi服务器通信期间发生错误时，在哪些情况下可以使用过时的缓存响应。  该指令的参数与<a href="#uwsgi_next_upstream">uwsgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择要处理请求的uwsgi服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对uwsgi服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对uwsgi服务器的访问次数，可以使用<a href="#uwsgi_cache_lock">uwsgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_cache_valid** [ *code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">uwsgi_cache_valid 200 302 10m;
uwsgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">uwsgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">uwsgi_cache_valid 200 302 10m;
uwsgi_cache_valid 301      1h;
uwsgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#uwsgi_ignore_headers">uwsgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与uwsgi服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_force_rangeson</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_force_ranges off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.7.7版本中。 </p>
<p>无论这些响应中的“Accept-Ranges”字段如何，都可以对来自uwsgi服务器的缓存和未缓存响应启用字节范围支持。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_hide_header*field*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>默认情况下，nginx不会从uwsgi服务器对客户端的响应中传递标题字段“Status”和“X-Accel -…”。   <code>uwsgi_hide_header</code>指令设置了不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#uwsgi_pass_header">uwsgi_pass_header</a>指令。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ignore_client_abort off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>确定客户端在不等待响应的情况下关闭连接时是否应关闭与uwsgi服务器的连接。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ignore_headers*field*</code> …;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>禁用从uwsgi服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#uwsgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#uwsgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的uwsgi服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从uwsgi服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到uwsgi服务器的连接，则总速率将是指定限制的两倍。  仅当启用了来自uwsgi服务器的响应<a href="#uwsgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用<a href="#uwsgi_buffering">缓冲</a>来自uwsgi服务器的响应，并且整个响应不适合<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#uwsgi_cache">缓存</a>或<a href="#uwsgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_modifier1*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_modifier1 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">uwsgi数据包标头中</a> <code>modifier1</code>字段的<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">值</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_modifier2*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_modifier2 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">uwsgi数据包标头中</a> <code>modifier2</code>字段的<a href="http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html#uwsgi-packet-header" target="_blank" rel="noopener">值</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#uwsgi_next_upstream_tries">尝试次数</a>和<a href="#uwsgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#uwsgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#uwsgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">uwsgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
uwsgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#uwsgi_cache_bypass">uwsgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_param**  *parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给uwsgi服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>uwsgi_param</code>指令时，这些指令才从先前级别继承。 </p>
<p>  标准<a href="https://tools.ietf.org/html/rfc3875#section-4.1" target="_blank" rel="noopener">CGI环境变量</a>应作为uwsgi标头提供，请参阅分发中提供的<code>uwsgi_params</code>文件： </p>
<pre class="notranslate">location / {
    include uwsgi_params;
    ...
}
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">uwsgi_param HTTPS $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass** [ *protocol*</code> ://] <code>*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置uwsgi服务器的协议和地址。  作为<code>*protocol*</code> ，可以指定“ <code>suwsgi</code> ”或“ <code>suwsgi</code> ”（安全的<code>suwsgi</code> over SSL）。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">uwsgi_pass localhost:9000;
uwsgi_pass uwsgi://localhost:9000;
uwsgi_pass suwsgi://[2001:db8::1]:9090;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">uwsgi_pass unix:/tmp/uwsgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<blockquote>
<p>  从版本1.5.8开始支持安全的uwsgi协议。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将来自uwsgi服务器的<a href="#uwsgi_hide_header">其他禁用的</a>头字段传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给uwsgi服务器。  另请参见<a href="#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给uwsgi服务器。  另请参见<a href="#uwsgi_pass_request_body">uwsgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从uwsgi服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果uwsgi服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到uwsgi服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到uwsgi服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#uwsgi_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到uwsgi服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果uwsgi服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  为uwsgi服务器的传出连接配置“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对安全的uwsgi服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对安全的uwsgi服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  指定对安全的uwsgi服务器的请求的启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#uwsgi_ssl_verify">验证</a>受保护的uwsgi服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_name host from uwsgi_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  允许覆盖用于<a href="#uwsgi_ssl_verify">验证</a>安全uwsgi服务器证书的服务器名称，并在与安全uwsgi服务器建立连接时<a href="#uwsgi_ssl_server_name">通过SNI</a>传递。 </p>
<p>  默认情况下，使用<a href="#uwsgi_pass">uwsgi_pass</a>的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  为安全的uwsgi服务器启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在与安全的uwsgi服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.8版本中。 </p>
<p>  确定在使用安全的uwsgi服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#uwsgi_ssl_verify">验证</a>安全uwsgi服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  启用或禁用安全uwsgi服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在安全的uwsgi服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_store** on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">uwsgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，保存的文件和保存临时文件的目录（由<a href="#uwsgi_temp_path">uwsgi_temp_path</a>指令设置）都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = /fetch$uri;
}

location /fetch/ {
    internal;

    uwsgi_pass         backend:9000;
    ...

    uwsgi_store        on;
    uwsgi_store_access user:rw group:rw all:r;
    uwsgi_temp_path    /data/temp;

    alias              /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">uwsgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">uwsgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从uwsgi服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>受<a href="#uwsgi_buffer_size">uwsgi_buffer_size</a>和<a href="#uwsgi_buffers">uwsgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uwsgi_temp_path**  *path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uwsgi_temp_path uwsgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从uwsgi服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">uwsgi_temp_path /spool/nginx/uwsgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/uwsgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#uwsgi_cache_path">uwsgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_userid_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_userid_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_userid_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-userid-module"><a href="#Module-ngx-http-userid-module" class="headerlink" title="Module ngx_http_userid_module"></a>Module ngx_http_userid_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#userid">userid</a> <br>     <a href="#userid_domain">userid_domain</a> <br>     <a href="#userid_expires">userid_expires</a> <br>     <a href="#userid_mark">userid_mark</a> <br>     <a href="#userid_name">userid_name</a> <br>     <a href="#userid_p3p">userid_p3p</a> <br>     <a href="#userid_path">userid_path</a> <br>     <a href="#userid_service">userid_service</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_userid_module</code>模块设置适合客户端识别的cookie。  可以使用嵌入变量<a href="#var_uid_got">$ uid_got</a>和<a href="#var_uid_set">$ uid_set</a>记录已接收和设置的cookie。  该模块与Apache的<a href="http://www.lexa.ru/programs/mod-uid-eng.html" target="_blank" rel="noopener">mod_uid</a>模块兼容。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">userid         on;
userid_name    uid;
userid_domain  example.com;
userid_path    /;
userid_expires 365d;
userid_p3p     'policyref="/w3c/p3p.xml", CP="CUR ADM OUR NOR STA NID"';
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid** on</code> |    <code>v1</code> |    <code>log</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用设置cookie并记录收到的cookie： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_domain*name*</code> | <code>none</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_domain none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义为其设置cookie的域。   <code>none</code>参数禁用cookie的域设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_expires*time*</code> | <code>max</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_expires off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置浏览器保留cookie的时间。  参数<code>max</code>将导致cookie在“ <code>31 Dec 2037 23:55:55 GMT</code> ”到期。  参数<code>off</code>将导致cookie在浏览器会话结束时到期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_mark**  *letter*</code> | <code>*digit*</code> |    <code>=</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_mark off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果参数未<code>off</code> ，则启用cookie标记机制并设置用作标记的字符。  此机制用于在保留客户端标识符的同时添加或更改<a href="#userid_p3p">userid_p3p</a>和/或cookie过期时间。  标记可以是英文字母（区分大小写），数字或“ <code>=</code> ”字符的任何字母。 </p>
<p>  如果设置了标记，则将其与cookie中传递的客户端标识符的base64表示中的第一个填充符号进行比较。  如果它们不匹配，则会使用指定的标记，到期时间和“P3P”标头重新发送cookie。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_name uid;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置cookie名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_p3p*string*</code> | <code>none</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_p3p none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将与cookie一起发送的“P3P”标题字段的值。  如果指令设置为特殊值<code>none</code> ，则不会在响应中发送“P3P”标头。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_path*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_path /;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义cookie的设置路径。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**userid_service*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">userid_service IP address of the server;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果标识符由多个服务器（服务）发出，则应为每个服务分配其自己的<code>*number*</code>以确保客户端标识符是唯一的。  对于版本1 cookie，默认值为零。  对于版本2 cookie，默认值是由服务器IP地址的最后四个八位字节组成的数字。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_userid_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-module"><a href="#Module-ngx-http-upstream-module" class="headerlink" title="Module ngx_http_upstream_module"></a>Module ngx_http_upstream_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream">upstream</a> <br>     <a href="#server">server</a> <br>     <a href="#zone">zone</a> <br>     <a href="#state">state</a> <br>     <a href="#hash">hash</a> <br>     <a href="#ip_hash">ip_hash</a> <br>     <a href="#keepalive">keepalive</a> <br>     <a href="#keepalive_requests">keepalive_requests</a> <br>     <a href="#keepalive_timeout">keepalive_timeout</a> <br>     <a href="#ntlm">ntlm</a> <br>     <a href="#least_conn">least_conn</a> <br>     <a href="#least_time">least_time</a> <br>     <a href="#queue">queue</a> <br>     <a href="#random">random</a> <br>     <a href="#sticky">sticky</a> <br>     <a href="#sticky_cookie_insert">sticky_cookie_insert</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_upstream_module</code>模块用于定义可由<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>和<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>指令引用的服务器组。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream **backend** {
    server backend1.example.com       weight=5;
    server backend2.example.com:8080;
    server unix:/tmp/backend3;

    server backup1.example.com:8080   backup;
    server backup2.example.com:8080   backup;
}

server {
    location / {
        proxy_pass http:// **backend** ;
    }
}
</pre>



<p>  具有定期<a href="ngx_http_upstream_hc_module.html">运行状况检查的</a>动态可配置组可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分： </p>
<pre class="notranslate">resolver 10.0.0.1;

upstream **dynamic** {
    zone upstream_dynamic 64k;

    server backend1.example.com      weight=5;
    server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
    server 192.0.2.1                 max_fails=3;
    server backend3.example.com      resolve;
    server backend4.example.com      service=http resolve;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
}

server {
    location / {
        proxy_pass http:// **dynamic** ;
        health_check;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义一组服务器。  服务器可以侦听不同的端口。  此外，可以混合侦听TCP和UNIX域套接字的服务器。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com weight=5;
    server 127.0.0.1:8080       max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend3;

    server backup1.example.com  backup;
}
</pre>



<p>  默认情况下，使用加权循环平衡方法在服务器之间分配请求。  在上面的示例中，每个7个请求将按如下方式分发：5个请求转到<code>backend1.example.com</code> ，1个请求转发给第二个和第三个服务器。  如果在与服务器通信期间发生错误，请求将被传递到下一个服务器，依此类推，直到将尝试所有正常运行的服务器。  如果无法从任何服务器获得成功的响应，则客户端将接收与最后一个服务器的通信结果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**server*address*</code> [ <code>*parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  定义服务器的<code>*address*</code>和其他<code>*parameters*</code> 。  可以将地址指定为域名或IP地址，带有可选端口，或者指定为“ <code>unix:</code> ”前缀后指定的UNIX域套接字路径。  如果未指定端口，则使用端口80。  解析为多个IP地址的域名一次定义多个服务器。 </p>
<p>  可以定义以下参数： </p>
<blockquote>
<p>  如果启用了<a href="#keepalive">空闲keepalive</a>连接，多个<a href="ngx_core_module.html#worker_processes">工作程序</a>和<a href="#zone">共享内存</a> ，则代理服务器的活动和空闲连接总数可能会超过<code>max_conns</code>值。 </p>
<p>  自版本1.5.9和版本1.11.5之前，此参数作为我们的<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
<ul>
<li>指定数量的不成功尝试与服务器通信的时间应该考虑服务器不可用; -   以及服务器被视为不可用的时间段。 </li>
</ul>
</blockquote>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<p>  要使此参数起作用，必须在<a href="ngx_http_core_module.html#http">http</a>块中指定<a href="ngx_http_core_module.html#resolver">解析程序</a>指令。  例： </p>
<pre class="notranslate">http {
    resolver 10.0.0.1;

    upstream u {
        zone ...;
        ...
        server example.com resolve;
    }
}
</pre>



<p>  如果服务名称不包含点（“ <code>.</code> ”），则构造符合<a href="https://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC</a>的名称，并将TCP协议添加到服务前缀。  例如，要查找<code>_http._tcp.backend.example.com</code> SRV记录，必须指定该指令： </p>
<pre class="notranslate">server backend.example.com service=http resolve;
</pre>

<p>  如果服务名称包含一个或多个点，则通过加入服务前缀和服务器名称来构造名称。  例如，要查找<code>_http._tcp.backend.example.com</code>和<code>server1.backend.example.com</code> SRV记录，必须指定指令： </p>
<pre class="notranslate">server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</pre>



<p>  最高优先级SRV记录（具有相同最低优先级值的记录）将被解析为主服务器，其余SRV记录将被解析为备份服务器。  如果为服务器指定了<a href="#backup">backup</a>参数，则高优先级SRV记录将解析为备份服务器，其余SRV记录将被忽略。 </p>
<blockquote>
<p>  该参数不能与<a href="#hash">hash</a>和<a href="#ip_hash">ip_hash</a>负载平衡方法一起使用。 </p>
<p>  在1.13.6版之前，只能使用<a href="ngx_http_api_module.html">API</a>模块更改参数。 </p>
<p>  如果组中只有一个服务器，则忽略<code>max_fails</code> ， <code>fail_timeout</code>和<code>slow_start</code>参数，并且永远不会将此类服务器视为不可用。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**zone*name*</code> [ <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.0版本中。 </p>
<p>  定义共享内存区域的<code>*name*</code>和<code>*size*</code> ，该区域保持组工作进程之间共享的组配置和运行时状态。  几个组可能共享同一个区域。  在这种情况下，仅指定一次<code>*size*</code>就足够了。 </p>
<p>  此外，作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动nginx。  可通过<a href="ngx_http_api_module.html">API</a>模块（1.13.3）访问该配置。 </p>
<blockquote>
<p>  在1.13.3版之前，只能通过<a href="ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a>处理的特殊位置访问配置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**state*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  指定保持动态可配置组状态的<code>*file*</code> 。 </p>
<p>  例子： </p>
<pre class="notranslate">state /var/lib/nginx/state/servers.conf; # path for Linux
state /var/db/nginx/state/servers.conf;  # path for FreeBSD
</pre>



<p>  该状态目前仅限于具有其参数的服务器列表。  解析配置时会读取文件，每次<a href="ngx_http_api_module.html#http_upstreams_http_upstream_name_servers_">更改</a>上游配置时都会更新该文件。  应避免直接更改文件内容。  该指令不能与<a href="#server">server</a>指令一起使用。 </p>
<blockquote>
<p>   <a href="control.html#reconfiguration">配置重新加载</a>或<a href="control.html#upgrade">二进制升级</a>期间所做的更改可能会丢失。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hash*key*</code> [ <code>consistent</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.7.2版本中。 </p>
<p>  指定服务器组的负载平衡方法，其中客户端 - 服务器映射基于散列<code>*key*</code> 。   <code>*key*</code>可以包含文本，变量及其组合。  请注意，从组中添加或删除服务器可能会导致将大多数密钥重新映射到不同的服务器。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached" target="_blank" rel="noopener">Cache :: Memcached</a> Perl库兼容。 </p>
<p>  如果指定了<code>consistent</code>参数，则将使用<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="noopener">ketama</a>一致性哈希方法。  该方法确保在向组添加服务器或从组中删除服务器时，只有少数密钥将重新映射到不同的服务器。  这有助于为缓存服务器实现更高的缓存命中率。  该方法与<a href="https://metacpan.org/pod/Cache::Memcached::Fast" target="_blank" rel="noopener">Cache :: Memcached :: Fast</a> Perl库兼容，并将<code>*ketama_points*</code>参数设置为160。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ip_hash** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  指定组应使用负载平衡方法，其中请求根据客户端IP地址在服务器之间分配。  客户端IPv4地址的前三个八位字节或整个IPv6地址用作散列密钥。  该方法确保来自同一客户端的请求将始终传递到同一服务器，除非此服务器不可用。  在后一种情况下，客户端请求将被传递到另一个服务器。  最有可能的是，它也将始终是同一台服务器。 </p>
<blockquote>
<p>  从版本1.3.2和1.2.2开始支持IPv6地址。 </p>
</blockquote>
<p>  如果需要临时删除其中一个服务器，则应使用<code>down</code>参数对其进行标记，以保留客户端IP地址的当前哈希值。 </p>
<p>  例： </p>
<pre class="notranslate">upstream backend {
    ip_hash;

    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com **down** ;
    server backend4.example.com;
}
</pre>





<blockquote>
<p>  在版本1.3.1和1.2.2之前，无法使用<code>ip_hash</code>负载平衡方法为服务器指定权重。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive*connections*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  激活缓存以连接到上游服务器。 </p>
<p>   <code>*connections*</code>参数设置在每个工作进程的缓存中保留的上游服务器的最大空闲keepalive连接数。  超过此数量时，将关闭最近最少使用的连接。 </p>
<blockquote>
<p>  应特别注意的是， <code>keepalive</code>指令不限制nginx工作进程可以打开的上游服务器的连接总数。   <code>*connections*</code>参数应设置为足够小的数字，以便上游服务器也可以处理新的传入连接。 </p>
</blockquote>
<p>  使用keepalive连接的memcached上游示例配置： </p>
<pre class="notranslate">upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;

    keepalive 32;
}

server {
    ...

    location /memcached/ {
        set $memcached_key $uri;
        memcached_pass memcached_backend;
    }

}
</pre>



<p>  对于HTTP， <a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>指令应设置为“ <code>1.1</code> ”，并且应清除“Connection”头字段： </p>
<pre class="notranslate">upstream http_backend {
    server 127.0.0.1:8080;

    keepalive 16;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre>





<blockquote>
<p>  或者，可以通过将“Connection：Keep-Alive”头字段传递给上游服务器来使用HTTP / 1.0持久连接，但不建议使用此方法。 </p>
</blockquote>
<p>  对于FastCGI服务器，需要设置<a href="ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a>才能使keepalive连接正常工作： </p>
<pre class="notranslate">upstream fastcgi_backend {
    server 127.0.0.1:9000;

    keepalive 8;
}

server {
    ...

    location /fastcgi/ {
        fastcgi_pass fastcgi_backend;
        fastcgi_keep_conn on;
        ...
    }
}
</pre>





<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>keepalive</code>指令之前激活它们。 </p>
<p>   SCGI和uwsgi协议没有keepalive连接的概念。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">keepalive_requests 100;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  设置可通过一个keepalive连接提供的最大请求数。  在发出最大请求数后，将关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keepalive_timeout*timeout*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">keepalive_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  设置超时，在此期间与上游服务器的空闲keepalive连接将保持打开状态。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ntlm** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.9.2版本中。 </p>
<p>  允许使用<a href="https://en.wikipedia.org/wiki/Integrated_Windows_Authentication" target="_blank" rel="noopener">NTLM身份验证</a>代理请求。  一旦客户端发送具有以“ <code>Negotiate</code> ”或“ <code>NTLM</code> ”开头的“Authorization”头字段值的请求，上游连接就绑定到客户端连接。  进一步的客户端请求将通过相同的上游连接进行代理，从而保持身份验证上下文。 </p>
<p>  为了使NTLM身份验证起作用，必须启用与上游服务器的keepalive连接。   <a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>指令应设置为“ <code>1.1</code> ”，并且应清除“Connection”头字段： </p>
<pre class="notranslate">upstream http_backend {
    server 127.0.0.1:8080;

    ntlm;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre>





<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>ntlm</code>指令之前激活它们。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_conn** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.3.1和1.2.2版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将请求传递到具有最少活动连接的服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**least_time** header</code> |    <code>last_byte</code>    [ <code>inflight</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.7.10版本中。 </p>
<p>  指定组应使用负载平衡方法，其中请求以最少的平均响应时间和最少的活动连接传递给服务器，同时考虑服务器的权重。  如果有多个这样的服务器，则使用加权循环平衡方法依次尝试它们。 </p>
<p>  如果指定了<code>header</code>参数，则使用接收<a href="#var_upstream_header_time">响应头的</a>时间。  如果指定了<code>last_byte</code>参数，则使用接收<a href="#var_upstream_response_time">完整响应的</a>时间。  如果指定了<code>inflight</code>参数（1.11.6），则还会考虑不完整的请求。 </p>
<blockquote>
<p>  在1.11.6版之前，默认情况下会考虑不完整的请求。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**queue*number*</code>[ <code>timeout</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.5.12版本中。 </p>
<p>  如果在处理请求时无法立即选择上游服务器，则请求将被放入队列中。  该指令指定了可以同时在队列中的最大请求<code>*number*</code> 。  如果队列已满，或者在<code>timeout</code>参数中指定的时间段内无法选择要传递请求的服务器，则会将502（错误网关）错误返回给客户端。 </p>
<p>   <code>timeout</code>参数的默认值为60秒。 </p>
<blockquote>
<p>  使用除默认循环方法之外的负载平衡器方法时，必须在<code>queue</code>指令之前激活它们。 </p>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random** [ two</code> [ <code>*method*</code> ]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.15.1版本中。 </p>
<p>  指定组应使用负载平衡方法，其中将请求传递给随机选择的服务器，同时考虑服务器的权重。 </p>
<p>  可选的<code>two</code>参数指示nginx随机选择<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="noopener">两个</a>服务器，然后使用指定的<code>method</code>选择服务器。  默认方法是<code>least_conn</code> ，它将请求传递给活动连接数最少的服务器。 </p>
<p>   <code>least_time</code>方法将请求传递给具有最少平均响应时间和最少活动连接数的服务器。  如果指定了<code>least_time=header</code> ，则使用接收<a href="#var_upstream_header_time">响应头</a>的时间。  如果指定了<code>least_time=last_byte</code> ，则使用接收<a href="#var_upstream_response_time">完整响应</a>的时间。 </p>
<blockquote>
<p>   <code>least_time</code>方法可作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅</a>的一部分。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sticky** cookie</code> <code>*name*</code>    [ <code>expires=</code> <code>*time*</code> ]    [ <code>domain=</code> <code>*domain*</code> ]    [ <code>httponly</code> ]    [ <code>secure</code> ]    [ <code>path=</code> <code>*path*</code> ]; <br> <code>**sticky** route</code> <code>*$variable*</code> …; <br> <code>**sticky** learn</code>    <code>create=</code> <code>*$variable*</code>    <code>lookup=</code> <code>*$variable*</code>    <code>zone=</code> <code>*name*</code> : <code>*size*</code>    [ <code>timeout=</code> <code>*time*</code> ]    [ <code>header</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  启用会话关联，这会将来自同一客户端的请求传递到一组服务器中的同一服务器。  有三种方法可供选择： </p>
<p>  使用<code>cookie</code>方法时，有关指定服务器的信息将在nginx生成的HTTP cookie中传递： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com;
    server backend2.example.com;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre>



<p>  来自尚未绑定到特定服务器的客户端的请求将传递到由配置的balance方法选择的服务器。  使用此cookie的进一步请求将传递到指定的服务器。  如果指定的服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
<p>  第一个参数设置要设置或检查的cookie的名称。   cookie值是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。  但是，如果指定了<a href="#server">server</a>指令的“ <code>route</code> ”参数，则cookie值将是“ <code>route</code> ”参数的值： </p>
<pre class="notranslate">upstream backend {
    server backend1.example.com route= **a** ;
    server backend2.example.com route= **b** ;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre>

<p>  在这种情况下，“ <code>srv_id</code> ”cookie的值将是<code>*a*</code>或<code>*b*</code> 。 </p>
<p>  其他参数可能如下： </p>
<p>  如果省略任何参数，则不会设置相应的cookie字段。 </p>
<p>  使用<code>route</code>方法时，代理服务器在收到第一个请求时为客户端分配路由。  来自此客户端的所有后续请求将在cookie或URI中携带路由信息。  将此信息与<a href="#server">服务器</a>指令的“ <code>route</code> ”参数进行比较，以标识应将请求代理到的服务器。  如果未指定“ <code>route</code> ”参数，则路由名称将是IP地址和端口的MD5哈希值或UNIX域套接字路径的十六进制表示形式。  如果指定的服务器无法处理请求，则配置的平衡方法将选择新服务器，就好像请求中没有路由信息一样。 </p>
<p>   <code>route</code>方法的参数指定可能包含路由信息的变量。  第一个非空变量用于查找匹配服务器。 </p>
<p>  例： </p>
<pre class="notranslate">map $cookie_jsessionid $route_cookie {
    ~.+\.(?P&lt;route&gt;\w+)$ $route;
}

map $request_uri $route_uri {
    ~jsessionid=.+\.(?P&lt;route&gt;\w+)$ $route;
}

upstream backend {
    server backend1.example.com route=a;
    server backend2.example.com route=b;

    sticky route $route_cookie $route_uri;
}
</pre>

<p>  这里，路由取自“ <code>JSESSIONID</code> ”cookie（如果请求中存在）。  否则，使用来自URI的路由。 </p>
<p>  当使用<code>learn</code>方法（1.7.1）时，nginx会分析上游服务器响应并学习通常在HTTP cookie中传递的服务器启动的会话。 </p>
<pre class="notranslate">upstream backend {
   server backend1.example.com:8080;
   server backend2.example.com:8081;

   sticky learn
          create=$upstream_cookie_examplecookie
          lookup=$cookie_examplecookie
          zone=client_sessions:1m;
}
</pre>

<p>  在该示例中，上游服务器通过在响应中设置cookie“ <code>EXAMPLECOOKIE</code> ”来创建会话。  使用此cookie的进一步请求将传递到同一服务器。  如果服务器无法处理请求，则选择新服务器，就好像客户端尚未绑定一样。 </p>
<p>  参数<code>create</code>和<code>lookup</code>指定分别指示如何创建新会话和搜索现有会话的变量。  两个参数可以多次指定，在这种情况下使用第一个非空变量。 </p>
<p>  会话存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>zone</code>参数配置。  一兆字节区域可以在64位平台上存储大约4000个会话。  在<code>timeout</code>参数指定的时间内未访问的会话将从区域中删除。  默认情况下， <code>timeout</code>设置为10分钟。 </p>
<p>   <code>header</code>参数（1.13.1）允许在从上游服务器接收响应头之后立即创建会话。 </p>
<p>   <code>sync</code>参数（1.13.8）启用共享内存区域的<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a> 。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sticky_cookie_insert*name*</code>[ <code>expires=</code> <code>*time*</code> ][ <code>domain=</code> <code>*domain*</code> ][ <code>path=</code> <code>*path*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>upstream</code> <br>                </td></p>
<p>  从1.5.7版开始，该指令已过时。  应该使用具有新语法的等效<a href="#sticky">粘性</a>指令： </p>
<blockquote>
<p>   <code>sticky cookie</code> <code>*name*</code> [ <code>expires=</code> <code>*time*</code> ] [ <code>domain=</code> <code>*domain*</code> ] [ <code>path=</code> <code>*path*</code> ]; </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_upstream_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_hc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_hc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_hc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-hc-module"><a href="#Module-ngx-http-upstream-hc-module" class="headerlink" title="Module ngx_http_upstream_hc_module"></a>Module ngx_http_upstream_hc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#health_check">health_check</a> <br>     <a href="#match">match</a> <br></td>

<p>   <code>ngx_http_upstream_hc_module</code>模块允许对周围位置中引用的<a href="ngx_http_upstream_module.html#upstream">组</a>中的服务器进行定期运行状况检查。  服务器组必须驻留在<a href="ngx_http_upstream_module.html#zone">共享内存中</a> 。 </p>
<p>  如果运行状况检查失败，则服务器将被视为运行状况不佳。  如果为同一组服务器定义了多个运行状况检查，则任何检查的单个故障都将使相应的服务器被视为不健康。  客户端请求不会传递到处于“检查”状态的不健康服务器和服务器。 </p>
<blockquote>
<p>  请注意，与健康检查一起使用时，大多数变量都将具有空值。 </p>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream dynamic {
    zone upstream_dynamic 64k;

    server backend1.example.com      weight=5;
    server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
    server 192.0.2.1                 max_fails=3;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
}

server {
    location / {
        proxy_pass http://dynamic;
        health_check;
    }
}
</pre>

<p>  使用此配置，nginx将每隔五秒向<code>backend</code>组中的每个服务器发送“ <code>/</code> ”请求。  如果发生任何通信错误或超时，或者代理服务器使用2xx或3xx以外的状态代码进行响应，运行状况检查将失败，并且服务器将被视为运行状况不佳。 </p>
<p>  可以配置运行状况检查以测试响应的状态代码，某些标题字段及其值的存在以及正文内容。  测试使用<a href="#match">match</a>伪指令单独配置，并在<a href="#health_check">health_check</a>指令的<code>match</code>参数中引用： </p>
<pre class="notranslate">http {
    server {
    ...
        location / {
            proxy_pass http://backend;
            health_check match=welcome;
        }
    }

    match welcome {
        status 200;
        header Content-Type = text/html;
        body ~ "Welcome to nginx!";
    }
}
</pre>

<p>  此配置显示，为了通过运行状况检查，对运行状况检查请求的响应应该成功，状态为200，并包含“ <code>Welcome to nginx!</code>   “ 在身体里。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**health_check** [ *parameters*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  启用对周围位置中引用的<a href="ngx_http_upstream_module.html#upstream">组</a>中的服务器的定期运行状况检查。 </p>
<p>  支持以下可选参数： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**match*name*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义用于验证对运行状况检查请求的响应的命名测试集。 </p>
<p>  可以在响应中测试以下项目： </p>
<p>  如果指定了多个测试，则响应仅在匹配所有测试时才匹配。 </p>
<blockquote>
<p>  仅检查响应体的前256k。 </p>
</blockquote>
<p>  例子： </p>
<pre class="notranslate"># status is 200, content type is "text/html",
# and body contains "Welcome to nginx!"
match welcome {
    status 200;
    header Content-Type = text/html;
    body ~ "Welcome to nginx!";
}
</pre>



<pre class="notranslate"># status is not one of 301, 302, 303, or 307, and header does not have "Refresh:"
match not_redirect {
    status ! 301-303 307;
    header ! Refresh;
}
</pre>



<pre class="notranslate"># status ok and not in maintenance mode
match server_ok {
    status 200-399;
    body !~ "maintenance mode";
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_upstream_conf_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_upstream_conf_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_upstream_conf_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-upstream-conf-module"><a href="#Module-ngx-http-upstream-conf-module" class="headerlink" title="Module ngx_http_upstream_conf_module"></a>Module ngx_http_upstream_conf_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#upstream_conf">upstream_conf</a> <br></td>

<p>   <code>ngx_http_upstream_conf_module</code>模块允许通过简单的HTTP接口即时配置上游服务器组，而无需重新启动nginx。   <a href="ngx_http_upstream_module.html#zone">http</a>或<a href="stream/ngx_stream_upstream_module.html#zone">流</a>服务器组必须驻留在共享内存中。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供，直到1.13.10。  它被1.13.3中的<a href="ngx_http_api_module.html">ngx_http_api_module</a>模块取代。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">upstream backend {
    zone upstream_backend 64k;

    ...
}

server {
    location /upstream_conf {
        **upstream_conf** ;
        allow 127.0.0.1;
        deny all;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**upstream_conf** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的上游配置的HTTP接口。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p>  配置命令可用于： </p>
<ul>
<li>查看组配置; -   查看，修改或删除服务器; -   添加新服务器。 </li>
</ul>
<blockquote>
<p>  由于组中的地址不需要是唯一的，因此组中的特定服务器由其ID引用。  添加新服务器或查看组配置时，会自动分配ID并显示ID。 </p>
</blockquote>
<p>  配置命令由作为请求参数传递的参数组成，例如： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend
</pre>



<p>  支持以下参数： </p>
<blockquote>
<p>  在1.7.2版之前，还需要<code>backup=</code>来查看，修改或删除现有备份服务器。 </p>
</blockquote>
<p>  添加服务器时，可以将其指定为域名。  在这种情况下，将监视与域名对应的IP地址的更改并自动应用于上游配置，而无需重新启动nginx（1.7.2）。  这需要<a href="ngx_http_core_module.html#resolver">http</a>或<a href="stream/ngx_stream_core_module.html#resolver">流</a>块中的“ <code>resolver</code> ”指令。  另请参阅<a href="ngx_http_upstream_module.html#resolve">http</a>或<a href="stream/ngx_stream_upstream_module.html#resolve">流</a>上游服务器的“ <code>resolve</code> ”参数。 </p>
<p>  前三个参数选择一个对象。  这可以是整个http或流上游服务器组，也可以是特定服务器。  如果没有其他参数，则会显示所选组或服务器的配置。 </p>
<p>  例如，要查看整个组的配置，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend
</pre>

<p>  要查看特定服务器的配置，还要指定其ID： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42
</pre>



<p>  要添加新服务器，请在“ <code>server=</code> ”参数中指定其地址。  如果未指定其他参数，将添加服务器，并将其他参数设置为其默认值（请参阅<a href="ngx_http_upstream_module.html#server">http</a>或<a href="stream/ngx_stream_upstream_module.html#server">流</a> “ <code>server</code> ”指令）。 </p>
<p>  例如，要添加新的主服务器，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080
</pre>

<p>  要添加新的备份服务器，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;backup=&amp;server=127.0.0.1:8080
</pre>

<p>  要添加新的主服务器，请将其参数设置为非默认值并将其标记为“ <code>down</code> ”，发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?add=&amp;upstream=backend&amp;server=127.0.0.1:8080&amp;weight=2&amp;down=
</pre>

<p>  要删除服务器，请指定其ID： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?remove=&amp;upstream=backend&amp;id=42
</pre>

<p>  要将现有服务器标记为“ <code>down</code> ”，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;down=
</pre>

<p>  要修改现有服务器的地址，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;server=192.0.2.3:8123
</pre>

<p>  要修改现有服务器的其他参数，请发送： </p>
<pre class="notranslate">http://127.0.0.1/upstream_conf?upstream=backend&amp;id=42&amp;max_fails=3&amp;weight=4
</pre>

<p>  以上示例适用于<a href="ngx_http_upstream_module.html">http</a>上游服务器组。   <a href="stream/ngx_stream_upstream_module.html">流</a>上游服务器组的类似示例需要“ <code>stream=</code> ”参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_sub_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_sub_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_sub_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-sub-module"><a href="#Module-ngx-http-sub-module" class="headerlink" title="Module ngx_http_sub_module"></a>Module ngx_http_sub_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#sub_filter">sub_filter</a> <br>     <a href="#sub_filter_last_modified">sub_filter_last_modified</a> <br>     <a href="#sub_filter_once">sub_filter_once</a> <br>     <a href="#sub_filter_types">sub_filter_types</a> <br></td>

<p>   <code>ngx_http_sub_module</code>模块是一个过滤器，它通过将一个指定的字符串替换为另一个来修改响应。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_sub_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    sub_filter '&lt;a href="http://127.0.0.1:8080/'  '&lt;a href="https://$host/';
    sub_filter '&lt;img src="http://127.0.0.1:8080/' '&lt;img src="https://$host/';
    sub_filter_once on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter*string*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置要替换的字符串和替换字符串。  忽略大小写匹配的字符串匹配。  要替换的字符串（1.9.4）和替换字符串可以包含变量。  可以在一个配置级别（1.9.4）上指定几个<code>sub_filter</code>指令。  当且仅当在当前级别上没有定义<code>sub_filter</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在替换期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在处理期间修改响应的内容时，将删除标头字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_onceon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_once on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是查找要重复替换的每个字符串。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sub_filter_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">sub_filter_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还在具有指定MIME类型的响应中启用字符串替换。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_stub_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_stub_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_stub_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-stub-status-module"><a href="#Module-ngx-http-stub-status-module" class="headerlink" title="Module ngx_http_stub_status_module"></a>Module ngx_http_stub_status_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#stub_status">stub_status</a> <br> <a href="#data">Data</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_stub_status_module</code>模块提供对基本状态信息的访问。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_stub_status_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location = /basic_status {
    stub_status;
}
</pre>

<p>  此配置创建一个简单的网页，其基本状态数据可能如下所示： </p>
<pre class="notranslate">Active connections: 291 
server accepts handled requests
 16630948 16630948 31070465 
Reading: 6 Writing: 179 Waiting: 106 
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**stub_status** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  可从周围位置访问基本状态信息。 </p>
<blockquote>
<p>  在1.7.5之前的版本中，指令语法需要任意参数，例如“ <code>stub_status on</code> ”。 </p>
</blockquote>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>  提供以下状态信息： </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_stub_status_module</code>模块支持以下嵌入变量（1.3.14）： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_status_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_status_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_status_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-status-module"><a href="#Module-ngx-http-status-module" class="headerlink" title="Module ngx_http_status_module"></a>Module ngx_http_status_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#status">status</a> <br>     <a href="#status_format">status_format</a> <br>     <a href="#status_zone">status_zone</a> <br> <a href="#data">Data</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>   <code>ngx_http_status_module</code>模块提供对各种状态信息的访问。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供，直到1.13.10。  它被1.13.3中的<a href="ngx_http_api_module.html">ngx_http_api_module</a>模块取代。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    upstream **backend** {
        **zone** http_backend 64k;

        server backend1.example.com weight=5;
        server backend2.example.com;
    }

    proxy_cache_path /data/nginx/cache_backend keys_zone= **cache_backend** :10m;

    server {
        server_name backend.example.com;

        location / {
            proxy_pass  http://backend;
            proxy_cache cache_backend;

            health_check;
        }

        **status_zone server_backend;**
    }

    server {
        listen 127.0.0.1;

        location /upstream_conf {
            upstream_conf;
        }

        location /status {
            status;
        }

        location = /status.html {
        }
    }
}

stream {
    upstream **backend** {
        **zone** stream_backend 64k;

        server backend1.example.com:12345 weight=5;
        server backend2.example.com:12345;
    }

    server {
        listen      127.0.0.1:12345;
        proxy_pass  backend;
        **status_zone server_backend;**
        health_check;
    }
}
</pre>



<p>  使用此配置的状态请求示例： </p>
<pre class="notranslate">http://127.0.0.1/status
http://127.0.0.1/status/nginx_version
http://127.0.0.1/status/caches/cache_backend
http://127.0.0.1/status/upstreams
http://127.0.0.1/status/upstreams/backend
http://127.0.0.1/status/upstreams/backend/peers/1
http://127.0.0.1/status/upstreams/backend/peers/1/weight
http://127.0.0.1/status/stream
http://127.0.0.1/status/stream/upstreams
http://127.0.0.1/status/stream/upstreams/backend
http://127.0.0.1/status/stream/upstreams/backend/peers/1
http://127.0.0.1/status/stream/upstreams/backend/peers/1/weight
</pre>



<p>  简单监视页面随附此发行版一起提供，可在默认配置中以“ <code>/status.html</code> ”身份访问。  它需要配置位置“ <code>/status</code> ”和“ <code>/status.html</code> ”，如上所示。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  可以从周围的位置访问状态信息。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status_formatjson</code> ; <br> <code>**status_formatjsonp</code> [ <code>*callback*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">status_format json;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，状态信息以JSON格式输出。 </p>
<p>  或者，数据可以输出为JSONP。   <code>*callback*</code>参数指定回调函数的名称。  该值可以包含变量。  如果省略参数，或者计算的值是空字符串，则使用“ <code>ngx_status_jsonp_callback</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**status_zone*zone*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> <br>                </td></p>
<p>  允许在指定<code>*zone*</code>收集虚拟<a href="ngx_http_core_module.html#server">http</a>或<a href="stream/ngx_stream_core_module.html#server">流</a> （1.7.11）服务器状态信息。  多个服务器可能共享同一个区域。 </p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>  提供以下状态信息： </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li><a href="#version">版本</a> 8中添加了<a href="#upstreams">http</a>和<a href="#stream_upstreams">流</a>上游中的<a href="#zone">区域</a>字段。 -    <a href="#version">版本</a> 8中添加了<a href="#slabs">slab</a>状态数据。 -    <a href="#version">版本</a> 8中添加了<a href="#state">检查</a>状态。 -    <a href="#version">版本</a> 8中添加了<a href="#upstreams">http</a>和<a href="#stream_upstreams">流</a>上游中的<a href="#name">名称</a>和<a href="#service">服务</a>字段。 -    <a href="#version">版本</a> 8中添加了<a href="#nginx_build">nginx_build</a>和<a href="#ppid">ppid</a>字段。 -    <a href="#version">版本</a> 7中添加了<a href="#sessions">会话</a>状态数据和流<a href="#stream_server_zones">server_zones</a>中的<a href="#stream_discarded">丢弃</a>字段。 -    <a href="#zombies">僵尸</a>字段是从<a href="#version">版本</a> 6中的nginx <a href="debugging_log.html">调试</a>版本移动的。 -    <a href="#version">版本</a> 6中添加了<a href="#ssl">ssl</a>状态数据。 -    <a href="#server_zones">server_zones中</a>的<a href="#discarded">丢弃</a>字段已在<a href="#version">版本</a> 6中添加。 -    <a href="#queue">队列</a>状态数据已在<a href="#version">版本</a> 6中添加。 -    <a href="#pid">pid</a>字段已在<a href="#version">版本</a> 6中添加。 -    <a href="#upstreams">上游</a>中的服务器列表已移至<a href="#version">版本</a> 6中的<a href="#peers">对等项</a> 。 -   在<a href="#version">版本</a> 5中删除了上游服务器的<code>keepalive</code>字段。 -    <a href="#stream">流</a>状态数据已在<a href="#version">版本</a> 5中添加。 -    <a href="#generation">生成</a>字段已在<a href="#version">版本</a> 5中添加。 -    <a href="#processes">进程中</a>重新<a href="#respawned">生成的</a>字段已在<a href="#version">版本</a> 5中添加。 -    <a href="#version">版本</a> 5中添加了<a href="#upstreams">上游</a>中的<a href="#header_time">header_time</a>和<a href="#response_time">response_time</a>字段。 -    <a href="#version">版本</a> 4中添加了<a href="#upstreams">上游中</a>的<a href="#selected">选定</a>字段。 -    <a href="#version">版本</a> 4中添加了<a href="#upstreams">上游</a>的<a href="#state">排水</a>状态。 -    <a href="#upstreams">上游</a>中的<a href="#id">id</a>和<a href="#max_conns">max_conns</a>字段已在<a href="#version">版本</a> 3中添加。 -    <a href="#version">版本</a> 3中添加了<a href="#caches">缓存</a>中<code>revalidated</code>字段。 -    <a href="#version">版本</a> 2中添加了<a href="#server_zones">server_zones</a> ， <a href="#caches">caches</a>和<a href="#load_timestamp">load_timestamp</a>状态数据。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssl-module"><a href="#Module-ngx-http-ssl-module" class="headerlink" title="Module ngx_http_ssl_module"></a>Module ngx_http_ssl_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssl">ssl</a> <br>     <a href="#ssl_buffer_size">ssl_buffer_size</a> <br>     <a href="#ssl_certificate">ssl_certificate</a> <br>     <a href="#ssl_certificate_key">ssl_certificate_key</a> <br>     <a href="#ssl_ciphers">ssl_ciphers</a> <br>     <a href="#ssl_client_certificate">ssl_client_certificate</a> <br>     <a href="#ssl_crl">ssl_crl</a> <br>     <a href="#ssl_dhparam">ssl_dhparam</a> <br>     <a href="#ssl_early_data">ssl_early_data</a> <br>     <a href="#ssl_ecdh_curve">ssl_ecdh_curve</a> <br>     <a href="#ssl_password_file">ssl_password_file</a> <br>     <a href="#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> <br>     <a href="#ssl_protocols">ssl_protocols</a> <br>     <a href="#ssl_session_cache">ssl_session_cache</a> <br>     <a href="#ssl_session_ticket_key">ssl_session_ticket_key</a> <br>     <a href="#ssl_session_tickets">ssl_session_tickets</a> <br>     <a href="#ssl_session_timeout">ssl_session_timeout</a> <br>     <a href="#ssl_stapling">ssl_stapling</a> <br>     <a href="#ssl_stapling_file">ssl_stapling_file</a> <br>     <a href="#ssl_stapling_responder">ssl_stapling_responder</a> <br>     <a href="#ssl_stapling_verify">ssl_stapling_verify</a> <br>     <a href="#ssl_trusted_certificate">ssl_trusted_certificate</a> <br>     <a href="#ssl_verify_client">ssl_verify_client</a> <br>     <a href="#ssl_verify_depth">ssl_verify_depth</a> <br> <a href="#errors">Error Processing</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_ssl_module</code>模块为HTTPS提供必要的支持。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_ssl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  为减少处理器负载，建议使用 </p>
<ul>
<li>设置<a href="ngx_core_module.html#worker_processes">工作进程数</a>等于处理器数， -   启用<a href="ngx_http_core_module.html#keepalive_timeout">保持活动</a>连接， -   启用<a href="#ssl_session_cache_shared">共享</a>会话缓存， -   禁用<a href="#ssl_session_cache_builtin">内置</a>会话缓存， -   并可能增加会话<a href="#ssl_session_timeout">生命周期</a> （默认为5分钟）： </li>
</ul>
<pre class="notranslate"> **worker_processes auto;**

http {

    ...

    server {
        listen              443 ssl;
        **keepalive_timeout   70;**

        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
        ssl_certificate     /usr/local/nginx/conf/cert.pem;
        ssl_certificate_key /usr/local/nginx/conf/cert.key;
        **ssl_session_cache   shared:SSL:10m;**
        **ssl_session_timeout 10m;**

        ...
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**sslon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令在1.15.0版本中已过时。  应该使用<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_buffer_size 16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  设置用于发送数据的缓冲区的大小。 </p>
<p>  默认情况下，缓冲区大小为16k，这对应于发送大响应时的最小开销。  要最小化第一个字节的时间，使用较小的值可能是有益的，例如： </p>
<pre class="notranslate">ssl_buffer_size 4k;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定虚拟服务器的PEM格式的证书的<code>*file*</code> 。  如果除了主证书之外还应指定中间证书，则应按以下顺序在同一文件中指定它们：首先是主证书，然后是中间证书。   PEM格式的密钥可以放在同一文件中。 </p>
<p>  从版本1.11.0开始，可以多次指定此指令以加载不同类型的证书，例如，RSA和ECDSA： </p>
<pre class="notranslate">server {
    listen              443 ssl;
    server_name         example.com;

    ssl_certificate     example.com.rsa.crt;
    ssl_certificate_key example.com.rsa.key;

    ssl_certificate     example.com.ecdsa.crt;
    ssl_certificate_key example.com.ecdsa.key;

    ...
}
</pre>



<blockquote>
<p>  只有OpenSSL 1.0.2或更高版本支持不同<a href="configuring_https_servers.html#chains">证书的</a>单独<a href="configuring_https_servers.html#chains">证书链</a> 。  对于旧版本，只能使用一个证书链。 </p>
</blockquote>
<p>  应该记住，由于HTTPS协议对最大互操作性的限制，虚拟服务器应该监听<a href="configuring_https_servers.html#name_based_https_servers">不同的IP地址</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定具有给定虚拟服务器的PEM格式的密钥的<code>*file*</code> 。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ciphers HIGH:!aNULL:!MD5;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定启用的密码。  密码以OpenSSL库理解的格式指定，例如： </p>
<pre class="notranslate">ssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
</pre>



<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<blockquote>
<p>  以前版本的nginx默认使用<a href="configuring_https_servers.html#compatibility">不同的</a>密码。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_client_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  如果启用了<a href="#ssl_stapling">ssl_stapling，</a>则指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#ssl_verify_client">验证</a>客户端证书和OCSP响应。 </p>
<p>  证书列表将发送给客户。  如果不需要，可以使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.8.7版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#ssl_verify_client">验证</a>客户端证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_dhparam*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在0.7.2版本中。 </p>
<p>  为DHE密码指定具有DH参数的<code>*file*</code> 。 </p>
<p>  默认情况下，不设置任何参数，因此不会使用DHE密码。 </p>
<blockquote>
<p>  在1.11.0版之前，默认使用内置参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_early_dataon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_early_data off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.15.3版中。 </p>
<p>  启用或禁用TLS 1.3 <a href="https://tools.ietf.org/html/rfc8446#section-2.3" target="_blank" rel="noopener">早期数据</a> 。 </p>
<blockquote>
<p>  在早期数据中发送的请求会受到<a href="https://tools.ietf.org/html/rfc8470" target="_blank" rel="noopener">重播攻击</a> 。  为了防止应用程序层发生此类攻击，应使用<a href="#var_ssl_early_data">$ ssl_early_data</a>变量。 </p>
</blockquote>
<pre class="notranslate">proxy_set_header Early-Data $ssl_early_data;
</pre>



<blockquote>
<p>  使用OpenSSL 1.1.1或更高版本（1.15.4）和<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">BoringSSL</a>时，支持该指令。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_ecdh_curve*curve*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_ecdh_curve auto;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  指定ECDHE密码的<code>*curve*</code> 。 </p>
<p>  使用OpenSSL 1.0.2或更高版本时，可以指定多条曲线（1.11.0），例如： </p>
<pre class="notranslate">ssl_ecdh_curve prime256v1:secp384r1;
</pre>



<p>  特殊值<code>auto</code> （1.11.0）指示nginx在使用OpenSSL 1.0.2或更高版本时使用内置在OpenSSL库中的列表，或者使用旧版本的<code>prime256v1</code> 。 </p>
<blockquote>
<p>  在版本1.11.0之前，默认使用<code>prime256v1</code>曲线。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.7.3版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p>  例： </p>
<pre class="notranslate">http {
    ssl_password_file /etc/keys/global.pass;
    ...

    server {
        server_name www1.example.com;
        ssl_certificate_key /etc/keys/first.key;
    }

    server {
        server_name www2.example.com;

        # named pipe can also be used instead of a file
        ssl_password_file /etc/keys/fifo;
        ssl_certificate_key /etc/keys/second.key;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_prefer_server_cipherson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_prefer_server_ciphers off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  启用指定的协议。 </p>
<blockquote>
<p>   <code>TLSv1.1</code>和<code>TLSv1.2</code>参数（ <code>TLSv1.2</code> ）仅在使用OpenSSL 1.0.1或更高版本时有效。 </p>
<p>  仅当使用使用TLSv1.3支持构建的OpenSSL 1.1.1时， <code>TLSv1.3</code>参数（1.13.0）才有效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_cache** off</code> |    <code>none</code> |    [ <code>builtin</code> [: <code>*size*</code> ]]    [ <code>shared</code> : <code>*name*</code> : <code>*size*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_cache none;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置存储会话参数的缓存的类型和大小。  缓存可以是以下任何类型： </p>
<p>  两种缓存类型可以同时使用，例如： </p>
<pre class="notranslate">ssl_session_cache builtin:1000 shared:SSL:10m;
</pre>

<p>  但只使用没有内置缓存的共享缓存应该更有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticket_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  设置具有用于加密和解密TLS会话票证的密钥的<code>*file*</code> 。  如果必须在多个服务器之间共享相同的密钥，则该指令是必需的。  默认情况下，使用随机生成的密钥。 </p>
<p>  如果指定了多个密钥，则仅使用第一个密钥来加密TLS会话票证。  这允许配置键旋转，例如： </p>
<pre class="notranslate">ssl_session_ticket_key current.key;
ssl_session_ticket_key previous.key;
</pre>



<p>  该<code>*file*</code>必须包含80或48个字节的随机数据，并且可以使用以下命令创建： </p>
<pre class="notranslate">openssl rand 80 &gt; ticket.key
</pre>

<p>  根据文件大小，AES256（对于80字节密钥，1.11.8）或AES128（对于48字节密钥）用于加密。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_ticketson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_tickets on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  通过<a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">TLS会话票证</a>启用或禁用会话恢复。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_session_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_session_timeout 5m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  指定客户端可以重用会话参数的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_staplingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_stapling off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  启用或禁用服务器<a href="https://tools.ietf.org/html/rfc6066#section-8" target="_blank" rel="noopener">对OCSP响应</a>的<a href="https://tools.ietf.org/html/rfc6066#section-8" target="_blank" rel="noopener">装订</a> 。  例： </p>
<pre class="notranslate">ssl_stapling on;
resolver 192.0.2.1;
</pre>



<p>  要使OCSP装订起作用，应该知道服务器证书颁发者的证书。  如果<a href="#ssl_certificate">ssl_certificate</a>文件不包含中间证书，则服务器证书颁发者的证书应存在于<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>文件中。 </p>
<p>  要解析OCSP响应程序主机名，还应指定<a href="ngx_http_core_module.html#resolver">解析程序</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  设置后，将从指定的<code>*file*</code>获取装订的OCSP响应，而不是查询服务器证书中指定的OCSP响应程序。 </p>
<p>  该文件应为DER格式，由“ <code>openssl ocsp</code> ”命令生成。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_responder*url*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  覆盖“ <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.1" target="_blank" rel="noopener">Authority Information Access</a> ”证书扩展中指定的OCSP响应程序的URL。 </p>
<p>  仅支持“ <code>http://</code> ”OCSP响应者： </p>
<pre class="notranslate">ssl_stapling_responder http://ocsp.example.com/;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_stapling_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_stapling_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  启用或禁用服务器对OCSP响应的验证。 </p>
<p>  要使验证<a href="#ssl_trusted_certificate">生效，</a>应使用<a href="#ssl_trusted_certificate">ssl_trusted_certificate</a>指令将服务器证书颁发者的证书，根证书和所有中间证书配置为受信任。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  该指令出现在1.3.7版本中。 </p>
<p>  如果启用了<a href="#ssl_stapling">ssl_stapling，</a>则指定具有PEM格式的可信CA证书的<code>*file*</code> ，该证书用于<a href="#ssl_verify_client">验证</a>客户端证书和OCSP响应。 </p>
<p>  与<a href="#ssl_client_certificate">ssl_client_certificate</a>设置的证书<a href="#ssl_client_certificate">不同</a> ，这些证书的列表不会发送给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_client** on</code> | <code>off</code> |    <code>optional</code> | <code>optional_no_ca</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_client off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  启用客户端证书验证。  验证结果存储在<a href="#var_ssl_client_verify">$ ssl_client_verify</a>变量中。 </p>
<p>   <code>optional</code>参数（0.8.7+）请求客户端证书，并在证书存在时验证它。 </p>
<p>   <code>optional_no_ca</code>参数（1.3.8,1.2.5）请求客户端证书，但不要求它由受信任的CA证书签名。  这适用于nginx外部的服务执行实际证书验证的情况。  可以通过<a href="#var_ssl_client_cert">$ ssl_client_cert</a>变量访问证书的内容。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置客户端证书链中的验证深度。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>   <code>ngx_http_ssl_module</code>模块支持几个非标准错误代码，可以使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令用于重定向： </p>
<p>  重定向发生在完全解析请求并且变量（例如<code>$request_uri</code> ， <code>$uri</code> ， <code>$args</code>和其他变量）可用之后。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_ssl_module</code>模块支持几个嵌入变量： </p>
<pre class="notranslate">AES128-SHA:AES256-SHA:0x00ff
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才完全支持该变量。  对于旧版本，该变量仅适用于新会话，仅列出已知密码。 </p>
<p>  不推荐使用该变量，应该使用<code>$ssl_client_escaped_cert</code>变量。 </p>
<p>  在1.11.6版之前，变量名称为<code>$ssl_client_i_dn</code> 。 </p>
<p>  在1.11.6版之前，变量名称为<code>$ssl_client_s_dn</code> 。 </p>
<p>  在1.11.7版之前，“ <code>FAILED</code> ”结果不包含<code>*reason*</code>字符串。 </p>
</blockquote>
<pre class="notranslate">0x001d:prime256v1:secp521r1:secp384r1
</pre>

<blockquote>
<p>  仅在使用OpenSSL 1.0.2或更高版本时才支持该变量。  对于旧版本，变量值将为空字符串。 </p>
<p>  该变量仅适用于新会话。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_ssi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_ssi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_ssi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-ssi-module"><a href="#Module-ngx-http-ssi-module" class="headerlink" title="Module ngx_http_ssi_module"></a>Module ngx_http_ssi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ssi">ssi</a> <br>     <a href="#ssi_last_modified">ssi_last_modified</a> <br>     <a href="#ssi_min_file_chunk">ssi_min_file_chunk</a> <br>     <a href="#ssi_silent_errors">ssi_silent_errors</a> <br>     <a href="#ssi_types">ssi_types</a> <br>     <a href="#ssi_value_length">ssi_value_length</a> <br> <a href="#commands">SSI Commands</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_ssi_module</code>模块是一个过滤器，用于处理通过它的响应中的SSI（服务器端包含）命令。  目前，支持的SSI命令列表不完整。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    ssi on;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssion</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用响应中SSI命令的处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_last_modifiedon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_last_modified off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.1版本中。 </p>
<p>  允许在SSI处理期间保留原始响应中的“Last-Modified”头字段，以便于响应缓存。 </p>
<p>  默认情况下，在处理过程中修改响应内容时会删除标题字段，并且可能包含动态生成的元素或与原始响应无关的部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_min_file_chunksize</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_min_file_chunk 1k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置存储在磁盘上的响应部分的最小<code>*size*</code> ，从使用<a href="ngx_http_core_module.html#sendfile">sendfile</a>发送它们开始是有意义的。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_silent_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_silent_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果启用，则在SSI处理期间发生<code>[an error occurred while processing the directive]</code> ，禁止输出“ <code>[an error occurred while processing the directive]</code> ”字符串。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还可以在具有指定MIME类型的响应中处理SSI命令。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssi_value_length*length*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ssi_value_length 256;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置SSI命令中参数值的最大长度。 </p>
<h4 id="SSI命令"><a href="#SSI命令" class="headerlink" title="SSI命令"></a>SSI命令</h4><p>   SSI命令具有以下通用格式： </p>
<pre class="notranslate">&lt;!--# command parameter1=value1 parameter2=value2 ... --&gt;
</pre>



<p>  支持以下命令： </p>
<pre class="notranslate">&lt;!--# block name="one" --&gt;
stub
&lt;!--# endblock --&gt;
</pre>

<pre class="notranslate">[an error occurred while processing the directive]
</pre>

<pre class="notranslate">"%A, %d-%b-%Y %H:%M:%S %Z"
</pre>

<pre class="notranslate">&lt;!--# echo var="name" default=" **no** " --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="$name" --&gt;&lt;!--# echo var="name" --&gt;&lt;!--#
       else --&gt; **no** &lt;!--# endif --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="..." --&gt;
...
&lt;!--# elif expr="..." --&gt;
...
&lt;!--# else --&gt;
...
&lt;!--# endif --&gt;
</pre>
<li>  变量存在检查： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name" --&gt;
</pre></blockquote></li><li>  变量与文本的比较： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name = `*text*` " --&gt;
&lt;!--# if expr="$name != `*text*` " --&gt;
</pre></blockquote></li><li>  变量与正则表达式的比较： <blockquote class="example"><pre class="notranslate">&lt;!--# if expr="$name = / `*text*` /" --&gt;
&lt;!--# if expr="$name != / `*text*` /" --&gt;
</pre></blockquote></li>
<pre class="notranslate">&lt;!--# if expr="$name = `*text*` " --&gt;
&lt;!--# if expr="$name != `*text*` " --&gt;
</pre>

<pre class="notranslate">&lt;!--# if expr="$name = /(.+)@(?P&lt;domain&gt;.+)/" --&gt;
    &lt;!--# echo var="1" --&gt;
    &lt;!--# echo var="domain" --&gt;
&lt;!--# endif --&gt;
</pre>

<pre class="notranslate">&lt;!--# include file="footer.html" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" --&gt;
</pre>

<pre class="notranslate">&lt;!--# block name="one" --&gt;&amp;nbsp;&lt;!--# endblock --&gt;
&lt;!--# include virtual="/remote/body.php?argument=value" stub="one" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" wait="yes" --&gt;
</pre>

<pre class="notranslate">&lt;!--# include virtual="/remote/body.php?argument=value" set="one" --&gt;
</pre>

<pre class="notranslate">location /remote/ {
    subrequest_output_buffer_size 64k;
    ...
}
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_ssi_module</code>模块支持两个嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_split_clients_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_split_clients_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_split_clients_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-split-clients-module"><a href="#Module-ngx-http-split-clients-module" class="headerlink" title="Module ngx_http_split_clients_module"></a>Module ngx_http_split_clients_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#split_clients">split_clients</a> <br></td>

<p>   <code>ngx_http_split_clients_module</code>模块创建适用于A / B测试的变量，也称为拆分测试。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    split_clients "${remote_addr}AAA" $variant {
                   0.5%               .one;
                   2.0%               .two;
                   *                  "";
    }

    server {
        location / {
            index index${variant}.html;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**split_clients**  *string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为A / B测试创建变量，例如： </p>
<pre class="notranslate">split_clients "${remote_addr}AAA" $variant {
               0.5%               .one;
               2.0%               .two;
               *                  "";
}
</pre>

<p>  使用MurmurHash2对原始字符串的值进行哈希处理。  在给出的示例中，从0到21474835（0.5％）的哈希值对应于<code>$variant</code>变量的值<code>&quot;.one&quot;</code> ，从21474836到107374180（2％）的哈希值对应于值<code>&quot;.two&quot;</code>和哈希值从107374181到4294967295的值对应于值<code>&quot;&quot;</code> （空字符串）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_spdy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_spdy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_spdy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-spdy-module"><a href="#Module-ngx-http-spdy-module" class="headerlink" title="Module ngx_http_spdy_module"></a>Module ngx_http_spdy_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#spdy_chunk_size">spdy_chunk_size</a> <br>     <a href="#spdy_headers_comp">spdy_headers_comp</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_spdy_module</code>模块为<a href="http://www.chromium.org/spdy/spdy-protocol" target="_blank" rel="noopener">SPDY</a>提供实验支持。  目前，已实施SPDY协议<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1" target="_blank" rel="noopener">草案3.1</a> 。 </p>
<blockquote>
<p>  在1.5.10版之前，实施了SPDY协议<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2" target="_blank" rel="noopener">草案2</a> 。 </p>
</blockquote>
<p>  默认情况下不构建此模块，应使用<code>--with-http_spdy_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块已被1.9.5中的<a href="ngx_http_v2_module.html">ngx_http_v2_module</a>模块取代。 </p>
</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  该模块是实验性的，需要注意的是经纪人。 </p>
<p>   SPDY协议的当前实现不支持“服务器推送”。 </p>
<p>  在1.5.9之前的版本中，SPDY连接中的响应不能受<a href="ngx_http_core_module.html#limit_rate">速率限制</a> 。 </p>
<p>  无论<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>和<a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>指令值如何，都无法禁用客户端请求正文的缓冲。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 443 ssl spdy;

    ssl_certificate server.crt;
    ssl_certificate_key server.key;
    ...
}
</pre>



<blockquote>
<p>  请注意，为了在同一端口上同时接受<a href="ngx_http_ssl_module.html">HTTPS</a>和SPDY连接，所使用的<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库应支持“Next Protocol Negotiation”TLS扩展，自Ope​​nSSL 1.0.1版开始可用。 </p>
</blockquote>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**spdy_chunk_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">spdy_chunk_size 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.9版本中。 </p>
<p>  设置响应主体被<a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2#TOC-Data-frames" target="_blank" rel="noopener">切片</a>到的块的最大大小。  值太低会导致更高的开销。  由于<a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener">HOL阻塞，</a>太高的值会损害优先级。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**spdy_headers_comp*level*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">spdy_headers_comp 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> <br>                </td></p>
<p>  设置响应的标头压缩<code>*level*</code> ，范围从1（最快，压缩程度较低）到9（最慢，最佳压缩）。  特殊值0关闭标头压缩。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_spdy_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_slice_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_slice_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_slice_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-slice-module"><a href="#Module-ngx-http-slice-module" class="headerlink" title="Module ngx_http_slice_module"></a>Module ngx_http_slice_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#slice">slice</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_slice_module</code>模块（1.9.8）是一个过滤器，它将请求拆分为子请求，每个子请求都返回一定范围的响应。  过滤器提供更有效的大响应缓存。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_slice_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    **slice**             1m;
    proxy_cache       cache;
    proxy_cache_key   $uri$is_args$args **$slice_range** ;
    proxy_set_header  Range **$slice_range** ;
    proxy_cache_valid 200 206 1h;
    proxy_pass        http://localhost:8000;
}
</pre>

<p>  在此示例中，响应被拆分为1兆字节的可缓存切片。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**slice*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">slice 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置切片的<code>*size*</code> 。  零值禁用将响应拆分为切片。  请注意，值太低可能会导致内存使用过多并打开大量文件。 </p>
<p>  为了使子请求返回所需的范围， <code>$slice_range</code>变量应作为<code>Range</code>请求头字段<a href="ngx_http_proxy_module.html#proxy_set_header">传递</a>给代理服务器。  如果启用了<a href="ngx_http_proxy_module.html#proxy_cache">缓存</a> ，则应将<code>$slice_range</code>添加到<a href="ngx_http_proxy_module.html#proxy_cache_key">缓存键，</a>并<a href="ngx_http_proxy_module.html#proxy_cache_valid">启用</a>具有206状态代码的响应缓存。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_slice_module</code>模块支持以下嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_session_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_session_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_session_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-session-log-module"><a href="#Module-ngx-http-session-log-module" class="headerlink" title="Module ngx_http_session_log_module"></a>Module ngx_http_session_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#session_log">session_log</a> <br>     <a href="#session_log_format">session_log_format</a> <br>     <a href="#session_log_zone">session_log_zone</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_session_log_module</code>模块启用日志记录会话（即多个HTTP请求的聚合），而不是单个HTTP请求。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  以下配置根据请求客户端地址和“User-Agent”请求标头字段设置会话日志并将请求映射到会话： </p>
<pre class="notranslate">    session_log_zone /path/to/log format=combined
                     zone=one:1m timeout=30s
                     md5=$binary_remote_addr$http_user_agent;

    location /media/ {
        session_log one;
    }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log*name*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">session_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许使用指定的会话日志。  特殊值<code>off</code>取消从先前配置级别继承的所有<code>session_log</code>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log_format**  *name*</code>    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">session_log_format combined “…”;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定日志的输出格​​式。   <code>$body_bytes_sent</code>变量的值在会话中的所有请求中聚合。  可用于记录的所有其他变量的值对应于会话中的第一个请求。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**session_log_zone**  *path*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>format</code> = <code>*format*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>id</code> = <code>*id*</code> ]    [ <code>md5</code> = <code>*md5*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置日志文件的路径，并配置用于存储当前活动会话的共享内存区域。 </p>
<p>  只要会话中的最后一个请求自指定<code>timeout</code> （默认为30秒）以来经过的时间，会话就被视为活动状态。  会话不再处于活动状态时，会将其写入日志。 </p>
<p>   <code>id</code>参数标识请求映射到的会话。   <code>id</code>参数设置为MD5哈希的十六进制表示（例如，使用变量从cookie获取）。  如果未指定此参数或不表示有效的MD5哈希，则nginx将根据<code>md5</code>参数的值计算MD5哈希，并使用此哈希创建新会话。   <code>id</code>和<code>md5</code>参数都可以包含变量。 </p>
<p>   <code>format</code>参数设置<a href="#session_log_format">session_log_format</a>指令配置的自定义会话日志格式。  如果未指定format，则使用预定义的“ <code>combined</code> ”格式。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_session_log_module</code>模块支持两个嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_secure_link_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_secure_link_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_secure_link_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-secure-link-module"><a href="#Module-ngx-http-secure-link-module" class="headerlink" title="Module ngx_http_secure_link_module"></a>Module ngx_http_secure_link_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#secure_link">secure_link</a> <br>     <a href="#secure_link_md5">secure_link_md5</a> <br>     <a href="#secure_link_secret">secure_link_secret</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_secure_link_module</code>模块（0.7.18）用于检查请求链路的真实性，保护资源免受未经授权的访问，并限制链路生存期。 </p>
<p>  通过将请求中传递的校验和值与为请求计算的值进行比较来验证所请求链接的真实性。  如果链接的生命周期有限且时间已过，则该链接将被视为过时。  这些检查的状态在<code>$secure_link</code>变量中可用。 </p>
<p>  该模块提供两种备选操作模式。  第一种模式由<a href="#secure_link_secret">secure_link_secret</a>指令启用，用于检查请求链接的真实性以及保护资源免受未经授权的访问。  第二种模式（0.8.50）由<a href="#secure_link">secure_link</a>和<a href="#secure_link_md5">secure_link_md5</a>指令启用，也用于限制链接的生命周期。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_secure_link_module</code>配置参数启用它。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link*expression*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义一个包含变量的字符串，从中提取链接的校验和值和生命周期。 </p>
<p>   <code>*expression*</code>中使用的变量通常与请求相关联;  见下面的<a href="#secure_link_md5">例子</a> 。 </p>
<p>  将从字符串中提取的校验和值与<a href="#secure_link_md5">secure_link_md5</a>指令定义的表达式的MD5哈希值进行比较。  如果校验和不同，则<code>$secure_link</code>变量设置为空字符串。  如果校验和相同，则检查链路生存期。  如果链接的生命周期有限且时间已过，则<code>$secure_link</code>变量设置为“ <code>0</code> ”。  否则，它被设置为“ <code>1</code> ”。  请求中传递的MD5哈希值在<a href="https://tools.ietf.org/html/rfc4648#section-5" target="_blank" rel="noopener">base64url中</a>编码。 </p>
<p>  如果链接的生命周期有限，则到期时间设置为自Epoch（Thu，1970年1月1日1970:00 00:00:00 GMT）以来的秒数。  该值在MD5哈希之后的表达式中指定，并以逗号分隔。  请求中传递的到期时间可通过<code>$secure_link_expires</code>变量获得，以便在<a href="#secure_link_md5">secure_link_md5</a>指令中使用。  如果未指定到期时间，则链接具有无限生存期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link_md5*expression*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义将为其计算MD5哈希值并与请求中传递的值进行比较的表达式。 </p>
<p>  表达式应包含链接（资源）和秘密成分的安全部分。  如果链接的生命周期有限，则表达式还应包含<code>$secure_link_expires</code> 。 </p>
<p>  为防止未经授权的访问，表达式可能包含有关客户端的一些信息，例如其地址和浏览器版本。 </p>
<p>  例： </p>
<pre class="notranslate">location /s/ {
    secure_link $arg_md5,$arg_expires;
    secure_link_md5 "$secure_link_expires$uri$remote_addr secret";

    if ($secure_link = "") {
        return 403;
    }

    if ($secure_link = "0") {
        return 410;
    }

    ...
}
</pre>

<p>   “ <code>/s/link?md5=_e4Nc3iduzkWRm01TBBNYw&amp;amp;expires=2147483647</code> ”链接限制对IP地址为127.0.0.1的客户端的“ <code>/s/link</code> ”访问。  该链接的使用寿命有限，直到2038年1月19日（GMT）。 </p>
<p>  在UNIX上， <code>*md5*</code>请求参数值可以获取为： </p>
<pre class="notranslate">echo -n '2147483647/s/link127.0.0.1 secret' | \
    openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d =
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**secure_link_secret*word*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义用于检查所请求链接的真实性的密码。 </p>
<p>  请求链接的完整URI如下所示： </p>
<pre class="notranslate">/ `*prefix*` / `*hash*` / `*link*`
</pre>

<p>   <code>*hash*</code>是为链接和秘密字的串联计算的MD5哈希的十六进制表示，而<code>*prefix*</code>是没有斜杠的任意字符串。 </p>
<p>  如果请求的链接通过了真实性检查，则<code>$secure_link</code>变量将设置为从请求URI中提取的链接。  否则， <code>$secure_link</code>变量设置为空字符串。 </p>
<p>  例： </p>
<pre class="notranslate">location /p/ {
    secure_link_secret secret;

    if ($secure_link = "") {
        return 403;
    }

    rewrite ^ /secure/$secure_link;
}

location /secure/ {
    internal;
}
</pre>

<p>   “ <code>/p/5e814704a28d9bc1914ff19fa0c4a00a/link</code> ”的请求将在内部重定向到“ <code>/secure/link</code> ”。 </p>
<p>  在UNIX上，此示例的哈希值可以获得为： </p>
<pre class="notranslate">echo -n 'linksecret' | openssl md5 -hex
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_scgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_scgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_scgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-scgi-module"><a href="#Module-ngx-http-scgi-module" class="headerlink" title="Module ngx_http_scgi_module"></a>Module ngx_http_scgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#scgi_bind">scgi_bind</a> <br>     <a href="#scgi_buffer_size">scgi_buffer_size</a> <br>     <a href="#scgi_buffering">scgi_buffering</a> <br>     <a href="#scgi_buffers">scgi_buffers</a> <br>     <a href="#scgi_busy_buffers_size">scgi_busy_buffers_size</a> <br>     <a href="#scgi_cache">scgi_cache</a> <br>     <a href="#scgi_cache_background_update">scgi_cache_background_update</a> <br>     <a href="#scgi_cache_bypass">scgi_cache_bypass</a> <br>     <a href="#scgi_cache_key">scgi_cache_key</a> <br>     <a href="#scgi_cache_lock">scgi_cache_lock</a> <br>     <a href="#scgi_cache_lock_age">scgi_cache_lock_age</a> <br>     <a href="#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a> <br>     <a href="#scgi_cache_max_range_offset">scgi_cache_max_range_offset</a> <br>     <a href="#scgi_cache_methods">scgi_cache_methods</a> <br>     <a href="#scgi_cache_min_uses">scgi_cache_min_uses</a> <br>     <a href="#scgi_cache_path">scgi_cache_path</a> <br>     <a href="#scgi_cache_purge">scgi_cache_purge</a> <br>     <a href="#scgi_cache_revalidate">scgi_cache_revalidate</a> <br>     <a href="#scgi_cache_use_stale">scgi_cache_use_stale</a> <br>     <a href="#scgi_cache_valid">scgi_cache_valid</a> <br>     <a href="#scgi_connect_timeout">scgi_connect_timeout</a> <br>     <a href="#scgi_force_ranges">scgi_force_ranges</a> <br>     <a href="#scgi_hide_header">scgi_hide_header</a> <br>     <a href="#scgi_ignore_client_abort">scgi_ignore_client_abort</a> <br>     <a href="#scgi_ignore_headers">scgi_ignore_headers</a> <br>     <a href="#scgi_intercept_errors">scgi_intercept_errors</a> <br>     <a href="#scgi_limit_rate">scgi_limit_rate</a> <br>     <a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a> <br>     <a href="#scgi_next_upstream">scgi_next_upstream</a> <br>     <a href="#scgi_next_upstream_timeout">scgi_next_upstream_timeout</a> <br>     <a href="#scgi_next_upstream_tries">scgi_next_upstream_tries</a> <br>     <a href="#scgi_no_cache">scgi_no_cache</a> <br>     <a href="#scgi_param">scgi_param</a> <br>     <a href="#scgi_pass">scgi_pass</a> <br>     <a href="#scgi_pass_header">scgi_pass_header</a> <br>     <a href="#scgi_pass_request_body">scgi_pass_request_body</a> <br>     <a href="#scgi_pass_request_headers">scgi_pass_request_headers</a> <br>     <a href="#scgi_read_timeout">scgi_read_timeout</a> <br>     <a href="#scgi_request_buffering">scgi_request_buffering</a> <br>     <a href="#scgi_send_timeout">scgi_send_timeout</a> <br>     <a href="#scgi_socket_keepalive">scgi_socket_keepalive</a> <br>     <a href="#scgi_store">scgi_store</a> <br>     <a href="#scgi_store_access">scgi_store_access</a> <br>     <a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a> <br>     <a href="#scgi_temp_path">scgi_temp_path</a> <br></td>

<p>   <code>ngx_http_scgi_module</code>模块允许将请求传递给SCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    include   scgi_params;
    scgi_pass localhost:9000;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到SCGI服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>scgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到SCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">scgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自SCGI服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从SCGI服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用缓冲来自SCGI服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从SCGI服务器接收响应，并将其保存到<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#scgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a>和<a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从SCGI服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#scgi_buffer_size">scgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从SCGI服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自SCGI服务器的响应<a href="#scgi_buffering">缓冲</a>时，限制在响应尚未完全读取时可能忙于向客户端发送响应的缓冲区的总<code>*size*</code> 。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>受<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#scgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">scgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
scgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#scgi_no_cache">scgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">scgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给SCGI服务器，一次只允许一个请求填充根据<a href="#scgi_cache_key">scgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给SCGI服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给SCGI服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#scgi_cache_lock">scgi_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给SCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给SCGI服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_methods** GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#scgi_no_cache">scgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_path**  *path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#scgi_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">scgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#scgi_temp_path">scgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#scgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#scgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#scgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">scgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        scgi_pass        backend;
        scgi_cache       cache_zone;
        scgi_cache_key   $uri;
        scgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_use_stale** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与SCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。  该指令的参数与<a href="#scgi_next_upstream">scgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择处理请求的SCGI服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对SCGI服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对SCGI服务器的访问次数，可以使用<a href="#scgi_cache_lock">scgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_cache_valid** [ *code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">scgi_cache_valid 200 302 10m;
scgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">scgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">scgi_cache_valid 200 302 10m;
scgi_cache_valid 301      1h;
scgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与SCGI服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_force_rangeson</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_force_ranges off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.7.7版本中。 </p>
<p>无论来自这些响应中的“Accept-Ranges”字段，都可以对来自SCGI服务器的缓存和未缓存响应启用字节范围支持。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_hide_header*field*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>默认情况下，nginx不会将SCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。   <code>scgi_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#scgi_pass_header">scgi_pass_header</a>指令。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_ignore_client_abort off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>确定客户端在不等待响应的情况下关闭连接时是否应关闭与SCGI服务器的连接。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_ignore_headers*field*</code> …;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>禁用从SCGI服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>如果未禁用，则处理这些标头字段会产生以下影响： </p>
</li>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#scgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#scgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的SCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从SCGI服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到SCGI服务器的连接，则总速率将是指定限制的两倍。  仅当启用了来自SCGI服务器的响应<a href="#scgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自SCGI服务器的响应<a href="#scgi_buffering">缓冲</a> ，并且整个响应不适合<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#scgi_temp_file_write_size">scgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#scgi_cache">缓存</a>或<a href="#scgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#scgi_next_upstream_tries">尝试次数</a>和<a href="#scgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#scgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#scgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">scgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
scgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#scgi_cache_bypass">scgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_param**  *parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给SCGI服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>scgi_param</code>指令时，这些指令才从先前级别继承。 </p>
<p>  标准<a href="https://tools.ietf.org/html/rfc3875#section-4.1" target="_blank" rel="noopener">CGI环境变量</a>应作为SCGI头提供，请参阅分发中提供的<code>scgi_params</code>文件： </p>
<pre class="notranslate">location / {
    include scgi_params;
    ...
}
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">scgi_param HTTPS $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置SCGI服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">scgi_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">scgi_pass unix:/tmp/scgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将已<a href="#scgi_hide_header">禁用的</a>头字段从SCGI服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给SCGI服务器。  另请参见<a href="#scgi_pass_request_headers">scgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给SCGI服务器。  另请参见<a href="#scgi_pass_request_body">scgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从SCGI服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果SCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到SCGI服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到SCGI服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#scgi_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码来发送原始请求主体时，无论指令值如何，都将缓冲请求主体。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求发送到SCGI服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果SCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置与SCGI服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_store** on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">scgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#scgi_temp_path">scgi_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root              /data/www;
    error_page        404 = /fetch$uri;
}

location /fetch/ {
    internal;

    scgi_pass         backend:9000;
    ...

    scgi_store        on;
    scgi_store_access user:rw group:rw all:r;
    scgi_temp_path    /data/temp;

    alias             /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">scgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">scgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从SCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#scgi_buffer_size">scgi_buffer_size</a>和<a href="#scgi_buffers">scgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#scgi_max_temp_file_size">scgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**scgi_temp_path**  *path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">scgi_temp_path scgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储包含从SCGI服务器接收的数据的临时文件的目录。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">scgi_temp_path /spool/nginx/scgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/scgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#scgi_cache_path">scgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_rewrite_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_rewrite_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_rewrite_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-rewrite-module"><a href="#Module-ngx-http-rewrite-module" class="headerlink" title="Module ngx_http_rewrite_module"></a>Module ngx_http_rewrite_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#break">break</a> <br>     <a href="#if">if</a> <br>     <a href="#return">return</a> <br>     <a href="#rewrite">rewrite</a> <br>     <a href="#rewrite_log">rewrite_log</a> <br>     <a href="#set">set</a> <br>     <a href="#uninitialized_variable_warn">uninitialized_variable_warn</a> <br> <a href="#internals">Internal Implementation</a> <br></td>

<p>   <code>ngx_http_rewrite_module</code>模块用于使用PCRE正则表达式更改请求URI，返回重定向和有条件地选择配置。 </p>
<p>   <a href="#break">break</a> ， <a href="#if">if</a> ， <a href="#return">return</a> ， <a href="#rewrite">rewrite</a>和<a href="#set">set</a>指令按以下顺序处理： </p>
<ul>
<li>在<a href="ngx_http_core_module.html#server">服务器</a>级别指定的此模块的指令是按顺序执行的; -   反复： <ul class="compact"><li>  基于请求URI搜索<a href="ngx_http_core_module.html#location">位置</a> ; -   在找到的位置内指定的该模块的指令是顺序执行的; -   如果<a href="#rewrite">重写</a>请求URI，则重复循环，但不超过<a href="ngx_http_core_module.html#internal">10次</a> 。 </li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**break** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  停止处理当前的<code>ngx_http_rewrite_module</code>指令集。 </p>
<p>  如果在该<a href="ngx_http_core_module.html#location">位置</a>内指定了指令，则在该<a href="ngx_http_core_module.html#location">位置</a>继续进一步处理该请求。 </p>
<p>  例： </p>
<pre class="notranslate">if ($slow) {
    limit_rate 10k;
    break;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**if** ( &lt;code class=&quot;notranslate&quot;&gt;*condition*</code> ) { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  评估指定的<code>*condition*</code> 。  如果为true，则执行在大括号内指定的此模块指令，并在<code>if</code>指令内为该请求分配配置。   <code>if</code>指令内的配置继承自先前的配置级别。 </p>
<p>  条件可以是以下任何一种： </p>
<ul>
<li>变量名;  如果变量的值为空字符串或“ <code>0</code> ”，则为false; <blockquote class="note">  在版本1.0.1之前，任何以“ <code>0</code> ”开头的字符串都被视为错误值。 </blockquote>-   使用“ <code>=</code> ”和“ <code>!=</code> ”运算符比较变量和字符串; -   使用“ <code>~</code> ”（对于区分大小写的匹配）和“ <code>~*</code> ”（对于不区分大小写的匹配）运算符，将变量与正则表达式进行匹配。  正则表达式可以包含可供以后在<code>$1</code> .. <code>$9</code>变量中重用的捕获。  负操作符“ <code>!~</code> ”和“ <code>!~*</code> ”也可用。  如果正则表达式包含“ <code>}</code> ”或“ <code>;</code>   “字符，整个表达式应该用单引号或双引号括起来。 -   使用“ <code>-f</code> ”和“ <code>!-f</code> ”运算符检查文件是否存在; -   使用“ <code>-d</code> ”和“ <code>!-d</code> ”运算符检查目录是否存在; -   使用“ <code>-e</code> ”和“ <code>!-e</code> ”运算符检查文件，目录或符号链接是否存在; -   使用“ <code>-x</code> ”和“ <code>!-x</code> ”运算符检查可执行文件。 </li>
</ul>
<p>  例子： </p>
<pre class="notranslate">if ($http_user_agent ~ MSIE) {
    rewrite ^(.*)$ /msie/$1 break;
}

if ($http_cookie ~* "id=([^;]+)(?:;|$)") {
    set $id $1;
}

if ($request_method = POST) {
    return 405;
}

if ($slow) {
    limit_rate 10k;
}

if ($invalid_referer) {
    return 403;
}
</pre>



<blockquote>
<p>   <code>$invalid_referer</code>嵌入变量的值由<a href="ngx_http_referer_module.html#valid_referers">valid_referers</a>指令设置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**return*code*</code> [ <code>*text*</code> ]; <br> <code>**return*code*</code> <code>*URL*</code> ; <br> <code>**return*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  停止处理并将指定的<code>*code*</code>返回给客户端。  非标准代码444在不发送响应头的情况下关闭连接。 </p>
<p>  从版本0.8.42开始，可以指定重定向URL（对于代码301,302,303,307和308）或响应正文<code>*text*</code> （对于其他代码）。  响应正文文本和重定向URL可以包含变量。  作为特殊情况，可以将重定向URL指定为此服务器的本地URI，在这种情况下，根据请求方案（ <code>$scheme</code> ）以及<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>和<a href="ngx_http_core_module.html#port_in_redirect">port_in_redirect</a>指令形成完整重定向URL。 </p>
<p>  另外，可以将用于具有代码302的临时重定向的<code>*URL*</code>指定为唯一参数。  这样的参数应该以“ <code>http://</code> ”，“ <code>https://</code> ”或“ <code>$scheme</code> ”字符串开头。   <code>*URL*</code>可以包含变量。 </p>
<blockquote>
<p>  在版本0.7.51之前只能返回以下代码：204,400,402-406,408,410,411,413,416和500-504。 </p>
<p>  在版本1.1.16和1.0.13之前，代码307不被视为重定向。 </p>
<p>  在版本1.13.0之前，代码308不被视为重定向。 </p>
</blockquote>
<p>  另请参见<a href="ngx_http_core_module.html#error_page">error_page</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**rewrite**  *regex*</code>    <code>*replacement*</code>    [ <code>*flag*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  如果指定的正则表达式与请求URI匹配，则URI将根据<code>*replacement*</code>字符串中的指定进行更改。   <code>rewrite</code>指令按照它们在配置文件中的出现顺序依次执行。  可以使用标志终止对指令的进一步处理。  如果替换字符串以“ <code>http://</code> ”，“ <code>https://</code> ”或“ <code>$scheme</code> ”开头，则处理停止并将重定向返回给客户端。 </p>
<p>  可选的<code>*flag*</code>参数可以是以下之一： </p>
<p>  完整重定向URL根据请求方案（ <code>$scheme</code> ）以及<a href="ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a>和<a href="ngx_http_core_module.html#port_in_redirect">port_in_redirect</a>指令形成。 </p>
<p>  例： </p>
<pre class="notranslate">server {
    ...
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
    return  403;
    ...
}
</pre>



<p>  但是如果这些指令放在“ <code>/download/</code> ”位置， <code>last</code>标志应该用<code>break</code>替换，否则nginx会生成10个周期并返回500错误： </p>
<pre class="notranslate">location /download/ {
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  break;
    return  403;
}
</pre>



<p>  如果<code>*replacement*</code>字符串包含新请求参数，则先前的请求参数将附加在它们之后。  如果这是不希望的，在替换字符串的末尾加上一个问号可以避免附加它们，例如： </p>
<pre class="notranslate">rewrite ^/users/(.*)$ /show?user=$1? last;
</pre>



<p>  如果正则表达式包含“ <code>}</code> ”或“ <code>;</code>   “字符，整个表达式应该用单引号或双引号括起来。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**rewrite_logon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">rewrite_log off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  启用或禁用将<code>ngx_http_rewrite_module</code>模块指令处理结果记录到<code>notice</code>级别的<a href="ngx_core_module.html#error_log">error_log</a>中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set*$variable*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  设置指定<code>*variable*</code>的<code>*value*</code> 。  该<code>*value*</code>可以包含文本，变量及其组合。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**uninitialized_variable_warnon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">uninitialized_variable_warn on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if</code> <br>                </td></p>
<p>  控制是否记录有关未初始化变量的警告。 </p>
<h4 id="内部实施"><a href="#内部实施" class="headerlink" title="内部实施"></a>内部实施</h4><p>   <code>ngx_http_rewrite_module</code>模块指令在配置阶段编译为在请求处理期间解释的内部指令。  解释器是一个简单的虚拟堆栈机器。 </p>
<p>  例如，指令 </p>
<pre class="notranslate">location /download/ {
    if ($forbidden) {
        return 403;
    }

    if ($slow) {
        limit_rate 10k;
    }

    rewrite ^/(download/.*)/media/(.*)\..*$ /$1/mp3/$2.mp3 break;
}
</pre>

<p>  将被翻译成这些说明： </p>
<pre class="notranslate">variable $forbidden
check against zero
    return 403
    end of code
variable $slow
check against zero
match of regular expression
copy "/"
copy $1
copy "/mp3/"
copy $2
copy ".mp3"
end of regular expression
end of code
</pre>



<p>  请注意，上面的<a href="ngx_http_core_module.html#limit_rate">limit_rate</a>指令没有说明，因为它与<code>ngx_http_rewrite_module</code>模块无关。  为<a href="#if">if</a>块创建单独的配置。  如果条件成立，则为此配置分配一个请求，其中<code>limit_rate</code>等于10k。 </p>
<p>  指令 </p>
<pre class="notranslate">rewrite ^/(download/.*)/media/(.*)\..*$ /$1/mp3/$2.mp3 break;
</pre>

<p>  如果正则表达式中的第一个斜杠放在括号内，则可以通过一条指令变小： </p>
<pre class="notranslate">rewrite ^( **/** download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;
</pre>

<p>  相应的说明将如下所示： </p>
<pre class="notranslate">match of regular expression
copy $1
copy "/mp3/"
copy $2
copy ".mp3"
end of regular expression
end of code
</pre>





</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_referer_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_referer_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_referer_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-referer-module"><a href="#Module-ngx-http-referer-module" class="headerlink" title="Module ngx_http_referer_module"></a>Module ngx_http_referer_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#referer_hash_bucket_size">referer_hash_bucket_size</a> <br>     <a href="#referer_hash_max_size">referer_hash_max_size</a> <br>     <a href="#valid_referers">valid_referers</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_referer_module</code>模块用于阻止对“Referer”头字段中具有无效值的请求访问站点。  应该记住，使用适当的“Referer”字段值来构造请求非常容易，因此本模块的预期目的不是要彻底阻止此类请求，而是阻止常规浏览器发送的请求的大量流量。  还应该考虑到，即使对于有效请求，常规浏览器也可能不发送“Referer”字段。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">valid_referers none blocked server_names
               *.example.com example.* www.example.org/galleries/
               ~\.google\.;

if ($invalid_referer) {
    return 403;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**referer_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">referer_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.0.5版本中。 </p>
<p>  设置有效引用散列表的存储区大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**referer_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">referer_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.0.5版本中。 </p>
<p>  设置有效引用者哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**valid_referers** none</code> |    <code>blocked</code> |    <code>server_names</code> |    <code>*string*</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定将导致嵌入的<code>$invalid_referer</code>变量设置为空字符串的“Referer”请求标头字段值。  否则，变量将设置为“ <code>1</code> ”。  搜索匹配不区分大小写。 </p>
<p>  参数可以如下： </p>
<p>  例： </p>
<pre class="notranslate">valid_referers none blocked server_names
               *.example.com example.* www.example.org/galleries/
               ~\.google\.;
</pre>



<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_realip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_realip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_realip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-realip-module"><a href="#Module-ngx-http-realip-module" class="headerlink" title="Module ngx_http_realip_module"></a>Module ngx_http_realip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#set_real_ip_from">set_real_ip_from</a> <br>     <a href="#real_ip_header">real_ip_header</a> <br>     <a href="#real_ip_recursive">real_ip_recursive</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_realip_module</code>模块用于将客户端地址和可选端口更改为在指定的头字段中发送的端口。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_realip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">set_real_ip_from  192.168.1.0/24;
set_real_ip_from  192.168.2.1;
set_real_ip_from  2001:0db8::/32;
real_ip_header    X-Forwarded-For;
real_ip_recursive on;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**set_real_ip_from**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义已知可发送正确替换地址的可信地址。  如果指定了特殊值<code>unix:</code>则所有UNIX域套接字都将受信任。  也可以使用主机名（1.13.1）指定可信地址。 </p>
<blockquote>
<p>  从版本1.3.0和1.2.1开始支持IPv6地址。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**real_ip_header**  *field*</code> |    <code>X-Real-IP</code> |    <code>X-Forwarded-For</code> |    <code>proxy_protocol</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">real_ip_header X-Real-IP;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义请求标头字段，其值将用于替换客户端地址。 </p>
<p>  包含可选端口的请求标头字段值也用于替换客户端端口（1.11.0）。  应根据<a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">RFC 3986</a>指定地址和端口。 </p>
<p>   <code>proxy_protocol</code>参数（1.5.12）将客户端地址更改为PROXY协议头中的地址。  必须先通过在<a href="ngx_http_core_module.html#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**real_ip_recursiveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">real_ip_recursive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  如果禁用递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为<a href="#real_ip_header">real_ip_header</a>指令定义的请求头字段中发送的最后一个地址。  如果启用了递归搜索，则匹配其中一个可信地址的原始客户端地址将替换为请求头字段中发送的最后一个非受信任地址。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_random_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_random_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_random_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-random-index-module"><a href="#Module-ngx-http-random-index-module" class="headerlink" title="Module ngx_http_random_index_module"></a>Module ngx_http_random_index_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#random_index">random_index</a> <br></td>

<p>   <code>ngx_http_random_index_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求，并在目录中选择一个随机文件作为索引文件。  在<a href="ngx_http_index_module.html">ngx_http_index_module</a>模块之前处理该模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_random_index_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    random_index on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**random_indexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">random_index off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  启用或禁用周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_proxy_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_proxy_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_proxy_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-proxy-module"><a href="#Module-ngx-http-proxy-module" class="headerlink" title="Module ngx_http_proxy_module"></a>Module ngx_http_proxy_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#proxy_bind">proxy_bind</a> <br>     <a href="#proxy_buffer_size">proxy_buffer_size</a> <br>     <a href="#proxy_buffering">proxy_buffering</a> <br>     <a href="#proxy_buffers">proxy_buffers</a> <br>     <a href="#proxy_busy_buffers_size">proxy_busy_buffers_size</a> <br>     <a href="#proxy_cache">proxy_cache</a> <br>     <a href="#proxy_cache_background_update">proxy_cache_background_update</a> <br>     <a href="#proxy_cache_bypass">proxy_cache_bypass</a> <br>     <a href="#proxy_cache_convert_head">proxy_cache_convert_head</a> <br>     <a href="#proxy_cache_key">proxy_cache_key</a> <br>     <a href="#proxy_cache_lock">proxy_cache_lock</a> <br>     <a href="#proxy_cache_lock_age">proxy_cache_lock_age</a> <br>     <a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a> <br>     <a href="#proxy_cache_max_range_offset">proxy_cache_max_range_offset</a> <br>     <a href="#proxy_cache_methods">proxy_cache_methods</a> <br>     <a href="#proxy_cache_min_uses">proxy_cache_min_uses</a> <br>     <a href="#proxy_cache_path">proxy_cache_path</a> <br>     <a href="#proxy_cache_purge">proxy_cache_purge</a> <br>     <a href="#proxy_cache_revalidate">proxy_cache_revalidate</a> <br>     <a href="#proxy_cache_use_stale">proxy_cache_use_stale</a> <br>     <a href="#proxy_cache_valid">proxy_cache_valid</a> <br>     <a href="#proxy_connect_timeout">proxy_connect_timeout</a> <br>     <a href="#proxy_cookie_domain">proxy_cookie_domain</a> <br>     <a href="#proxy_cookie_path">proxy_cookie_path</a> <br>     <a href="#proxy_force_ranges">proxy_force_ranges</a> <br>     <a href="#proxy_headers_hash_bucket_size">proxy_headers_hash_bucket_size</a> <br>     <a href="#proxy_headers_hash_max_size">proxy_headers_hash_max_size</a> <br>     <a href="#proxy_hide_header">proxy_hide_header</a> <br>     <a href="#proxy_http_version">proxy_http_version</a> <br>     <a href="#proxy_ignore_client_abort">proxy_ignore_client_abort</a> <br>     <a href="#proxy_ignore_headers">proxy_ignore_headers</a> <br>     <a href="#proxy_intercept_errors">proxy_intercept_errors</a> <br>     <a href="#proxy_limit_rate">proxy_limit_rate</a> <br>     <a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a> <br>     <a href="#proxy_method">proxy_method</a> <br>     <a href="#proxy_next_upstream">proxy_next_upstream</a> <br>     <a href="#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> <br>     <a href="#proxy_next_upstream_tries">proxy_next_upstream_tries</a> <br>     <a href="#proxy_no_cache">proxy_no_cache</a> <br>     <a href="#proxy_pass">proxy_pass</a> <br>     <a href="#proxy_pass_header">proxy_pass_header</a> <br>     <a href="#proxy_pass_request_body">proxy_pass_request_body</a> <br>     <a href="#proxy_pass_request_headers">proxy_pass_request_headers</a> <br>     <a href="#proxy_read_timeout">proxy_read_timeout</a> <br>     <a href="#proxy_redirect">proxy_redirect</a> <br>     <a href="#proxy_request_buffering">proxy_request_buffering</a> <br>     <a href="#proxy_send_lowat">proxy_send_lowat</a> <br>     <a href="#proxy_send_timeout">proxy_send_timeout</a> <br>     <a href="#proxy_set_body">proxy_set_body</a> <br>     <a href="#proxy_set_header">proxy_set_header</a> <br>     <a href="#proxy_socket_keepalive">proxy_socket_keepalive</a> <br>     <a href="#proxy_ssl_certificate">proxy_ssl_certificate</a> <br>     <a href="#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> <br>     <a href="#proxy_ssl_ciphers">proxy_ssl_ciphers</a> <br>     <a href="#proxy_ssl_crl">proxy_ssl_crl</a> <br>     <a href="#proxy_ssl_name">proxy_ssl_name</a> <br>     <a href="#proxy_ssl_password_file">proxy_ssl_password_file</a> <br>     <a href="#proxy_ssl_protocols">proxy_ssl_protocols</a> <br>     <a href="#proxy_ssl_server_name">proxy_ssl_server_name</a> <br>     <a href="#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> <br>     <a href="#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> <br>     <a href="#proxy_ssl_verify">proxy_ssl_verify</a> <br>     <a href="#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> <br>     <a href="#proxy_store">proxy_store</a> <br>     <a href="#proxy_store_access">proxy_store_access</a> <br>     <a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a> <br>     <a href="#proxy_temp_path">proxy_temp_path</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_proxy_module</code>模块允许将请求传递到另一台服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    proxy_pass       http://localhost:8000;
    proxy_set_header Host      $host;
    proxy_set_header X-Real-IP $remote_addr;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使与可选端口（1.11.2）的指定本地IP地址建立到代理服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>proxy_bind</code>指令的效果，允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到代理服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">proxy_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还需要配置内核路由表以拦截来自代理服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从代理服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用来自代理服务器的响应缓冲。 </p>
<p>  启用缓冲后，nginx会尽快从代理服务器接收响应，并将其保存到<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#proxy_temp_path">临时文件中</a> 。  写入临时文件由<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a>和<a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从代理服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#proxy_buffer_size">proxy_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#proxy_ignore_headers">proxy_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从代理服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自代理服务器的响应<a href="#proxy_buffering">缓冲</a>时，限制可能忙于向响应客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>由<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#proxy_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
proxy_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#proxy_no_cache">proxy_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_convert_headon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_convert_head on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.9.7版中。 </p>
<p>  启用或禁用将“ <code>HEAD</code> ”方法转换为“ <code>GET</code> ”以进行缓存。  禁用转换时，应将<a href="#proxy_cache_key">缓存键</a>配置为包含<code>$request_method</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_key $scheme$proxy_host$request_uri;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">proxy_cache_key "$host$request_uri $cookie_user";
</pre>

<p>  默认情况下，指令的值接近字符串 </p>
<pre class="notranslate">proxy_cache_key $scheme$proxy_host$uri$is_args$args;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给代理服务器，一次只允许一个请求填充根据<a href="#proxy_cache_key">proxy_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给代理服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给代理服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  设置<a href="#proxy_cache_lock">proxy_cache_lock</a>的超时。  当<code>*time*</code>到期时，请求将被传递给代理服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递到代理服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_methods** GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.59版本中。 </p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#proxy_no_cache">proxy_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_path**  *path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的文件名是将MD5功能应用于<a href="#proxy_cache_key">缓存键的结果</a> 。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  临时文件的目录是根据<code>use_temp_path</code>参数（1.7.10）设置的。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#proxy_temp_path">proxy_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#proxy_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#proxy_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#proxy_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        proxy_pass http://backend;
        proxy_cache cache_zone;
        proxy_cache_key $uri;
        proxy_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_use_stale** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与代理服务器通信期间可以在哪些情况下使用过时的缓存响应。  该指令的参数与<a href="#proxy_next_upstream">proxy_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择代理服务器来处理请求，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这允许在更新缓存数据时最小化对代理服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对代理服务器的访问次数，可以使用<a href="#proxy_cache_lock">proxy_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cache_valid** [ *code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">proxy_cache_valid 200 302 10m;
proxy_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">proxy_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">proxy_cache_valid 200 302 10m;
proxy_cache_valid 301      1h;
proxy_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#proxy_ignore_headers">proxy_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_connect_timeout*time*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_connect_timeout 60s;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>定义与代理服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cookie_domainoff</code> ; <br> <code>**proxy_cookie_domain*domain*</code> <code>*replacement*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cookie_domain off;</pre>                </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>该指令出现在1.1.15版中。 </p>
<p>设置应在代理服务器响应的“Set-Cookie”标头字段的<code>domain</code>属性中更改的文本。  假设代理服务器返回带有“ <code>domain=localhost</code> ”属性的“Set-Cookie”头字段。  指令 </p>
</li>
</ul>
<pre class="notranslate">proxy_cookie_domain localhost example.org;
</pre>

<p>  将此属性重写为“ <code>domain=example.org</code> ”。 </p>
<p>   <code>*domain*</code>开头处的点和<code>*replacement*</code>字符串以及<code>domain</code>属性将被忽略。  匹配不区分大小写。 </p>
<p>   <code>*domain*</code>和<code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_cookie_domain www.$host $host;
</pre>



<p>  也可以使用正则表达式指定该指令。  在这种情况下， <code>*domain*</code>应该从“ <code>~</code> ”符号开始。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_cookie_domain ~\.(?P&lt;sl_domain&gt;[-0-9a-z]+\.[a-z]+)$ $sl_domain;
</pre>



<p>  可能有几个<code>proxy_cookie_domain</code>指令： </p>
<pre class="notranslate">proxy_cookie_domain localhost example.org;
proxy_cookie_domain ~\.([a-z]+\.[a-z]+)$ $1;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_cookie_domain</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_cookie_domain off;
proxy_cookie_domain localhost example.org;
proxy_cookie_domain www.example.org example.org;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_cookie_pathoff</code> ; <br> <code>**proxy_cookie_path*path*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_cookie_path off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.15版中。 </p>
<p>  设置应在代理服务器响应的“Set-Cookie”标头字段的<code>path</code>属性中更改的文本。  假设代理服务器返回带有属性“ <code>path=/two/some/uri/</code> ”的“Set-Cookie”头字段。  指令 </p>
<pre class="notranslate">proxy_cookie_path /two/ /;
</pre>

<p>  将此属性重写为“ <code>path=/some/uri/</code> ”。 </p>
<p>   <code>*path*</code>和<code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_cookie_path $uri /some$uri;
</pre>



<p>  也可以使用正则表达式指定该指令。  在这种情况下， <code>*path*</code>应该从用于区分大小写匹配的“ <code>~</code> ”符号开始，或者从用于区分大小写匹配的“ <code>~*</code> ”符号开始。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre>



<p>  可能有几个<code>proxy_cookie_path</code>指令： </p>
<pre class="notranslate">proxy_cookie_path /one/ /;
proxy_cookie_path / /two/;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_cookie_path</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_cookie_path off;
proxy_cookie_path /two/ /;
proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论代理服务器中的“Accept-Ranges”字段如何，都可以对代理服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_headers_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_headers_hash_bucket_size 64;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="#proxy_hide_header">proxy_hide_header</a>和<a href="#proxy_set_header">proxy_set_header</a>指令使用的哈希表的桶<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_headers_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_headers_hash_max_size 512;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<a href="#proxy_hide_header">proxy_hide_header</a>和<a href="#proxy_set_header">proxy_set_header</a>指令使用的哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会从代理服务器对客户端的响应中传递标题字段“Date”，“Server”，“X-Pad”和“X-Accel -…”。   <code>proxy_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#proxy_pass_header">proxy_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_http_version1.0</code> | <code>1.1</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_http_version 1.0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  设置代理的HTTP协议版本。  默认情况下，使用版本1.0。  建议将1.1版与<a href="ngx_http_upstream_module.html#keepalive">keepalive</a>连接和<a href="ngx_http_upstream_module.html#ntlm">NTLM身份验证配合使用</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ignore_client_aborton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ignore_client_abort off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在客户端关闭连接而不等待响应时是否应关闭与代理服务器的连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从代理服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#proxy_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#proxy_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的代理响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从代理服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开到代理服务器的两个连接，则总速率将是指定限制的两倍。  仅当启用了代理服务器的响应<a href="#proxy_buffering">缓冲时</a> ，此限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自代理服务器的响应<a href="#proxy_buffering">缓冲</a> ，并且整个响应不适合<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#proxy_cache">缓存</a>或<a href="#proxy_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_method*method*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定在转发到代理服务器的请求中使用的HTTP <code>*method*</code> ，而不是客户端请求中的方法。  参数值可以包含变量（1.11.6）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_502</code> ， <code>http_503</code> ， <code>http_504</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#proxy_next_upstream_tries">尝试次数</a>和<a href="#proxy_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#proxy_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#proxy_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;
proxy_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#proxy_cache_bypass">proxy_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass*URL*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> , <code>limit_except</code> <br>                </td></p>
<p>  设置代理服务器的协议和地址以及应映射位置的可选URI。  作为协议，可以指定“ <code>http</code> ”或“ <code>https</code> ”。  可以将地址指定为域名或IP地址，以及可选端口： </p>
<pre class="notranslate">proxy_pass http://localhost:8000/uri/;
</pre>

<p>  或者作为在单词“ <code>unix</code> ”之后指定并用冒号括起来的UNIX域套接字路径： </p>
<pre class="notranslate">proxy_pass http://unix:/tmp/backend.socket:/uri/;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的服务器组中搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p>  请求URI按如下方式传递给服务器： </p>
<p><li>  如果使用URI指定了<code>proxy_pass</code>指令，那么当请求传递给服务器时，与该位置匹配的<a href="ngx_http_core_module.html#location">规范化</a>请求URI的一部分将被指令中指定的URI替换： <blockquote class="example"><pre class="notranslate">location /name/ {<br>    proxy_pass <a href="http://127.0.0.1/remote/" target="_blank" rel="noopener">http://127.0.0.1/remote/</a>;<br>}<br></pre></blockquote></li><li>  如果指定了<code>proxy_pass</code>而没有URI，则请求URI将以与处理原始请求时客户端发送的格式相同的形式传递给服务器，或者在处理更改的URI时传递完整的规范化请求URI： <blockquote class="example"><pre class="notranslate">location /some/path/ {<br>    proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>;<br>}<br></pre></blockquote><blockquote class="note">  在版本1.1.12之前，如果指定了<code>proxy_pass</code>而没有URI，则在某些情况下可能会传递原始请求URI而不是更改的URI。 </blockquote></li></p>
<pre class="notranslate">location /some/path/ {
    proxy_pass http://127.0.0.1;
}
</pre>



<p>  在某些情况下，无法确定要替换的请求URI的部分： </p>
<ul>
<li>使用正则表达式指定位置时，以及在命名位置内指定位置。   在这些情况下，应指定<code>proxy_pass</code>而不使用URI。 </li><li>  使用<a href="ngx_http_rewrite_module.html#rewrite">rewrite</a>指令在代理位置内更改URI时，将使用相同的配置来处理请求（ <code>break</code> ）： <blockquote class="example"><pre class="notranslate">location /name/ {<br>rewrite    /name/([^/]+) /users?name=$1 break;<br>proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>;<br>}<br></pre></blockquote>  在这种情况下，将忽略指令中指定的URI，并将完整更改的请求URI传递给服务器。 </li><li>  在<code>proxy_pass</code>中使用变量时： <blockquote class="example"><pre class="notranslate">location /name/ {<br>proxy_pass <a href="http://127.0.0.1$request_uri" target="_blank" rel="noopener">http://127.0.0.1$request_uri</a>;<br>}<br></pre></blockquote>  在这种情况下，如果在指令中指定了URI，则将其原样传递给服务器，替换原始请求URI。 </li><pre class="notranslate">location /name/ {
proxy_pass http://127.0.0.1$request_uri;
}
</pre>




</ul>
<p>   <a href="websocket.html">WebSocket</a>代理需要特殊配置，从版本1.3.13开始支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将已<a href="#proxy_hide_header">禁用的</a>头字段从代理服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给代理服务器。 </p>
<pre class="notranslate">location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";

    proxy_pass ...
}
</pre>

<p>  另请参阅<a href="#proxy_set_header">proxy_set_header</a>和<a href="#proxy_pass_request_headers">proxy_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求的标头字段传递给代理服务器。 </p>
<pre class="notranslate">location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_headers off;
    proxy_pass_request_body off;

    proxy_pass ...
}
</pre>

<p>  另请参阅<a href="#proxy_set_header">proxy_set_header</a>和<a href="#proxy_pass_request_body">proxy_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从代理服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果代理服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_redirectdefault</code> ; <br> <code>**proxy_redirectoff</code> ; <br> <code>**proxy_redirect*redirect*</code> <code>*replacement*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_redirect default;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应在代理服务器响应的“位置”和“刷新”标头字段中更改的文本。  假设代理服务器返回标题字段“ <code>Location: http://localhost:8000/two/some/uri/</code> ”。  指令 </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/two/ http://frontend/one/;
</pre>

<p>  将此字符串重写为“ <code>Location: http://frontend/one/some/uri/</code> ”。 </p>
<p>   <code>*replacement*</code>字符串中可能省略了服务器名称： </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/two/ /;
</pre>

<p>  然后将插入主服务器的名称和端口（如果与80不同）。 </p>
<p>   <code>default</code>参数指定的默认替换使用<a href="ngx_http_core_module.html#location">location</a>和<a href="#proxy_pass">proxy_pass</a>指令的参数。  因此，以下两种配置是等效的： </p>
<pre class="notranslate">location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect default;
</pre>



<pre class="notranslate">location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect http://upstream:port/two/ /one/;
</pre>

<p>  如果使用变量指定<a href="#proxy_pass">proxy_pass，</a>则不允许使用<code>default</code>参数。 </p>
<p>   <code>*replacement*</code>字符串可以包含变量： </p>
<pre class="notranslate">proxy_redirect http://localhost:8000/ http://$host:$server_port/;
</pre>



<p>   <code>*redirect*</code>还可以包含（1.1.11）变量： </p>
<pre class="notranslate">proxy_redirect http://$proxy_host:8000/ /;
</pre>



<p>  可以使用正则表达式指定（1.1.11）指令。  在这种情况下， <code>*redirect*</code>应该以“ <code>~</code> ”符号开头，以区分大小写的匹配，或者使用“ <code>~*</code> ”符号以区分大小写匹配。  正则表达式可以包含命名和位置捕获， <code>*replacement*</code>可以引用它们： </p>
<pre class="notranslate">proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
</pre>



<p>  可能有几个<code>proxy_redirect</code>指令： </p>
<pre class="notranslate">proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre>



<p>   <code>off</code>参数取消所有<code>proxy_redirect</code>指令对当前级别的影响： </p>
<pre class="notranslate">proxy_redirect off;
proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre>



<p>  使用此指令，还可以将主机名添加到代理服务器发出的相对重定向： </p>
<pre class="notranslate">proxy_redirect / /;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到代理服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到代理服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#proxy_next_upstream">下一个服务器</a> 。 </p>
<p>  当使用HTTP / 1.1分块传输编码发送原始请求主体时，无论指令值如何，都将缓冲请求主体，除非为代理<a href="#proxy_http_version">启用</a>了HTTP / 1.1。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_send_lowat*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_send_lowat 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令设置为非零值，则nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或具有指定<code>*size*</code>的<code>SO_SNDLOWAT</code>套接字选项来最小化到代理服务器的传出连接上的发送操作数。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到代理服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果代理服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_set_body*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许重新定义传递给代理服务器的请求正文。  该<code>*value*</code>可以包含文本，变量及其组合。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_set_header*field*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_set_header Host $proxy_host;</pre><pre class="notranslate">proxy_set_header Connection close;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将字段重新定义或附加到<a href="#proxy_pass_request_headers">传递</a>给代理服务器的请求标头。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>proxy_set_header</code>指令时，这些指令才从先前级别继承。  默认情况下，只重新定义了两个字段： </p>
<pre class="notranslate">proxy_set_header Host       $proxy_host;
proxy_set_header Connection close;
</pre>

<p>  如果启用了缓存，则标题字段为“If-Modified-Since”，“If-Unmodified-Since”，“If-None-Match”，“If-Match”，“Range”和“If-Range”来自原始请求不会传递给代理服务器。 </p>
<p>  未更改的“主机”请求标头字段可以像这样传递： </p>
<pre class="notranslate">proxy_set_header Host       $http_host;
</pre>



<p>  但是，如果客户端请求标头中不存在此字段，则不会传递任何内容。  在这种情况下，最好使用<code>$host</code>变量 - 它的值等于“Host”请求头字段中的服务器名称，或者如果此字段不存在则等于主服务器名称： </p>
<pre class="notranslate">proxy_set_header Host       $host;
</pre>



<p>  此外，服务器名称可以与代理服务器的端口一起传递： </p>
<pre class="notranslate">proxy_set_header Host       $host:$proxy_port;
</pre>



<p>  如果标头字段的值为空字符串，则此字段将不会传递给代理服务器： </p>
<pre class="notranslate">proxy_set_header Accept-Encoding "";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到代理服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，该证书用于对代理的HTTPS服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对代理的HTTPS服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> （1.7.9），该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  指定对代理HTTPS服务器的请求的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_name $proxy_host;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  允许覆盖用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器证书的服务器名称，并在与代理HTTPS服务器建立连接时<a href="#proxy_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#proxy_pass">proxy_pass</a> URL的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  为代理HTTPS服务器的请求启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在与代理的HTTPS服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在使用代理服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#proxy_ssl_verify">验证</a>代理HTTPS服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  启用或禁用代理HTTPS服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.0版本中。 </p>
<p>  在代理的HTTPS服务器证书链中设置验证深度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_store** on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">proxy_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#proxy_temp_path">proxy_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = /fetch$uri;
}

location /fetch/ {
    internal;

    proxy_pass         http://backend/;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    alias              /data/www/;
}
</pre>



<p>  或者像这样： </p>
<pre class="notranslate">location /images/ {
    root               /data/www;
    error_page         404 = @fetch;
}

location @fetch {
    internal;

    proxy_pass         http://backend;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    root               /data/www;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">proxy_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">proxy_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从代理服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#proxy_buffer_size">proxy_buffer_size</a>和<a href="#proxy_buffers">proxy_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**proxy_temp_path**  *path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">proxy_temp_path proxy_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从代理服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">proxy_temp_path /spool/nginx/proxy_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/proxy_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参阅<a href="#proxy_cache_path">proxy_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_proxy_module</code>模块支持嵌入式变量，这些变量可用于使用<a href="#proxy_set_header">proxy_set_header</a>指令组合头： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_perl_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_perl_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_perl_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-perl-module"><a href="#Module-ngx-http-perl-module" class="headerlink" title="Module ngx_http_perl_module"></a>Module ngx_http_perl_module</h2><td align="left" class="notranslate"> <a href="#issues">Known Issues</a> <br> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#perl">perl</a> <br>     <a href="#perl_modules">perl_modules</a> <br>     <a href="#perl_require">perl_require</a> <br>     <a href="#perl_set">perl_set</a> <br> <a href="#ssi">Calling Perl from SSI</a> <br> <a href="#methods">The $r Request Object Methods</a> <br></td>

<p>   <code>ngx_http_perl_module</code>模块用于在Perl中实现位置和变量处理程序，并将Perl调用插入到SSI中。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_perl_module</code>配置参数启用它。 </p>
<blockquote>
<p>  此模块需要<a href="https://www.perl.org/get.html" target="_blank" rel="noopener">Perl</a> 5.6.1或更高版本。   C编译器应该与用于构建Perl的编译器兼容。 </p>
</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>  该模块是实验性的，需要注意的是经纪人。 </p>
<p>  为了让Perl在重新配置期间重新编译已修改的模块，它应该使用<code>-Dusemultiplicity=yes</code>或<code>-Dusethreads=yes</code>参数<code>-Dusethreads=yes</code> 。  另外，为了使Perl在运行时泄漏更少的内存，应该使用<code>-Dusemymalloc=no</code>参数构建它。  要在已构建的Perl中检查这些参数的值（在示例中指定了首选值），请运行： </p>
<pre class="notranslate">$ perl -V:usemultiplicity -V:usemymalloc
usemultiplicity='define';
usemymalloc='n';
</pre>



<p>  请注意，在使用新的<code>-Dusemultiplicity=yes</code>或<code>-Dusethreads=yes</code>参数重建Perl之后，还必须重建所有二进制Perl模块 - 它们将停止使用新的Perl。 </p>
<p>  每次重新配置后，主进程和工作进程都有可能增大。  如果主进程增长到不可接受的大小，则可以在不更改可执行文件的情况下应用<a href="control.html#upgrade">实时升级</a>过程。 </p>
<p>  当Perl模块执行长时间运行的操作（例如解析域名，连接到另一个服务器或查询数据库）时，将不会处理分配给当前工作进程的其他请求。  因此，建议仅执行具有可预测和短执行时间的此类操作，例如访问本地文件系统。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    perl_modules perl/lib;
    perl_require hello.pm;

    perl_set $msie6 '

        sub {
            my $r = shift;
            my $ua = $r-&gt;header_in("User-Agent");

            return "" if $ua =~ /Opera/;
            return "1" if $ua =~ / MSIE [6-9]\.\d+/;
            return "";
        }

    ';

    server {
        location / {
            perl hello::handler;
        }
    }
</pre>



<p>   <code>perl/lib/hello.pm</code>模块： </p>
<pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    $r-&gt;send_http_header("text/html");
    return OK if $r-&gt;header_only;

    $r-&gt;print("hello!\n&lt;br/&gt;");

    if (-f $r-&gt;filename or -d _) {
        $r-&gt;print($r-&gt;uri, " exists!\n");
    }

    return OK;
}

1;
__END__
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl*module*</code> :: <code>*function*</code> |’sub { … }’;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  为给定位置设置Perl处理程序。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_modules*path*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为Perl模块设置其他路径。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_require*module*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  定义将在每次重新配置期间加载的模块的名称。  可以存在几个<code>perl_require</code>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**perl_set**  *$variable*</code>    <code>*module*</code> :: <code>*function*</code> |’sub { … }’;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为指定的变量安装Perl处理程序。 </p>
<h4 id="从SSI调用Perl"><a href="#从SSI调用Perl" class="headerlink" title="从SSI调用Perl"></a>从SSI调用Perl</h4><p>  调用Perl的SSI命令具有以下格式： </p>
<pre class="notranslate">&lt;!--# perl sub=" `*module*` :: `*function*` " arg=" `*parameter1*` " arg=" `*parameter2*` " ...
--&gt;
</pre>



<h4 id="r请求对象方法"><a href="#r请求对象方法" class="headerlink" title="$ r请求对象方法"></a>$ r请求对象方法</h4><pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    if ($r-&gt;request_method ne "POST") {
        return DECLINED;
    }

    if ($r-&gt;has_request_body( **\&amp;post** )) {
        return OK;
    }

    return HTTP_BAD_REQUEST;
}

sub **post** {
    my $r = shift;

    $r-&gt;send_http_header;

    $r-&gt;print("request_body: \"", $r-&gt;request_body, "\"&lt;br/&gt;");
    $r-&gt;print("request_body_file: \"", $r-&gt;request_body_file, "\"&lt;br/&gt;\n");

    return OK;
}

1;

__END__
</pre>

<blockquote>
<p>  目前不支持重定向到命名位置。 </p>
</blockquote>
<pre class="notranslate">package hello;

use nginx;

sub handler {
    my $r = shift;

    $r-&gt;discard_request_body;
    $r-&gt;variable("var", "OK");
    $r-&gt;sleep(1000, **\&amp;next** );

    return OK;
}

sub **next** {
    my $r = shift;

    $r-&gt;send_http_header;
    $r-&gt;print($r-&gt;variable("var"));

    return OK;
}

1;

__END__
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mp4_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mp4_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mp4_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mp4-module"><a href="#Module-ngx-http-mp4-module" class="headerlink" title="Module ngx_http_mp4_module"></a>Module ngx_http_mp4_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#mp4">mp4</a> <br>     <a href="#mp4_buffer_size">mp4_buffer_size</a> <br>     <a href="#mp4_max_buffer_size">mp4_max_buffer_size</a> <br>     <a href="#mp4_limit_rate">mp4_limit_rate</a> <br>     <a href="#mp4_limit_rate_after">mp4_limit_rate_after</a> <br></td>

<p>   <code>ngx_http_mp4_module</code>模块为MP4文件提供伪流服务器端支持。  此类文件通常具有<code>.mp4</code> ， <code>.m4v</code>或<code>.m4a</code>文件扩展名。 </p>
<p>  伪流与兼容的Flash播放器结合使用。  播放器使用查询字符串参数中指定的开始时间（仅命名为<code>start</code>并以秒为单位指定）向服务器发送HTTP请求，服务器以流响应，使其起始位置对应于请求的时间，例如： </p>
<pre class="notranslate">http://example.com/elephants_dream.mp4?start=238.88
</pre>

<p>  这允许在任何时间执行随机搜索，或者在时间线的中间开始回放。 </p>
<p>  为了支持搜索，基于H.264的格式将元数据存储在所谓的“moov原子”中。  它是文件的一部分，用于保存整个文件的索引信息。 </p>
<p>  要开始播放，播放器首先需要读取元数据。  这是通过使用<code>start=0</code>参数发送特殊请求来完成的。  许多编码软件在文件末尾插入元数据。  这对于伪流是次优的，因为播放器必须在开始播放之前下载整个文件。  如果元数据位于文件的开头，则nginx只需开始发回文件内容就足够了。  如果元数据位于文件末尾，则nginx必须读取整个文件并准备新流，以便元数据位于媒体数据之前。  这涉及一些CPU，内存和磁盘I / O开销，因此最好事先<a href="http://flowplayer.org/plugins/streaming/pseudostreaming.html#prepare" target="_blank" rel="noopener">准备一个用于伪流的原始文件</a> ，而不是让nginx在每个这样的请求上执行此操作。 </p>
<p>  该模块还支持HTTP请求的<code>end</code>参数（1.5.13），该请求设置回放的结束点。   <code>end</code>参数可以使用<code>start</code>参数指定，也可以单独指定： </p>
<pre class="notranslate">http://example.com/elephants_dream.mp4?start=238.88&amp;end=555.55
</pre>



<p>  对于具有非零<code>start</code>或<code>end</code>参数的匹配请求，nginx将从文件中读取元数据，准备具有所请求时间范围的流，并将其发送到客户端。  这具有与上述相同的开销。 </p>
<p>  如果匹配请求不包含<code>start</code>和<code>end</code>参数，则没有开销，并且文件仅作为静态资源发送。  一些播放器也支持字节范围请求，因此不需要此模块。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_mp4_module</code>配置参数启用它。 </p>
<blockquote>
<p>  如果以前使用过第三方mp4模块，则应禁用它。 </p>
</blockquote>
<p>   <a href="ngx_http_flv_module.html">ngx_http_flv_module</a>模块提供了对FLV文件的类似伪流支持。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /video/ {
    mp4;
    mp4_buffer_size       1m;
    mp4_max_buffer_size   5m;
    mp4_limit_rate        on;
    mp4_limit_rate_after  30s;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_buffer_size 512K;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于处理MP4文件的缓冲区的初始<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_max_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_max_buffer_size 10M;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在元数据处理期间，可能需要更大的缓冲区。  它的大小不能超过指定的<code>*size*</code> ，否则nginx将返回500（内部服务器错误）服务器错误，并记录以下消息： </p>
<pre class="notranslate">"/some/movie/file.mp4" mp4 moov atom is too large:
12583268, you may want to increase mp4_max_buffer_size
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_limit_rate** on</code> |    <code>off</code> |    <code>*factor*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_limit_rate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制向客户端传输的响应速率。  根据所服务的MP4文件的平均比特率限制速率。  要计算速率，比特率乘以指定的<code>*factor*</code> 。  特殊值“ <code>on</code> ”对应于因子1.1。  特殊值“ <code>off</code> ”禁用速率限制。  根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mp4_limit_rate_after*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mp4_limit_rate_after 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置媒体数据的初始量（以回放时间测量），之后对客户端的进一步传输将是速率限制的。 </p>
<blockquote>
<p>  该指令作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_mirror_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_mirror_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_mirror_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-mirror-module"><a href="#Module-ngx-http-mirror-module" class="headerlink" title="Module ngx_http_mirror_module"></a>Module ngx_http_mirror_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#mirror">mirror</a> <br>     <a href="#mirror_request_body">mirror_request_body</a> <br></td>

<p>   <code>ngx_http_mirror_module</code>模块（1.13.4）通过创建后台镜像子请求来实现原始请求的镜像。  忽略对镜像子请求的响应。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    mirror /mirror;
    proxy_pass http://backend;
}

location = /mirror {
    internal;
    proxy_pass http://test_backend$request_uri;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mirror*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mirror off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将镜像原始请求的URI。  可以在同一级别指定多个镜像。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**mirror_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">mirror_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否镜像客户端请求正文。  启用后，将在创建镜像子请求之前读取客户端请求正文。  在这种情况下，将禁用由<a href="ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> ， <a href="ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a>和<a href="ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a>指令设置的无缓冲客户机请求正文代理。 </p>
<pre class="notranslate">location / {
    mirror /mirror;
    mirror_request_body off;
    proxy_pass http://backend;
}

location = /mirror {
    internal;
    proxy_pass http://log_backend;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_memcached_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_memcached_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_memcached_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-memcached-module"><a href="#Module-ngx-http-memcached-module" class="headerlink" title="Module ngx_http_memcached_module"></a>Module ngx_http_memcached_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#memcached_bind">memcached_bind</a> <br>     <a href="#memcached_buffer_size">memcached_buffer_size</a> <br>     <a href="#memcached_connect_timeout">memcached_connect_timeout</a> <br>     <a href="#memcached_force_ranges">memcached_force_ranges</a> <br>     <a href="#memcached_gzip_flag">memcached_gzip_flag</a> <br>     <a href="#memcached_next_upstream">memcached_next_upstream</a> <br>     <a href="#memcached_next_upstream_timeout">memcached_next_upstream_timeout</a> <br>     <a href="#memcached_next_upstream_tries">memcached_next_upstream_tries</a> <br>     <a href="#memcached_pass">memcached_pass</a> <br>     <a href="#memcached_read_timeout">memcached_read_timeout</a> <br>     <a href="#memcached_send_timeout">memcached_send_timeout</a> <br>     <a href="#memcached_socket_keepalive">memcached_socket_keepalive</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_memcached_module</code>模块用于从memcached服务器获取响应。  密钥在<code>$memcached_key</code>变量中设置。  响应应该通过nginx外部的方式预先存储在memcached中。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    location / {
        set            $memcached_key "$uri?$args";
        memcached_pass host:11211;
        error_page     404 502 504 = @fallback;
    }

    location @fallback {
        proxy_pass     http://backend;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到memcached服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>memcached_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到memcached服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">memcached_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自memcached服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从memcached服务器接收的响应的缓冲区的<code>*size*</code> 。  一旦收到响应，响应就会同步传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与memcached服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论来自这些响应中的“Accept-Ranges”字段，都可以对来自memcached服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_gzip_flag*flag*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.6版本中。 </p>
<p>  如果设置了<code>*flag*</code> ，则在memcached服务器响应中启用<code>*flag*</code>存在的测试，并将“ <code>Content-Encoding</code> ”响应头字段设置为“ <code>gzip</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_response</code> |    <code>not_found</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_response</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>not_found</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#memcached_next_upstream_tries">尝试次数</a>和<a href="#memcached_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#memcached_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#memcached_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置memcached服务器地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">memcached_pass localhost:11211;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">memcached_pass unix:/tmp/memcached.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从memcached服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果memcached服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到memcached服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果memcached服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**memcached_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">memcached_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到memcached服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_map_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_map_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_map_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-map-module"><a href="#Module-ngx-http-map-module" class="headerlink" title="Module ngx_http_map_module"></a>Module ngx_http_map_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#map">map</a> <br>     <a href="#map_hash_bucket_size">map_hash_bucket_size</a> <br>     <a href="#map_hash_max_size">map_hash_max_size</a> <br></td>

<p>   <code>ngx_http_map_module</code>模块创建的变量的值取决于其他变量的值。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">map $http_host $name {
    hostnames;

    default       0;

    example.com   1;
    *.example.com 1;
    example.org   2;
    *.example.org 2;
    .example.net  3;
    wap.*         4;
}

map $http_user_agent $mobile {
    default       0;
    "~Opera Mini" 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map**  *string*</code>    <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  创建一个新变量，其值取决于第一个参数中指定的一个或多个源变量的值。 </p>
<blockquote>
<p>  在0.9.0版之前，只能在第一个参数中指定单个变量。 </p>
<p>  由于变量仅在使用时进行评估，因此即使是大量“ <code>map</code> ”变量的声明也不会增加请求处理的额外成本。 </p>
</blockquote>
<p>  地图块内的参数指定源和结果值之间的映射。 </p>
<p>  源值指定为字符串或正则表达式（0.9.6）。 </p>
<p>  字符串匹配忽略大小写。 </p>
<p>  对于区分大小写的匹配，正则表达式应该从“ <code>~</code> ”符号开始，或者对于不区分大小写的匹配，应该从“ <code>~*</code> ”符号（1.0.4）开始。  正则表达式可以包含命名和位置捕获，以后可以在其他指令中使用结果变量。 </p>
<p>  如果源值与下面描述的特殊参数名称之一匹配，则应使用“ <code>\</code> ”符号作为前缀。 </p>
<p>  结果值可以包含文本，变量（0.9.0）及其组合（1.11.0）。 </p>
<p>  还支持以下特殊参数： </p>
<pre class="notranslate">*.example.com 1;
example.*     1;
</pre>

<pre class="notranslate">example.com   1;
*.example.com 1;
</pre>

<pre class="notranslate">.example.com  1;
</pre>



<p>  如果源值与多个指定变量匹配，例如掩码和正则表达式匹配，则将按以下优先级顺序选择第一个匹配变量： </p>
<ol>
<li>没有掩码的字符串值 1.   带有前缀掩码的最长字符串值，例如“ <code>*.example.com</code> ” 1.   带有后缀掩码的最长字符串值，例如“ <code>mail.*</code> ” 1.   第一个匹配正则表达式（按配置文件中的出现顺序） 1.   默认值 </li>
</ol>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_bucket_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_bucket_size 32|64|128;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的存储区大小。  默认值取决于处理器的缓存行大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**map_hash_max_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">map_hash_max_size 2048;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置<a href="#map">映射</a>变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_log_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_log_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_log_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-log-module"><a href="#Module-ngx-http-log-module" class="headerlink" title="Module ngx_http_log_module"></a>Module ngx_http_log_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#access_log">access_log</a> <br>     <a href="#log_format">log_format</a> <br>     <a href="#open_log_file_cache">open_log_file_cache</a> <br></td>

<p>   <code>ngx_http_log_module</code>模块以指定的格式写入请求日志。 </p>
<p>  请求记录在处理结束的位置的上下文中。  如果在请求处理期间发生<a href="ngx_http_core_module.html#internal">内部重定向</a> ，则它可能与原始位置不同。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">log_format compression '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $bytes_sent '
                       '"$http_referer" "$http_user_agent" "$gzip_ratio"';

access_log /spool/logs/nginx-access.log compression buffer=32k;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**access_log**  *path*</code>    [ <code>*format*</code>    [ <code>buffer</code> = <code>*size*</code> ]    [ <code>gzip[= &lt;code class=&quot;notranslate&quot;&gt;*level*</code> ] ]    [ <code>flush</code> = <code>*time*</code> ]    [ <code>if</code> = <code>*condition*</code> ]]; <br> <code>**access_logoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">access_log logs/access.log combined;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> , <code>limit_except</code> <br>                </td></p>
<p>  设置缓冲日志写入的路径，格式和配置。  可以在同一级别指定多个日志。  可以通过在第一个参数中指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  特殊值<code>off</code>取消当前级别的所有<code>access_log</code>指令。  如果未指定格式，则使用预定义的“ <code>combined</code> ”格式。 </p>
<p>  如果使用<code>buffer</code>或<code>gzip</code> （1.3.10,1.2.7）参数，则将缓冲写入日志。 </p>
<blockquote>
<p>  缓冲区大小不得超过磁盘文件的原子写入大小。  对于FreeBSD，这个大小是无限的。 </p>
</blockquote>
<p>  启用缓冲后，数据将写入文件： </p>
<ul>
<li>如果下一个日志行不适合缓冲区; -   如果缓冲的数据早于<code>flush</code>参数（1.3.10,1.2.7）指定的数据; -   当工作进程<a href="control.html">重新打开</a>日志文件或正在关闭时。 </li>
</ul>
<p>  如果使用<code>gzip</code>参数，则在写入文件之前将压缩缓冲的数据。  压缩级别可以设置为1（最快，压缩较少）和9（最慢，最佳压缩）。  默认情况下，缓冲区大小等于64K字节，压缩级别设置为1.由于数据是以原子块压缩的，因此日志文件可以随时通过“ <code>zcat</code> ”解压缩或读取。 </p>
<p>  例： </p>
<pre class="notranslate">access_log /path/to/log.gz combined gzip flush=5m;
</pre>





<blockquote>
<p>  要使gzip压缩起作用，必须使用zlib库构建nginx。 </p>
</blockquote>
<p>  文件路径可以包含变量（0.7.6+），但是这样的日志有一些约束： </p>
<ul>
<li>工作进程使用其凭据的<a href="ngx_core_module.html#user">用户</a>应具有在具有此类日志的目录中创建文件的权限; -   缓冲写入不起作用; -   每个日志写入都会打开和关闭该文件。  但是，由于常用文件的描述符可以存储在<a href="#open_log_file_cache">缓存中</a> ，因此写入旧文件可以在<a href="#open_log_file_cache">open_log_file_cache</a>指令的<code>valid</code>参数指定的时间内继续写入 </li><li>  在每个日志写入期间，检查是否存在请求的<a href="ngx_http_core_module.html#root">根目录</a> ，如果它不存在，则不会创建日志。  因此，在同一级别指定<a href="ngx_http_core_module.html#root">root</a>和<code>access_log</code>是个好主意： <blockquote class="example"><pre class="notranslate">server {<br>root       /spool/vhost/data/$host;<br>access_log /spool/vhost/logs/$host;<br>…<br></pre></blockquote></li>
</ul>
<p>   <code>if</code>参数（1.7.0）启用条件记录。  如果<code>*condition*</code>评估为“0”或空字符串，则不会记录请求。  在以下示例中，将不记录响应代码为2xx和3xx的请求： </p>
<pre class="notranslate">map $status $loggable {
    ~^[23]  0;
    default 1;
}

access_log /path/to/access.log combined if=$loggable;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**log_format**  *name*</code>    [ <code>escape</code> = <code>default</code> | <code>json</code> | <code>none</code> ]    <code>*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">log_format combined “…”;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定日志格式。 </p>
<p>   <code>escape</code>参数（1.11.8）允许设置在变量中转义的<code>json</code>或<code>default</code>字符，默认情况下，使用<code>default</code>转义。   <code>none</code>值（1.13.10）禁用转义。 </p>
<p>  日志格式可以包含公共变量，以及仅在日志写入时存在的变量： </p>
<blockquote>
<p>  在现代nginx版本变量<a href="ngx_http_core_module.html#var_status">$ status</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.2,1.2.2</a> ）， <a href="ngx_http_core_module.html#var_bytes_sent">$ bytes_sent</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2.5</a> ）， <a href="ngx_http_core_module.html#var_connection">$ connection</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2.5</a> ）， <a href="ngx_http_core_module.html#var_connection">$ connection_requests</a> （ <a href="ngx_http_core_module.html#var_bytes_sent">1.3.8,1.2</a> ） .5）， <a href="ngx_http_core_module.html#var_msec">$ msec</a> （1.3.9,1.2.6）， <a href="ngx_http_core_module.html#var_request_time">$ request_time</a> （1.3.9,1.2.6）， <a href="ngx_http_core_module.html#var_pipe">$ pipe</a> （1.3.12,1.2.7）， <a href="ngx_http_core_module.html#var_request_length">$ request_length</a> （1.3.12,1.2.7） ）， <a href="ngx_http_core_module.html#var_time_iso8601">$ time_iso8601</a> （ <a href="ngx_http_core_module.html#var_time_iso8601">1.3.12,1.2.7</a> ）和<a href="ngx_http_core_module.html#var_time_local">$ time_local</a> （1.3.12,1.2.7）也可用作公共变量。 </p>
</blockquote>
<p>  发送到客户端的标题行具有前缀“ <code>sent_http_</code> ”，例如<code>$sent_http_content_range</code> 。 </p>
<p>  配置始终包含预定义的“ <code>combined</code> ”格式： </p>
<pre class="notranslate">log_format combined '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent"';
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**open_log_file_cachemax</code> = <code>*N*</code>[ <code>inactive</code> = <code>*time*</code> ][ <code>min_uses</code> = <code>*N*</code> ][ <code>valid</code> = <code>*time*</code> ]; <br> <code>**open_log_file_cacheoff</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">open_log_file_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义一个缓存，用于存储名称中包含变量的常用日志的文件描述符。  该指令具有以下参数： </p>
<p>  用法示例： </p>
<pre class="notranslate">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_req_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_req_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_req_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-req-module"><a href="#Module-ngx-http-limit-req-module" class="headerlink" title="Module ngx_http_limit_req_module"></a>Module ngx_http_limit_req_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_req">limit_req</a> <br>     <a href="#limit_req_log_level">limit_req_log_level</a> <br>     <a href="#limit_req_status">limit_req_status</a> <br>     <a href="#limit_req_zone">limit_req_zone</a> <br></td>

<p>   <code>ngx_http_limit_req_module</code>模块（0.7.21）用于限制每个定义密钥的请求处理速率，特别是来自单个IP地址的请求的处理速率。  使用“漏桶”方法进行限制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

    ...

    server {

        ...

        location /search/ {
            limit_req zone=one burst=5;
        }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req** zone</code> = <code>*name*</code>    [ <code>burst</code> = <code>*number*</code> ]    [ <code>nodelay</code> |     <code>delay</code> = <code>*number*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置共享内存区域和请求的最大突发大小。  如果请求速率超过为区域配置的速率，则延迟其处理，以便以定义的速率处理请求。  过多的请求被延迟，直到它们的数量超过最大突发大小，在这种情况下请求以<a href="#limit_req_status">错误</a>终止。  默认情况下，最大突发大小等于零。  例如，指令 </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

server {
    location /search/ {
        limit_req zone=one burst=5;
    }
</pre>

<p>  允许每秒平均不超过1个请求，突发不超过5个请求。 </p>
<p>  如果不希望在请求受限的情况下延迟过多的请求，则应使用参数<code>nodelay</code> ： </p>
<pre class="notranslate">limit_req zone=one burst=5 nodelay;
</pre>



<p>   <code>delay</code>参数（1.15.7）指定过多请求被延迟的限制。  默认值为零，即所有过多的请求都会延迟。 </p>
<p>  可能有几个<code>limit_req</code>指令。  例如，以下配置将限制来自单个IP地址的请求的处理速率，同时限制虚拟服务器的请求处理速率： </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s;
limit_req_zone $server_name zone=perserver:10m rate=10r/s;

server {
    ...
    limit_req zone=perip burst=5 nodelay;
    limit_req zone=perserver burst=10;
}
</pre>



<p>  当且仅当当前级别上没有<code>limit_req</code>指令时，这些指令才从先前级别继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_req_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.18版本中。 </p>
<p>  为服务器因速率超过或延迟请求处理而拒绝处理请求的情况设置所需的日志记录级别。  延迟的记录水平比拒绝的记录水平低一个点;  例如，如果指定了“ <code>limit_req_log_level notice</code> ”，则会使用<code>info</code>级别记录延迟。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_status*code*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_req_status 503;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  设置要响应拒绝的请求而返回的状态代码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_req_zone**  *key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code>    <code>rate</code> = <code>*rate*</code>    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态存储当前的过多请求数。   <code>*key*</code>可以包含文本，变量及其组合。  具有空键值的请求不计算在内。 </p>
<blockquote>
<p>  在1.7.6版之前， <code>*key*</code>可以只包含一个变量。 </p>
</blockquote>
<p>  用法示例： </p>
<pre class="notranslate">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
</pre>



<p>  这里，状态保持在10兆字节区域“1”，并且该区域的平均请求处理速率不能超过每秒1个请求。 </p>
<p>  客户端IP地址用作密钥。  请注意，此处使用<code>$binary_remote_addr</code>变量而不是<code>$remote_addr</code> 。  对于IPv4地址， <code>$binary_remote_addr</code>变量的大小始终为4个字节，对于IPv6地址，则为16个字节。  存储状态在32位平台上总是占用64个字节，在64位平台上占用128个字节。  一兆字节区域可以保留大约16,000个64字节状态或大约8千个128字节状态。 </p>
<p>  如果区域存储耗尽，则删除最近最少使用的状态。  即使在此之后无法创建新状态，该请求也会因<a href="#limit_req_status">错误</a>而终止。 </p>
<p>  速率以每秒请求数（r / s）指定。  如果需要每秒少于一个请求的速率，则在每分钟请求（r / m）中指定。  例如，每秒半请求为30r / m。 </p>
<p>   <code>sync</code>参数（1.15.3）启用共享内存区域的<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a> 。 </p>
<blockquote>
<p>   <code>sync</code>参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_limit_conn_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_limit_conn_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_limit_conn_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-limit-conn-module"><a href="#Module-ngx-http-limit-conn-module" class="headerlink" title="Module ngx_http_limit_conn_module"></a>Module ngx_http_limit_conn_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#limit_conn">limit_conn</a> <br>     <a href="#limit_conn_log_level">limit_conn_log_level</a> <br>     <a href="#limit_conn_status">limit_conn_status</a> <br>     <a href="#limit_conn_zone">limit_conn_zone</a> <br>     <a href="#limit_zone">limit_zone</a> <br></td>

<p>   <code>ngx_http_limit_conn_module</code>模块用于限制每个定义密钥的连接数，特别是来自单个IP地址的连接数。 </p>
<p>  并非所有连接都被计算在内  仅当连接具有服务器正在处理的请求并且已经读取了整个请求标头时才计算连接。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    limit_conn_zone $binary_remote_addr zone=addr:10m;

    ...

    server {

        ...

        location /download/ {
            limit_conn addr 1;
        }
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn*zone*</code> <code>*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置共享内存区域和给定键值的最大允许连接数。  超过此限制时，服务器将返回<a href="#limit_conn_status">错误</a>以回复请求。  例如，指令 </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    location /download/ {
        limit_conn addr 1;
    }
</pre>

<p>  每次只允许一个IP地址连接一个。 </p>
<blockquote>
<p>  在HTTP / 2和SPDY中，每个并发请求被视为单独的连接。 </p>
</blockquote>
<p>  可能有几个<code>limit_conn</code>指令。  例如，以下配置将限制每个客户端IP与服务器的连接数，同时限制与虚拟服务器的连接总数： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;

server {
    ...
    limit_conn perip 10;
    limit_conn perserver 100;
}
</pre>



<p>  当且仅当当前级别上没有<code>limit_conn</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_log_levelinfo</code> |<code>notice</code> |<code>warn</code> |<code>error</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_log_level error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.18版本中。 </p>
<p>  为服务器限制连接数的情况设置所需的日志记录级别。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_status*code*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">limit_conn_status 503;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  设置要响应拒绝的请求而返回的状态代码。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_conn_zone**  *key*</code>    <code>zone</code> = <code>*name*</code> : <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置共享内存区域的参数，该区域将保留各种键的状态。  特别是，状态包括当前的连接数。   <code>*key*</code>可以包含文本，变量及其组合。  具有空键值的请求不计算在内。 </p>
<blockquote>
<p>  在1.7.6版之前， <code>*key*</code>可以只包含一个变量。 </p>
</blockquote>
<p>  用法示例： </p>
<pre class="notranslate">limit_conn_zone $binary_remote_addr zone=addr:10m;
</pre>

<p>  这里，客户端IP地址用作密钥。  请注意，此处使用<code>$binary_remote_addr</code>变量而不是<code>$remote_addr</code> 。   <code>$remote_addr</code>变量的大小可以在7到15个字节之间变化。  存储状态在32位平台上占用32或64字节的内存，在64位平台上占用64字节。  对于IPv4地址， <code>$binary_remote_addr</code>变量的大小始终为4个字节，对于IPv6地址，则为16个字节。  存储状态在32位平台上总是占用32或64字节，在64位平台上占用64字节。  一兆字节区域可以保留大约32,000个32字节状态或大约16,000个64字节状态。  如果区域存储空间耗尽，服务器将向所有其他请求返回<a href="#limit_conn_status">错误</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**limit_zone**  *name*</code>    <code>*$variable*</code>    <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令在1.1.8版本中已过时，已在1.7.6版本中删除。  应使用具有更改语法的等效<a href="#limit_conn_zone">limit_conn_zone</a>指令： </p>
<blockquote>
<p>   <code>limit_conn_zone</code> <code>*$variable*</code> <code>zone</code> = <code>*name*</code> ： <code>*size*</code> ; </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_keyval_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_keyval_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_keyval_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-keyval-module"><a href="#Module-ngx-http-keyval-module" class="headerlink" title="Module ngx_http_keyval_module"></a>Module ngx_http_keyval_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#keyval">keyval</a> <br>     <a href="#keyval_zone">keyval_zone</a> <br></td>

<p>   <code>ngx_http_keyval_module</code>模块（1.13.3）创建的变量的值取自<a href="ngx_http_api_module.html#http_keyvals_">API</a>管理的键值对。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {

    keyval_zone zone=one:32k state=one.keyval;
    keyval $arg_text $text zone=one;
    ...
    server {
        ...
        location / {
            return 200 $text;
        }

        location /api {
            api write=on;
        }
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval**  *key*</code>    <code>*$variable*</code>    <code>zone</code> = <code>*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  创建一个新的<code>*$variable*</code>其值由<code>*key*</code>数据库中的键查找。  字符串匹配忽略大小写。  数据库存储在<code>zone</code>参数指定的共享内存区域中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**keyval_zone** zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>state</code> = <code>*file*</code> ]    [ <code>timeout</code> = <code>*time*</code> ]    [ <code>sync</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置保留键值数据库的共享内存区域的<code>*name*</code>和<code>*size*</code> 。  键值对由<a href="ngx_http_api_module.html#http_keyvals_">API</a>管理。 </p>
<p>  可选的<code>state</code>参数指定一个<code>*file*</code> ，该<code>*file*</code>以JSON格式保持键值数据库的当前状态，并使其在nginx重新启动时保持不变。 </p>
<p>  可选的<code>timeout</code>参数（1.15.0）设置从区域中删除键值对的时间。 </p>
<p>  可选的<code>sync</code>参数（1.15.0）可以<a href="stream/ngx_stream_zone_sync_module.html#zone_sync">同步</a>共享内存区域。  同步需要设置<a href="#keyval_timeout">超时</a>参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_js_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_js_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_js_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-js-module"><a href="#Module-ngx-http-js-module" class="headerlink" title="Module ngx_http_js_module"></a>Module ngx_http_js_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#js_content">js_content</a> <br>     <a href="#js_include">js_include</a> <br>     <a href="#js_set">js_set</a> <br> <a href="#arguments">Request Argument</a> <br></td>

<p>   <code>ngx_http_js_module</code>模块用于在<a href="njs/index.html">njs中</a>实现位置和变量处理程序 - 这是JavaScript语言的一个子集。 </p>
<p>  默认情况下不构建此模块。  可<a href="njs/install.html">在此处</a>下载和安装说明。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">load_module modules/ngx_http_js_module.so;
...

http {
    js_include http.js;

    js_set $foo     foo;
    js_set $summary summary;

    server {
        listen 8000;

        location / {
            add_header X-Foo $foo;
            js_content baz;
        }

        location = /summary {
            return 200 $summary;
        }

        location = /hello {
            js_content hello;
        }
    }
}
</pre>



<p>   <code>http.js</code>文件： </p>
<pre class="notranslate">function foo(r) {
    r.log("hello from foo() handler");
    return "foo";
}

function summary(r) {
    var a, s, h;

    s = "JS summary\n\n";

    s += "Method: " + r.method + "\n";
    s += "HTTP version: " + r.httpVersion + "\n";
    s += "Host: " + r.headersIn.host + "\n";
    s += "Remote Address: " + r.remoteAddress + "\n";
    s += "URI: " + r.uri + "\n";

    s += "Headers:\n";
    for (h in r.headersIn) {
        s += "  header '" + h + "' is '" + r.headersIn[h] + "'\n";
    }

    s += "Args:\n";
    for (a in r.args) {
        s += "  arg '" + a + "' is '" + r.args[a] + "'\n";
    }

    return s;
}

function baz(r) {
    r.status = 200;
    r.headersOut.foo = 1234;
    r.headersOut['Content-Type'] = "text/plain; charset=utf-8";
    r.headersOut['Content-Length'] = 15;
    r.sendHeader();
    r.send("nginx");
    r.send("java");
    r.send("script");

    r.finish();
}

function hello(r) {
    r.return(200, "Hello world!");
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_content*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  将njs函数设置为位置内容处理程序。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_include*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定在njs中实现位置和变量处理程序的文件。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**js_set*$variable*</code> <code>*function*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  为指定的变量设置njs函数。 </p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>  每个HTTP njs处理程序都接收一个参数，一个请求<a href="njs/reference.html#http">对象</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_index_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_index_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_index_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-index-module"><a href="#Module-ngx-http-index-module" class="headerlink" title="Module ngx_http_index_module"></a>Module ngx_http_index_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#index">index</a> <br></td>

<p>   <code>ngx_http_index_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求。  这些请求也可以由<a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a>和<a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>模块处理。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    index index.$geo.html index.html;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**index*file*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">index index.html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义将用作索引的文件。   <code>*file*</code>名可以包含变量。  按指定顺序检查文件。  列表的最后一个元素可以是具有绝对路径的文件。  例： </p>
<pre class="notranslate">index index.$geo.html index.0.html /index.html;
</pre>



<p>  应该注意，使用索引文件会导致内部重定向，并且可以在不同的位置处理请求。  例如，使用以下配置： </p>
<pre class="notranslate">location = / {
    index index.html;
}

location / {
    ...
}
</pre>

<p>   “ <code>/</code> ”请求实际上将在第二个位置处理为“ <code>/index.html</code> ”。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_image_filter_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_image_filter_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_image_filter_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-image-filter-module"><a href="#Module-ngx-http-image-filter-module" class="headerlink" title="Module ngx_http_image_filter_module"></a>Module ngx_http_image_filter_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#image_filter">image_filter</a> <br>     <a href="#image_filter_buffer">image_filter_buffer</a> <br>     <a href="#image_filter_interlace">image_filter_interlace</a> <br>     <a href="#image_filter_jpeg_quality">image_filter_jpeg_quality</a> <br>     <a href="#image_filter_sharpen">image_filter_sharpen</a> <br>     <a href="#image_filter_transparency">image_filter_transparency</a> <br>     <a href="#image_filter_webp_quality">image_filter_webp_quality</a> <br></td>

<p>   <code>ngx_http_image_filter_module</code>模块（0.7.54+）是一个过滤器，可以转换JPEG，GIF，PNG和WebP格式的图像。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_image_filter_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块使用<a href="http://libgd.org" target="_blank" rel="noopener">libgd</a>库。  建议使用最新版本的库。 </p>
<p>   WebP格式支持出现在1.11.6版中。  要以此格式转换图像，必须使用WebP支持编译<code>libgd</code>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /img/ {
    proxy_pass   http://backend;
    image_filter resize 150 100;
    image_filter rotate 90;
    error_page   415 = /empty;
}

location = /empty {
    empty_gif;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filteroff</code> ; <br> <code>**image_filtertest</code> ; <br> <code>**image_filtersize</code> ; <br> <code>**image_filter** rotate</code>    <code>90</code> | <code>180</code> |    <code>270</code> ; <br> <code>**image_filter** resize</code>    <code>*width*</code>    <code>*height*</code> ; <br> <code>**image_filter** crop</code>    <code>*width*</code>    <code>*height*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  设置要对图像执行的转换类型： </p>
<pre class="notranslate">{ "img" : { "width": 100, "height": 100, "type": "gif" } }
</pre>

<pre class="notranslate">{}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_buffer*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_buffer 1M;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取图像的缓冲区的最大大小。  超出大小时，服务器返回错误415（不支持的介质类型）。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_interlaceon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_interlace off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.3.15版本中。 </p>
<p>  如果启用，最终图像将被隔行扫描。  对于JPEG，最终图像将采用“渐进式JPEG”格式。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_jpeg_quality*quality*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_jpeg_quality 75;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置变换后的JPEG图像的所需<code>*quality*</code> 。  可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。  建议的最大值为95.参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_sharpen*percent*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_sharpen 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  增加最终图像的清晰度。  锐度百分比可以超过100.零值禁用锐化。  参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_transparencyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_transparency on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义在使用调色板指定的颜色转换GIF图像或PNG图像时是否应保留透明度。  透明度的丧失导致图像质量更好。  始终保留PNG中的Alpha通道透明度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**image_filter_webp_quality*quality*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">image_filter_webp_quality 80;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置转换的WebP图像的所需<code>*quality*</code> 。  可接受的值在1到100的范围内。较小的值通常意味着较低的图像质量和较少的传输数据。  参数值可以包含变量。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_hls_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_hls_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_hls_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-hls-module"><a href="#Module-ngx-http-hls-module" class="headerlink" title="Module ngx_http_hls_module"></a>Module ngx_http_hls_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#hls">hls</a> <br>     <a href="#hls_buffers">hls_buffers</a> <br>     <a href="#hls_forward_args">hls_forward_args</a> <br>     <a href="#hls_fragment">hls_fragment</a> <br>     <a href="#hls_mp4_buffer_size">hls_mp4_buffer_size</a> <br>     <a href="#hls_mp4_max_buffer_size">hls_mp4_max_buffer_size</a> <br></td>

<p>   <code>ngx_http_hls_module</code>模块为MP4和MOV媒体文件提供HTTP实时流（HLS）服务器端支持。  此类文件通常具有<code>.mp4</code> ， <code>.m4v</code> ， <code>.m4a</code> ， <code>.mov</code>或<code>.qt</code>文件扩展名。  该模块支持H.264视频编解码器，AAC和MP3音频编解码器。 </p>
<p>  对于每个媒体文件，支持两个URI： </p>
<ul>
<li>带有“ <code>.m3u8</code> ”文件扩展名的播放列表URI。   URI可以接受可选参数： <ul class="compact"><li>   “ <code>start</code> ”和“ <code>end</code> ”以秒为单位定义播放列表边界（1.9.0）。 -    “ <code>offset</code> ”将初始播放位置移动到以秒为单位的时间偏移（1.9.0）。  正值设置从播放列表开头的时间偏移量。  负值设置播放列表中最后一个片段末尾的时间偏移量。 -    “ <code>len</code> ”以秒为单位定义片段长度。 -    “ <code>start</code> ”和“ <code>end</code> ”以秒为单位定义片段边界。 </li>
</ul>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    hls;
    hls_fragment            5s;
    hls_buffers             10 10m;
    hls_mp4_buffer_size     1m;
    hls_mp4_max_buffer_size 5m;
    root /var/video/;
}
</pre>

<p>  使用此配置，“/ <code>/var/video/test.mp4</code> ”文件支持以下URI： </p>
<pre class="notranslate">http://hls.example.com/test.mp4.m3u8?offset=1.000&amp;start=1.000&amp;end=2.200
http://hls.example.com/test.mp4.m3u8?len=8.000
http://hls.example.com/test.mp4.ts?start=1.000&amp;end=2.200
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的HLS流。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_buffers 8 2m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取和写入数据帧的缓冲区的最大<code>*number*</code>和<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_forward_argson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_forward_args off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.12版本中。 </p>
<p>  将播放列表请求中的参数添加到片段的URI中。  这对于在请求片段时或在使用<a href="ngx_http_secure_link_module.html">ngx_http_secure_link_module</a>模块保护HLS流时执行客户端授权可能很有用。 </p>
<p>  例如，如果客户端请求播放列表<code>http://example.com/hls/test.mp4.m3u8?a=1&amp;amp;b=2</code> ，则参数<code>a=1</code>和<code>b=2</code>将添加到参数后的片段的URI中<code>start</code>和<code>end</code> ： </p>
<pre class="notranslate">#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:15
#EXT-X-PLAYLIST-TYPE:VOD

#EXTINF:9.333,
test.mp4.ts?start=0.000&amp;end=9.333&amp;a=1&amp;b=2
#EXTINF:7.167,
test.mp4.ts?start=9.333&amp;end=16.500&amp;a=1&amp;b=2
#EXTINF:5.416,
test.mp4.ts?start=16.500&amp;end=21.916&amp;a=1&amp;b=2
#EXTINF:5.500,
test.mp4.ts?start=21.916&amp;end=27.416&amp;a=1&amp;b=2
#EXTINF:15.167,
test.mp4.ts?start=27.416&amp;end=42.583&amp;a=1&amp;b=2
#EXTINF:9.626,
test.mp4.ts?start=42.583&amp;end=52.209&amp;a=1&amp;b=2

#EXT-X-ENDLIST
</pre>



<p>  如果使用<a href="ngx_http_secure_link_module.html">ngx_http_secure_link_module</a>模块保护HLS流，则不应在<a href="ngx_http_secure_link_module.html#secure_link_md5">secure_link_md5</a>表达式中使用<code>$uri</code> ，因为这会在请求片段时导致错误。  应该使用<a href="ngx_http_map_module.html#map">基URI</a>而不是<code>$uri</code> （ <code>$hls_uri</code>中为<code>$hls_uri</code> ）： </p>
<pre class="notranslate">http {
    ...

    map $uri $hls_uri {
        ~^(?&lt;base_uri&gt;.*).m3u8$ $base_uri;
        ~^(?&lt;base_uri&gt;.*).ts$   $base_uri;
        default                 $uri;
    }

    server {
        ...

        location /hls/ {
            hls;
            hls_forward_args on;

            alias /var/videos/;

            secure_link $arg_md5,$arg_expires;
            secure_link_md5 "$secure_link_expires$hls_uri$remote_addr secret";

            if ($secure_link = "") {
                return 403;
            }

            if ($secure_link = "0") {
                return 410;
            }
        }
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_fragment*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_fragment 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为没有“ <code>len</code> ”参数的请求的播放列表URI定义默认片段长度。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_mp4_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_mp4_buffer_size 512k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于处理MP4和MOV文件的缓冲区的初始<code>*size*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**hls_mp4_max_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">hls_mp4_max_buffer_size 10m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在元数据处理期间，可能需要更大的缓冲区。  它的大小不能超过指定的<code>*size*</code> ，否则nginx将返回服务器错误500（内部服务器错误），并记录以下消息： </p>
<pre class="notranslate">"/some/movie/file.mp4" mp4 moov atom is too large:
12583268, you may want to increase hls_mp4_max_buffer_size
</pre>





</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_headers_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_headers_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_headers_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-headers-module"><a href="#Module-ngx-http-headers-module" class="headerlink" title="Module ngx_http_headers_module"></a>Module ngx_http_headers_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#add_header">add_header</a> <br>     <a href="#add_trailer">add_trailer</a> <br>     <a href="#expires">expires</a> <br></td>

<p>   <code>ngx_http_headers_module</code>模块允许将“Expires”和“Cache-Control”头字段以及任意字段添加到响应头。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">expires    24h;
expires    modified +24h;
expires    @24h;
expires    0;
expires    -1;
expires    epoch;
expires    $expires;
add_header Cache-Control private;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_header*name*</code> <code>*value*</code>[ <code>always</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  将指定字段添加到响应头，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1.16,1.0.13）或308（1.13） .0）。  该值可以包含变量。 </p>
<p>  可能有几个<code>add_header</code>指令。  当且仅当在当前级别上没有定义<code>add_header</code>指令时，这些指令才从前一级继承。 </p>
<p>  如果指定了<code>always</code>参数（1.7.5），则无论响应代码如何，都将添加标题字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_trailer*name*</code> <code>*value*</code>[ <code>always</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  该指令出现在1.13.2版中。 </p>
<p>  如果响应代码等于200,201,206,301,302,303,307或308，则将指定字段添加到响应的末尾。该值可以包含变量。 </p>
<p>  可能有几个<code>add_trailer</code>指令。  当且仅当在当前级别上没有定义<code>add_trailer</code>指令时，这些指令才从先前级别继承。 </p>
<p>  如果指定了<code>always</code>参数，则无论响应代码如何，都将添加指定的字段。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**expires** [ modified</code> ] <code>*time*</code> ; <br> <code>**expires** epoch</code> |    <code>max</code> |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">expires off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用添加或修改“Expires”和“Cache-Control”响应头字段，前提是响应代码等于200,201（1.3.10），204,206,301,302,303,304,307（1.1。 16,1.0.13）或308（1.13.0）。  参数可以是正<a href="syntax.html">时间</a>或负<a href="syntax.html">时间</a> 。 </p>
<p>   “Expires”字段中的时间计算为指令中指定的当前时间和<code>*time*</code>的总和。  如果使用<code>modified</code>参数（0.7.0,0.6.32），则计算时间为文件修改时间与指令中指定时间的总和。 </p>
<p>  此外，可以使用“ <code>@</code> ”前缀（0.7.9,0.6.34）指定一天中的时间： </p>
<pre class="notranslate">expires @15h30m;
</pre>



<p>   <code>epoch</code>参数对应于绝对时间“ <code>Thu, 01 Jan 1970 00:00:01 GMT</code> ”。   “Cache-Control”字段的内容取决于指定时间的符号： </p>
<ul>
<li>时间是负面的 - “Cache-Control：no-cache”。 -   时间为正或零 - “Cache-Control：max-age = <code>*t*</code> ”，其中<code>*t*</code>是指令中指定的时间，以秒为单位。 </li>
</ul>
<p>   <code>max</code>参数将“Expires”设置为值“ <code>Thu, 31 Dec 2037 23:55:55 GMT</code> ”，并将“Cache-Control”设置为10年。 </p>
<p>   <code>off</code>参数禁用添加或修改“Expires”和“Cache-Control”响应头字段。 </p>
<p>  最后一个参数值可以包含变量（1.7.9）： </p>
<pre class="notranslate">map $sent_http_content_type $expires {
    default         off;
    application/pdf 42d;
    ~image/         max;
}

expires $expires;
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_static_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_static_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_static_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-static-module"><a href="#Module-ngx-http-gzip-static-module" class="headerlink" title="Module ngx_http_gzip_static_module"></a>Module ngx_http_gzip_static_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gzip_static">gzip_static</a> <br></td>

<p>   <code>ngx_http_gzip_static_module</code>模块允许发送带有“ <code>.gz</code> ”文件扩展名的预压缩文件，而不是常规文件。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_gzip_static_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">gzip_static  on;
gzip_proxied expired no-cache no-store private auth;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_static** on</code> |    <code>off</code> |    <code>always</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_static off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用（“ <code>on</code> ”）或禁用（“ <code>off</code> ”）检查预压缩文件是否存在。  还考虑了以下指令： <a href="ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> ， <a href="ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a> ， <a href="ngx_http_gzip_module.html#gzip_disable">gzip_disable</a>和<a href="ngx_http_gzip_module.html#gzip_vary">gzip_vary</a> 。 </p>
<p>  使用“ <code>always</code> ”值（1.3.6），在所有情况下都使用gzip压缩文件，而不检查客户端是否支持它。  如果磁盘上没有未压缩的文件或者使用了<a href="ngx_http_gunzip_module.html">ngx_http_gunzip_module，</a>则非常有用。 </p>
<p>  可以使用<code>gzip</code>命令或任何其他兼容的文件压缩文件。  建议原始文件和压缩文件的修改日期和时间相同。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gzip-module"><a href="#Module-ngx-http-gzip-module" class="headerlink" title="Module ngx_http_gzip_module"></a>Module ngx_http_gzip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gzip">gzip</a> <br>     <a href="#gzip_buffers">gzip_buffers</a> <br>     <a href="#gzip_comp_level">gzip_comp_level</a> <br>     <a href="#gzip_disable">gzip_disable</a> <br>     <a href="#gzip_http_version">gzip_http_version</a> <br>     <a href="#gzip_min_length">gzip_min_length</a> <br>     <a href="#gzip_proxied">gzip_proxied</a> <br>     <a href="#gzip_types">gzip_types</a> <br>     <a href="#gzip_vary">gzip_vary</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_gzip_module</code>模块是一个使用“gzip”方法压缩响应的过滤器。  这通常有助于将传输数据的大小减少一半甚至更多。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">gzip            on;
gzip_min_length 1000;
gzip_proxied    expired no-cache no-store private auth;
gzip_types      text/plain application/xml;
</pre>



<p>   <code>$gzip_ratio</code>变量可用于记录实现的压缩比。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzipon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  启用或禁用gzipping响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_buffers 32 4k|16 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于压缩响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<blockquote>
<p>  在版本0.7.28之前，默认使用四个4K或8K缓冲区。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_comp_level*level*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_comp_level 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置响应的gzip压缩<code>*level*</code> 。  可接受的值范围为1到9。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_disable*regex*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.6.23版本中。 </p>
<p>  对具有与任何指定正则表达式匹配的“User-Agent”标头字段的请求禁用gzipping响应。 </p>
<p>  特殊掩码“ <code>msie6</code> ”（0.7.12）对应于正则表达式“ <code>MSIE [4-6]\.</code>   “，但工作得更快。  从版本0.8.11开始，“ <code>MSIE 6.0; ... SV1</code>   <code>MSIE 6.0; ... SV1</code>此掩码中不包括“ <code>MSIE 6.0; ... SV1</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_http_version1.0</code> | <code>1.1</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_http_version 1.1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置压缩响应所需的最低HTTP请求版本。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_min_length*length*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_min_length 20;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将被gzip压缩的响应的最小长度。  长度仅由“Content-Length”响应头字段确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_proxied** off</code> |    <code>expired</code> |    <code>no-cache</code> |    <code>no-store</code> |    <code>private</code> |    <code>no_last_modified</code> |    <code>no_etag</code> |    <code>auth</code> |    <code>any</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_proxied off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  根据请求和响应启用或禁用对代理请求的响应的gzipping。  代理请求的事实由“Via”请求头字段的存在确定。  该指令接受多个参数： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  除了“ <code>text/html</code> ”之外，还允许对指定的MIME类型进行gzipping响应。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。  始终压缩“ <code>text/html</code> ”类型的响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gzip_varyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gzip_vary off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令<a href="#gzip">gzip</a> ， <a href="ngx_http_gzip_static_module.html#gzip_static">gzip_static</a>或<a href="ngx_http_gunzip_module.html#gunzip">gunzip</a>处于活动状态，则启用或禁用插入“Vary：Accept-Encoding”响应头字段。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_gunzip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_gunzip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_gunzip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-gunzip-module"><a href="#Module-ngx-http-gunzip-module" class="headerlink" title="Module ngx_http_gunzip_module"></a>Module ngx_http_gunzip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#gunzip">gunzip</a> <br>     <a href="#gunzip_buffers">gunzip_buffers</a> <br></td>

<p>   <code>ngx_http_gunzip_module</code>模块是一个过滤器，它使用“ <code>Content-Encoding: gzip</code> ”解压缩响应，用于不支持“gzip”编码方法的客户端。  当需要存储压缩数据以节省空间并降低I / O成本时，该模块将非常有用。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_gunzip_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /storage/ {
    gunzip on;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gunzipon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gunzip off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用对缺少gzip支持的客户端的gzip压缩解压缩。  如果启用，则在确定客户端是否支持gzip时还会考虑以下指令： <a href="ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> ， <a href="ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a>和<a href="ngx_http_gzip_module.html#gzip_disable">gzip_disable</a> 。  另请参见<a href="ngx_http_gzip_module.html#gzip_vary">gzip_vary</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**gunzip_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">gunzip_buffers 32 4k|16 8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于解压缩响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_grpc_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_grpc_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_grpc_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-grpc-module"><a href="#Module-ngx-http-grpc-module" class="headerlink" title="Module ngx_http_grpc_module"></a>Module ngx_http_grpc_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#grpc_bind">grpc_bind</a> <br>     <a href="#grpc_buffer_size">grpc_buffer_size</a> <br>     <a href="#grpc_connect_timeout">grpc_connect_timeout</a> <br>     <a href="#grpc_hide_header">grpc_hide_header</a> <br>     <a href="#grpc_ignore_headers">grpc_ignore_headers</a> <br>     <a href="#grpc_intercept_errors">grpc_intercept_errors</a> <br>     <a href="#grpc_next_upstream">grpc_next_upstream</a> <br>     <a href="#grpc_next_upstream_timeout">grpc_next_upstream_timeout</a> <br>     <a href="#grpc_next_upstream_tries">grpc_next_upstream_tries</a> <br>     <a href="#grpc_pass">grpc_pass</a> <br>     <a href="#grpc_pass_header">grpc_pass_header</a> <br>     <a href="#grpc_read_timeout">grpc_read_timeout</a> <br>     <a href="#grpc_send_timeout">grpc_send_timeout</a> <br>     <a href="#grpc_set_header">grpc_set_header</a> <br>     <a href="#grpc_socket_keepalive">grpc_socket_keepalive</a> <br>     <a href="#grpc_ssl_certificate">grpc_ssl_certificate</a> <br>     <a href="#grpc_ssl_certificate_key">grpc_ssl_certificate_key</a> <br>     <a href="#grpc_ssl_ciphers">grpc_ssl_ciphers</a> <br>     <a href="#grpc_ssl_crl">grpc_ssl_crl</a> <br>     <a href="#grpc_ssl_name">grpc_ssl_name</a> <br>     <a href="#grpc_ssl_password_file">grpc_ssl_password_file</a> <br>     <a href="#grpc_ssl_protocols">grpc_ssl_protocols</a> <br>     <a href="#grpc_ssl_server_name">grpc_ssl_server_name</a> <br>     <a href="#grpc_ssl_session_reuse">grpc_ssl_session_reuse</a> <br>     <a href="#grpc_ssl_trusted_certificate">grpc_ssl_trusted_certificate</a> <br>     <a href="#grpc_ssl_verify">grpc_ssl_verify</a> <br>     <a href="#grpc_ssl_verify_depth">grpc_ssl_verify_depth</a> <br></td>

<p>   <code>ngx_http_grpc_module</code>模块允许将请求传递到gRPC服务器（1.13.10）。  该模块需要<a href="ngx_http_v2_module.html">ngx_http_v2_module</a>模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">server {
    listen 9000 http2;

    location / {
        grpc_pass 127.0.0.1:9000;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  使用可选端口从指定的本地IP地址发出到gRPC服务器的传出连接。  参数值可以包含变量。  特殊值<code>off</code>取消了从先前配置级别继承的<code>grpc_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数允许到gRPC服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">grpc_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要像指定<code>transparent</code>参数那样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自gRPC服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从gRPC服务器接收的响应的缓冲区的<code>*size*</code> 。  一旦收到响应，响应就会同步传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与gRPC服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会从gRPC服务器对客户端的响应中传递标题字段“Date”，“Server”和“X-Accel -…”。   <code>grpc_hide_header</code>指令设置了不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#grpc_pass_header">grpc_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从gRPC服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”和“X-Accel-Charset”。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的gRPC服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_502</code> |    <code>http_503</code> |    <code>http_504</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_502</code> ， <code>http_503</code> ， <code>http_504</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#grpc_next_upstream_tries">尝试次数</a>和<a href="#grpc_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制请求可以传递到<a href="#grpc_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  限制将请求传递到<a href="#grpc_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置gRPC服务器地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">grpc_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">grpc_pass unix:/tmp/grpc.socket;
</pre>

<p>  或者，可以使用“ <code>grpc://</code> ”方案： </p>
<pre class="notranslate">grpc_pass grpc://127.0.0.1:9000;
</pre>

<p>  要通过SSL使用gRPC，应使用“ <code>grpcs://</code> ”方案： </p>
<pre class="notranslate">grpc_pass grpcs://127.0.0.1:443;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将<a href="#grpc_hide_header">其他禁用的</a>头字段从gRPC服务器传递到客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从gRPC服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果gRPC服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求发送到gRPC服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果gRPC服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_set_header*field*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_set_header Content-Length $content_length;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将字段重新定义或附加到<a href="#grpc_pass_request_headers">传递</a>给gRPC服务器的请求标头。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>grpc_set_header</code>指令时，这些指令才从前一级继承。 </p>
<p>  如果标头字段的值是空字符串，则该字段将不会传递给gRPC服务器： </p>
<pre class="notranslate">grpc_set_header Accept-Encoding "";
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置与gRPC服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的证书的<code>*file*</code> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_certificate_key*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的密钥的<code>*file*</code> ，用于对gRPC SSL服务器进行身份验证。 </p>
<p>  可以指定value <code>engine</code> ： <code>*name*</code> ： <code>*id*</code>而不是<code>*file*</code> ，该<code>*file*</code>从OpenSSL引擎<code>*name*</code>加载具有指定<code>*id*</code>密钥。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_ciphers*ciphers*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_ciphers DEFAULT;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定对gRPC SSL服务器的请求的已启用密码。  密码以OpenSSL库理解的格式指定。 </p>
<p>  可以使用“ <code>openssl ciphers</code> ”命令查看完整列表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_crl*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的已吊销证书（CRL）的<code>*file*</code> ，用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_name*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_name host from grpc_pass;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许覆盖用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器证书的服务器名称，并在与gRPC SSL服务器建立连接时<a href="#grpc_ssl_server_name">通过SNI传递</a> 。 </p>
<p>  默认情况下，使用<a href="#grpc_pass">grpc_pass</a>的主机部分。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_password_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有密钥密码的<code>*file*</code> ，其中每个密码在单独的行上指定。  在加载密钥时依次尝试密码短语。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_protocols** [ SSLv2</code> ]    [ <code>SSLv3</code> ]    [ <code>TLSv1</code> ]    [ <code>TLSv1.1</code> ]    [ <code>TLSv1.2</code> ]    [ <code>TLSv1.3</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为gRPC SSL服务器的请求启用指定的协议。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_server_nameon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_server_name off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在与gRPC SSL服务器建立连接时，启用或禁用通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066）传递服务器名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_session_reuseon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_session_reuse on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在使用gRPC服务器时是否可以重用SSL会话。  如果日志中出现“ <code>SSL3_GET_FINISHED:digest check failed</code> ”错误，请尝试禁用会话重用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_trusted_certificate*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定具有PEM格式的可信CA证书的<code>*file*</code> ，用于<a href="#grpc_ssl_verify">验证</a> gRPC SSL服务器的证书。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_verifyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_verify off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用gRPC SSL服务器证书的验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**grpc_ssl_verify_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">grpc_ssl_verify_depth 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置gRPC SSL服务器证书链中的验证深度。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geo_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geo_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geo_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geo-module"><a href="#Module-ngx-http-geo-module" class="headerlink" title="Module ngx_http_geo_module"></a>Module ngx_http_geo_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geo">geo</a> <br></td>

<p>   <code>ngx_http_geo_module</code>模块使用取决于客户端IP地址的值创建变量。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">geo $geo {
    default        0;

    127.0.0.1      2;
    192.168.1.0/24 1;
    10.1.0.0/16    1;

    ::1            2;
    2001:0db8::/32 1;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geo** [ *$address*</code> ] <code>*$variable*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  描述指定变量的值对客户端IP地址的依赖性。  默认情况下，地址取自<code>$remote_addr</code>变量，但也可以从另一个变量（0.7.27）获取，例如： </p>
<pre class="notranslate">geo $arg_remote_addr $geo {
    ...;
}
</pre>





<blockquote>
<p>  由于变量仅在使用时进行评估，因此即使存在大量已声明的“ <code>geo</code> ”变量也不会导致请求处理的任何额外成本。 </p>
</blockquote>
<p>  如果变量的值不表示有效的IP地址，则使用“ <code>255.255.255.255</code> ”地址。 </p>
<p>  地址指定为CIDR表示法中的前缀（包括单个地址）或范围（0.7.23）。 </p>
<blockquote>
<p>  从版本1.3.10和1.2.7开始支持IPv6前缀。 </p>
</blockquote>
<p>  还支持以下特殊参数： </p>
<blockquote>
<p>  从版本1.3.0和1.2.1开始支持受信任的IPv6地址。 </p>
</blockquote>
<p>  例： </p>
<pre class="notranslate">geo $country {
    default        ZZ;
    include        conf/geo.conf;
    delete         127.0.0.0/16;
    proxy          192.168.100.0/24;
    proxy          2001:0db8::/32;

    127.0.0.0/24   US;
    127.0.0.1/32   RU;
    10.1.0.0/16    RU;
    192.168.1.0/24 UK;
}
</pre>



<p>   <code>conf/geo.conf</code>文件可以包含以下行： </p>
<pre class="notranslate">10.2.0.0/16    RU;
192.168.2.0/24 RU;
</pre>



<p>  使用最具体匹配的值。  例如，对于127.0.0.1地址，将选择值“ <code>RU</code> ”，而不是“ <code>US</code> ”。 </p>
<p>  范围示例： </p>
<pre class="notranslate">geo $country {
    ranges;
    default                   ZZ;
    127.0.0.0-127.0.0.0       US;
    127.0.0.1-127.0.0.1       RU;
    127.0.0.1-127.0.0.255     US;
    10.1.0.0-10.1.255.255     RU;
    192.168.1.0-192.168.1.255 UK;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_geoip_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_geoip_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_geoip_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-geoip-module"><a href="#Module-ngx-http-geoip-module" class="headerlink" title="Module ngx_http_geoip_module"></a>Module ngx_http_geoip_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#geoip_country">geoip_country</a> <br>     <a href="#geoip_city">geoip_city</a> <br>     <a href="#geoip_org">geoip_org</a> <br>     <a href="#geoip_proxy">geoip_proxy</a> <br>     <a href="#geoip_proxy_recursive">geoip_proxy_recursive</a> <br></td>

<p>   <code>ngx_http_geoip_module</code>模块（0.8.6+）使用预编译的<a href="http://www.maxmind.com" target="_blank" rel="noopener">MaxMind</a>数据库创建具有取决于客户端IP地址的值的变量。 </p>
<p>  使用支持IPv6的数据库（1.3.12,1.2.7）时，IPv4地址将被查找为IPv4映射的IPv6地址。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_geoip_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="http://www.maxmind.com/app/c" target="_blank" rel="noopener">MaxMind GeoIP</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    geoip_country         GeoIP.dat;
    geoip_city            GeoLiteCity.dat;
    geoip_proxy           192.168.100.0/24;
    geoip_proxy           2001:0db8::/32;
    geoip_proxy_recursive on;
    ...
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_country*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家/地区的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_city*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  指定用于根据客户端IP地址确定国家，地区和城市的数据库。  使用此数据库时，以下变量可用： </p>
<blockquote>
<p>  此变量可能包含过时的信息，因为不推荐使用相应的数据库字段。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_org*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.0.3版本中。 </p>
<p>  指定用于根据客户端IP地址确定组织的数据库。  使用此数据库时，以下变量可用： </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_proxy*address*</code> | <code>*CIDR*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  定义可信地址。  当请求来自可信地址时，将使用来自“X-Forwarded-For”请求头字段的地址。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**geoip_proxy_recursiveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">geoip_proxy_recursive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.3.0和1.2.1版本中。 </p>
<p>  如果禁用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用“X-Forwarded-For”中发送的最后一个地址。  如果启用递归搜索，则不使用与其中一个可信地址匹配的原始客户端地址，而是使用在“X-Forwarded-For”中发送的最后一个不可信地址。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_flv_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_flv_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_flv_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-flv-module"><a href="#Module-ngx-http-flv-module" class="headerlink" title="Module ngx_http_flv_module"></a>Module ngx_http_flv_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#flv">flv</a> <br></td>

<p>   <code>ngx_http_flv_module</code>模块为Flash Video（FLV）文件提供伪流服务器端支持。 </p>
<p>  它特别通过请求URI的查询字符串中的<code>start</code>参数处理请求，方法是从请求的字节偏移量和前置FLV头开始发回文件的内容。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_flv_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location ~ \.flv$ {
    flv;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**flv** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_fastcgi_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_fastcgi_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_fastcgi_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-fastcgi-module"><a href="#Module-ngx-http-fastcgi-module" class="headerlink" title="Module ngx_http_fastcgi_module"></a>Module ngx_http_fastcgi_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#fastcgi_bind">fastcgi_bind</a> <br>     <a href="#fastcgi_buffer_size">fastcgi_buffer_size</a> <br>     <a href="#fastcgi_buffering">fastcgi_buffering</a> <br>     <a href="#fastcgi_buffers">fastcgi_buffers</a> <br>     <a href="#fastcgi_busy_buffers_size">fastcgi_busy_buffers_size</a> <br>     <a href="#fastcgi_cache">fastcgi_cache</a> <br>     <a href="#fastcgi_cache_background_update">fastcgi_cache_background_update</a> <br>     <a href="#fastcgi_cache_bypass">fastcgi_cache_bypass</a> <br>     <a href="#fastcgi_cache_key">fastcgi_cache_key</a> <br>     <a href="#fastcgi_cache_lock">fastcgi_cache_lock</a> <br>     <a href="#fastcgi_cache_lock_age">fastcgi_cache_lock_age</a> <br>     <a href="#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a> <br>     <a href="#fastcgi_cache_max_range_offset">fastcgi_cache_max_range_offset</a> <br>     <a href="#fastcgi_cache_methods">fastcgi_cache_methods</a> <br>     <a href="#fastcgi_cache_min_uses">fastcgi_cache_min_uses</a> <br>     <a href="#fastcgi_cache_path">fastcgi_cache_path</a> <br>     <a href="#fastcgi_cache_purge">fastcgi_cache_purge</a> <br>     <a href="#fastcgi_cache_revalidate">fastcgi_cache_revalidate</a> <br>     <a href="#fastcgi_cache_use_stale">fastcgi_cache_use_stale</a> <br>     <a href="#fastcgi_cache_valid">fastcgi_cache_valid</a> <br>     <a href="#fastcgi_catch_stderr">fastcgi_catch_stderr</a> <br>     <a href="#fastcgi_connect_timeout">fastcgi_connect_timeout</a> <br>     <a href="#fastcgi_force_ranges">fastcgi_force_ranges</a> <br>     <a href="#fastcgi_hide_header">fastcgi_hide_header</a> <br>     <a href="#fastcgi_ignore_client_abort">fastcgi_ignore_client_abort</a> <br>     <a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a> <br>     <a href="#fastcgi_index">fastcgi_index</a> <br>     <a href="#fastcgi_intercept_errors">fastcgi_intercept_errors</a> <br>     <a href="#fastcgi_keep_conn">fastcgi_keep_conn</a> <br>     <a href="#fastcgi_limit_rate">fastcgi_limit_rate</a> <br>     <a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a> <br>     <a href="#fastcgi_next_upstream">fastcgi_next_upstream</a> <br>     <a href="#fastcgi_next_upstream_timeout">fastcgi_next_upstream_timeout</a> <br>     <a href="#fastcgi_next_upstream_tries">fastcgi_next_upstream_tries</a> <br>     <a href="#fastcgi_no_cache">fastcgi_no_cache</a> <br>     <a href="#fastcgi_param">fastcgi_param</a> <br>     <a href="#fastcgi_pass">fastcgi_pass</a> <br>     <a href="#fastcgi_pass_header">fastcgi_pass_header</a> <br>     <a href="#fastcgi_pass_request_body">fastcgi_pass_request_body</a> <br>     <a href="#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a> <br>     <a href="#fastcgi_read_timeout">fastcgi_read_timeout</a> <br>     <a href="#fastcgi_request_buffering">fastcgi_request_buffering</a> <br>     <a href="#fastcgi_send_lowat">fastcgi_send_lowat</a> <br>     <a href="#fastcgi_send_timeout">fastcgi_send_timeout</a> <br>     <a href="#fastcgi_socket_keepalive">fastcgi_socket_keepalive</a> <br>     <a href="#fastcgi_split_path_info">fastcgi_split_path_info</a> <br>     <a href="#fastcgi_store">fastcgi_store</a> <br>     <a href="#fastcgi_store_access">fastcgi_store_access</a> <br>     <a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a> <br>     <a href="#fastcgi_temp_path">fastcgi_temp_path</a> <br> <a href="#parameters">Parameters Passed to a FastCGI Server</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_fastcgi_module</code>模块允许将请求传递给FastCGI服务器。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    fastcgi_pass  localhost:9000;
    fastcgi_index index.php;

    fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
    fastcgi_param QUERY_STRING    $query_string;
    fastcgi_param REQUEST_METHOD  $request_method;
    fastcgi_param CONTENT_TYPE    $content_type;
    fastcgi_param CONTENT_LENGTH  $content_length;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_bind**  *address*</code>    [ <code>transparent</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.8.22版本中。 </p>
<p>  使用可选端口（1.11.2）从指定的本地IP地址发出到FastCGI服务器的传出连接。  参数值可以包含变量（1.3.12）。  特殊值<code>off</code> （1.3.12）取消了从先前配置级别继承的<code>fastcgi_bind</code>指令的效果，该指令允许系统自动分配本地IP地址和端口。 </p>
<p>   <code>transparent</code>参数（1.11.0）允许到FastCGI服务器的传出连接源自非本地IP地址，例如，来自客户端的真实IP地址： </p>
<pre class="notranslate">fastcgi_bind $remote_addr transparent;
</pre>

<p>  为了使此参数有效，通常需要使用<a href="ngx_core_module.html#user">超级用户</a>权限运行nginx工作进程。  在Linux上，不需要（1.13.8），就像指定了<code>transparent</code>参数一样，工作进程从主进程继承<code>CAP_NET_RAW</code>功能。  还必须配置内核路由表以拦截来自FastCGI服务器的网络流量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffer_size 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取从FastCGI服务器接收的响应的第一部分的缓冲区的<code>*size*</code> 。  这部分通常包含一个小的响应头。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.6版本中。 </p>
<p>  启用或禁用缓冲来自FastCGI服务器的响应。 </p>
<p>  启用缓冲后，nginx会尽快从FastCGI服务器接收响应，并将其保存到<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的缓冲区中。  如果整个响应不适合内存，则可以将其中的一部分保存到磁盘上的<a href="#fastcgi_temp_path">临时文件中</a> 。  写入临时文件由<a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a>和<a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a>指令控制。 </p>
<p>  禁用缓冲时，响应会在收到响应时立即同步传递给客户端。   nginx不会尝试从FastCGI服务器读取整个响应。   nginx一次可以从服务器接收的数据的最大大小由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>指令设置。 </p>
<p>  也可以通过在“X-Accel-Buffering”响应头字段中传递“ <code>yes</code> ”或“ <code>no</code> ”来启用或禁用缓冲。  可以使用<a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_buffers*number*</code> <code>*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_buffers 8 4k|8k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于从FastCGI服务器读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> ，用于单个连接。  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_busy_buffers_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_busy_buffers_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从FastCGI服务器<a href="#fastcgi_buffering">缓冲</a>响应时，限制可能忙于向响应客户端发送响应的缓冲区的总<code>*size*</code> ，而响应尚未完全读取。  同时，其余的缓冲区可用于读取响应，并在需要时缓冲部分响应临时文件。  默认情况下， <code>*size*</code>由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的两个缓冲区的大小限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache*zone*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于缓存的共享内存区域。  可以在多个地方使用相同的区域。  参数值可以包含变量（1.7.9）。   <code>off</code>参数禁用从先前配置级别继承的高速缓存。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_background_updateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_background_update off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  允许启动后台子请求以更新过期的缓存项，同时将过时的缓存响应返回给客户端。  请注意，在更新时必须<a href="#fastcgi_cache_use_stale_updating">允许</a>使用陈旧的缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_bypass*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不从缓存中获取响应的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会从缓存中获取响应： </p>
<pre class="notranslate">fastcgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
fastcgi_cache_bypass $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#fastcgi_no_cache">fastcgi_no_cache</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_key*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  例如，定义缓存的键 </p>
<pre class="notranslate">fastcgi_cache_key localhost:9000$request_uri;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lockon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用后，通过将请求传递给FastCGI服务器，一次只允许一个请求填充根据<a href="#fastcgi_cache_key">fastcgi_cache_key</a>指令标识的新缓存元素。  同一缓存元素的其他请求将等待响应出现在缓存中或缓存锁定以释放此元素，直到<a href="#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a>指令设置的时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lock_age*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock_age 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.8版本中。 </p>
<p>  如果传递给FastCGI服务器以填充新缓存元素的最后一个请求在指定<code>*time*</code>内没有完成，则可以将另一个请求传递给FastCGI服务器。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_lock_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_lock_timeout 5s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  为<a href="#fastcgi_cache_lock">fastcgi_cache_lock</a>设置超时。  当<code>*time*</code>到期时，请求将被传递给FastCGI服务器，但是，响应将不会被缓存。 </p>
<blockquote>
<p>  在1.7.8之前，可以缓存响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_max_range_offset*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.11.6版中。 </p>
<p>  设置字节范围请求的偏移量（以字节为单位）。  如果范围超出偏移量，则范围请求将传递给FastCGI服务器，并且不会缓存响应。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_methods** GET</code> |    <code>HEAD</code> |    <code>POST</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_methods GET HEAD;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.59版本中。 </p>
<p>  如果此指令中列出了客户端请求方法，则将缓存响应。   “ <code>GET</code> ”和“ <code>HEAD</code> ”方法总是添加到列表中，但建议明确指定它们。  另请参见<a href="#fastcgi_no_cache">fastcgi_no_cache</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_min_uses*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_min_uses 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将缓存响应的请求<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_path**  *path*</code>    [ <code>levels</code> = <code>*levels*</code> ]    [ <code>use_temp_path</code> = <code>on</code> | <code>off</code> ]    <code>keys_zone</code> = <code>*name*</code> : <code>*size*</code>    [ <code>inactive</code> = <code>*time*</code> ]    [ <code>max_size</code> = <code>*size*</code> ]    [ <code>manager_files</code> = <code>*number*</code> ]    [ <code>manager_sleep</code> = <code>*time*</code> ]    [ <code>manager_threshold</code> = <code>*time*</code> ]    [ <code>loader_files</code> = <code>*number*</code> ]    [ <code>loader_sleep</code> = <code>*time*</code> ]    [ <code>loader_threshold</code> = <code>*time*</code> ]    [ <code>purger</code> = <code>on</code> | <code>off</code> ]    [ <code>purger_files</code> = <code>*number*</code> ]    [ <code>purger_sleep</code> = <code>*time*</code> ]    [ <code>purger_threshold</code> = <code>*time*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  设置缓存的路径和其他参数。  缓存数据存储在文件中。  缓存中的密钥和文件名都是将MD5功能应用于代理URL的结果。   <code>levels</code>参数定义高速缓存的层次结构级别：从1到3，每个级别接受值1或2.例如，在以下配置中 </p>
<pre class="notranslate">fastcgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre>

<p>  缓存中的文件名如下所示： </p>
<pre class="notranslate">/data/nginx/cache/ **c** / **29** /b7f54b2df7773722d382f4809d650 **29c**
</pre>



<p>  首先将缓存的响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和缓存可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，缓存和保存临时文件的目录都放在同一文件系统上。  根据<code>use_temp_path</code>参数（1.7.10）设置临时文件的目录。  如果省略此参数或将其设置为<code>on</code> ，则将使用<a href="#fastcgi_temp_path">fastcgi_temp_path</a>指令为给定位置设置的目录。  如果该值设置为<code>off</code> ，则临时文件将直接放入缓存目录中。 </p>
<p>  此外，所有活动密钥和有关数据的信息都存储在共享内存区域中，其<code>*name*</code>和<code>*size*</code>由<code>keys_zone</code>参数配置。  一兆字节区域可以存储大约8000个密钥。 </p>
<blockquote>
<p>  作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，共享存储器区域还存储扩展的高速缓存<a href="ngx_http_api_module.html#http_caches_">信息</a> ，因此，需要为相同数量的密钥指定更大的区域大小。  例如，一兆字节区域可以存储大约4000个密钥。 </p>
</blockquote>
<p>  在<code>inactive</code>参数指定的时间内未访问的缓存数据将从缓存中删除，无论其新鲜度如何。  默认情况下， <code>inactive</code>设置为10分钟。 </p>
<p>  特殊的“缓存管理器”进程监视<code>max_size</code>参数设置的最大缓存大小。  超过此大小时，它会删除最近最少使用的数据。  在<code>manager_files</code> ， <code>manager_threshold</code>和<code>manager_sleep</code>参数（1.11.5）配置的迭代中删除数据。  在一次迭代期间，不会删除<code>manager_files</code>项（默认情况下为100）。  一次迭代的持续时间受<code>manager_threshold</code>参数限制（默认情况下为200毫秒）。  在迭代之间，由<code>manager_sleep</code>参数（默认为50毫秒）配置的暂停。 </p>
<p>  启动一分钟后，激活特殊的“缓存加载程序”进程。  它将有关存储在文件系统中的先前缓存数据的信息加载到缓存区。  加载也是在迭代中完成的。  在一次迭代期间，加载的<code>loader_files</code>项目不超过（默认情况下为100）。  此外，一次迭代的持续时间受<code>loader_threshold</code>参数限制（默认为200毫秒）。  在迭代之间，由<code>loader_sleep</code>参数（默认为50毫秒）配置暂停。 </p>
<p>  此外，以下参数作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供： </p>
<blockquote>
<p>  在版本1.7.3,1.7.7和1.11.10中，缓存头格式已更改。  升级到较新的nginx版本之前，缓存的响应将被视为无效。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_purge** string ...;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  定义将请求视为缓存清除请求的条件。  如果字符串参数的至少一个值不为空并且不等于“0”，则移除具有相应<a href="#fastcgi_cache_key">高速缓存键</a>的高速缓存条目。  通过返回204（无内容）响应来指示成功操作的结果。 </p>
<p>  如果清除请求的<a href="#fastcgi_cache_key">缓存键</a>以星号（“ <code>*</code> ”）结尾，则将从缓存中删除与通配符键匹配的所有缓存条目。  但是，这些条目将保留在磁盘上，直到它们被删除<a href="#fastcgi_cache_path">为非活动状态</a> ，或由<a href="#purger">缓存</a>清除程序（1.7.12）处理，或者客户端尝试访问它们。 </p>
<p>  配置示例： </p>
<pre class="notranslate">fastcgi_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        fastcgi_pass        backend;
        fastcgi_cache       cache_zone;
        fastcgi_cache_key   $uri;
        fastcgi_cache_purge $purge_method;
    }
}
</pre>



<blockquote>
<p>  此功能作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_revalidateon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_revalidate off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.5.7版本中。 </p>
<p>  使用具有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用过期缓存项的重新验证。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_use_stale** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>updating</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_cache_use_stale off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定在与FastCGI服务器通信期间发生错误时可以使用过时的缓存响应的情况。  该指令的参数与<a href="#fastcgi_next_upstream">fastcgi_next_upstream</a>指令的参数匹配。 </p>
<p>  如果无法选择要处理请求的FastCGI服务器，则<code>error</code>参数还允许使用过时的缓存响应。 </p>
<p>  此外，如果当前正在更新，则<code>updating</code>参数允许使用过时的缓存响应。  这样可以在更新缓存数据时最大限度地减少对FastCGI服务器的访问次数。 </p>
<p>  在响应变为失效后，也可以在响应头中直接启用过时的缓存响应指定的秒数（1.11.10）。  这比使用指令参数的优先级低。 </p>
<ul>
<li>“Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-3" target="_blank" rel="noopener">stale-while-revalidate</a> ”扩展允许使用陈旧的缓存响应（如果当前正在更新）。 -    “Cache-Control”头字段的“ <a href="https://tools.ietf.org/html/rfc5861#section-4" target="_blank" rel="noopener">stale-if-error</a> ”扩展允许在出现错误时使用陈旧的缓存响应。 </li>
</ul>
<p>  要在填充新缓存元素时最小化对FastCGI服务器的访问次数，可以使用<a href="#fastcgi_cache_lock">fastcgi_cache_lock</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_cache_valid** [ *code*</code> …] <code>*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置不同响应代码的缓存时间。  例如，以下指令 </p>
<pre class="notranslate">fastcgi_cache_valid 200 302 10m;
fastcgi_cache_valid 404      1m;
</pre>

<p>  为代码为200和302的响应设置10分钟的缓存，为代码404的响应设置1分钟。 </p>
<p>  如果仅指定了缓存<code>*time*</code> </p>
<pre class="notranslate">fastcgi_cache_valid 5m;
</pre>

<p>  然后只缓存200,301和302个响应。 </p>
<p>  此外，可以指定<code>any</code>参数来缓存任何响应： </p>
<pre class="notranslate">fastcgi_cache_valid 200 302 10m;
fastcgi_cache_valid 301      1h;
fastcgi_cache_valid any      1m;
</pre>



<p>  缓存的参数也可以直接在响应头中设置。  这比使用该指令设置缓存时间具有更高的优先级。 </p>
<ul>
<li><p>“X-Accel-Expires”标题字段以秒为单位设置响应的缓存时间。  零值禁用响应的缓存。  如果值以<code>@</code>前缀开头，则设置自Epoch以来的绝对时间（以秒为单位），响应可以高速缓存。 -   如果标题不包括“X-Accel-Expires”字段，则可以在标题字段“Expires”或“Cache-Control”中设置高速缓存的参数。 -   如果标头包含“Set-Cookie”字段，则不会缓存此类响应。 -   如果标题包含具有特殊值“ <code>*</code> ”的“Vary”字段，则不会缓存此类响应（1.7.7）。  如果标题包含具有另一个值的“Vary”字段，则将考虑相应的请求标题字段来缓存这样的响应（1.7.7）。<br>可以使用<a href="#fastcgi_ignore_headers">fastcgi_ignore_headers</a>指令禁用这些响应头字段中的一个或多个的处理。<br><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_catch_stderr*string*</code> ;<br>                </td><br><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td><br><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>设置要在从FastCGI服务器接收的响应的错误流中搜索的字符串。  如果找到该<code>*string*</code> ，则认为FastCGI服务器返回了<a href="#fastcgi_next_upstream">无效响应</a> 。  这允许在nginx中处理应用程序错误，例如： </p>
</li>
</ul>
<pre class="notranslate">location /php/ {
    fastcgi_pass backend:9000;
    ...
    fastcgi_catch_stderr "PHP Fatal error";
    fastcgi_next_upstream error timeout invalid_header;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_connect_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_connect_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义与FastCGI服务器建立连接的超时。  应该注意，此超时通常不会超过75秒。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_force_rangeson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_force_ranges off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  无论来自这些响应中的“Accept-Ranges”字段如何，都可以对来自FastCGI服务器的缓存和未缓存响应启用字节范围支持。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_hide_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  默认情况下，nginx不会将FastCGI服务器的响应中的标题字段“Status”和“X-Accel -…”传递给客户端。   <code>fastcgi_hide_header</code>指令设置不会传递的其他字段。  相反，如果需要允许传递字段，则可以使用<a href="#fastcgi_pass_header">fastcgi_pass_header</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_ignore_client_aborton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_ignore_client_abort off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定客户端在不等待响应的情况下关闭连接时是否应关闭与FastCGI服务器的连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_ignore_headers*field*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  禁用从FastCGI服务器处理某些响应头字段。  可以忽略以下字段：“X-Accel-Redirect”，“X-Accel-Expires”，“X-Accel-Limit-Rate”（1.1.6），“X-Accel-Buffering”（1.1.6） ，“X-Accel-Charset”（1.1.6），“Expires”，“Cache-Control”，“Set-Cookie”（0.8.44）和“Vary”（1.7.7）。 </p>
<p>  如果未禁用，则处理这些标头字段会产生以下影响： </p>
<ul>
<li>“X-Accel-Expires”，“Expires”，“Cache-Control”，“Set-Cookie”和“Vary”设置响应<a href="#fastcgi_cache_valid">缓存</a>的参数; -    “X-Accel-Redirect”执行<a href="ngx_http_core_module.html#internal">内部重定向</a>到指定的URI; -    “X-Accel-Limit-Rate”设置向客户端传输响应的<a href="ngx_http_core_module.html#limit_rate">速率限制</a> ; -    “X-Accel-Buffering”启用或禁用<a href="#fastcgi_buffering">缓冲</a>响应; -    “X-Accel-Charset”设置了所需的响应<a href="ngx_http_charset_module.html#charset">字符集</a> 。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_index*name*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  在<code>$fastcgi_script_name</code>变量的值中设置将在以斜杠结尾的URI之后附加的文件名。  例如，使用这些设置 </p>
<pre class="notranslate">fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
</pre>

<p>  和“ <code>/page.php</code> ”请求， <code>SCRIPT_FILENAME</code>参数将等于“ <code>/home/www/scripts/php/page.php</code> ”，并且使用“ <code>/</code> ”请求它将等于“ <code>/home/www/scripts/php/index.php</code> “。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_intercept_errorson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_intercept_errors off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  确定代码大于或等于300的FastCGI服务器响应是应该传递给客户端还是被拦截并重定向到nginx以便使用<a href="ngx_http_core_module.html#error_page">error_page</a>指令进行处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_keep_connon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_keep_conn off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.1.4版中。 </p>
<p>  默认情况下，FastCGI服务器将在发送响应后立即关闭连接。  但是，当此伪指令设置为<code>on</code> ，nginx将指示FastCGI服务器保持连接打开。  特别是，这对于FastCGI服务器的<a href="ngx_http_upstream_module.html#keepalive">keepalive</a>连接起作用是必要的。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_limit_rate*rate*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_limit_rate 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.7版本中。 </p>
<p>  限制从FastCGI服务器读取响应的速度。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果nginx同时打开两个到FastCFI服务器的连接，则总速率将是指定限制的两倍。  仅当启用了对来自FastCGI服务器的响应的<a href="#fastcgi_buffering">缓冲时</a> ，该限制才有效。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_max_temp_file_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_max_temp_file_size 1024m;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用来自FastCGI服务器的响应<a href="#fastcgi_buffering">缓冲</a> ，并且整个响应不适合<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的缓冲区时，响应的一部分可以保存到临时文件中。  该指令设置临时文件的最大<code>*size*</code> 。  一次写入临时文件的数据大小由<a href="#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a>指令设置。 </p>
<p>  零值禁用缓冲对临时文件的响应。 </p>
<blockquote>
<p>  此限制不适用于将<a href="#fastcgi_cache">缓存</a>或<a href="#fastcgi_store">存储</a>在磁盘上的响应。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream** error</code> |    <code>timeout</code> |    <code>invalid_header</code> |    <code>http_500</code> |    <code>http_503</code> |    <code>http_403</code> |    <code>http_404</code> |    <code>http_429</code> |    <code>non_idempotent</code> |    <code>off</code>    …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream error timeout;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定应将请求传递到下一个服务器的情况： </p>
<p>  应该记住，只有在尚未向客户端发送任何内容的情况下，才能将请求传递给下一个服务器。  也就是说，如果在传输响应的过程中发生错误或超时，则无法修复此问题。 </p>
<p>  该指令还定义了与服务器通信的<a href="ngx_http_upstream_module.html#max_fails">不成功尝试</a> 。   <code>error</code> ， <code>timeout</code>和<code>invalid_header</code>情况始终被视为不成功的尝试，即使它们未在指令中指定。   <code>http_500</code> ， <code>http_503</code>和<code>http_429</code>情况仅在指令中指定<code>http_429</code>被视为不成功尝试。   <code>http_403</code>和<code>http_404</code>情况从未被视为不成功的尝试。 </p>
<p>  将请求传递到下一个服务器可能会受到<a href="#fastcgi_next_upstream_tries">尝试次数</a>和<a href="#fastcgi_next_upstream_timeout">时间的限制</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream_timeout 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制请求可以传递到<a href="#fastcgi_next_upstream">下一个服务器的时间</a> 。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_next_upstream_tries*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_next_upstream_tries 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.5版本中。 </p>
<p>  限制将请求传递到<a href="#fastcgi_next_upstream">下一个服务器</a>的可能尝试次数。   <code>0</code>值关闭此限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_no_cache*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义不将响应保存到缓存的条件。  如果字符串参数的至少一个值不为空且不等于“0”，则不会保存响应： </p>
<pre class="notranslate">fastcgi_no_cache $cookie_nocache $arg_nocache$arg_comment;
fastcgi_no_cache $http_pragma    $http_authorization;
</pre>

<p>  可以与<a href="#fastcgi_cache_bypass">fastcgi_cache_bypass</a>指令一起使用。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_param**  *parameter*</code> <code>*value*</code>    [ <code>if_not_empty</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置应传递给FastCGI服务器的参数。  该<code>*value*</code>可以包含文本，变量及其组合。  当且仅当在当前级别上没有定义<code>fastcgi_param</code>指令时，这些指令才从前一级继承。 </p>
<p>  以下示例显示了PHP的最低必需设置： </p>
<pre class="notranslate">fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
fastcgi_param QUERY_STRING    $query_string;
</pre>



<p>   <code>SCRIPT_FILENAME</code>参数在PHP中用于确定脚本名称， <code>QUERY_STRING</code>参数用于传递请求参数。 </p>
<p>  对于处理<code>POST</code>请求的脚本，还需要以下三个参数： </p>
<pre class="notranslate">fastcgi_param REQUEST_METHOD  $request_method;
fastcgi_param CONTENT_TYPE    $content_type;
fastcgi_param CONTENT_LENGTH  $content_length;
</pre>



<p>  如果PHP是使用<code>--enable-force-cgi-redirect</code>配置参数构建的，则还应使用值“200”传递<code>REDIRECT_STATUS</code>参数： </p>
<pre class="notranslate">fastcgi_param REDIRECT_STATUS 200;
</pre>



<p>  如果使用<code>if_not_empty</code> （1.1.11）指定了该指令，则只有在其值不为空时，才会将此参数传递给服务器： </p>
<pre class="notranslate">fastcgi_param HTTPS           $https if_not_empty;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass*address*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  设置FastCGI服务器的地址。  地址可以指定为域名或IP地址，以及端口： </p>
<pre class="notranslate">fastcgi_pass localhost:9000;
</pre>

<p>  或者作为UNIX域套接字路径： </p>
<pre class="notranslate">fastcgi_pass unix:/tmp/fastcgi.socket;
</pre>



<p>  如果域名解析为多个地址，则所有这些地址都将以循环方式使用。  此外，可以将地址指定为<a href="ngx_http_upstream_module.html">服务器组</a> 。 </p>
<p>  参数值可以包含变量。  在这种情况下，如果将地址指定为域名，则在所描述的<a href="ngx_http_upstream_module.html">服务器组中</a>搜索名称，如果未找到，则使用<a href="ngx_http_core_module.html#resolver">解析器</a>确定。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_header*field*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将FastCGI服务器上<a href="#fastcgi_hide_header">禁用的</a>标头字段传递给客户端。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_request_bodyon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_pass_request_body on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示是否将原始请求正文传递给FastCGI服务器。  另请参见<a href="#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_pass_request_headerson</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_pass_request_headers on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指示原始请求的标头字段是否传递给FastCGI服务器。  另请参见<a href="#fastcgi_pass_request_body">fastcgi_pass_request_body</a>指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_read_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_read_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义从FastCGI服务器读取响应的超时。  仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。  如果FastCGI服务器在此时间内未传输任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_request_bufferingon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_request_buffering on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  启用或禁用客户端请求正文的缓冲。 </p>
<p>  启用缓冲后，在将请求发送到FastCGI服务器之前，将从客户端<a href="ngx_http_core_module.html#client_body_buffer_size">读取</a>整个请求正文。 </p>
<p>  禁用缓冲时，请求主体在收到时立即发送到FastCGI服务器。  在这种情况下，如果nginx已经开始发送请求主体，则无法将请求传递给<a href="#fastcgi_next_upstream">下一个服务器</a> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_send_lowat*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_send_lowat 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果指令设置为非零值，则nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或具有指定<code>*size*</code>的<code>SO_SNDLOWAT</code>套接字选项来最小化到FastCGI服务器的传出连接上的发送操作数。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_send_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_send_timeout 60s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置将请求传输到FastCGI服务器的超时。  仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。  如果FastCGI服务器在此时间内未收到任何内容，则关闭连接。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_socket_keepaliveon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_socket_keepalive off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  配置到FastCGI服务器的传出连接的“TCP keepalive”行为。  默认情况下，操作系统的设置对套接字有效。  如果指令设置为值“ <code>on</code> ”，则为套接字打开<code>SO_KEEPALIVE</code>套接字选项。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_split_path_info*regex*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  定义捕获<code>$fastcgi_path_info</code>变量值的正则表达式。  正则表达式应该有两个捕获：第一个变为<code>$fastcgi_script_name</code>变量的值，第二个变为<code>$fastcgi_path_info</code>变量的值。  例如，使用这些设置 </p>
<pre class="notranslate">location ~ ^(.+\.php)(.*)$ {
    fastcgi_split_path_info       ^(.+\.php)(.*)$;
    fastcgi_param SCRIPT_FILENAME /path/to/php$fastcgi_script_name;
    fastcgi_param PATH_INFO       $fastcgi_path_info;
</pre>

<p>  和“ <code>/show.php/article/0001</code> ”请求， <code>SCRIPT_FILENAME</code>参数将等于“ <code>/path/to/php/show.php</code>参数将等于“ <code>/article/0001</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_store** on</code> |    <code>off</code> |    <code>*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_store off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许将文件保存到磁盘。   <code>on</code>参数使用与指令<a href="ngx_http_core_module.html#alias">别名</a>或<a href="ngx_http_core_module.html#root">root</a>对应的路径保存文件。   <code>off</code>参数禁用文件保存。  此外，可以使用带变量的<code>*string*</code>显式设置文件名： </p>
<pre class="notranslate">fastcgi_store /data/www$original_uri;
</pre>



<p>  根据接收到的“Last-Modified”响应头字段设置文件的修改时间。  首先将响应写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="#fastcgi_temp_path">fastcgi_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  该指令可用于创建静态不可更改文件的本地副本，例如： </p>
<pre class="notranslate">location /images/ {
    root                 /data/www;
    error_page           404 = /fetch$uri;
}

location /fetch/ {
    internal;

    fastcgi_pass         backend:9000;
    ...

    fastcgi_store        on;
    fastcgi_store_access user:rw group:rw all:r;
    fastcgi_temp_path    /data/temp;

    alias                /data/www/;
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_store_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_store_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">fastcgi_store_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">fastcgi_store_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_temp_file_write_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_temp_file_write_size 8k|16k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  当启用从FastCGI服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据<code>*size*</code> 。  默认情况下， <code>*size*</code>由<a href="#fastcgi_buffer_size">fastcgi_buffer_size</a>和<a href="#fastcgi_buffers">fastcgi_buffers</a>指令设置的两个缓冲区限制。  临时文件的最大大小由<a href="#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a>指令设置。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**fastcgi_temp_path**  *path*</code>    [ <code>*level1*</code>    [ <code>*level2*</code>    [ <code>*level3*</code> ]]];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">fastcgi_temp_path fastcgi_temp;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  定义用于存储临时文件的目录，其中包含从FastCGI服务器接收的数据。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">fastcgi_temp_path /spool/nginx/fastcgi_temp 1 2;
</pre>

<p>  临时文件可能如下所示： </p>
<pre class="notranslate">/spool/nginx/fastcgi_temp/ **7** / **45** /00000123 **457**
</pre>



<p>  另请参见<a href="#fastcgi_cache_path">fastcgi_cache_path</a>指令的<code>use_temp_path</code>参数。 </p>
<h4 id="传递给FastCGI服务器的参数"><a href="#传递给FastCGI服务器的参数" class="headerlink" title="传递给FastCGI服务器的参数"></a>传递给FastCGI服务器的参数</h4><p>   HTTP请求标头字段作为参数传递给FastCGI服务器。  在作为FastCGI服务器运行的应用程序和脚本中，这些参数通常可用作环境变量。  例如，“User-Agent”标头字段作为<code>HTTP_USER_AGENT</code>参数传递。  除HTTP请求头字段外，还可以使用<a href="#fastcgi_param">fastcgi_param</a>指令传递任意参数。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_fastcgi_module</code>模块支持可用于使用<a href="#fastcgi_param">fastcgi_param</a>指令设置参数的嵌入变量： </p>
<pre class="notranslate">fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
</pre>

<p>  使用<a href="#fastcgi_split_path_info">fastcgi_split_path_info</a>指令时， <code>$fastcgi_script_name</code>变量等于指令设置的第一个捕获的值。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_f4f_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_f4f_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_f4f_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-f4f-module"><a href="#Module-ngx-http-f4f-module" class="headerlink" title="Module ngx_http_f4f_module"></a>Module ngx_http_f4f_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#f4f">f4f</a> <br>     <a href="#f4f_buffer_size">f4f_buffer_size</a> <br></td>

<p>   <code>ngx_http_f4f_module</code>模块为Adobe HTTP动态流（HDS）提供服务器端支持。 </p>
<p>  该模块以“ <code>/videoSeg1-Frag1</code> ”形式实现HTTP动态流式处理请求的处理 - 使用<code>videoSeg1.f4x</code>索引文件从<code>videoSeg1.f4f</code>文件中提取所需的片段。  该模块是Apache的Adobe f4f模块（HTTP Origin Module）的替代品。 </p>
<p>  需要使用Adobe的f4fpackager进行常规预处理，有关详细信息，请参阅相关文档。 </p>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /video/ {
    f4f;
    ...
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**f4f** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**f4f_buffer_size*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">f4f_buffer_size 512k;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置用于读取<code>.f4x</code>索引文件的缓冲区的<code>*size*</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_empty_gif_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_empty_gif_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_empty_gif_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-empty-gif-module"><a href="#Module-ngx-http-empty-gif-module" class="headerlink" title="Module ngx_http_empty_gif_module"></a>Module ngx_http_empty_gif_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#empty_gif">empty_gif</a> <br></td>

<p>   <code>ngx_http_empty_gif_module</code>模块发出单像素透明GIF。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location = /_.gif {
    empty_gif;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**empty_gif** ;</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>location</code> <br>                </td></p>
<p>  打开周围位置的模块处理。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_dav_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_dav_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_dav_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-dav-module"><a href="#Module-ngx-http-dav-module" class="headerlink" title="Module ngx_http_dav_module"></a>Module ngx_http_dav_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#create_full_put_path">create_full_put_path</a> <br>     <a href="#dav_access">dav_access</a> <br>     <a href="#dav_methods">dav_methods</a> <br>     <a href="#min_delete_depth">min_delete_depth</a> <br></td>

<p>   <code>ngx_http_dav_module</code>模块用于通过WebDAV协议进行文件管理自动化。  该模块处理HTTP和WebDAV方法PUT，DELETE，MKCOL，COPY和MOVE。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_dav_module</code>配置参数启用它。 </p>
<blockquote>
<p>  需要其他WebDAV方法才能运行的WebDAV客户端不适用于此模块。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    root                  /data/www;

    client_body_temp_path /data/client_temp;

    dav_methods PUT DELETE MKCOL COPY MOVE;

    create_full_put_path  on;
    dav_access            group:rw  all:r;

    limit_except GET {
        allow 192.168.1.0/32;
        deny  all;
    }
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**create_full_put_pathon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">create_full_put_path off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>   WebDAV规范仅允许在现有目录中创建文件。  该指令允许创建所有需要的中间目录。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**dav_access*users*</code> : <code>*permissions*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">dav_access user:rw;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  为新创建的文件和目录设置访问权限，例如： </p>
<pre class="notranslate">dav_access user:rw group:rw all:r;
</pre>



<p>  如果指定了任何<code>group</code>或<code>all</code>访问权限，则可以省略<code>user</code>权限： </p>
<pre class="notranslate">dav_access group:rw all:r;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**dav_methods** off</code> | <code>*method*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">dav_methods off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许指定的HTTP和WebDAV方法。  参数<code>off</code>拒绝此模块处理的所有方法。  支持以下方法： <code>PUT</code> ， <code>DELETE</code> ， <code>MKCOL</code> ， <code>COPY</code>和<code>MOVE</code> 。 </p>
<p>  使用PUT方法上载的文件首先写入临时文件，然后重命名该文件。  从版本0.8.9开始，临时文件和持久性存储可以放在不同的文件系统上。  但是，请注意，在这种情况下，文件将跨两个文件系统复制，而不是廉价的重命名操作。  因此，建议对于任何给定位置，由<a href="ngx_http_core_module.html#client_body_temp_path">client_body_temp_path</a>指令设置的保存文件和保存临时文件的目录都放在同一文件系统上。 </p>
<p>  使用PUT方法创建文件时，可以通过在“Date”标题字段中传递修改日期来指定修改日期。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**min_delete_depth*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">min_delete_depth 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  允许DELETE方法删除文件，前提是请求路径中的元素数不小于指定的数。  例如，指令 </p>
<pre class="notranslate">min_delete_depth 4;
</pre>

<p>  允许删除请求中的文件 </p>
<pre class="notranslate">/users/00/00/name
/users/00/00/name/pic.jpg
/users/00/00/page.html
</pre>

<p>  并否认删除 </p>
<pre class="notranslate">/users/00/00
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_core_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_core_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_core_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-core-module"><a href="#Module-ngx-http-core-module" class="headerlink" title="Module ngx_http_core_module"></a>Module ngx_http_core_module</h2><td align="left" class="notranslate"> <a href="#directives">Directives</a> <br>     <a href="#absolute_redirect">absolute_redirect</a> <br>     <a href="#aio">aio</a> <br>     <a href="#aio_write">aio_write</a> <br>     <a href="#alias">alias</a> <br>     <a href="#chunked_transfer_encoding">chunked_transfer_encoding</a> <br>     <a href="#client_body_buffer_size">client_body_buffer_size</a> <br>     <a href="#client_body_in_file_only">client_body_in_file_only</a> <br>     <a href="#client_body_in_single_buffer">client_body_in_single_buffer</a> <br>     <a href="#client_body_temp_path">client_body_temp_path</a> <br>     <a href="#client_body_timeout">client_body_timeout</a> <br>     <a href="#client_header_buffer_size">client_header_buffer_size</a> <br>     <a href="#client_header_timeout">client_header_timeout</a> <br>     <a href="#client_max_body_size">client_max_body_size</a> <br>     <a href="#connection_pool_size">connection_pool_size</a> <br>     <a href="#default_type">default_type</a> <br>     <a href="#directio">directio</a> <br>     <a href="#directio_alignment">directio_alignment</a> <br>     <a href="#disable_symlinks">disable_symlinks</a> <br>     <a href="#error_page">error_page</a> <br>     <a href="#etag">etag</a> <br>     <a href="#http">http</a> <br>     <a href="#if_modified_since">if_modified_since</a> <br>     <a href="#ignore_invalid_headers">ignore_invalid_headers</a> <br>     <a href="#internal">internal</a> <br>     <a href="#keepalive_disable">keepalive_disable</a> <br>     <a href="#keepalive_requests">keepalive_requests</a> <br>     <a href="#keepalive_timeout">keepalive_timeout</a> <br>     <a href="#large_client_header_buffers">large_client_header_buffers</a> <br>     <a href="#limit_except">limit_except</a> <br>     <a href="#limit_rate">limit_rate</a> <br>     <a href="#limit_rate_after">limit_rate_after</a> <br>     <a href="#lingering_close">lingering_close</a> <br>     <a href="#lingering_time">lingering_time</a> <br>     <a href="#lingering_timeout">lingering_timeout</a> <br>     <a href="#listen">listen</a> <br>     <a href="#location">location</a> <br>     <a href="#log_not_found">log_not_found</a> <br>     <a href="#log_subrequest">log_subrequest</a> <br>     <a href="#max_ranges">max_ranges</a> <br>     <a href="#merge_slashes">merge_slashes</a> <br>     <a href="#msie_padding">msie_padding</a> <br>     <a href="#msie_refresh">msie_refresh</a> <br>     <a href="#open_file_cache">open_file_cache</a> <br>     <a href="#open_file_cache_errors">open_file_cache_errors</a> <br>     <a href="#open_file_cache_min_uses">open_file_cache_min_uses</a> <br>     <a href="#open_file_cache_valid">open_file_cache_valid</a> <br>     <a href="#output_buffers">output_buffers</a> <br>     <a href="#port_in_redirect">port_in_redirect</a> <br>     <a href="#postpone_output">postpone_output</a> <br>     <a href="#read_ahead">read_ahead</a> <br>     <a href="#recursive_error_pages">recursive_error_pages</a> <br>     <a href="#request_pool_size">request_pool_size</a> <br>     <a href="#reset_timedout_connection">reset_timedout_connection</a> <br>     <a href="#resolver">resolver</a> <br>     <a href="#resolver_timeout">resolver_timeout</a> <br>     <a href="#root">root</a> <br>     <a href="#satisfy">satisfy</a> <br>     <a href="#send_lowat">send_lowat</a> <br>     <a href="#send_timeout">send_timeout</a> <br>     <a href="#sendfile">sendfile</a> <br>     <a href="#sendfile_max_chunk">sendfile_max_chunk</a> <br>     <a href="#server">server</a> <br>     <a href="#server_name">server_name</a> <br>     <a href="#server_name_in_redirect">server_name_in_redirect</a> <br>     <a href="#server_names_hash_bucket_size">server_names_hash_bucket_size</a> <br>     <a href="#server_names_hash_max_size">server_names_hash_max_size</a> <br>     <a href="#server_tokens">server_tokens</a> <br>     <a href="#subrequest_output_buffer_size">subrequest_output_buffer_size</a> <br>     <a href="#tcp_nodelay">tcp_nodelay</a> <br>     <a href="#tcp_nopush">tcp_nopush</a> <br>     <a href="#try_files">try_files</a> <br>     <a href="#types">types</a> <br>     <a href="#types_hash_bucket_size">types_hash_bucket_size</a> <br>     <a href="#types_hash_max_size">types_hash_max_size</a> <br>     <a href="#underscores_in_headers">underscores_in_headers</a> <br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a> <br>     <a href="#variables_hash_max_size">variables_hash_max_size</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**absolute_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">absolute_redirect on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.11.8版中。 </p>
<p>  如果禁用，nginx发出的重定向将是相对的。 </p>
<p>  另请参见<a href="#server_name_in_redirect">server_name_in_redirect</a>和<a href="#port_in_redirect">port_in_redirect</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**aio** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>off</code> |<br>    <code>threads</code> [ <code>=</code> <code>*pool*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">aio off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.11版本中。 </p>
<p>  启用或禁用在FreeBSD和Linux上使用异步文件I / O（AIO）： </p>
<pre class="notranslate">location /video/ {
    aio            on;
    output_buffers 1 64k;
}
</pre>



<p>  在FreeBSD上，可以从FreeBSD 4.3开始使用AIO。  在FreeBSD 11.0之前，AIO可以静态链接到内核： </p>
<pre class="notranslate">options VFS_AIO
</pre>

<p>  或作为内核可加载模块动态加载： </p>
<pre class="notranslate">kldload aio
</pre>



<p>  在Linux上，可以从内核版本2.6.22开始使用AIO。  此外，有必要启用<a href="#directio">directio</a> ，否则读取将被阻止： </p>
<pre class="notranslate">location /video/ {
    aio            on;
    directio       512;
    output_buffers 1 128k;
}
</pre>



<p>  在Linux上， <a href="#directio">directio</a>只能用于读取在512字节边界（或XFS为4K）上对齐的块。  在阻塞模式下读取文件的未对齐结束。  对于字节范围请求和不是从文件开头的FLV请求也是如此：在文件开头和结尾读取未对齐数据将被阻塞。 </p>
<p>  当在Linux上启用AIO和<a href="#sendfile">sendfile时</a> ，AIO用于大于或等于<a href="#directio">directio</a>指令中指定大小的文件，而<a href="#sendfile">sendfile</a>用于较小大小的文件或禁用<a href="#directio">directio</a>时。 </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    aio            on;
    directio       8m;
}
</pre>



<p>  最后，可以使用多线程（1.7.11）读取和<a href="#sendfile">发送</a>文件，而不会阻止工作进程： </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    aio            threads;
}
</pre>

<p>  读取和发送文件操作被卸载到指定<a href="ngx_core_module.html#thread_pool">池的</a>线程。  如果省略池名称，则使用名称为“ <code>default</code> ”的池。  池名称也可以使用变量设置： </p>
<pre class="notranslate">aio threads=pool$disk;
</pre>

<p>  默认情况下，禁用多线程，应使用<code>--with-threads</code>配置参数启用它。  目前，多线程仅与<a href="events.html#epoll">epoll</a> ， <a href="events.html#kqueue">kqueue</a>和<a href="events.html#eventport">eventport</a>方法兼容。  只在Linux上支持多线程文件发送。 </p>
<p>  另请参见<a href="#sendfile">sendfile</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**aio_writeon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">aio_write off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.9.13版本中。 </p>
<p>  如果启用了<a href="#aio">aio</a> ，则指定是否用于写入文件。  目前，这仅在使用<code>aio threads</code> ，并且仅限于使用从代理服务器接收的数据编写临时文件。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**alias*path*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  定义指定位置的替换。  例如，使用以下配置 </p>
<pre class="notranslate">location /i/ {
    alias /data/w3/images/;
}
</pre>

<p>  根据“ <code>/i/top.gif</code> ”的请求，将发送文件<code>/data/w3/images/top.gif</code> 。 </p>
<p>   <code>*path*</code>值可以包含变量， <code>$document_root</code>和<code>$realpath_root</code>除外。 </p>
<p>  如果在使用正则表达式定义的位置内使用<code>alias</code>则此类正则表达式应包含捕获，而<code>alias</code>应引用这些捕获（0.7.40），例如： </p>
<pre class="notranslate">location ~ ^/users/(.+\.(?:gif|jpe?g|png))$ {
    alias /data/w3/images/$1;
}
</pre>



<p>  当location匹配指令值的最后一部分时： </p>
<pre class="notranslate">location /images/ {
    alias /data/w3/images/;
}
</pre>

<p>  最好使用<a href="#root">root</a>指令： </p>
<pre class="notranslate">location /images/ {
    root /data/w3;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**chunked_transfer_encodingon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">chunked_transfer_encoding on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  允许在HTTP / 1.1中禁用分块传输编码。  尽管符合标准要求，但在使用软件无法支持分块编码时，它可能会派上用场。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_buffer_size 8k|16k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置读取客户端请求正文的缓冲区大小。  如果请求主体大于缓冲区，则整个主体或仅其部分被写入<a href="#client_body_temp_path">临时文件</a> 。  默认情况下，缓冲区大小等于两个内存页。  这是x86上的8K，其他32位平台和x86-64。  在其他64位平台上通常为16K。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_in_file_only** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>clean</code> |<br>    <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_in_file_only off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  确定nginx是否应将整个客户端请求主体保存到文件中。  该指令可以在调试期间使用，或者在使用<code>$request_body_file</code>变量或模块<a href="ngx_http_perl_module.html">ngx_http_perl_module</a>的<a href="ngx_http_perl_module.html#methods">$ r-&gt; request_body_file</a>方法时使用。 </p>
<p>  设置为打开值<code>on</code> ，请求处理后不会删除临时文件。 </p>
<p>  值<code>clean</code>将导致删除请求处理后留下的临时文件。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_in_single_bufferon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_in_single_buffer off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  确定nginx是否应将整个客户端请求主体保存在单个缓冲区中。  使用<code>$request_body</code>变量时，建议使用该指令，以保存所涉及的复制操作数。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_temp_path** 
    &lt;code class=&quot;notranslate&quot;&gt;*path*</code><br>    [ <code>*level1*</code><br>    [ <code>*level2*</code><br>    [ <code>*level3*</code> ]]]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_temp_path client_body_temp;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义用于存储包含客户端请求主体的临时文件的目录。  在指定目录下最多可以使用三级子目录层次结构。  例如，在以下配置中 </p>
<pre class="notranslate">client_body_temp_path /spool/nginx/client_temp 1 2;
</pre>

<p>  临时文件的路径可能如下所示： </p>
<pre class="notranslate">/spool/nginx/client_temp/7/45/00000123457
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_body_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_body_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义读取客户端请求正文的超时。  超时仅设置为两个连续读取操作之间的时间段，而不是整个请求主体的传输。  如果客户端在此时间内未传输任何内容，请求将以408（请求超时）错误终止。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_header_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_header_buffer_size 1k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  设置缓冲区大小以读取客户端请求标头。  对于大多数请求，1K字节的缓冲区就足够了。  但是，如果请求包含长cookie或来自WAP客户端，则可能不适合1K。  如果请求行或请求头字段不适合此缓冲区，则分配由<a href="#large_client_header_buffers">large_client_header_buffers</a>指令配置的较大缓冲区。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_header_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_header_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  定义读取客户端请求标头的超时。  如果客户端在此时间内未传输整个标头，请求将以408（请求超时）错误终止。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**client_max_body_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">client_max_body_size 1m;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置客户端请求正文的最大允许大小，在“Content-Length”请求标头字段中指定。  如果请求中的大小超过配置的值，则会将413（请求实体太大）错误返回给客户端。  请注意，浏览器无法正确显示此错误。  将<code>*size*</code>设置为0将禁用检查客户端请求正文大小。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**connection_pool_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">connection_pool_size 256|512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  允许精确调整每个连接的内存分配。  该指令对性能的影响最小，通常不应使用。  默认情况下，大小在32位平台上等于256字节，在64位平台上等于512字节。 </p>
<blockquote>
<p>  在1.9.8版之前，所有平台上的默认值均为256。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**default_type*mime-type*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">default_type text/plain;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  定义响应的默认MIME类型。  可以使用<a href="#types">types</a>指令设置文件扩展名到MIME类型的映射。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**directio*size*</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">directio off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.7.7版本中。 </p>
<p>  在读取大于或等于指定<code>*size*</code>文件时，允许使用<code>O_DIRECT</code>标志（FreeBSD，Linux）， <code>F_NOCACHE</code>标志（macOS）或<code>directio()</code>函数（Solaris）。  该指令自动禁用（0.7.15）对给定请求使用<a href="#sendfile">sendfile</a> 。  它对于提供大型文件非常有用： </p>
<pre class="notranslate">directio 4m;
</pre>

<p>  或者在Linux上使用<a href="#aio">aio</a>时。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**directio_alignment*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">directio_alignment 512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.11版本中。 </p>
<p>  设置<a href="#directio">directio</a>的对齐方式。  在大多数情况下，512字节对齐就足够了。  但是，在Linux下使用XFS时，需要将其增加到4K。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**disable_symlinksoff</code> ; <br> <code>**disable_symlinks** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>if_not_owner</code><br>    [ <code>from</code> = <code>*part*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">disable_symlinks off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.15版中。 </p>
<p>  确定打开文件时应如何处理符号链接： </p>
<p>  例： </p>
<pre class="notranslate">disable_symlinks on from=$document_root;
</pre>



<p>  该指令仅适用于具有<code>openat()</code>和<code>fstatat()</code>接口的系统。  这些系统包括FreeBSD，Linux和Solaris的现代版本。 </p>
<p>  参数<code>on</code>和<code>if_not_owner</code>添加了处理开销。 </p>
<blockquote>
<p>  在不支持仅为搜索打开目录的系统上，要使用这些参数，需要工作进程对所有正在检查的目录具有读取权限。 </p>
<p>   <a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a> ， <a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>和<a href="ngx_http_dav_module.html">ngx_http_dav_module</a>模块当前忽略此指令。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**error_page** 
    &lt;code class=&quot;notranslate&quot;&gt;*code*</code> …<br>    [ <code>=</code> [ <code>*response*</code> ]]<br>    <code>*uri*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  定义将为指定错误显示的URI。   <code>*uri*</code>值可以包含变量。 </p>
<p>  例： </p>
<pre class="notranslate">error_page 404             /404.html;
error_page 500 502 503 504 /50x.html;
</pre>



<p>  这导致内部重定向到指定的<code>*uri*</code> ，客户端请求方法更改为“ <code>GET</code> ”（对于“ <code>GET</code> ”和“ <code>HEAD</code> ”以外的所有方法）。 </p>
<p>  此外，可以使用“ <code>=</code> <code>*response*</code> ”语法将响应代码更改为另一个，例如： </p>
<pre class="notranslate">error_page 404 =200 /empty.gif;
</pre>



<p>  如果代理服务器或FastCGI / uwsgi / SCGI / gRPC服务器处理错误响应，并且服务器可能返回不同的响应代码（例如，200,302,401或404），则可以使用代码进行响应收益： </p>
<pre class="notranslate">error_page 404 = /404.php;
</pre>



<p>  如果在内部重定向期间无需更改URI和方法，则可以将错误处理传递到命名位置： </p>
<pre class="notranslate">location / {
    error_page 404 = @fallback;
}

location @fallback {
    proxy_pass http://backend;
}
</pre>





<blockquote>
<p>  如果<code>*uri*</code>处理导致错误，则将上次发生的错误的状态代码返回给客户端。 </p>
</blockquote>
<p>  也可以使用URL重定向进行错误处理： </p>
<pre class="notranslate">error_page 403      http://example.com/forbidden.html;
error_page 404 =301 http://example.com/notfound.html;
</pre>

<p>  在这种情况下，默认情况下，响应代码302返回给客户端。  它只能更改为重定向状态代码之一（301,302,303,307和308）。 </p>
<blockquote>
<p>  在版本1.1.16和1.0.13之前，代码307不被视为重定向。 </p>
<p>  在版本1.13.0之前，代码308不被视为重定向。 </p>
</blockquote>
<p>  当且仅当在当前级别上没有定义<code>error_page</code>指令时，这些指令才从前一级继承。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**etagon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">etag on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.3.3版本中。 </p>
<p>  启用或禁用自动生成静态资源的“ETag”响应头字段。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**http** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>main</code> <br><br>                </td></p>
<p>  提供指定HTTP服务器指令的配置文件上下文。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**if_modified_since** 
    &lt;code class=&quot;notranslate&quot;&gt;off</code> |<br>    <code>exact</code> |<br>    <code>before</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">if_modified_since exact;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.7.24版本中。 </p>
<p>  指定如何将响应的修改时间与“If-Modified-Since”请求标头字段中的时间进行比较： </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**ignore_invalid_headerson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">ignore_invalid_headers on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  控制是否应忽略具有无效名称的标头字段。  有效名称由英文字母，数字，连字符和可能的下划线组成（由<a href="#underscores_in_headers">underscores_in_headers</a>指令控制）。 </p>
<p>  如果在<a href="#server">服务器</a>级别指定了该指令，则仅在服务器是默认服务器时使用其值。  指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**internal** ;</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  指定给定位置只能用于内部请求。  对于外部请求，返回客户端错误404（未找到）。  内部请求如下： </p>
<ul>
<li>由<a href="#error_page">error_page</a> ， <a href="ngx_http_index_module.html#index">index</a> ， <a href="ngx_http_random_index_module.html#random_index">random_index</a>和<a href="#try_files">try_files</a>指令重定向的请求; -   来自上游服务器的“X-Accel-Redirect”响应头字段重定向的请求; -   由<a href="ngx_http_ssi_module.html">ngx_http_ssi_module</a>模块的“ <code>include virtual</code> ”命令， <a href="ngx_http_addition_module.html">ngx_http_addition_module</a>模块指令以及<a href="ngx_http_auth_request_module.html#auth_request">auth_request</a>和<a href="ngx_http_mirror_module.html#mirror">mirror</a>指令形成的子请求; -   请求由<a href="ngx_http_rewrite_module.html#rewrite">重写</a>指令更改。 </li>
</ul>
<p>  例： </p>
<pre class="notranslate">error_page 404 /404.html;

location = /404.html {
    internal;
}
</pre>



<blockquote>
<p>  每个请求最多有10个内部重定向，以防止在错误配置中发生的请求处理周期。  如果达到此限制，则返回错误500（内部服务器错误）。  在这种情况下，可以在错误日志中看到“重写或内部重定向周期”消息。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_disablenone</code> | <code>*browser*</code> …; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_disable msie6;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  禁用与行为不当的浏览器保持连接状态。   <code>*browser*</code>参数指定将受影响的浏览器。  一旦收到POST请求，值<code>msie6</code>将禁用与旧版本MSIE的保持活动连接。  值<code>safari</code>禁用与macOS和类似macOS的操作系统上的Safari和类似Safari的浏览器的保持活动连接。  值<code>none</code>与所有浏览器保持连接。 </p>
<blockquote>
<p>  在版本1.1.18之前，值<code>safari</code>与所有操作系统上的所有Safari和类似Safari的浏览器相匹配，默认情况下禁用与它们保持连接的连接。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_requests*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_requests 100;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.0版本中。 </p>
<p>  设置可通过一个保持活动连接提供的最大请求数。  在发出最大请求数后，将关闭连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**keepalive_timeout** 
    &lt;code class=&quot;notranslate&quot;&gt;*timeout*</code><br>    [ <code>*header_timeout*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">keepalive_timeout 75s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  第一个参数设置一个超时，在此期间保持活动的客户端连接将在服务器端保持打开状态。  零值禁用保持活动的客户端连接。  可选的第二个参数在“Keep-Alive：timeout = <code>*time*</code> ”响应头字段中设置一个值。  两个参数可能不同。 </p>
<p>   Mozilla和Konqueror识别“Keep-Alive：timeout = <code>*time*</code> ”标题字段。   MSIE在大约60秒内自行关闭保持连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**large_client_header_buffers*number*</code> <code>*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">large_client_header_buffers 4 8k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  设置用于读取大客户机请求标头的缓冲区的最大<code>*number*</code>和<code>*size*</code> 。  请求行不能超过一个缓冲区的大小，否则会将414（Request-URI Too Large）错误返回给客户端。  请求头字段也不能超过一个缓冲区的大小，或者400（错误请求）错误返回给客户端。  缓冲区仅按需分配。  默认情况下，缓冲区大小等于8K字节。  如果在请求处理结束后连接转换为保持活动状态，则释放这些缓冲区。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_except*method*</code> … { … } <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  限制允许位置内的HTTP方法。   <code>*method*</code>参数可以是以下之一： <code>GET</code> ， <code>HEAD</code> ， <code>POST</code> ， <code>PUT</code> ， <code>DELETE</code> ， <code>MKCOL</code> ， <code>COPY</code> ， <code>MOVE</code> ， <code>OPTIONS</code> ， <code>PROPFIND</code> ， <code>PROPPATCH</code> ， <code>LOCK</code> ， <code>UNLOCK</code>或<code>PATCH</code> 。  允许<code>GET</code>方法也允许使用<code>HEAD</code>方法。  使用<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> （1.13.10）模块指令可以限制对其他方法的访问： </p>
<pre class="notranslate">limit_except GET {
    allow 192.168.1.0/32;
    deny  all;
}
</pre>

<p>  请注意，这将限制对<strong>除</strong> GET和HEAD <strong>之外的</strong>所有方法的访问。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_rate*rate*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">limit_rate 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  限制向客户端传输的响应速率。   <code>*rate*</code>以每秒字节数指定。  零值禁用速率限制。  根据请求设置限制，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍。 </p>
<p>  也可以在<code>$limit_rate</code>变量中设置速率限制。  在根据特定条件限制费率的情况下，它可能很有用： </p>
<pre class="notranslate">server {

    if ($slow) {
        set $limit_rate 4k;
    }

    ...
}
</pre>



<p>  还可以在代理服务器响应的“X-Accel-Limit-Rate”头字段中设置速率限制。  可以使用<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a>和<a href="ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**limit_rate_after*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">limit_rate_after 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  该指令出现在0.8.0版本中。 </p>
<p>  设置初始量，在此之后，对客户端的响应的进一步传输将受到速率限制。 </p>
<p>  例： </p>
<pre class="notranslate">location /flv/ {
    flv;
    limit_rate_after 500k;
    limit_rate       50k;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_close** 
    &lt;code class=&quot;notranslate&quot;&gt;off</code> |<br>    <code>on</code> |<br>    <code>always</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_close on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.0和1.0.6版本中。 </p>
<p>  控制nginx如何关闭客户端连接。 </p>
<p>  默认值“ <code>on</code> ”指示nginx在完全关闭连接之前<a href="#lingering_timeout">等待</a>并<a href="#lingering_time">处理</a>来自客户端的其他数据，但仅当启发式表明客户端可能正在发送更多数据时。 </p>
<p>  值“ <code>always</code> ”将导致nginx无条件地等待并处理其他客户端数据。 </p>
<p>  值“ <code>off</code> ”告诉nginx永远不要等待更多数据并立即关闭连接。  此行为会破坏协议，不应在正常情况下使用。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_time*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_time 30s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  当<a href="#lingering_close">lingering_close</a>生效时，此指令指定nginx处理（读取和忽略）来自客户端的其他数据的最长时间。  之后，即使有更多数据，连接也将关闭。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**lingering_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">lingering_timeout 5s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  当<a href="#lingering_close">lingering_close</a>生效时，此指令指定更多客户端数据到达的最长等待时间。  如果在此期间未收到数据，则关闭连接。  否则，将读取并忽略数据，并且nginx会再次开始等待更多数据。  重复“wait-read-ignore”循环，但不会超过<a href="#lingering_time">lingering_time</a>指令指定的循环。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;*address*</code> [: <code>*port*</code> ]<br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>setfib</code> = <code>*number*</code> ]<br>    [ <code>fastopen</code> = <code>*number*</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]<br>    [ <code>reuseport</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br> <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;*port*</code><br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>setfib</code> = <code>*number*</code> ]<br>    [ <code>fastopen</code> = <code>*number*</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>ipv6only</code> = <code>on</code> | <code>off</code> ]<br>    [ <code>reuseport</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br> <code>**listen** 
    &lt;code class=&quot;notranslate&quot;&gt;unix:</code> <code>*path*</code><br>    [ <code>default_server</code> ]<br>    [ <code>ssl</code> ]<br>    [ <code>http2</code> | <code>spdy</code> ]<br>    [ <code>proxy_protocol</code> ]<br>    [ <code>backlog</code> = <code>*number*</code> ]<br>    [ <code>rcvbuf</code> = <code>*size*</code> ]<br>    [ <code>sndbuf</code> = <code>*size*</code> ]<br>    [ <code>accept_filter</code> = <code>*filter*</code> ]<br>    [ <code>deferred</code> ]<br>    [ <code>bind</code> ]<br>    [ <code>so_keepalive</code> = <code>on</code> | <code>off</code> |[ <code>*keepidle*</code> ]:[ <code>*keepintvl*</code> ]:[ <code>*keepcnt*</code> ]]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">listen <em>:80 | </em>:8000;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  设置IP的<code>*address*</code>和<code>*port*</code> ，或服务器将接受请求的UNIX域套接字的<code>*path*</code> 。  可以指定<code>*address*</code>和<code>*port*</code> ，或仅指定<code>*address*</code>或仅<code>*port*</code> 。   <code>*address*</code>也可以是主机名，例如： </p>
<pre class="notranslate">listen 127.0.0.1:8000;
listen 127.0.0.1;
listen 8000;
listen *:8000;
listen localhost:8000;
</pre>

<p>   IPv6地址（0.7.36）在方括号中指定： </p>
<pre class="notranslate">listen [::]:8000;
listen [::1];
</pre>

<p>   UNIX域套接字（0.8.21）使用“ <code>unix:</code> ”前缀指定： </p>
<pre class="notranslate">listen unix:/var/run/nginx.sock;
</pre>



<p>  如果仅给出<code>*address*</code> ，则使用端口80。 </p>
<p>  如果指令不存在，那么如果nginx以超级用户权限运行，则使用<code>*:80</code> ，否则使用<code>*:8000</code> 。 </p>
<p>   <code>default_server</code>参数（如果存在）将使服务器成为指定<code>*address*</code> ： <code>*port*</code>对的默认服务器。  如果没有任何指令具有<code>default_server</code>参数，则具有<code>*address*</code> ： <code>*port*</code>对的第一个服务器将成为该对的默认服务器。 </p>
<blockquote>
<p>  在0.8.21之前的版本中，此参数仅命名为<code>default</code> 。 </p>
</blockquote>
<p>   <code>ssl</code>参数（0.7.14）允许指定此端口上接受的所有连接都应在SSL模式下工作。  这样可以为处理HTTP和HTTPS请求的服务器提供更紧凑的<a href="configuring_https_servers.html#single_http_https_server">配置</a> 。 </p>
<p>   <code>http2</code>参数（1.9.5）将端口配置为接受<a href="ngx_http_v2_module.html">HTTP / 2</a>连接。  通常，为了使其工作，也应该指定<code>ssl</code>参数，但是也可以将nginx配置为接受没有SSL的HTTP / 2连接。 </p>
<p>   <code>spdy</code>参数（1.3.15-1.9.4）允许接受此端口上的<a href="ngx_http_spdy_module.html">SPDY</a>连接。  通常，为了使其工作，还应指定<code>ssl</code>参数，但也可以将nginx配置为接受不带SSL的SPDY连接。 </p>
<p>   <code>proxy_protocol</code>参数（1.5.12）允许指定此端口上接受的所有连接都应使用<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="noopener">PROXY协议</a> 。 </p>
<blockquote>
<p>  自版本1.13.11起支持PROXY协议版本2。 </p>
</blockquote>
<p>   <code>listen</code>指令可以有几个特定于与套接字相关的系统调用的附加参数。  这些参数可以在任何<code>listen</code>指令中指定，但对于给定的<code>*address*</code>只能指定一次： <code>*port*</code>对。 </p>
<blockquote>
<p>  在0.8.21之前的版本中，它们只能在<code>listen</code>指令中与<code>default</code>参数一起指定。 </p>
<p>  除非服务器可以处理多次<a href="https://tools.ietf.org/html/rfc7413#section-6.1" target="_blank" rel="noopener">使用数据</a>的<a href="https://tools.ietf.org/html/rfc7413#section-6.1" target="_blank" rel="noopener">同一SYN数据包，</a>否则不要启用此功能。 </p>
<p>  在1.3.4版之前，如果省略此参数，则操作系统的设置对套接字有效。 </p>
<p>  不恰当地使用此选项可能会产生安全<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">隐患</a> 。 </p>
</blockquote>
<pre class="notranslate">so_keepalive=30m::10</pre>



<p>  例： </p>
<pre class="notranslate">listen 127.0.0.1 default_server accept_filter=dataready backlog=1024;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**location** [
    &lt;code class=&quot;notranslate&quot;&gt;=</code> |<br>    <code>~</code> |<br>    <code>~*</code> |<br>    <code>^~</code><br>    ] <code>*uri*</code> { … } <br> <code>**location@</code> <code>*name*</code> { … } <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  根据请求URI设置配置。 </p>
<p>  在解码以“ <code>%XX</code> ”形式编码的文本，解析对相对路径分量的引用之后，针对规范化的URI执行匹配<code>.</code>   “和” <code>..</code> “，并且可能<a href="#merge_slashes">将</a>两个或多个相邻斜线<a href="#merge_slashes">压缩</a>成单个斜线。 </p>
<p>  位置可以由前缀字符串或正则表达式定义。  正则表达式使用前面的“ <code>~*</code> ”修饰符（用于不区分大小写的匹配）或“ <code>~</code> ”修饰符（用于区分大小写的匹配）指定。  为了找到与给定请求匹配的位置，nginx首先检查使用前缀字符串（前缀位置）定义的位置。  其中，选择并记住具有最长匹配前缀的位置。  然后按照它们在配置文件中的出现顺序检查正则表达式。  正则表达式的搜索在第一个匹配时终止，并使用相应的配置。  如果未找到与正则表达式的匹配，则使用先前记住的前缀位置的配置。 </p>
<p>  可以嵌套<code>location</code>块，但下面提到了一些例外情况。 </p>
<p>  对于不区分大小写的操作系统（如macOS和Cygwin），与前缀字符串匹配会忽略大小写（0.7.7）。  但是，比较仅限于一个字节的区域设置。 </p>
<p>  正则表达式可以包含稍后可以在其他指令中使用的捕获（0.7.40）。 </p>
<p>  如果最长匹配前缀位置具有“ <code>^~</code> ”修饰符，则不检查正则表达式。 </p>
<p>  此外，使用“ <code>=</code> ”修饰符可以定义URI和位置的精确匹配。  如果找到完全匹配，则搜索终止。  例如，如果频繁发生“ <code>/</code> ”请求，则定义“ <code>location = /</code> ”将加速这些请求的处理，因为搜索在第一次比较之后立即终止。  这样的位置显然不能包含嵌套位置。 </p>
<blockquote>
<p>  在0.7.1到0.8.41的版本中，如果请求与前缀位置匹配而没有“ <code>=</code> ”和“ <code>^~</code> ”修饰符，则搜索也会终止，并且不会检查正则表达式。 </p>
</blockquote>
<p>  让我们通过一个例子来说明以上内容： </p>
<pre class="notranslate">location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
</pre>

<p>   “ <code>/</code> ”请求将匹配配置A，“/ <code>/index.html</code> ”请求将匹配配置B，“/ <code>/documents/document.html</code> ”请求将匹配配置C，“/ <code>/images/1.gif</code> ”请求将匹配配置D，“/ <code>/documents/1.jpg</code> ”请求将匹配配置E. </p>
<p>   “ <code>@</code> ”前缀定义了命名位置。  这样的位置不用于常规请求处理，而是用于请求重定向。  它们不能嵌套，也不能包含嵌套位置。 </p>
<p>  如果位置由以斜杠字符结尾的前缀字符串定义，并且请求由<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>或<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass之一</a>处理，则执行特殊处理。  为了响应URI等于此字符串但没有尾部斜杠的请求，带有代码301的永久重定向将返回到请求的URI，并附加斜杠。  如果不需要，可以像下面这样定义URI和位置的完全匹配： </p>
<pre class="notranslate">location /user/ {
    proxy_pass http://user.example.com;
}

location = /user {
    proxy_pass http://login.example.com;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**log_not_foundon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">log_not_found on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用将未找到的文件的错误记录到<a href="ngx_core_module.html#error_log">error_log中</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**log_subrequeston</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">log_subrequest off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用将子请求记录到<a href="ngx_http_log_module.html#access_log">access_log中</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**max_ranges*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.1.2版中。 </p>
<p>  限制字节范围请求中允许的最大范围数。  超出限制的请求将被处理，就像没有指定字节范围一样。  默认情况下，范围数量不受限制。  零值完全禁用字节范围支持。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**merge_slasheson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">merge_slashes on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  启用或禁用将URI中的两个或多个相邻斜杠压缩为单个斜杠。 </p>
<p>  请注意，压缩对于正确匹配前缀字符串和正则表达式位置至关重要。  没有它，“ <code>//scripts/one.php</code> ”请求将不匹配 </p>
<pre class="notranslate">location /scripts/ {
    ...
}
</pre>

<p>  并且可能被处理为静态文件。  所以它被转换为“ <code>/scripts/one.php</code> ”。 </p>
<p>  如果URI包含base64编码的名称，则必须<code>off</code>压缩，因为base64在内部使用“ <code>/</code> ”字符。  但是，出于安全考虑，最好避免关闭压缩。 </p>
<p>  如果在<a href="#server">服务器</a>级别指定了该指令，则仅在服务器是默认服务器时使用其值。  指定的值也适用于侦听同一地址和端口的所有虚拟服务器。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**msie_paddingon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">msie_padding on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用向状态大于400的MSIE客户端的响应添加注释，以将响应大小增加到512字节。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**msie_refreshon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">msie_refresh off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用发布刷新而不是MSIE客户端的重定向。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cacheoff</code> ; <br> <code>**open_file_cache** 
&lt;code class=&quot;notranslate&quot;&gt;max</code> = <code>*N*</code><br>[ <code>inactive</code> = <code>*time*</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  配置可以存储的缓存： </p>
<ul>
<li>打开文件描述符，它们的大小和修改时间; -   关于目录存在的信息; -   文件查找错误，例如“找不到文件”，“没有读取权限”等。 <blockquote class="note">  应该通过<a href="#open_file_cache_errors">open_file_cache_errors</a>指令单独启用缓存错误。 </blockquote></li>
</ul>
<p>  该指令具有以下参数： </p>
<p>  例： </p>
<pre class="notranslate">open_file_cache          max=1000 inactive=20s;
open_file_cache_valid    30s;
open_file_cache_min_uses 2;
open_file_cache_errors   on;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_errorson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_errors off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  通过<a href="#open_file_cache">open_file_cache</a>启用或禁用文件查找错误的缓存。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_min_uses*number*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_min_uses 1;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置在<a href="#open_file_cache">open_file_cache</a>指令的<code>inactive</code>参数配置的时间段内文件访问的最小<code>*number*</code> ，这是文件描述符在缓存中保持打开所必需的。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**open_file_cache_valid*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">open_file_cache_valid 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置应验证<a href="#open_file_cache">open_file_cache</a>元素的时间。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**output_buffers*number*</code> <code>*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">output_buffers 2 32k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置用于从磁盘读取响应的缓冲区的<code>*number*</code>和<code>*size*</code> 。 </p>
<blockquote>
<p>  在1.9.5版之前，默认值为1 32k。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**port_in_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">port_in_redirect on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用在nginx发出的<a href="#absolute_redirect">绝对</a>重定向中指定端口。 </p>
<p>  在重定向中使用主服务器名称由<a href="#server_name_in_redirect">server_name_in_redirect</a>指令控制。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**postpone_output*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">postpone_output 1460;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果可能，客户端数据的传输将被推迟，直到nginx至少要发送<code>*size*</code>字节的数据。  零值禁用推迟数据传输。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**read_ahead*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">read_ahead 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置使用文件时内核的预读取量。 </p>
<p>  在Linux上，使用<code>posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)</code>系统调用，因此忽略<code>*size*</code>参数。 </p>
<p>  在FreeBSD上，使用了自FreeBSD 9.0-CURRENT以来支持的<code>fcntl(O_READAHEAD,</code> <code>*size*</code> <code>)</code>系统调用。   FreeBSD 7必须<a href="http://sysoev.ru/freebsd/patch.readahead.txt" target="_blank" rel="noopener">打补丁</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**recursive_error_pageson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">recursive_error_pages off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  使用<a href="#error_page">error_page</a>指令启用或禁用多个重定向。  此类重定向的数量<a href="#internal">有限</a> 。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**request_pool_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">request_pool_size 4k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p>  允许精确调整每个请求的内存分配。  该指令对性能的影响最小，通常不应使用。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**reset_timedout_connectionon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">reset_timedout_connection off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用重置超时连接。  重置如下进行。  在关闭套接字之前，在其上设置<code>SO_LINGER</code>选项，超时值为0.当套接字关闭时，TCP RST将发送到客户端，并释放此套接字占用的所有内存。  这有助于避免将已填充缓冲区的已关闭套接字保持在FIN_WAIT1状态很长时间。 </p>
<p>  应该注意，超时保持连接正常关闭。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**resolver** 
    &lt;code class=&quot;notranslate&quot;&gt;*address*</code> …<br>    [ <code>valid</code> = <code>*time*</code> ]<br>    [ <code>ipv6</code> = <code>on</code> | <code>off</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  将用于解析上游服务器名称的名称服务器配置到地址中，例如： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353;
</pre>

<p>  可以将地址指定为域名或IP地址，以及可选端口（1.3.1,1.2.2）。  如果未指定端口，则使用端口53。  以循环方式查询名称服务器。 </p>
<blockquote>
<p>  在1.1.7版之前，只能配置一个名称服务器。  从版本1.3.1和1.2.2开始支持使用IPv6地址指定名称服务器。 </p>
</blockquote>
<p>  默认情况下，nginx将在解析时查找IPv4和IPv6地址。  如果不需要查找IPv6地址，可以指定<code>ipv6=off</code>参数。 </p>
<blockquote>
<p>  从版本1.5.8开始支持将名称解析为IPv6地址。 </p>
</blockquote>
<p>  默认情况下，nginx使用响应的TTL值缓存答案。  可选的<code>valid</code>参数允许覆盖它： </p>
<pre class="notranslate">resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre>



<blockquote>
<p>  在版本1.1.9之前，无法调整缓存时间，并且nginx始终缓存5分钟的持续时间。 </p>
<p>  为防止DNS欺骗，建议在正确安全的受信任本地网络中配置DNS服务器。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**resolver_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">resolver_timeout 30s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置名称解析的超时，例如： </p>
<pre class="notranslate">resolver_timeout 5s;
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**root*path*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">root html;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  设置请求的根目录。  例如，使用以下配置 </p>
<pre class="notranslate">location /i/ {
    root /data/w3;
}
</pre>

<p>  将发送<code>/data/w3/i/top.gif</code>文件以响应“ <code>/i/top.gif</code> ”请求。 </p>
<p>   <code>*path*</code>值可以包含变量， <code>$document_root</code>和<code>$realpath_root</code>除外。 </p>
<p>  仅通过向<code>root</code>指令的值添加URI来构造文件的路径。  如果必须修改URI，则应使用<a href="#alias">别名</a>指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**satisfyall</code> | <code>any</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">satisfy all;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果所有（ <code>all</code> ）或至少一个（ <code>any</code> ） <a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> ， <a href="ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>或<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a>模块允许访问，则允许访问。 </p>
<p>  例： </p>
<pre class="notranslate">location / {
    satisfy any;

    allow 192.168.1.0/32;
    deny  all;

    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**send_lowat*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">send_lowat 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  如果指令设置为非零值，nginx将尝试通过使用<a href="events.html#kqueue">kqueue</a>方法的<code>NOTE_LOWAT</code>标志或<code>SO_SNDLOWAT</code>套接字选项来最小化客户端套接字上的发送操作数。  在这两种情况下都使用指定的<code>*size*</code> 。 </p>
<p>  在Linux，Solaris和Windows上忽略此指令。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**send_timeout*time*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">send_timeout 60s;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置将响应传输到客户端的超时。  仅在两次连续写操作之间设置超时，而不是整个响应的传输。  如果客户端在此时间内未收到任何内容，则会关闭连接。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**sendfileon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">sendfile off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br><br>                </td></p>
<p>  启用或禁用<code>sendfile()</code>的使用。 </p>
<p>  从nginx 0.8.12和FreeBSD 5.2.1开始， <a href="#aio">aio</a>可用于预加载<code>sendfile()</code>数据： </p>
<pre class="notranslate">location /video/ {
    sendfile       on;
    tcp_nopush     on;
    aio            on;
}
</pre>

<p>  在此配置中，使用<code>SF_NODISKIO</code>标志调用<code>sendfile()</code> ，这会导致它不阻塞磁盘I / O，而是报告数据不在内存中。  然后，nginx通过读取一个字节来启动异步数据加载。  在第一次读取时，FreeBSD内核将文件的前128K字节加载到内存中，尽管下一次读取只会以16K块的形式加载数据。  可以使用<a href="#read_ahead">read_ahead</a>指令更改此<a href="#read_ahead">设置</a> 。 </p>
<blockquote>
<p>  在1.7.11版之前，可以使用<code>aio sendfile;</code>启用预加载<code>aio sendfile;</code>   。 </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**sendfile_max_chunk*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">sendfile_max_chunk 0;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  设置为非零值时，限制可在单个<code>sendfile()</code>调用中传输的数据量。  没有限制，一个快速连接可能完全占用工作进程。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置虚拟服务器的配置。  基于IP（基于IP地址）和基于名称（基于“主机”请求标头字段）的虚拟服务器之间没有明确的区别。  相反， <a href="#listen">listen</a>指令描述了应该接受服务器连接的所有地址和端口， <a href="#server_name">server_name</a>指令列出了所有服务器名称。   “ <a href="request_processing.html">如何nginx处理请求</a> ”文档中提供了示例配置。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_name*name*</code> …; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_name “”;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  设置虚拟服务器的名称，例如： </p>
<pre class="notranslate">server {
    server_name example.com www.example.com;
}
</pre>



<p>  第一个名称成为主服务器名称。 </p>
<p>  服务器名称可以包含替换名称的第一个或最后一个部分的星号（“ <code>*</code> ”）： </p>
<pre class="notranslate">server {
    server_name example.com *.example.com www.example.*;
}
</pre>

<p>  这些名称称为通配符名称。 </p>
<p>  上面提到的前两个名称可以合二为一： </p>
<pre class="notranslate">server {
    server_name .example.com;
}
</pre>



<p>  也可以在服务器名称中使用正则表达式，在名称前面加上波浪号（“ <code>~</code> ”）： </p>
<pre class="notranslate">server {
    server_name www.example.com ~^www\d+\.example\.com$;
}
</pre>



<p>  正则表达式可以包含以后可以在其他指令中使用的捕获（0.7.40）： </p>
<pre class="notranslate">server {
    server_name ~^(www\.)?(.+)$;

    location / {
        root /sites/$2;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre>



<p>  正则表达式中的命名捕获创建变量（0.8.25），以后可以在其他指令中使用它们： </p>
<pre class="notranslate">server {
    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;

    location / {
        root /sites/$domain;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre>



<p>  如果指令的参数设置为“ <code>$hostname</code> ”（0.9.4），则插入机器的主机名。 </p>
<p>  也可以指定一个空的服务器名称（0.7.11）： </p>
<pre class="notranslate">server {
    server_name www.example.com "";
}
</pre>

<p>  它允许此服务器处理请求而不使用“Host”头字段 - 而不是默认服务器 - 用于给定地址：端口对。  这是默认设置。 </p>
<blockquote>
<p>  在0.8.48之前，默认使用机器的主机名。 </p>
</blockquote>
<p>  在按名称搜索虚拟服务器期间，如果名称与多个指定的变体匹配（例如，通配符名称和正则表达式匹配），将按以下优先级顺序选择第一个匹配的变体： </p>
<ol>
<li>确切的名字 1.   以星号开头的最长通配符名称，例如“ <code>*.example.com</code> ” 1.   最长的通配符名称以星号结尾，例如“ <code>mail.*</code> ” 1.   第一个匹配的正则表达式（按配置文件中的出现顺序） </li>
</ol>
<p>  服务器名称的详细描述在单独的<a href="server_names.html">服务器名称</a>文档中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_name_in_redirecton</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_name_in_redirect off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  在nginx发出的<a href="#absolute_redirect">绝对</a>重定向中启用或禁用<a href="#server_name">server_name</a>指令指定的主服务器名称。  禁用主服务器名称时，将使用“主机”请求标头字段中的名称。  如果此字段不存在，则使用服务器的IP地址。 </p>
<p>  在重定向中使用端口由<a href="#port_in_redirect">port_in_redirect</a>指令控制。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_names_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_names_hash_bucket_size 32|64|128;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置服务器名称哈希表的存储桶大小。  默认值取决于处理器缓存行的大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_names_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_names_hash_max_size 512;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置服务器名称哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**server_tokens** 
    &lt;code class=&quot;notranslate&quot;&gt;on</code> |<br>    <code>off</code> |<br>    <code>build</code> |<br>    <code>*string*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">server_tokens on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用在错误页面和“服务器”响应头字段中发出nginx版本。 </p>
<p>   <code>build</code>参数（1.11.10）允许发出<a href="configure.html#build">构建名称</a>和nginx版本。 </p>
<p>  此外，作为<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，从版本1.9.13开始，错误页面上的签名和“服务器”响应头字段值可以使用带变量的<code>*string*</code>显式设置。  空字符串禁用“服务器”字段的发射。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**subrequest_output_buffer_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">subrequest_output_buffer_size 4k|8k;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  该指令出现在1.13.10版本中。 </p>
<p> Sets the <code>*size*</code> of the buffer used for storing the response body of a subrequest.  默认情况下，缓冲区大小等于一个内存页面。  这是4K或8K，具体取决于平台。  然而，它可以做得更小。 </p>
<p> The directive is applicable only for subrequests with response bodies saved into memory. For example, such subrequests are created by <a href="ngx_http_ssi_module.html#ssi_include_set">SSI</a> . </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**tcp_nodelayon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">tcp_nodelay on;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p>  启用或禁用<code>TCP_NODELAY</code>选项的使用。 The option is enabled when a connection is transitioned into the keep-alive state. Additionally, it is enabled on SSL connections, for unbuffered proxying, and for <a href="websocket.html">WebSocket</a> proxying. </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**tcp_nopushon</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">tcp_nopush off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Enables or disables the use of the <code>TCP_NOPUSH</code> socket option on FreeBSD or the <code>TCP_CORK</code> socket option on Linux. The options are enabled only when <a href="#sendfile">sendfile</a> is used. Enabling the option allows </p>
<ul>
<li>sending the response header and the beginning of a file in one packet, on Linux and FreeBSD 4.*; -  sending a file in full packets. </li>
</ul>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**try_files*file*</code> … <code>*uri*</code> ; <br> <code>**try_files*file*</code> … = <code>*code*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the <code>*file*</code> parameter according to the <a href="#root">root</a> and <a href="#alias">alias</a> directives. It is possible to check directory’s existence by specifying a slash at the end of a name, eg “ <code>$uri/</code> ”. If none of the files were found, an internal redirect to the <code>*uri*</code> specified in the last parameter is made.  例如： </p>
<pre class="notranslate">location /images/ {
    try_files $uri /images/default.gif;
}

location = /images/default.gif {
    expires 30s;
}
</pre>

<p> The last parameter can also point to a named location, as shown in examples below. Starting from version 0.7.51, the last parameter can also be a <code>*code*</code> : </p>
<pre class="notranslate">location / {
    try_files $uri $uri/index.html $uri.html =404;
}
</pre>



<p> Example in proxying Mongrel: </p>
<pre class="notranslate">location / {
    try_files /system/maintenance.html
              $uri $uri/index.html $uri.html
              @mongrel;
}

location @mongrel {
    proxy_pass http://mongrel;
}
</pre>



<p> Example for Drupal/FastCGI: </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @drupal;
}

location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
    fastcgi_param QUERY_STRING    $args;

    ... other fastcgi_param's
}

location @drupal {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    fastcgi_param SCRIPT_NAME     /index.php;
    fastcgi_param QUERY_STRING    q=$uri&amp;$args;

    ... other fastcgi_param's
}
</pre>

<p> In the following example, </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @drupal;
}
</pre>

<p> the <code>try_files</code> directive is equivalent to </p>
<pre class="notranslate">location / {
    error_page 404 = @drupal;
    log_not_found off;
}
</pre>

<p> And here, </p>
<pre class="notranslate">location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

    ...
}
</pre>

<p> <code>try_files</code> checks the existence of the PHP file before passing the request to the FastCGI server. </p>
<p> Example for Wordpress and Joomla: </p>
<pre class="notranslate">location / {
    try_files $uri $uri/ @wordpress;
}

location ~ \.php$ {
    try_files $uri @wordpress;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    ... other fastcgi_param's
}

location @wordpress {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    ... other fastcgi_param's
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types** { ... }</code> <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types {<br>    text/html  html;<br>    image/gif  gif;<br>    image/jpeg jpg;<br>}</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Maps file name extensions to MIME types of responses. Extensions are case-insensitive. Several extensions can be mapped to one type, for example: </p>
<pre class="notranslate">types {
    application/octet-stream bin exe dll;
    application/octet-stream deb;
    application/octet-stream dmg;
}
</pre>



<p> A sufficiently full mapping table is distributed with nginx in the <code>conf/mime.types</code> file. </p>
<p> To make a particular location emit the “ <code>application/octet-stream</code> ” MIME type for all requests, the following configuration can be used: </p>
<pre class="notranslate">location /download/ {
    types        { }
    default_type application/octet-stream;
}
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types_hash_bucket_size 64;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Sets the bucket size for the types hash tables.  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<blockquote>
<p> Prior to version 1.5.13, the default value depended on the size of the processor’s cache line. </p>
</blockquote>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**types_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">types_hash_max_size 1024;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> , <code>location</code> <br><br>                </td></p>
<p> Sets the maximum <code>*size*</code> of the types hash tables.  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**underscores_in_headerson</code> | <code>off</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">underscores_in_headers off;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> , <code>server</code> <br><br>                </td></p>
<p> Enables or disables the use of underscores in client request header fields. When the use of underscores is disabled, request header fields whose names contain underscores are marked as invalid and become subject to the <a href="#ignore_invalid_headers">ignore_invalid_headers</a> directive. </p>
<p> If the directive is specified on the <a href="#server">server</a> level, its value is only used if a server is a default one. The value specified also applies to all virtual servers listening on the same address and port. </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**variables_hash_bucket_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">variables_hash_bucket_size 64;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置变量哈希表的桶大小。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**variables_hash_max_size*size*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"><br>            <pre class="notranslate">variables_hash_max_size 1024;</pre><br>                </td></p>
<p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>http</code> <br><br>                </td></p>
<p>  设置变量哈希表的最大<code>*size*</code> 。  设置哈希表的详细信息在单独的<a href="hash.html">文档</a>中提供。 </p>
<blockquote>
<p> Prior to version 1.5.13, the default value was 512. </p>
</blockquote>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p> The <code>ngx_http_core_module</code> module supports embedded variables with names matching the Apache Server variables. First of all, these are variables representing client request header fields, such as <code>$http_user_agent</code> , <code>$http_cookie</code> , and so on. Also there are other variables: </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p>  必须先通过在<a href="#listen">listen</a>指令中设置<code>proxy_protocol</code>参数来启用PROXY协议。 </p>
<p> The variable’s value is made available in locations processed by the <a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> , <a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> , <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> , and <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> directives when the request body was read to a <a href="#client_body_buffer_size">memory buffer</a> . </p>
<p> At the end of processing, the file needs to be removed. To always write the request body to a file, <a href="#client_body_in_file_only">client_body_in_file_only</a> needs to be enabled. When the name of a temporary file is passed in a proxied request or in a request to a FastCGI/uwsgi/SCGI server, passing the request body should be disabled by the <a href="ngx_http_proxy_module.html#proxy_pass_request_body">proxy_pass_request_body off</a> , <a href="ngx_http_fastcgi_module.html#fastcgi_pass_request_body">fastcgi_pass_request_body off</a> , <a href="ngx_http_uwsgi_module.html#uwsgi_pass_request_body">uwsgi_pass_request_body off</a> , or <a href="ngx_http_scgi_module.html#scgi_pass_request_body">scgi_pass_request_body off</a> directives, respectively. </p>
<p>  计算此变量的值通常需要一次系统调用。  为避免系统调用， <a href="#listen">listen</a>指令必须指定地址并使用<code>bind</code>参数。 </p>
<p> The value of <code>$uri</code> may change during request processing, eg when doing internal redirects, or when using index files. </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_charset_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_charset_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_charset_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-charset-module"><a href="#Module-ngx-http-charset-module" class="headerlink" title="Module ngx_http_charset_module"></a>Module ngx_http_charset_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#charset">charset</a> <br>     <a href="#charset_map">charset_map</a> <br>     <a href="#charset_types">charset_types</a> <br>     <a href="#override_charset">override_charset</a> <br>     <a href="#source_charset">source_charset</a> <br></td>

<p>   <code>ngx_http_charset_module</code>模块将指定的字符集添加到“Content-Type”响应头字段。  此外，该模块可以将数据从一个字符集转换为另一个字符集，但有一些限制： </p>
<ul>
<li>转换是以一种方式执行的 - 从服务器到客户端， -   只能转换单字节字符集 -   或者来自UTF-8的单字节字符集。 </li>
</ul>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">include        conf/koi-win;

charset        windows-1251;
source_charset koi8-r;
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset*charset*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">charset off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  将指定的charset添加到“Content-Type”响应头字段。  如果此charset与<a href="#source_charset">source_charset</a>指令中指定的charset不同，则执行转换。 </p>
<p>  参数<code>off</code>取消将charset添加到“Content-Type”响应头字段。 </p>
<p>  可以使用变量定义charset： </p>
<pre class="notranslate">charset $charset;
</pre>

<p>  在这种情况下，变量的所有可能值需要以<a href="#charset_map">charset_map</a> ， <a href="#charset">charset</a>或<a href="#source_charset">source_charset</a>指令的形式存在于配置中至少一次。  对于<code>utf-8</code> ， <code>windows-1251</code>和<code>koi8-r</code> charsets，将文件<code>conf/koi-win</code> ， <code>conf/koi-utf</code>和<code>conf/win-utf</code>包含在<code>conf/koi-win</code>就足够了。  对于其他字符集，只需制作虚构的转换表即可，例如： </p>
<pre class="notranslate">charset_map iso-8859-5 _ { }
</pre>



<p>  此外，可以在“X-Accel-Charset”响应头字段中设置字符集。  可以使用<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> ， <a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a> ， <a href="ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a>和<a href="ngx_http_grpc_module.html#grpc_ignore_headers">grpc_ignore_headers</a>指令禁用此功能。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset_map*charset1*</code> <code>*charset2*</code> { … } <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  描述从一个字符集到另一个字符集的转换表。  使用相同的数据构建反向转换表。  字符代码以十六进制给出。   80-FF范围内的缺失字符被替换为“ <code>?</code>   ”。  从UTF-8转换时，单字节字符集中缺少的字符将替换为“ <code>&amp;amp;#XXXX;</code>   ”。 </p>
<p>  例： </p>
<pre class="notranslate">charset_map koi8-r windows-1251 {
    C0 FE ; # small yu
    C1 E0 ; # small a
    C2 E1 ; # small b
    C3 F6 ; # small ts
    ...
}
</pre>



<p>  在将转换表描述为UTF-8时，应在第二列中给出UTF-8字符集的代码，例如： </p>
<pre class="notranslate">charset_map koi8-r utf-8 {
    C0 D18E ; # small yu
    C1 D0B0 ; # small a
    C2 D0B1 ; # small b
    C3 D186 ; # small ts
    ...
}
</pre>



<p>  在分配文件<code>conf/koi-win</code> ， <code>conf/koi-utf</code>和<code>conf/win-utf</code>中提供了从<code>koi8-r</code>到<code>windows-1251</code> ，从<code>koi8-r</code>和<code>windows-1251</code>到<code>utf-8</code>完整转换表。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**charset_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">charset_types text/html text/xml text/plain text/vnd.wap.wmlapplication/javascript application/rss+xml;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.9版本中。 </p>
<p>  除了“ <code>text/html</code> ”之外，还可以在具有指定MIME类型的响应中启用模块处理。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
<blockquote>
<p>  在版本1.5.4之前，“ <code>application/x-javascript</code> ”被用作默认MIME类型而不是“ <code>application/javascript</code> ”。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**override_charseton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">override_charset off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  确定当答案已在“Content-Type”响应头字段中携带字符集时，是否应对从代理或FastCGI / uwsgi / SCGI / gRPC服务器接收的答案执行转换。  如果启用了转换，则将接收到的响应中指定的字符集用作源字符集。 </p>
<blockquote>
<p>  应当注意，如果在子请求中接收到响应，则始终执行从响应字符集到主请求字符集的转换，而不管<code>override_charset</code>指令设置如何。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**source_charset*charset*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>if in location</code> <br>                </td></p>
<p>  定义响应的源字符集。  如果此charset与<a href="#charset">charset</a>指令中指定的<a href="#charset">charset</a>不同，则执行转换。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_browser_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_browser_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_browser_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-browser-module"><a href="#Module-ngx-http-browser-module" class="headerlink" title="Module ngx_http_browser_module"></a>Module ngx_http_browser_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#ancient_browser">ancient_browser</a> <br>     <a href="#ancient_browser_value">ancient_browser_value</a> <br>     <a href="#modern_browser">modern_browser</a> <br>     <a href="#modern_browser_value">modern_browser_value</a> <br></td>

<p>   <code>ngx_http_browser_module</code>模块创建的变量的值取决于“User-Agent”请求标头字段的值： </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><p>  选择索引文件： </p>
<pre class="notranslate">modern_browser_value "modern.";

modern_browser msie      5.5;
modern_browser gecko     1.0.0;
modern_browser opera     9.0;
modern_browser safari    413;
modern_browser konqueror 3.0;

index index.${modern_browser}html index.html;
</pre>



<p>  旧浏览器的重定向： </p>
<pre class="notranslate">modern_browser msie      5.0;
modern_browser gecko     0.9.1;
modern_browser opera     8.0;
modern_browser safari    413;
modern_browser konqueror 3.0;

modern_browser unlisted;

ancient_browser Links Lynx netscape4;

if ($ancient_browser) {
    rewrite ^ /ancient.html;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ancient_browser*string*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  如果在“User-Agent”请求标头字段中找到任何指定的子字符串，则浏览器将被视为古代。  特殊字符串“ <code>netscape4</code> ”对应于正则表达式“ <code>^Mozilla/[1-4]</code> ”。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ancient_browser_value*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">ancient_browser_value 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<code>$ancient_browser</code>变量的值。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**modern_browser*browser*</code> <code>*version*</code> ; <br> <code>**modern_browserunlisted</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  指定从中将浏览器视为现代的版本。  浏览器可以是以下任何一种： <code>msie</code> ， <code>gecko</code> （基于Mozilla的浏览器）， <code>opera</code> ， <code>safari</code>或<code>konqueror</code> 。 </p>
<p>  可以使用以下格式指定版本：X，XX，XXX或XXXX每种格式的最大值分别为4000,4000.99,4000.99.99和4000.99.99.99。 </p>
<p>   <code>unlisted</code>的特殊值指定将浏览器视为现代浏览器，如果它未被<code>modern_browser</code>和<a href="#ancient_browser">ancient_browser</a>指令列出。  否则这样的浏览器被认为是古老的。  如果请求未在标头中提供“User-Agent”字段，则将浏览器视为未列出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**modern_browser_value*string*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">modern_browser_value 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  设置<code>$modern_browser</code>变量的值。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_autoindex_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_autoindex_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_autoindex_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-autoindex-module"><a href="#Module-ngx-http-autoindex-module" class="headerlink" title="Module ngx_http_autoindex_module"></a>Module ngx_http_autoindex_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#autoindex">autoindex</a> <br>     <a href="#autoindex_exact_size">autoindex_exact_size</a> <br>     <a href="#autoindex_format">autoindex_format</a> <br>     <a href="#autoindex_localtime">autoindex_localtime</a> <br></td>

<p>   <code>ngx_http_autoindex_module</code>模块处理以斜杠字符（’ <code>/</code> ‘）结尾的请求，并生成目录列表。  当<a href="ngx_http_index_module.html">ngx_http_index_module</a>模块找不到索引文件时，通常<code>ngx_http_autoindex_module</code>请求传递给<code>ngx_http_autoindex_module</code>模块。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    autoindex on;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  启用或禁用目录列表输出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_exact_sizeon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_exact_size on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  对于HTML <a href="#autoindex_format">格式</a> ，指定是否应在目录列表中输出确切的文件大小，或者更确切地舍入为千字节，兆字节和千兆字节。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_format** html</code> |    <code>xml</code> |    <code>json</code> |    <code>jsonp</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_format html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.7.9版本中。 </p>
<p>  设置目录列表的格式。 </p>
<p>  使用JSONP格式时，使用<code>callback</code>请求参数设置回调函数的名称。  如果参数缺失或具有空值，则使用JSON格式。 </p>
<p>  可以使用<a href="ngx_http_xslt_module.html">ngx_http_xslt_module</a>模块转换XML输出。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**autoindex_localtimeon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">autoindex_localtime off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  对于HTML <a href="#autoindex_format">格式</a> ，指定目录列表中的时间是应以本地时区还是UTC输出。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_request_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_request_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_request_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-request-module"><a href="#Module-ngx-http-auth-request-module" class="headerlink" title="Module ngx_http_auth_request_module"></a>Module ngx_http_auth_request_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_request">auth_request</a> <br>     <a href="#auth_request_set">auth_request_set</a> <br></td>

<p>   <code>ngx_http_auth_request_module</code>模块（1.5.4+）基于子请求的结果实现客户端授权。  如果子请求返回2xx响应代码，则允许访问。  如果它返回401或403，则拒绝访问，并显示相应的错误代码。  子请求返回的任何其他响应代码都被视为错误。 </p>
<p>  对于401错误，客户端还从子请求响应中接收“WWW-Authenticate”头。 </p>
<p>  默认情况下不构建此模块，应使用<code>--with-http_auth_request_module</code>配置参数启用它。 </p>
<p>  该模块可以通过<a href="ngx_http_core_module.html#satisfy">满足</a>指令与其他访问模块组合，例如<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> 。 </p>
<blockquote>
<p>  在1.7.3版之前，无法缓存对授权子请求的响应（使用<a href="ngx_http_proxy_module.html#proxy_cache">proxy_cache</a> ， <a href="ngx_http_proxy_module.html#proxy_store">proxy_store</a>等）。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location /private/ {
    auth_request /auth;
    ...
}

location = /auth {
    proxy_pass ...
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_request*uri*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_request off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  根据子请求的结果启用授权，并设置子请求将发送到的URI。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_request_set*$variable*</code> <code>*value*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  授权请求完成后，将请求<code>*variable*</code>设置为给定<code>*value*</code> 。  该值可能包含授权请求中的变量，例如<code>$upstream_http_*</code> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_jwt_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_jwt_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_jwt_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-jwt-module"><a href="#Module-ngx-http-auth-jwt-module" class="headerlink" title="Module ngx_http_auth_jwt_module"></a>Module ngx_http_auth_jwt_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_jwt">auth_jwt</a> <br>     <a href="#auth_jwt_claim_set">auth_jwt_claim_set</a> <br>     <a href="#auth_jwt_header_set">auth_jwt_header_set</a> <br>     <a href="#auth_jwt_key_file">auth_jwt_key_file</a> <br>     <a href="#auth_jwt_key_request">auth_jwt_key_request</a> <br>     <a href="#auth_jwt_leeway">auth_jwt_leeway</a> <br> <a href="#variables">Embedded Variables</a> <br></td>

<p>   <code>ngx_http_auth_jwt_module</code>模块（1.11.3）通过使用指定的密钥验证提供的<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web令牌</a> （JWT）来实现客户端授权。   JWT声明必须以<a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web签名</a> （JWS）结构进行编码。  该模块可用于<a href="http://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="noopener">OpenID Connect</a>身份验证。 </p>
<p>  该模块可以通过<a href="ngx_http_core_module.html#satisfy">满足</a>指令与其他访问模块组合，例如<a href="ngx_http_access_module.html">ngx_http_access_module</a> ， <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>和<a href="ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> 。 </p>
<p>  该模块支持以下加密<a href="https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms" target="_blank" rel="noopener">算法</a> ： </p>
<ul>
<li>HS256，HS384，HS512 -    RS256，RS384，RS512 -    ES256，ES384，ES512 -    EdDSA（Ed25519和Ed448签名）（1.15.7）<br>在1.13.7版之前，仅支持HS256，RS256，ES256算法。 </li>
</ul>
<blockquote>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    auth_jwt          "closed site";
    auth_jwt_key_file conf/keys.json;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt**  *string*</code>    [ <code>token=</code> <code>*$variable*</code> ] |    <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_jwt off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  启用JSON Web Token的验证。  指定的<code>*string*</code>用作域。  参数值可以包含变量。 </p>
<p>  可选的<code>token</code>参数指定包含JSON Web Token的变量。  默认情况下，JWT作为<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">承载令牌</a>在“授权”标头中传递。   JWT也可以作为cookie或查询字符串的一部分传递： </p>
<pre class="notranslate">auth_jwt "closed site" token=$cookie_auth_token;
</pre>



<p>  特殊值<code>off</code>取消了从先前配置级别继承的<code>auth_jwt</code>伪指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_claim_set*$variable*</code> <code>*name*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  将<code>*variable*</code>设置为由键名标识的JWT声明参数。  名称匹配从JSON树的顶级开始。  对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<pre class="notranslate">location / {
    auth_jwt           "closed site";
    auth_jwt_key_file  conf/keys.json;
    auth_jwt_claim_set $email info e-mail;
    auth_jwt_claim_set $job info "job title";
}
</pre>



<blockquote>
<p>  在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_header_set*$variable*</code> <code>*name*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> <br>                </td></p>
<p>  该指令出现在1.11.10版中。 </p>
<p>  将<code>*variable*</code>设置为由键名标识的JOSE标头参数。  名称匹配从JSON树的顶级开始。  对于数组，变量保留由逗号分隔的数组元素列表。 </p>
<blockquote>
<p>  在1.13.7版之前，只能指定一个键名，并且数组的结果未定义。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_key_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  指定<a href="https://tools.ietf.org/html/rfc7517#section-5" target="_blank" rel="noopener">JSON Web Key Set</a>格式的<code>*file*</code> ，用于验证JWT签名。  参数值可以包含变量。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_key_request*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  该指令出现在1.15.6版中。 </p>
<p>  允许从子请求中检索<a href="https://tools.ietf.org/html/rfc7517#section-5" target="_blank" rel="noopener">JSON Web Key Set</a>文件以验证JWT签名，并设置子请求将发送到的URI。  为避免验证开销，建议缓存密钥文件： </p>
<pre class="notranslate">proxy_cache_path /data/nginx/cache levels=1 keys_zone=foo:10m;

server {
    ...

    location / {
        auth_jwt             "closed site";
        auth_jwt_key_request /jwks_uri;
    }

    location = /jwks_uri {
        internal;
        proxy_cache foo;
        proxy_pass  http://idp.example.com/keys;
    }
}
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_jwt_leeway*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_jwt_leeway 0s;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在1.13.10版本中。 </p>
<p>  设置最大允许余地，以在验证<a href="https://tools.ietf.org/html/rfc7519#section-4.1.4" target="_blank" rel="noopener">exp</a>和<a href="https://tools.ietf.org/html/rfc7519#section-4.1.5" target="_blank" rel="noopener">nbf</a> JWT声明时补偿时钟偏差。 </p>
<h4 id="嵌入式变量"><a href="#嵌入式变量" class="headerlink" title="嵌入式变量"></a>嵌入式变量</h4><p>   <code>ngx_http_auth_jwt_module</code>模块支持嵌入变量： </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_auth_basic_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_auth_basic_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_auth_basic_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-auth-basic-module"><a href="#Module-ngx-http-auth-basic-module" class="headerlink" title="Module ngx_http_auth_basic_module"></a>Module ngx_http_auth_basic_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#auth_basic">auth_basic</a> <br>     <a href="#auth_basic_user_file">auth_basic_user_file</a> <br></td>

<p>   <code>ngx_http_auth_basic_module</code>模块允许通过使用“HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。 </p>
<p>  访问也可以通过<a href="ngx_http_access_module.html">地址</a> ， <a href="ngx_http_auth_request_module.html">子请求</a>的<a href="ngx_http_auth_request_module.html">结果</a>或<a href="ngx_http_auth_jwt_module.html">JWT来限制</a> 。  通过地址和密码同时限制访问由<a href="ngx_http_core_module.html#satisfy">satisf</a>指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_basic*string*</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">auth_basic off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  使用“HTTP基本身份验证”协议启用用户名和密码验证。  指定的参数用作域。  参数值可以包含变量（1.3.10,1.2.7）。  特殊值<code>off</code>允许取消从先前配置级别继承的<code>auth_basic</code>伪指令的效果。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**auth_basic_user_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  指定保存用户名和密码的文件，格式如下： </p>
<pre class="notranslate"># comment
name1:password1
name2:password2:comment
name3:password3
</pre>

<p>   <code>*file*</code>名可以包含变量。 </p>
<p>  支持以下密码类型： </p>
<ul>
<li>用<code>crypt()</code>函数加密;  可以使用Apache HTTP Server分发中的“ <code>htpasswd</code> ”实用程序或“ <code>openssl passwd</code> ”命令生成; -   使用基于MD5的密码算法（apr1）的Apache变体进行散列;  可以使用相同的工具生成; -   由<a href="https://tools.ietf.org/html/rfc2307#section-5.3" target="_blank" rel="noopener">RFC 2307中</a>描述的“ <code>{</code> <code>*scheme*</code> <code>}</code> <code>*data*</code> ”语法（1.0.3+）指定;  目前实现的方案包括<code>PLAIN</code> （不应使用示例一）， <code>SHA</code> （1.3.13）（不应使用普通SHA-1哈希）和<code>SSHA</code> （盐渍SHA-1哈希，一些软件包使用，特别是OpenLDAP和Dovecot）。 <blockquote class="note">  仅添加了对<code>SHA</code>方案的支持，以帮助从其他Web服务器迁移。  它不应该用于新密码，因为它使用的无盐SHA-1散列很容易受到<a href="http://en.wikipedia.org/wiki/Rainbow_attack" target="_blank" rel="noopener">彩虹表</a>攻击。 </blockquote></li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_api_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_api_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_api_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-api-module"><a href="#Module-ngx-http-api-module" class="headerlink" title="Module ngx_http_api_module"></a>Module ngx_http_api_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#api">api</a> <br>     <a href="#status_zone">status_zone</a> <br> <a href="#compatibility">Compatibility</a> <br> <a href="#endpoints">Endpoints</a> <br>     <a href="#root">/</a> <br>     <a href="#nginx">/nginx</a> <br>     <a href="#processes">/processes</a> <br>     <a href="#connections">/connections</a> <br>     <a href="#ssl">/ssl</a> <br>     <a href="#slabs_">/slabs/</a> <br>     <a href="#slabs_slab_zone_name">/slabs/{slabZoneName}</a> <br>     <a href="#http_">/http/</a> <br>     <a href="#http_requests">/http/requests</a> <br>     <a href="#http_server_zones_">/http/server_zones/</a> <br>     <a href="#http_server_zones_http_server_zone_name">/http/server_zones/{httpServerZoneName}</a> <br>     <a href="#http_caches_">/http/caches/</a> <br>     <a href="#http_caches_http_cache_zone_name">/http/caches/{httpCacheZoneName}</a> <br>     <a href="#http_upstreams_">/http/upstreams/</a> <br>     <a href="#http_upstreams_http_upstream_name_">/http/upstreams/{httpUpstreamName}/</a> <br>     <a href="#http_upstreams_http_upstream_name_servers_">/http/upstreams/{httpUpstreamName}/servers/</a> <br>     <a href="#http_upstreams_http_upstream_name_servers_http_upstream_server_id">/http/upstreams/{httpUpstreamName}/servers/{httpUpstreamServerId}</a> <br>     <a href="#http_keyvals_">/http/keyvals/</a> <br>     <a href="#http_keyvals_http_keyval_zone_name">/http/keyvals/{httpKeyvalZoneName}</a> <br>     <a href="#stream_">/stream/</a> <br>     <a href="#stream_server_zones_">/stream/server_zones/</a> <br>     <a href="#stream_server_zones_stream_server_zone_name">/stream/server_zones/{streamServerZoneName}</a> <br>     <a href="#stream_upstreams_">/stream/upstreams/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_">/stream/upstreams/{streamUpstreamName}/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_servers_">/stream/upstreams/{streamUpstreamName}/servers/</a> <br>     <a href="#stream_upstreams_stream_upstream_name_servers_stream_upstream_server_id">/stream/upstreams/{streamUpstreamName}/servers/{streamUpstreamServerId}</a> <br>     <a href="#stream_keyvals_">/stream/keyvals/</a> <br>     <a href="#stream_keyvals_stream_keyval_zone_name">/stream/keyvals/{streamKeyvalZoneName}</a> <br>     <a href="#stream_zone_sync_">/stream/zone_sync/</a> <br> <a href="#definitions">Response Objects</a> <br></td>

<p>   <code>ngx_http_api_module</code>模块（1.13.3）提供REST API，用于访问各种状态信息，即时配置上游服务器组以及管理<a href="ngx_http_keyval_module.html">键值对，</a>而无需重新配置nginx。 </p>
<blockquote>
<p>  该模块取代了<a href="ngx_http_status_module.html">ngx_http_status_module</a>和<a href="ngx_http_upstream_conf_module.html">ngx_http_upstream_conf_module</a>模块。 </p>
<p>  该模块作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分提供。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">http {
    upstream backend {
        zone http_backend 64k;

        server backend1.example.com weight=5;
        server backend2.example.com;
    }

    proxy_cache_path /data/nginx/cache_backend keys_zone=cache_backend:10m;

    server {
        server_name backend.example.com;

        location / {
            proxy_pass  http://backend;
            proxy_cache cache_backend;

            health_check;
        }

        status_zone server_backend;
    }

    keyval_zone zone=one:32k state=one.keyval;
    keyval $arg_text $text zone=one;

    server {
        listen 127.0.0.1;

        location /api {
            **api** write=on;
            allow 127.0.0.1;
            deny all;
        }
    }
}

stream {
    upstream backend {
        zone stream_backend 64k;

        server backend1.example.com:12345 weight=5;
        server backend2.example.com:12345;
    }

    server {
        listen      127.0.0.1:12345;
        proxy_pass  backend;
        status_zone server_backend;
        health_check;
    }
}
</pre>

<p>  所有API请求都包含URI中支持的API <a href="#api_version">版本</a> 。  使用此配置的API请求示例： </p>
<pre class="notranslate">http://127.0.0.1/api/3/
http://127.0.0.1/api/3/nginx
http://127.0.0.1/api/3/connections
http://127.0.0.1/api/3/http/requests
http://127.0.0.1/api/3/http/server_zones/server_backend
http://127.0.0.1/api/3/http/caches/cache_backend
http://127.0.0.1/api/3/http/upstreams/backend
http://127.0.0.1/api/3/http/upstreams/backend/servers/
http://127.0.0.1/api/3/http/upstreams/backend/servers/1
http://127.0.0.1/api/3/http/keyvals/one?key=arg1
http://127.0.0.1/api/3/stream/
http://127.0.0.1/api/3/stream/server_zones/server_backend
http://127.0.0.1/api/3/stream/upstreams/
http://127.0.0.1/api/3/stream/upstreams/backend
http://127.0.0.1/api/3/stream/upstreams/backend/servers/1
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**api** 
[ &lt;code class=&quot;notranslate&quot;&gt;write</code> = <code>on</code> | <code>off</code> ]; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>location</code> <br><br>                </td></p>
<p>  打开周围位置的REST API接口。  应<a href="ngx_http_core_module.html#satisfy">限制</a>访问此位置。 </p>
<p>   <code>write</code>参数确定API是只读还是读写。  默认情况下，API是只读的。 </p>
<p>  所有API请求都应在URI中包含受支持的API版本。  如果请求URI等于位置前缀，则返回支持的API版本列表。  当前的API版本为“ <code>3</code> ”。 </p>
<p>  请求行中的可选“ <code>fields</code> ”参数指定将输出所请求对象的哪些字段： </p>
<pre class="notranslate">http://127.0.0.1/api/3/nginx?fields=version,build
</pre>


<p><th class="notranslate"><br>            Syntax:<br>                </th><td class="notranslate"><br>            <code>**status_zone*zone*</code> ; <br><br>                </td></p>
<p><th class="notranslate"><br>            Default:<br>                </th><td class="notranslate"></td></p>
<pre><code>—

    &lt;/td&gt;
</code></pre><p><th class="notranslate"><br>            Context:<br>                </th><td class="notranslate"><br>            <code>server</code> <br><br>                </td></p>
<p>  该指令出现在1.13.12版中。 </p>
<p>  允许在指定<code>*zone*</code>收集虚拟<a href="ngx_http_core_module.html#server">http</a>或<a href="stream/ngx_stream_core_module.html#server">流</a>服务器状态信息。  多个服务器可能共享同一个区域。 </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li><a href="#stream_zone_sync_">/ stream / zone_sync /</a> data在<a href="#api_version">版本</a> 3中添加。 -    <a href="#api_version">版本</a> 2中添加了<a href="#def_nginx_http_upstream_conf_server">drain</a>参数。 -    <a href="#stream_keyvals_">/ stream / keyvals /</a> data在<a href="#api_version">版本</a> 2中添加。 </li>
</ul>
<h4 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h4><p>  支持的方法： </p>
<ul>
<li><code>GET</code> - 返回根端点列表   返回根端点列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><code>GET</code> - 返回nginx运行实例的状态   返回nginx版本，构建名称，地址，配置重新加载次数，主进程和工作进程的ID。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出运行实例的nginx字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_object">nginx</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回nginx进程状态   返回异常终止和重生的子进程的数量。   可能的回应： <ul class="compact"><li>   200  - 成功，退货<a href="#def_nginx_processes">流程</a><br>重置异常终止和重生的子进程的计数器。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><p><code>GET</code> - 返回客户端连接统计信息   返回客户端连接的统计信息   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出连接统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_connections">连接</a><br>重置已接受和已删除客户端连接的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><p><code>GET</code> - 返回SSL统计信息   返回SSL统计信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出SSL统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_ssl_object">SSL</a><br>重置SSL握手和会话重用的计数器。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功<br>支持的方法： </li>
<li><code>GET</code> - 所有楼板的返回状态   使用slab分配器返回每个共享内存区域的slab状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出板区域的哪些区域。  如果“ <code>fields</code> ”值为空，则仅输出区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有楼板的“ <a href="#def_nginx_slab_zone">带有slab分配器的共享内存区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回板的状态   使用slab分配器返回特定共享内存区域的slab状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出板区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_slab_zone">带有slab分配器的共享内存区域</a> -    404  - 未找到平板（ <code>SlabNotFound</code> ），返回<a href="#def_nginx_error">错误</a><br>重置每个内存插槽的“ <code>reqs</code> ”和“ <code>reqs</code> ”指标。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到平板（ <code>SlabNotFound</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回与HTTP相关的端点列表   返回第一级HTTP端点的列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP请求统计信息   返回客户端HTTP请求的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出客户端HTTP请求统计信息的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_requests">HTTP请求</a><br>重置客户端HTTP请求总数。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有HTTP服务器区域的状态   返回每个HTTP <a href="https://nginx.org/en/http/ngx_http_api_module.html#status_zone" target="_blank" rel="noopener">服务器区域的</a>状态信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出服务器区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http服务器区域的“ <a href="#def_nginx_http_server_zone">HTTP服务器区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP服务器区域的状态   返回特定HTTP服务器区域的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_server_zone">HTTP服务器区域</a> -    404  - 找不到服务器区域（ <code>ServerZoneNotFound</code> ），返回<a href="#def_nginx_error">错误</a><br>重置特定HTTP服务器区域中接受和丢弃的请求，响应，接收和发送字节的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 找不到服务器区域（ <code>ServerZoneNotFound</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有缓存的状态   返回由<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_path" target="_blank" rel="noopener">proxy_cache_path</a>和其他“ <code>*_cache_path</code> ”指令配置的每个缓存的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出缓存区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出缓存区的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http缓存的“ <a href="#def_nginx_http_cache">HTTP缓存</a> ”对象集合<br>支持的方法： </li>
<li><p><code>GET</code> - 返回缓存的状态   返回特定缓存的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出缓存区的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_cache">HTTP缓存</a> -    404  - 未找到缓存（ <code>CacheNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>重置特定缓存区域中缓存命中/未命中的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到缓存（ <code>CacheNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有HTTP上游服务器组的状态   返回每个HTTP上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出上游的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  -  Success，返回所有http上游的“ <a href="#def_nginx_http_upstream">HTTP Upstream</a> ”对象集合<br>支持的方法： </li>
<li><p><code>GET</code> -  HTTP上游服务器组的返回状态   返回特定HTTP上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream">HTTP上游</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>重置上游服务器组中每个上游服务器的统计信息和队列统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP上游服务器组中所有服务器的配置   返回特定HTTP上游服务器组中每个服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a>阵列 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>将新服务器添加到HTTP上游服务器组。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li>201  - 创建，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），缺少“ <code>server</code> ”参数（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时<code>error</code> “ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”可能没有端口（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”需要域名（ <code>UpstreamBadAddress</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），路径太长（ <code>UpstreamBadRoute</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），没有解析定义解析（ <code>UpstreamConfNoResolver</code> ），上游“ <code>*name*</code> ”没有备份（ <code>UpstreamNoBackup</code> ），上游“ <code>*name*</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code>   <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  - 找不到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回HTTP上游服务器组中服务器的配置   返回HTTP上游服务器组中特定服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>修改HTTP上游服务器组中特定服务器的设置。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时的“ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），无效的“ <code>server</code> ”参数（ <code>UpstreamBadAddress</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），无效的“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效的“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效的“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效的“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效的“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），路由太长（ <code>UpstreamBadRoute</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），服务器“ <code>*ID*</code> ”地址是不可变的（ <code>UpstreamServerImmutable</code> ），服务器“ <code>ID</code> ”权重是不可变的（ <code>UpstreamServerWeightImmutable</code> ），上游“ <code>name</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从HTTP上游服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
<li>200  - 成功，返回<a href="#def_nginx_http_upstream_conf_server">HTTP上游服务器</a>阵列 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），服务器“ <code>*id*</code> ”不可移动（ <code>UpstreamServerImmutable</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 从所有HTTP keyval区域返回键值对   返回每个HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>的键值对。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  如果“ <code>fields</code> ”值为空，则仅输出HTTP keyval区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有http密钥的“ <a href="#def_nginx_http_keyval_zone">HTTP Keyval共享内存区域</a> ”对象的集合<br>支持的方法： </li>
<li><p><code>GET</code> - 从HTTP键区域返回键值对   返回存储在特定HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>中的键值对。   请求参数： <dl class="compact"><dt>   <code>key</code> （ <code>string</code> ，可选） </dt><dd>  从HTTP keyval区域获取特定的键值对。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_http_keyval_zone">HTTP Keyval共享内存区域</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），返回<a href="#def_nginx_error">Error</a><br>向HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>添加新的键值对。  如果HTTP keyval共享内存区域为空，则可以输入多个键值对。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>201  - 创建 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能添加一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    409  - 密钥已存在（ <code>KeyvalKeyExists</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>更改键值对中所选键的值，或通过将键值设置为<code>null</code>来删除键。 </p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>204  - 成功 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能更新一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从HTTP keyval共享内存<a href="https://nginx.org/en/http/ngx_http_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域中</a>删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回与流相关的端点列表   返回第一级流端点的列表。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一个字符串数组<br>支持的方法： </li>
<li><code>GET</code> - 返回所有流服务器区域的状态   返回每个流<a href="https://nginx.org/en/http/ngx_http_api_module.html#status_zone" target="_blank" rel="noopener">服务器区域的</a>状态信息。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出服务器区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有流服务器区域的“ <a href="#def_nginx_stream_server_zone">Stream Server Zone</a> ”对象集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流服务器区域的状态   返回特定流服务器区域的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出服务器区域的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_server_zone">Stream Server Zone</a> -    404  - 未找到服务器区域（ <code>ServerZoneNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a><br>重置特定流服务器区域中接受和丢弃的连接，会话，接收和发送字节的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到服务器区域（ <code>ServerZoneNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回所有流上游服务器组的状态   返回每个流上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。  如果“ <code>fields</code> ”值为空，则仅输出上游的名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，为所有流上游返回“ <a href="#def_nginx_stream_upstream">Stream Upstream</a> ”对象的集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组的状态   返回特定流上游服务器组及其服务器的状态。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  限制将输出上游服务器组的哪些字段。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_upstream">Stream Upstream</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>重置上游服务器组中每个上游服务器的统计信息。 </li></ul></p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组中所有服务器的配置   返回特定流上游服务器组中每个服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回一组<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Servers</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>将新服务器添加到流上游服务器组。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li>201  - 创建，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），缺少“ <code>server</code> ”参数（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时<code>error</code> “ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），服务器“ <code>host</code> ”（ <code>UpstreamBadAddress</code> ）中没有端口，服务上游“ <code>host</code> ”可能没有端口（ <code>UpstreamBadAddress</code> ），服务上游“ <code>host</code> ”需要域名（ <code>UpstreamBadAddress</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> “（ <code>UpstreamBadMaxConns</code> ），无效” <code>max_fails</code> “（ <code>UpstreamBadMaxFails</code> ），无效” <code>fail_timeout</code> “（ <code>UpstreamBadFailTimeout</code> ），无效” <code>slow_start</code> “（ <code>UpstreamBadSlowStart</code> ），” <code>service</code> “为空（ <code>UpstreamBadService</code> ），无法解析解析器（ <code>UpstreamConfNoResolver</code> ），上游” <code>*name*</code> “没有备份（ <code>UpstreamNoBackup</code> ），上游” <code>*name*</code> “内存耗尽（ <code>UpstreamOutOfMemory</code>   <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>UpstreamNotFound</code> （ <code>UpstreamNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 返回流上游服务器组中服务器的配置   返回流上游服务器组中特定服务器的配置。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），返回<a href="#def_nginx_error">Error</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>修改流上游服务器组中特定服务器的设置。  服务器参数以JSON格式指定。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>200  - 成功，返回<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Server</a> -    400  - 上游是静态的（ <code>UpstreamStatic</code> ），无效的“ <code>*parameter*</code> ”值（ <code>UpstreamConfFormatError</code> ），未知参数“ <code>*name*</code> ”（ <code>UpstreamConfFormatError</code> ），嵌套对象或列表（ <code>UpstreamConfFormatError</code> ），解析时的“ <code>error</code> ”（ <code>UpstreamBadAddress</code> ），无效的“ <code>server</code> ”参数（ <code>UpstreamBadAddress</code> ），服务器“ <code>host</code> ”（ <code>UpstreamBadAddress</code> ）中没有端口，服务器ID无效（ <code>UpstreamBadServerId</code> ），无效“ <code>weight</code> ”（ <code>UpstreamBadWeight</code> ），无效“ <code>max_conns</code> ”（ <code>UpstreamBadMaxConns</code> ），无效“ <code>max_fails</code> ”（ <code>UpstreamBadMaxFails</code> ），无效“ <code>fail_timeout</code> ”（ <code>UpstreamBadFailTimeout</code> ），无效“ <code>slow_start</code> ”（ <code>UpstreamBadSlowStart</code> ），“ <code>service</code> ”为空（ <code>UpstreamBadService</code> ），服务器“ <code>*ID*</code> ”地址为不可变（ <code>UpstreamServerImmutable</code> ），服务器“ <code>*ID*</code> ”权重为不可变（ <code>UpstreamServerWeightImmutable</code> ），上游“ <code>name</code> ”内存耗尽（ <code>UpstreamOutOfMemory</code> ），返回<a href="#def_nginx_error">错误</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从流服务器组中删除服务器。 </p>
<p>可能的回应： </p>
</li>
<li>200  - 成功，返回一组<a href="#def_nginx_stream_upstream_conf_server">Stream Upstream Servers</a> -    400  -  Upstream是静态的（ <code>UpstreamStatic</code> ），无效的服务器ID（ <code>UpstreamBadServerId</code> ），服务器“ <code>*id*</code> ”不可移动（ <code>UpstreamServerImmutable</code> ），返回<a href="#def_nginx_error">Error</a> -    404  -  Upstream not found（ <code>UpstreamNotFound</code> ），ID为“ <code>*id*</code> ”的服务器不存在（ <code>UpstreamServerNotFound</code> ）， <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a>未配置（ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 从所有流键区域返回键值对   返回每个流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>的键值对。   请求参数： <dl class="compact"><dt>   <code>fields</code> （ <code>string</code> ，可选） </dt><dd>  如果“ <code>fields</code> ”值为空，则仅输出流密钥区域名称。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回所有流关键字的“ <a href="#def_nginx_stream_keyval_zone">Stream Keyval Shared Memory Zone</a> ”对象的集合 -    404  - 未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><p><code>GET</code> - 从流键区域返回键 - 值对   返回存储在特定流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a>中的键值对。   请求参数： <dl class="compact"><dt>   <code>key</code> （ <code>string</code> ，可选） </dt><dd>  从流密钥区域获取特定键值对。 </dd></dl>  可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_keyval_zone">Stream Keyval共享内存区域</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a><br>将新键值对添加到流键值共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域</a> 。  如果流键值共享内存区域为空，则可以输入多个键值对。 </li></ul></p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>201  - 创建 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能添加一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    409  - 密钥已存在（ <code>KeyvalKeyExists</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>更改键值对中所选键的值，或通过将键值设置为<code>null</code>来删除键。 </p>
<p>请求参数： </p>
</li>
</ul>
<p>  可能的回应： </p>
<ul>
<li><p>204  - 成功 -    400  - 需要密钥（ <code>KeyvalFormatError</code> ），只能更新一个密钥（ <code>KeyvalFormatError</code> ），嵌套对象或列表（ <code>KeyvalFormatError</code> ），返回<a href="#def_nginx_error">Error</a> -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未找到keyval键（ <code>KeyvalKeyNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a> -    415  -  JSON错误（ <code>JsonError</code> ），返回<a href="#def_nginx_error">Error</a><br>从流keyval共享内存<a href="https://nginx.org/en/stream/ngx_stream_keyval_module.html#keyval_zone" target="_blank" rel="noopener">区域中</a>删除所有键值对。 </p>
<p>可能的回应： </p>
</li>
<li>204  - 成功 -    404  - 未找到<code>KeyvalNotFound</code> （ <code>KeyvalNotFound</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">Error</a> -    405  - 禁用方法（ <code>MethodDisabled</code> ），返回<a href="#def_nginx_error">Error</a><br>支持的方法： </li>
<li><code>GET</code> - 返回节点的同步状态   返回群集节点的同步状态。   可能的回应： <ul class="compact"><li>   200  - 成功，返回<a href="#def_nginx_stream_zone_sync">Stream Zone Sync节点</a> -    404  - 未配置区域同步（ <code>ZoneSyncNotConfigured</code> ），未配置<a href="https://nginx.org/en/stream/ngx_stream_core_module.html#stream" target="_blank" rel="noopener">流</a> （ <code>StreamNotConfigured</code> ），返回<a href="#def_nginx_error">错误</a> </li>
</ul>
<h4 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h4><p><li id="def_nginx_object">   nginx的：   有关nginx的一般信息： <dl class="compact"><dt>   <code>version</code> （ <code>string</code> ） </dt><dd>   nginx的版本。 </dd><dt>   <code>build</code> （ <code>string</code> ） </dt><dd>   nginx构建的名称。 </dd><dt>   <code>address</code> （ <code>string</code> ） </dt><dd>  接受状态请求的服务器的地址。 </dd><dt>   <code>generation</code> （ <code>integer</code> ） </dt><dd>  配置<a href="https://nginx.org/en/control.html#reconfiguration" target="_blank" rel="noopener">重新加载</a>的总数。 </dd><dt>   <code>load_timestamp</code> （ <code>string</code> ） </dt><dd>  上次重新加载配置的时间，采用ISO 8601格式，分辨率为毫秒。 </dd><dt>   <code>timestamp</code> （ <code>string</code> ） </dt><dd>   ISO 8601格式的当前时间，分辨率为毫秒。 </dd><dt>   <code>pid</code> （ <code>integer</code> ） </dt><dd>  处理状态请求的工作进程的ID。 </dd><dt>   <code>ppid</code> （ <code>integer</code> ） </dt><dd>  启动<a href="https://nginx.org/en/http/ngx_http_status_module.html#pid" target="_blank" rel="noopener">工作进程</a>的主进程的ID。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “nginx” : {<br>    “version” : “1.15.2”,<br>    “build” : “nginx-plus-r16”,<br>    “address” : “206.251.255.64”,<br>    “generation” : 6,<br>    “load_timestamp” : “2018-10-08T09:05:48.776Z”,<br>    “timestamp” : “2018-10-08T15:23:17.056Z”,<br>    “pid” : 32212,<br>    “ppid” : 32210<br>  }<br>}</pre></blockquote></li><li id="def_nginx_processes">  流程： <dl class="compact"><dt>   <code>respawned</code> （ <code>integer</code> ） </dt><dd>  异常终止和重生的子进程的总数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “respawned” : 0<br>}</pre></blockquote></li><li id="def_nginx_connections">  连接：   已接受，已删除，活动和空闲连接的数量。 <dl class="compact"><dt>   <code>accepted</code> （ <code>integer</code> ） </dt><dd>  已接受的客户端连接总数。 </dd><dt>   <code>dropped</code> （ <code>integer</code> ） </dt><dd>  已删除的客户端连接总数。 </dd><dt>   <code>active</code> （ <code>integer</code> ） </dt><dd>  当前活动客户端连接数。 </dd><dt>   <code>idle</code> （ <code>integer</code> ） </dt><dd>  当前空闲客户端连接数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “accepted” : 4968119,<br>  “dropped” : 0,<br>  “active” : 5,<br>  “idle” : 117<br>}</pre></blockquote></li><li id="def_nginx_ssl_object">   SSL： <dl class="compact"><dt>   <code>handshakes</code> （ <code>integer</code> ） </dt><dd>  成功的SSL握手总数。 </dd><dt>   <code>handshakes_failed</code> （ <code>integer</code> ） </dt><dd>  失败的SSL握手总数。 </dd><dt>   <code>session_reuses</code> （ <code>integer</code> ） </dt><dd>   SSL握手期间会话​​重用的总次数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “handshakes” : 79572,<br>  “handshakes_failed” : 21025,<br>  “session_reuses” : 15762<br>}</pre></blockquote></li><li id="def_nginx_slab_zone">  带有slab分配器的共享内存区域： <dl class="compact"><dt> <code>pages</code> </dt> <dd>  空闲和已用内存页面的数量。 <dl class="compact"><dt>   <code>used</code> （ <code>integer</code> ） </dt><dd>  当前使用的内存页数。 </dd><dt>   <code>free</code> （ <code>integer</code> ） </dt><dd>  当前可用内存页数。 </dd></dl></dd><dt> <code>slots</code> </dt> <dd>  内存插槽的状态数据（8,16,32,64,128等）    “ <a href="#def_nginx_slab_zone_slot">Memory Slot</a> ”对象的集合 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “pages” : {<br>    “used” : 1143,<br>    “free” : 2928<br>  },<br>  “slots” : {<br>    “8” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “16” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “32” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “64” : {<br>      “used” : 1,<br>      “free” : 63,<br>      “reqs” : 1,<br>      “fails” : 0<br>    },<br>    “128” : {<br>      “used” : 0,<br>      “free” : 0,<br>      “reqs” : 0,<br>      “fails” : 0<br>    },<br>    “256” : {<br>      “used” : 18078,<br>      “free” : 178,<br>      “reqs” : 1635736,<br>      “fails” : 0<br>    }<br>  }<br>}</pre></blockquote></li>-   内存插槽： <dl class="compact"><dt>   <code>used</code> （ <code>integer</code> ） </dt><dd>  当前使用的内存插槽数。 </dd><dt>   <code>free</code> （ <code>integer</code> ） </dt><dd>  当前可用内存插槽的数量。 </dd><dt>   <code>reqs</code> （ <code>integer</code> ） </dt><dd>  分配指定大小内存的总尝试次数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  分配指定大小内存的尝试失败次数。 </dd></dl><li id="def_nginx_http_requests">   HTTP请求： <dl class="compact"><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  客户端请求的总数。 </dd><dt>   <code>current</code> （ <code>integer</code> ） </dt><dd>  当前的客户端请求数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “total” : 10624511,<br>  “current” : 4<br>}</pre></blockquote></li><li id="def_nginx_http_server_zone">   HTTP服务器区域： <dl class="compact"><dt>   <code>processing</code> （ <code>integer</code> ） </dt><dd>  当前正在处理的客户端请求数。 </dd><dt>   <code>requests</code> （ <code>integer</code> ） </dt><dd>  从客户端收到的客户端请求总数。 </dd><dt> <code>responses</code> </dt> <dd>  发送给客户端的响应总数和状态代码为“ <code>1xx</code> ”，“ <code>2xx</code> ”，“ <code>3xx</code> ”，“ <code>4xx</code> ”和“ <code>5xx</code> ”的响应数。 <dl class="compact"><dt>   <code>1xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>1xx</code> ”状态代码的响应数。 </dd><dt>   <code>2xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>2xx</code> ”状态代码的响应数。 </dd><dt>   <code>3xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>3xx</code> ”状态代码的响应数。 </dd><dt>   <code>4xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>4xx</code> ”状态代码的响应数。 </dd><dt>   <code>5xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>5xx</code> ”状态代码的响应数。 </dd><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  发送给客户端的响应总数。 </dd></dl></dd><dt>   <code>discarded</code> （ <code>integer</code> ） </dt><dd>  未发送响应而完成的请求总数。 </dd><dt>   <code>received</code> （ <code>integer</code> ） </dt><dd>  从客户端收到的总字节数。 </dd><dt>   <code>sent</code> （ <code>integer</code> ） </dt><dd>  发送给客户端的总字节数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “processing” : 1,<br>  “requests” : 706690,<br>  “responses” : {<br>    “1xx” : 0,<br>    “2xx” : 699482,<br>    “3xx” : 4522,<br>    “4xx” : 907,<br>    “5xx” : 266,<br>    “total” : 705177<br>  },<br>  “discarded” : 1513,<br>  “received” : 172711587,<br>  “sent” : 19415530115<br>}</pre></blockquote></li><li id="def_nginx_http_cache">   HTTP缓存： <dl class="compact"><dt>   <code>size</code> （ <code>integer</code> ） </dt><dd>  缓存的当前大小。 </dd><dt>   <code>max_size</code> （ <code>integer</code> ） </dt><dd>  配置中指定的高速缓存的最大大小限制。 </dd><dt>   <code>cold</code> （ <code>boolean</code> ） </dt><dd>  一个布尔值，指示“缓存加载器”进程是否仍在将数据从磁盘加载到缓存中。 </dd><dt> <code>hit</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_valid" target="_blank" rel="noopener">有效</a>响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>stale</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的过期响应总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_use_stale" target="_blank" rel="noopener">proxy_cache_use_stale</a>和其他“ <code>*_cache_use_stale</code> ”指令）。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>updating</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  在响应更新时从缓存读取的过期响应总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_use_stale_updating" target="_blank" rel="noopener">proxy_cache_use_stale</a>和其他“ <code>*_cache_use_stale</code> ”指令）。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>revalidated</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的过期和重新验证响应的总数（请参阅<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_revalidate" target="_blank" rel="noopener">proxy_cache_revalidate</a>和其他“ <code>*_cache_revalidate</code> <a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_revalidate" target="_blank" rel="noopener">_cache_revalidate</a> ”指令。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从缓存中读取的总字节数。 </dd></dl></dd><dt> <code>miss</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  在缓存中找不到的响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd><dt> <code>expired</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  未从缓存中获取的过期响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd><dt> <code>bypass</code> </dt> <dd><dl class="compact"><dt>   <code>responses</code> （ <code>integer</code> ） </dt><dd>  由于<a href="https://nginx.org/en/http/ngx_http_proxy_module.html#proxy_cache_bypass" target="_blank" rel="noopener">proxy_cache_bypass</a>和其他“ <code>*_cache_bypass</code> ”指令，缓存中未查找的响应总数。 </dd><dt>   <code>bytes</code> （ <code>integer</code> ） </dt><dd>  从代理服务器读取的总字节数。 </dd><dt>   <code>responses_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的响应总数。 </dd><dt>   <code>bytes_written</code> （ <code>integer</code> ） </dt><dd>  写入缓存的总字节数。 </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “size” : 530915328,<br>  “max_size” : 536870912,<br>  “cold” : false,<br>  “hit” : {<br>    “responses” : 254032,<br>    “bytes” : 6685627875<br>  },<br>  “stale” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “updating” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “revalidated” : {<br>    “responses” : 0,<br>    “bytes” : 0<br>  },<br>  “miss” : {<br>    “responses” : 1619201,<br>    “bytes” : 53841943822<br>  },<br>  “expired” : {<br>    “responses” : 45859,<br>    “bytes” : 1656847080,<br>    “responses_written” : 44992,<br>    “bytes_written” : 1641825173<br>  },<br>  “bypass” : {<br>    “responses” : 200187,<br>    “bytes” : 5510647548,<br>    “responses_written” : 200173,<br>    “bytes_written” : 44992<br>  }<br>}</pre></blockquote></li><li id="def_nginx_http_upstream">   HTTP上游： <dl class="compact"><dt> <code>peers</code> </dt> <dd>  一系列的： <dl class="compact"><dt>   <code>id</code> （ <code>integer</code> ） </dt><dd>  服务器的ID。 </dd><dt>   <code>server</code> （ <code>string</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">地址</a> 。 </dd><dt>   <code>service</code> （ <code>string</code> ） </dt><dd>   <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#service" target="_blank" rel="noopener">服务</a>参数值。 </dd><dt>   <code>name</code> （ <code>string</code> ） </dt><dd>   <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令中指定的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">服务器</a>名称。 </dd><dt>   <code>backup</code> （ <code>boolean</code> ） </dt><dd>  一个布尔值，指示服务器是否为<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#backup" target="_blank" rel="noopener">备份</a>服务器。 </dd><dt>   <code>weight</code> （ <code>integer</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#weight" target="_blank" rel="noopener">重量</a> 。 </dd><dt>   <code>state</code> （ <code>string</code> ） </dt><dd>  当前状态，可以是“ <code>up</code> ”，“ <code>draining</code> ”，“ <code>down</code> ”，“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”之一。 </dd><dt>   <code>active</code> （ <code>integer</code> ） </dt><dd>  当前活动连接数。 </dd><dt>   <code>max_conns</code> （ <code>integer</code> ） </dt><dd>  服务器的<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a>限制。 </dd><dt>   <code>requests</code> （ <code>integer</code> ） </dt><dd>  转发到此服务器的客户端请求总数。 </dd><dt> <code>responses</code> </dt> <dd><dl class="compact"><dt>   <code>1xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>1xx</code> ”状态代码的响应数。 </dd><dt>   <code>2xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>2xx</code> ”状态代码的响应数。 </dd><dt>   <code>3xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>3xx</code> ”状态代码的响应数。 </dd><dt>   <code>4xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>4xx</code> ”状态代码的响应数。 </dd><dt>   <code>5xx</code> （ <code>integer</code> ） </dt><dd>  带有“ <code>5xx</code> ”状态代码的响应数。 </dd><dt>   <code>total</code> （ <code>integer</code> ） </dt><dd>  从此服务器获取的响应总数。 </dd></dl></dd><dt>   <code>sent</code> （ <code>integer</code> ） </dt><dd>  发送到此服务器的总字节数。 </dd><dt>   <code>received</code> （ <code>integer</code> ） </dt><dd>  从此服务器接收的总字节数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  与服务器通信失败的总次数。 </dd><dt>   <code>unavail</code> （ <code>integer</code> ） </dt><dd>  由于尝试达到<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a>阈值的次数不成功，服务器因客户端请求（状态为“ <code>unavail</code> ”）而变为不可用的次数。 </dd><dt> <code>health_checks</code> </dt> <dd><dl class="compact"><dt>   <code>checks</code> （ <code>integer</code> ） </dt><dd>  进行的<a href="https://nginx.org/en/http/ngx_http_upstream_hc_module.html#health_check" target="_blank" rel="noopener">健康检查</a>请求总数。 </dd><dt>   <code>fails</code> （ <code>integer</code> ） </dt><dd>  健康检查失败的次数。 </dd><dt>   <code>unhealthy</code> （ <code>integer</code> ） </dt><dd>  服务器变得不健康的次数（状态“ <code>unhealthy</code> ”）。 </dd><dt>   <code>last_passed</code> （ <code>boolean</code> ） </dt><dd>  布尔值，指示上次运行状况检查请求是否成功并通过了<a href="https://nginx.org/en/http/ngx_http_upstream_hc_module.html#match" target="_blank" rel="noopener">测试</a> 。 </dd></dl></dd><dt>   <code>downtime</code> （ <code>integer</code> ） </dt><dd>  服务器处于“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”状态的总时间。 </dd><dt>   <code>downstart</code> （ <code>string</code> ） </dt><dd>  服务器变为“ <code>unavail</code> ”，“ <code>checking</code> ”或“ <code>unhealthy</code> ”的时间，采用ISO 8601格式，分辨率为毫秒。 </dd><dt> <code>selected</code> ( <code>string</code> ) </dt><dd> The time when the server was last selected to process a request, in the ISO 8601 format with millisecond resolution. </dd><dt> <code>header_time</code> ( <code>integer</code> ) </dt><dd> The average time to get the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#var_upstream_header_time" target="_blank" rel="noopener">response header</a> from the server. </dd><dt> <code>response_time</code> ( <code>integer</code> ) </dt><dd> The average time to get the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#var_upstream_response_time" target="_blank" rel="noopener">full response</a> from the server. </dd></dl></dd><dt> <code>keepalive</code> ( <code>integer</code> ) </dt><dd>  当前空闲<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a>连接数。 </dd><dt> <code>zombies</code> ( <code>integer</code> ) </dt><dd>  从组中删除但仍处理活动客户端请求的当前服务器数。 </dd><dt> <code>zone</code> ( <code>string</code> ) </dt><dd>  保持组配置和运行时状态的共享内存<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#zone" target="_blank" rel="noopener">区域</a>的名称。 </dd><dt> <code>queue</code> </dt> <dd>  对于请求<a href="https://nginx.org/en/http/ngx_http_upstream_module.html#queue" target="_blank" rel="noopener">队列</a> ，提供以下数据： <dl class="compact"><dt> <code>size</code> ( <code>integer</code> ) </dt><dd>  队列中当前的请求数。 </dd><dt> <code>max_size</code> ( <code>integer</code> ) </dt><dd>  可以同时在队列中的最大请求数。 </dd><dt> <code>overflows</code> ( <code>integer</code> ) </dt><dd>  由于队列溢出而拒绝的请求总数。 </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “upstream_backend” : {<br>    “peers” : [<br>      {<br>        “id” : 0,<br>        “server” : “10.0.0.1:8088”,<br>        “name” : “10.0.0.1:8088”,<br>        “backup” : false,<br>        “weight” : 5,<br>        “state” : “up”,<br>        “active” : 0,<br>        “max_conns” : 20,<br>        “requests” : 667231,<br>        “header_time” : 20,<br>        “response_time” : 36,<br>        “responses” : {<br>          “1xx” : 0,<br>          “2xx” : 666310,<br>          “3xx” : 0,<br>          “4xx” : 915,<br>          “5xx” : 6,<br>          “total” : 667231<br>        },<br>        “sent” : 251946292,<br>        “received” : 19222475454,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26214,<br>          “fails” : 0,<br>          “unhealthy” : 0,<br>          “last_passed” : true<br>        },<br>        “downtime” : 0,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      },<br>      {<br>        “id” : 1,<br>        “server” : “10.0.0.1:8089”,<br>        “name” : “10.0.0.1:8089”,<br>        “backup” : true,<br>        “weight” : 1,<br>        “state” : “unhealthy”,<br>        “active” : 0,<br>        “max_conns” : 20,<br>        “requests” : 0,<br>        “responses” : {<br>          “1xx” : 0,<br>          “2xx” : 0,<br>          “3xx” : 0,<br>          “4xx” : 0,<br>          “5xx” : 0,<br>          “total” : 0<br>        },<br>        “sent” : 0,<br>        “received” : 0,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26284,<br>          “fails” : 26284,<br>          “unhealthy” : 1,<br>          “last_passed” : false<br>        },<br>        “downtime” : 262925617,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      }<br>    ],<br>    “keepalive” : 0,<br>    “zombies” : 0,<br>    “zone” : “upstream_backend”<br>  }<br>}</pre></blockquote></li><li id="def_nginx_http_upstream_conf_server"> HTTP Upstream Server:  Dynamically configurable parameters of an HTTP upstream <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener">server</a> : <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd> The ID of the HTTP upstream server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#address" target="_blank" rel="noopener">address</a> parameter of the HTTP upstream server.  添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the <a href="https://nginx.org/en/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a> directive in the “ <code>http</code> ” block. See also the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#resolve" target="_blank" rel="noopener">resolve</a> parameter of the HTTP upstream server. </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#service" target="_blank" rel="noopener">service</a> parameter of the HTTP upstream server. This parameter cannot be changed. </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#weight" target="_blank" rel="noopener">weight</a> parameter of the HTTP upstream server. </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a> parameter of the HTTP upstream server. </dd><dt> <code>max_fails</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a> parameter of the HTTP upstream server. </dd><dt> <code>fail_timeout</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#fail_timeout" target="_blank" rel="noopener">fail_timeout</a> parameter of the HTTP upstream server. </dd><dt> <code>slow_start</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#slow_start" target="_blank" rel="noopener">slow_start</a> parameter of the HTTP upstream server. </dd><dt> <code>route</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#route" target="_blank" rel="noopener">route</a> parameter of the HTTP upstream server. </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd> When <code>true</code> , adds a <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#backup" target="_blank" rel="noopener">backup</a> server. This parameter cannot be changed. </dd><dt> <code>down</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#down" target="_blank" rel="noopener">down</a> parameter of the HTTP upstream server. </dd><dt> <code>drain</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/http/ngx_http_upstream_module.html#drain" target="_blank" rel="noopener">drain</a> parameter of the HTTP upstream server. </dd><dt> <code>parent</code> ( <code>string</code> ) </dt><dd> Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>host</code> ( <code>string</code> ) </dt><dd> Hostname of the resolved server. The hostname is assigned automatically and cannot be changed. </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “id” : 1,<br>  “server” : “10.0.0.1:8089”,<br>  “weight” : 4,<br>  “max_conns” : 0,<br>  “max_fails” : 0,<br>  “fail_timeout” : “10s”,<br>  “slow_start” : “10s”,<br>  “route” : “”,<br>  “backup” : true,<br>  “down” : true<br>}</pre></blockquote></li><li id="def_nginx_http_keyval_zone"> HTTP Keyval Shared Memory Zone:  Contents of an HTTP keyval shared memory zone.   例： <blockquote class="example"><pre class="notranslate">{<br>  “key1” : “value1”,<br>  “key2” : “value2”,<br>  “key3” : “value3”<br>}</pre></blockquote></li><li id="def_nginx_stream_server_zone"> Stream Server Zone: <dl class="compact"><dt> <code>processing</code> ( <code>integer</code> ) </dt><dd>  当前正在处理的客户端连接数。 </dd><dt> <code>connections</code> ( <code>integer</code> ) </dt><dd>  从客户端接受的连接总数。 </dd><dt> <code>sessions</code> </dt> <dd> The total number of completed sessions, and the number of sessions completed with status codes “ <code>2xx</code> ”, “ <code>4xx</code> ”, or “ <code>5xx</code> ”. <dl class="compact"><dt> <code>2xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>2xx</code> ”. </dd><dt> <code>4xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>4xx</code> ”. </dd><dt> <code>5xx</code> ( <code>integer</code> ) </dt><dd> The total number of sessions completed with <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#var_status" target="_blank" rel="noopener">status codes</a> “ <code>5xx</code> ”. </dd><dt> <code>total</code> ( <code>integer</code> ) </dt><dd>  已完成的客户会话总数。 </dd></dl></dd><dt> <code>discarded</code> ( <code>integer</code> ) </dt><dd>  在不创建会话的情况下完成的连接总数。 </dd><dt> <code>received</code> ( <code>integer</code> ) </dt><dd>  从客户端收到的总字节数。 </dd><dt> <code>sent</code> ( <code>integer</code> ) </dt><dd>  发送给客户端的总字节数。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “dns” : {<br>    “processing” : 1,<br>    “connections” : 155569,<br>    “sessions” : {<br>      “2xx” : 155564,<br>      “4xx” : 0,<br>      “5xx” : 0,<br>      “total” : 155569<br>    },<br>    “discarded” : 0,<br>    “received” : 4200363,<br>    “sent” : 20489184<br>  }<br>}</pre></blockquote></li><li id="def_nginx_stream_upstream"> Stream Upstream: <dl class="compact"><dt> <code>peers</code> </dt> <dd> An array of: <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd>  服务器的ID。 </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">地址</a> 。 </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd>   <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#service" target="_blank" rel="noopener">服务</a>参数值。 </dd><dt> <code>name</code> ( <code>string</code> ) </dt><dd>   <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a>指令中指定的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">服务器</a>名称。 </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd>  一个布尔值，指示服务器是否为<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#backup" target="_blank" rel="noopener">备份</a>服务器。 </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#weight" target="_blank" rel="noopener">重量</a> 。 </dd><dt> <code>state</code> ( <code>string</code> ) </dt><dd>  当前状态，可以是“ <code>up</code> ”，“ <code>down</code> ”，“ <code>unavail</code> ”，“ <code>checking</code> ”或“ <code>unhealthy</code> ”之一。 </dd><dt> <code>active</code> ( <code>integer</code> ) </dt><dd>  当前的连接数。 </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd>  服务器的<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a>限制。 </dd><dt> <code>connections</code> ( <code>integer</code> ) </dt><dd>  转发到此服务器的客户端连接总数。 </dd><dt> <code>connect_time</code> ( <code>integer</code> ) </dt><dd>  连接上游服务器的平均时间。 </dd><dt> <code>first_byte_time</code> ( <code>integer</code> ) </dt><dd>  接收第一个数据字节的平均时间。 </dd><dt> <code>response_time</code> ( <code>integer</code> ) </dt><dd>  接收最后一个数据字节的平均时间。 </dd><dt> <code>sent</code> ( <code>integer</code> ) </dt><dd>  发送到此服务器的总字节数。 </dd><dt> <code>received</code> ( <code>integer</code> ) </dt><dd>  从此服务器接收的总字节数。 </dd><dt> <code>fails</code> ( <code>integer</code> ) </dt><dd>  与服务器通信失败的总次数。 </dd><dt> <code>unavail</code> ( <code>integer</code> ) </dt><dd>  由于尝试达到<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a>阈值的次数不成功，服务器无法进行客户端连接（状态为“ <code>unavail</code> ”）的次数。 </dd><dt> <code>health_checks</code> </dt> <dd><dl class="compact"><dt> <code>checks</code> ( <code>integer</code> ) </dt><dd>  进行的<a href="https://nginx.org/en/stream/ngx_stream_upstream_hc_module.html#health_check" target="_blank" rel="noopener">健康检查</a>请求总数。 </dd><dt> <code>fails</code> ( <code>integer</code> ) </dt><dd>  健康检查失败的次数。 </dd><dt> <code>unhealthy</code> ( <code>integer</code> ) </dt><dd>  服务器变得不健康的次数（状态“ <code>unhealthy</code> ”）。 </dd><dt> <code>last_passed</code> ( <code>boolean</code> ) </dt><dd> Boolean indicating whether the last health check request was successful and passed <a href="https://nginx.org/en/stream/ngx_stream_upstream_hc_module.html#match" target="_blank" rel="noopener">tests</a> . </dd></dl></dd><dt> <code>downtime</code> ( <code>integer</code> ) </dt><dd>  服务器处于“ <code>unavail</code> ”，“ <code>checking</code> ”和“ <code>unhealthy</code> ”状态的总时间。 </dd><dt> <code>downstart</code> ( <code>string</code> ) </dt><dd> The time when the server became “ <code>unavail</code> ”, “ <code>checking</code> ”, or “ <code>unhealthy</code> ”, in the ISO 8601 format with millisecond resolution. </dd><dt> <code>selected</code> ( <code>string</code> ) </dt><dd> The time when the server was last selected to process a connection, in the ISO 8601 format with millisecond resolution. </dd></dl></dd><dt> <code>zombies</code> ( <code>integer</code> ) </dt><dd>  当前从组中删除但仍处理活动客户端连接的服务器数。 </dd><dt> <code>zone</code> ( <code>string</code> ) </dt><dd>  保持组配置和运行时状态的共享内存<a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#zone" target="_blank" rel="noopener">区域</a>的名称。 </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “dns” : {<br>    “peers” : [<br>      {<br>        “id” : 0,<br>        “server” : “10.0.0.1:12347”,<br>        “name” : “10.0.0.1:12347”,<br>        “backup” : false,<br>        “weight” : 5,<br>        “state” : “up”,<br>        “active” : 0,<br>        “max_conns” : 50,<br>        “connections” : 667231,<br>        “sent” : 251946292,<br>        “received” : 19222475454,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26214,<br>          “fails” : 0,<br>          “unhealthy” : 0,<br>          “last_passed” : true<br>        },<br>        “downtime” : 0,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      },<br>      {<br>        “id” : 1,<br>        “server” : “10.0.0.1:12348”,<br>        “name” : “10.0.0.1:12348”,<br>        “backup” : true,<br>        “weight” : 1,<br>        “state” : “unhealthy”,<br>        “active” : 0,<br>        “max_conns” : 50,<br>        “connections” : 0,<br>        “sent” : 0,<br>        “received” : 0,<br>        “fails” : 0,<br>        “unavail” : 0,<br>        “health_checks” : {<br>          “checks” : 26284,<br>          “fails” : 26284,<br>          “unhealthy” : 1,<br>          “last_passed” : false<br>        },<br>        “downtime” : 262925617,<br>        “downstart” : “2017-07-07T11:09:21.602Z”,<br>        “selected” : “2017-07-17T15:01:25.000Z”<br>      }<br>    ],<br>    “zombies” : 0,<br>    “zone” : “dns”<br>  }<br>}</pre></blockquote></li><li id="def_nginx_stream_upstream_conf_server"> Stream Upstream Server:  Dynamically configurable parameters of a stream upstream <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">server</a> : <dl class="compact"><dt> <code>id</code> ( <code>integer</code> ) </dt><dd> The ID of the stream upstream server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>server</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#server" target="_blank" rel="noopener">address</a> parameter of the stream upstream server.  添加服务器时，可以将其指定为域名。 In this case, changes of the IP addresses that correspond to a domain name will be monitored and automatically applied to the upstream configuration without the need of restarting nginx. This requires the <a href="https://nginx.org/en/stream/ngx_stream_core_module.html#resolver" target="_blank" rel="noopener">resolver</a> directive in the “ <code>stream</code> ” block. See also the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#resolve" target="_blank" rel="noopener">resolve</a> parameter of the stream upstream server. </dd><dt> <code>service</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#service" target="_blank" rel="noopener">service</a> parameter of the stream upstream server. This parameter cannot be changed. </dd><dt> <code>weight</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#weight" target="_blank" rel="noopener">weight</a> parameter of the stream upstream server. </dd><dt> <code>max_conns</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_conns" target="_blank" rel="noopener">max_conns</a> parameter of the stream upstream server. </dd><dt> <code>max_fails</code> ( <code>integer</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#max_fails" target="_blank" rel="noopener">max_fails</a> parameter of the stream upstream server. </dd><dt> <code>fail_timeout</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#fail_timeout" target="_blank" rel="noopener">fail_timeout</a> parameter of the stream upstream server. </dd><dt> <code>slow_start</code> ( <code>string</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#slow_start" target="_blank" rel="noopener">slow_start</a> parameter of the stream upstream server. </dd><dt> <code>backup</code> ( <code>boolean</code> ) </dt><dd> When <code>true</code> , adds a <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#backup" target="_blank" rel="noopener">backup</a> server. This parameter cannot be changed. </dd><dt> <code>down</code> ( <code>boolean</code> ) </dt><dd> Same as the <a href="https://nginx.org/en/stream/ngx_stream_upstream_module.html#down" target="_blank" rel="noopener">down</a> parameter of the stream upstream server. </dd><dt> <code>parent</code> ( <code>string</code> ) </dt><dd> Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed. </dd><dt> <code>host</code> ( <code>string</code> ) </dt><dd> Hostname of the resolved server. The hostname is assigned automatically and cannot be changed. </dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “id” : 0,<br>  “server” : “10.0.0.1:12348”,<br>  “weight” : 1,<br>  “max_conns” : 0,<br>  “max_fails” : 1,<br>  “fail_timeout” : “10s”,<br>  “slow_start” : 0,<br>  “backup” : false,<br>  “down” : false<br>}</pre></blockquote></li><li id="def_nginx_stream_keyval_zone"> Stream Keyval Shared Memory Zone:  Contents of a stream keyval shared memory zone.   例： <blockquote class="example"><pre class="notranslate">{<br>  “key1” : “value1”,<br>  “key2” : “value2”,<br>  “key3” : “value3”<br>}</pre></blockquote></li><li id="def_nginx_stream_zone_sync"> Stream Zone Sync Node: <dl class="compact"><dt> <code>zones</code> </dt> <dd> Synchronization information per each shared memory zone.  A collection of “ <a href="#def_nginx_stream_zone_sync_zone">Sync Zone</a> “ objects </dd><dt> <code>status</code> </dt> <dd> Synchronization information per node in a cluster. <dl class="compact"><dt> <code>bytes_in</code> ( <code>integer</code> ) </dt><dd> The number of bytes received by this node. </dd><dt> <code>msgs_in</code> ( <code>integer</code> ) </dt><dd> The number of messages received by this node. </dd><dt> <code>msgs_out</code> ( <code>integer</code> ) </dt><dd> The number of messages sent by this node. </dd><dt> <code>bytes_out</code> ( <code>integer</code> ) </dt><dd> The number of bytes sent by this node. </dd><dt> <code>nodes_online</code> ( <code>integer</code> ) </dt><dd> The number of peers this node is connected to. </dd></dl></dd></dl>  例： <blockquote class="example"><pre class="notranslate">{<br>  “zones” : {<br>    “zone1” : {<br>      “records_pending” : 2061,<br>      “records_total” : 260575<br>    },<br>    “zone2” : {<br>      “records_pending” : 0,<br>      “records_total” : 14749<br>    }<br>  },<br>  “status” : {<br>    “bytes_in” : 1364923761,<br>    “msgs_in” : 337236,<br>    “msgs_out” : 346717,<br>    “bytes_out” : 1402765472,<br>    “nodes_online” : 15<br>  }<br>}</pre></blockquote></li>-  Sync Zone:  Synchronization status of a shared memory zone. <dl class="compact"><dt> <code>records_pending</code> ( <code>integer</code> ) </dt><dd> The number of records that need to be sent to the cluster. </dd><dt> <code>records_total</code> ( <code>integer</code> ) </dt><dd> The total number of records stored in the shared memory zone. </dd></dl>-   错误：  nginx error object. <dl class="compact"><dt> <code>path</code> ( <code>string</code> ) </dt><dd> API path. </dd><dt> <code>method</code> ( <code>string</code> ) </dt><dd> HTTP method. </dd><dt> <code>error</code> </dt> <dd><dl class="compact"><dt> <code>status</code> ( <code>integer</code> ) </dt><dd> HTTP error code. </dd><dt> <code>text</code> ( <code>string</code> ) </dt><dd> Error description. </dd><dt> <code>code</code> ( <code>string</code> ) </dt><dd> Internal nginx error code. </dd></dl></dd><dt> <code>request_id</code> ( <code>string</code> ) </dt><dd> The ID of the request, equals the value of the <a href="https://nginx.org/en/http/ngx_http_core_module.html#var_request_id" target="_blank" rel="noopener">$request_id</a> variable. </dd><dt> <code>href</code> ( <code>string</code> ) </dt><dd> Link to reference documentation. </dd></dl></p>
<pre class="notranslate">{
  "respawned" : 0
}</pre>

<pre class="notranslate">{
  "handshakes" : 79572,
  "handshakes_failed" : 21025,
  "session_reuses" : 15762
}</pre>

<pre class="notranslate">{
  "total" : 10624511,
  "current" : 4
}</pre>

<pre class="notranslate">{
  "size" : 530915328,
  "max_size" : 536870912,
  "cold" : false,
  "hit" : {
    "responses" : 254032,
    "bytes" : 6685627875
  },
  "stale" : {
    "responses" : 0,
    "bytes" : 0
  },
  "updating" : {
    "responses" : 0,
    "bytes" : 0
  },
  "revalidated" : {
    "responses" : 0,
    "bytes" : 0
  },
  "miss" : {
    "responses" : 1619201,
    "bytes" : 53841943822
  },
  "expired" : {
    "responses" : 45859,
    "bytes" : 1656847080,
    "responses_written" : 44992,
    "bytes_written" : 1641825173
  },
  "bypass" : {
    "responses" : 200187,
    "bytes" : 5510647548,
    "responses_written" : 200173,
    "bytes_written" : 44992
  }
}</pre>

<pre class="notranslate">{
  "id" : 1,
  "server" : "10.0.0.1:8089",
  "weight" : 4,
  "max_conns" : 0,
  "max_fails" : 0,
  "fail_timeout" : "10s",
  "slow_start" : "10s",
  "route" : "",
  "backup" : true,
  "down" : true
}</pre>

<pre class="notranslate">{
  "dns" : {
    "processing" : 1,
    "connections" : 155569,
    "sessions" : {
      "2xx" : 155564,
      "4xx" : 0,
      "5xx" : 0,
      "total" : 155569
    },
    "discarded" : 0,
    "received" : 4200363,
    "sent" : 20489184
  }
}</pre>

<pre class="notranslate">{
  "id" : 0,
  "server" : "10.0.0.1:12348",
  "weight" : 1,
  "max_conns" : 0,
  "max_fails" : 1,
  "fail_timeout" : "10s",
  "slow_start" : 0,
  "backup" : false,
  "down" : false
}</pre>

<pre class="notranslate">{
  "zones" : {
    "zone1" : {
      "records_pending" : 2061,
      "records_total" : 260575
    },
    "zone2" : {
      "records_pending" : 0,
      "records_total" : 14749
    }
  },
  "status" : {
    "bytes_in" : 1364923761,
    "msgs_in" : 337236,
    "msgs_out" : 346717,
    "bytes_out" : 1402765472,
    "nodes_online" : 15
  }
}</pre>





</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_addition_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_addition_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_addition_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-addition-module"><a href="#Module-ngx-http-addition-module" class="headerlink" title="Module ngx_http_addition_module"></a>Module ngx_http_addition_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#add_before_body">add_before_body</a> <br>     <a href="#add_after_body">add_after_body</a> <br>     <a href="#addition_types">addition_types</a> <br></td>

<p>   <code>ngx_http_addition_module</code>模块是一个过滤器，用于在响应之前和之后添加文本。  默认情况下不构建此模块，应使用<code>--with-http_addition_module</code>配置参数启用它。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    add_before_body /before_action;
    add_after_body  /after_action;
}
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_before_body*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  添加由于在响应主体之前处理给定子请求而返回的文本。  作为参数的空字符串（ <code>&quot;&quot;</code> ）取消从先前配置级别继承的添加。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**add_after_body*uri*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  添加由于在响应主体之后处理给定子请求而返回的文本。  作为参数的空字符串（ <code>&quot;&quot;</code> ）取消从先前配置级别继承的添加。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**addition_types*mime-type*</code> …;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">addition_types text/html;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  该指令出现在0.7.9版本中。 </p>
<p>  除了“ <code>text/html</code> ”之外，还允许在具有指定MIME类型的响应中添加文本。  特殊值“ <code>*</code> ”匹配任何MIME类型（0.8.29）。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/ngx_http_access_module-nginx中文手册]]></title>
      <url>/ngx/http/ngx_http_access_module.html</url>
      <content type="html"><![CDATA[<p>http,ngx_http_access_module<br><a id="more"></a></p>
<h2 id="Module-ngx-http-access-module"><a href="#Module-ngx-http-access-module" class="headerlink" title="Module ngx_http_access_module"></a>Module ngx_http_access_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#allow">allow</a> <br>     <a href="#deny">deny</a> <br></td>

<p>   <code>ngx_http_access_module</code>模块允许限制对某些客户端地址的访问。 </p>
<p>  访问也可以通过<a href="ngx_http_auth_basic_module.html">密码</a> ， <a href="ngx_http_auth_request_module.html">子请求</a>的<a href="ngx_http_auth_request_module.html">结果</a>或<a href="ngx_http_auth_jwt_module.html">JWT来限制</a> 。  通过地址和密码同时限制访问由<a href="ngx_http_core_module.html#satisfy">satisf</a>指令控制。 </p>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">location / {
    deny  192.168.1.1;
    allow 192.168.1.0/24;
    allow 10.1.1.0/16;
    allow 2001:0db8::/32;
    deny  all;
}
</pre>



<p>  按顺序检查规则，直到找到第一个匹配项。  在此示例中，仅允许IPv4网络<code>10.1.1.0/16</code>和<code>192.168.1.0/24</code>不包括地址<code>192.168.1.1</code> ）和IPv6网络<code>2001:0db8::/32</code> 。  如果有很多规则，最好使用<a href="ngx_http_geo_module.html">ngx_http_geo_module</a>模块变量。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**allow**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  允许访问指定的网络或地址。  如果指定了特殊值<code>unix:</code> （1.5.1），则允许访问所有UNIX域套接字。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**deny**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> |    <code>all</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>http</code> , <code>server</code> , <code>location</code> , <code>limit_except</code> <br>                </td></p>
<p>  拒绝访问指定的网络或地址。  如果指定了特殊值<code>unix:</code> （1.5.1），则拒绝所有UNIX域套接字的访问。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/load_balancing-nginx中文手册]]></title>
      <url>/ngx/http/load_balancing.html</url>
      <content type="html"><![CDATA[<p>http,load_balancing<br><a id="more"></a></p>
<h2 id="使用nginx作为HTTP负载均衡器"><a href="#使用nginx作为HTTP负载均衡器" class="headerlink" title="使用nginx作为HTTP负载均衡器"></a>使用nginx作为HTTP负载均衡器</h2><td align="left" class="notranslate"> <a href="#nginx_load_balancing_methods">Load balancing methods</a> <br> <a href="#nginx_load_balancing_configuration">Default load balancing configuration</a> <br> <a href="#nginx_load_balancing_with_least_connected">Least connected load balancing</a> <br> <a href="#nginx_load_balancing_with_ip_hash">Session persistence</a> <br> <a href="#nginx_weighted_load_balancing">Weighted load balancing</a> <br> <a href="#nginx_load_balancing_health_checks">Health checks</a> <br> <a href="#nginx_load_balancing_additional_information">Further reading</a> <br></td>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>  跨多个应用程序实例的负载平衡是一种常用技术，用于优化资源利用率，最大化吞吐量，减少延迟并确保容错配置。 </p>
<p>  可以使用nginx作为非常有效的HTTP负载平衡器，将流量分配到多个应用程序服务器，并使用nginx提高Web应用程序的性能，可伸缩性和可靠性。 </p>
<h4 id="负载均衡方法"><a href="#负载均衡方法" class="headerlink" title="负载均衡方法"></a>负载均衡方法</h4><p>   nginx支持以下负载平衡机制（或​​方法）： </p>
<ul>
<li>循环 - 对应用程序服务器的请求以循环方式分发， -   最少连接 - 下一个请求被分配给活动连接数最少的服务器， -    ip-hash  - 哈希函数用于确定应为下一个请求选择哪个服务器（基于客户端的IP地址）。 </li>
</ul>
<h4 id="默认负载均衡配置"><a href="#默认负载均衡配置" class="headerlink" title="默认负载均衡配置"></a>默认负载均衡配置</h4><p>  使用nginx进行负载平衡的最简单配置可能如下所示： </p>
<pre class="notranslate">http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}
</pre>



<p>  在上面的示例中，在srv1-srv3上运行了3个相同应用程序的实例。  如果未特别配置负载平衡方法，则默认为循环。  所有请求都<a href="ngx_http_proxy_module.html#proxy_pass">代理</a>到服务器组myapp1，nginx应用HTTP负载平衡来分发请求。 </p>
<p>   nginx中的反向代理实现包括HTTP，HTTPS，FastCGI，uwsgi，SCGI，memcached和gRPC的负载平衡。 </p>
<p>  要为HTTPS而不是HTTP配置负载平衡，只需使用“https”作为协议。 </p>
<p>  为FastCGI，uwsgi，SCGI，memcached或gRPC设置负载平衡时，分别使用<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> ， <a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> ， <a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> ， <a href="ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a>和<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>指令。 </p>
<h4 id="最小连接负载平衡"><a href="#最小连接负载平衡" class="headerlink" title="最小连接负载平衡"></a>最小连接负载平衡</h4><p>  另一个负载平衡规则是最少连接的。  在某些请求需要更长时间才能完成的情况下，最小连接允许更公平地控制应用程序实例上的负载。 </p>
<p>  使用最少连接的负载平衡，nginx将尽量不会使繁忙的应用程序服务器过载请求，而是将新请求分发给不太繁忙的服务器。 </p>
<p>  当<a href="ngx_http_upstream_module.html#least_conn">least_conn</a>指令用作服务器组配置的一部分时，将激活nginx中的最小连接负载平衡： </p>
<pre class="notranslate">    upstream myapp1 {
        least_conn;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }
</pre>



<h4 id="会话持久性"><a href="#会话持久性" class="headerlink" title="会话持久性"></a>会话持久性</h4><p>  请注意，通过循环或最少连接的负载平衡，每个后续客户端的请求可能会分发到不同的服务器。  无法保证同一客户端始终指向同一服务器。 </p>
<p>  如果需要将客户端绑定到特定的应用程序服务器 - 换句话说，就始终尝试选择特定服务器而言，使客户端的会话“粘滞”或“持久” -  ip-hash负载平衡机制可以是用过的。 </p>
<p>  使用ip-hash，客户端的IP地址将用作散列密钥，以确定应为客户端的请求选择服务器组中的哪个服务器。  此方法可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。 </p>
<p>  要配置ip-hash负载平衡，只需将<a href="ngx_http_upstream_module.html#ip_hash">ip_hash</a>指令添加到服务器（上游）组配置： </p>
<pre class="notranslate">upstream myapp1 {
    ip_hash;
    server srv1.example.com;
    server srv2.example.com;
    server srv3.example.com;
}
</pre>



<h4 id="加权负载平衡"><a href="#加权负载平衡" class="headerlink" title="加权负载平衡"></a>加权负载平衡</h4><p>  通过使用服务器权重，甚至可以进一步影响nginx负载平衡算法。 </p>
<p>  在上面的示例中，未配置服务器权重，这意味着所有指定的服务器都被视为对特定负载平衡方法具有同等资格。 </p>
<p>  特别是对于循环，它还意味着在服务器上或多或少地平等分配请求 - 只要有足够的请求，并且以统一的方式处理请求并且足够快地完成。 </p>
<p>  当为服务器指定<a href="ngx_http_upstream_module.html#server">权重</a>参数时， <a href="ngx_http_upstream_module.html#server">权</a>重被计入负载平衡决策的一部分。 </p>
<pre class="notranslate">    upstream myapp1 {
        server srv1.example.com weight=3;
        server srv2.example.com;
        server srv3.example.com;
    }
</pre>



<p>  使用此配置，每5个新请求将分布在应用程序实例中，如下所示：3个请求将定向到srv1，一个请求将转到srv2，另一个请求转到srv3。 </p>
<p>  同样可以在最近的nginx版本中使用具有最少连接和ip-hash负载平衡的权重。 </p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p>   nginx中的反向代理实现包括带内（或被动）服务器运行状况检查。  如果来自特定服务器的响应失败并显示错误，则nginx会将此服务器标记为失败，并将尝试避免为后续入站请求选择此服务器一段时间。 </p>
<p>   <a href="ngx_http_upstream_module.html#server">max_fails</a>指令设置在<a href="ngx_http_upstream_module.html#server">fail_timeout</a>期间应该发生的与服务器通信的连续不成功尝试次数。  默认情况下， <a href="ngx_http_upstream_module.html#server">max_fails</a>设置为1.当设置为0时，将禁用此服务器的运行状况检查。   <a href="ngx_http_upstream_module.html#server">fail_timeout</a>参数还定义服务器将标记为失败的时间。  在服务器发生故障后的<a href="ngx_http_upstream_module.html#server">fail_timeout</a>时间间隔后，nginx将开始使用实时客户端的请求正常探测服务器。  如果探测成功，则将服务器标记为实时。 </p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p>  此外，还有更多指令和参数可以控制nginx中的服务器负载平衡，例如<a href="ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> ， <a href="ngx_http_upstream_module.html#server">backup</a> ， <a href="ngx_http_upstream_module.html#server">down</a>和<a href="ngx_http_upstream_module.html#keepalive">keepalive</a> 。  有关更多信息，请查看我们的<a href="..">参考文档</a> 。 </p>
<p>  最后但同样重要的是， <a href="https://www.nginx.com/products/application-load-balancing/" target="_blank" rel="noopener">应用程序负载平衡</a> ， <a href="https://www.nginx.com/products/application-health-checks/" target="_blank" rel="noopener">应用程序运行状况检查</a> ， <a href="https://www.nginx.com/products/live-activity-monitoring/" target="_blank" rel="noopener">活动监视</a>和服务器组的动态<a href="https://www.nginx.com/products/on-the-fly-reconfiguration/" target="_blank" rel="noopener">重新配置</a>是我们付费NGINX Plus订阅的一部分。 </p>
<p>  以下文章更详细地描述了与NGINX Plus的负载平衡： </p>
<ul>
<li><a href="https://www.nginx.com/blog/load-balancing-with-nginx-plus/" target="_blank" rel="noopener">使用NGINX和NGINX Plus进行负载均衡</a> -    <a href="https://www.nginx.com/blog/load-balancing-with-nginx-plus-part2/" target="_blank" rel="noopener">使用NGINX和NGINX Plus第2部分进行负载平衡</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/converting_rewrite_rules-nginx中文手册]]></title>
      <url>/ngx/http/converting_rewrite_rules.html</url>
      <content type="html"><![CDATA[<p>http,converting_rewrite_rules<br><a id="more"></a></p>
<h2 id="转换重写规则"><a href="#转换重写规则" class="headerlink" title="转换重写规则"></a>转换重写规则</h2><td align="left" class="notranslate"> <a href="#converting_mongrel_rules">Converting Mongrel rules</a> <br></td>

<h4 id="重定向到主站点"><a href="#重定向到主站点" class="headerlink" title="重定向到主站点"></a>重定向到主站点</h4><p>  在共享托管生活期间用于<em>仅</em>使用Apache的.htaccess文件配置<em>所有内容</em>的人通常会翻译以下规则： </p>
<pre class="notranslate">RewriteCond  %{HTTP_HOST}  example.org
RewriteRule  (.*)          http://www.example.org$1
</pre>

<p>  这样的事情： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  www.example.org  example.org;
    if ($http_host = example.org) {
        rewrite  (.*)  http://www.example.org$1;
    }
    ...
}
</pre>



<p>  这是一种错误，繁琐且无效的方式。  正确的方法是为<code>example.org</code>定义一个单独的服务器： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.org;
    return       301 http://www.example.org$request_uri;
}

server {
    listen       80;
    server_name  www.example.org;
    ...
}
</pre>



<blockquote>
<p>  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ <a href="http://www.example.org$request_uri?" target="_blank" rel="noopener">http://www.example.org$request_uri?</a>;<br></pre></blockquote></p>
</blockquote>
<p>  另一个例子。  而不是“倒置”逻辑“所有不是<code>example.com</code>而不是<code>www.example.com</code> ”： </p>
<pre class="notranslate">RewriteCond  %{HTTP_HOST}  !example.com
RewriteCond  %{HTTP_HOST}  !www.example.com
RewriteRule  (.*)          http://www.example.com$1
</pre>

<p>  一个人应该简单地定义<code>example.com</code> ， <code>www.example.com</code>和“其他一切”： </p>
<pre class="notranslate">server {
    listen       80;
    server_name  example.com www.example.com;
    ...
}

server {
    listen       80 default_server;
    server_name  _;
    return       301 http://example.com$request_uri;
}
</pre>



<blockquote>
<p>  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ <a href="http://example.com$request_uri?" target="_blank" rel="noopener">http://example.com$request_uri?</a>;<br></pre></blockquote></p>
</blockquote>
<h4 id="转换Mongrel规则"><a href="#转换Mongrel规则" class="headerlink" title="转换Mongrel规则"></a>转换Mongrel规则</h4><p>  典型的Mongrel规则： </p>
<pre class="notranslate">DocumentRoot /var/www/myapp.com/current/public

RewriteCond %{DOCUMENT_ROOT}/system/maintenance.html -f
RewriteCond %{SCRIPT_FILENAME} !maintenance.html
RewriteRule ^.*$ %{DOCUMENT_ROOT}/system/maintenance.html [L]

RewriteCond %{REQUEST_FILENAME} -f
RewriteRule ^(.*)$ $1 [QSA,L]

RewriteCond %{REQUEST_FILENAME}/index.html -f
RewriteRule ^(.*)$ $1/index.html [QSA,L]

RewriteCond %{REQUEST_FILENAME}.html -f
RewriteRule ^(.*)$ $1.html [QSA,L]

RewriteRule ^/(.*)$ balancer://mongrel_cluster%{REQUEST_URI} [P,QSA,L]
</pre>

<p>  应转换为 </p>
<pre class="notranslate">location / {
    root       /var/www/myapp.com/current/public;

    try_files  /system/maintenance.html
               $uri  $uri/index.html $uri.html
               @mongrel;
}

location @mongrel {
    proxy_pass  http://mongrel;
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http/configuring_https_servers-nginx中文手册]]></title>
      <url>/ngx/http/configuring_https_servers.html</url>
      <content type="html"><![CDATA[<p>http,configuring_https_servers<br><a id="more"></a></p>
<h2 id="配置HTTPS服务器"><a href="#配置HTTPS服务器" class="headerlink" title="配置HTTPS服务器"></a>配置HTTPS服务器</h2><td align="left" class="notranslate"> <a href="#optimization">HTTPS server optimization</a> <br> <a href="#chains">SSL certificate chains</a> <br> <a href="#single_http_https_server">A single HTTP/HTTPS server</a> <br> <a href="#name_based_https_servers">Name-based HTTPS servers</a> <br>     <a href="#certificate_with_several_names">An SSL certificate with several names</a> <br>     <a href="#sni">Server Name Indication</a> <br> <a href="#compatibility">Compatibility</a> <br></td>

<p>  要配置HTTPS服务器，必须在<a href="ngx_http_core_module.html#server">服务器</a>块中的<a href="ngx_http_core_module.html#listen">侦听套接字</a>上启用<code>ssl</code>参数，并且应指定<a href="ngx_http_ssl_module.html#ssl_certificate">服务器证书</a>和<a href="ngx_http_ssl_module.html#ssl_certificate_key">私钥</a>文件的位置： </p>
<pre class="notranslate">server {
    listen              443 **ssl** ;
    server_name         www.example.com;
    ssl_certificate     **www.example.com.crt** ;
    ssl_certificate_key **www.example.com.key** ;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
</pre>

<p>  服务器证书是公共实体。  它被发送到连接到服务器的每个客户端。  私钥是一个安全的实体，应该存储在具有受限访问权限的文件中，但是，它必须是nginx的主进程可读的。  私钥可以替代地存储在与证书相同的文件中： </p>
<pre class="notranslate">    ssl_certificate     www.example.com.cert;
    ssl_certificate_key www.example.com.cert;
</pre>

<p>  在这种情况下，还应限制文件访问权限。  虽然证书和密钥存储在一个文件中，但只有证书才会发送到客户端。 </p>
<p>  指令<a href="ngx_http_ssl_module.html#ssl_protocols">ssl_protocols</a>和<a href="ngx_http_ssl_module.html#ssl_ciphers">ssl_ciphers</a>可用于限制连接以仅包括SSL / TLS的强版本和密码。  默认情况下，nginx使用“ <code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2</code> ”和“ <code>ssl_ciphers HIGH:!aNULL:!MD5</code> ”，因此通常不需要明确配置它们。  请注意，这些指令的默认值已多次<a href="#compatibility">更改</a> 。 </p>
<h4 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h4><p>   SSL操作会消耗额外的CPU资源。  在多处理器系统上，应运行多个<a href="ngx_core_module.html#worker_processes">工作进程</a> ，不少于可用CPU核心数。   CPU占用最多的操作是SSL握手。  有两种方法可以最大限度地减少每个客户端的这些操作数量：第一种方法是通过启用<a href="ngx_http_core_module.html#keepalive_timeout">keepalive</a>连接来通过一个连接发送多个请求，第二种方法是重用SSL会话参数以避免SSL并行连接和后续连接。  会话存储在工作<a href="ngx_http_ssl_module.html#ssl_session_cache">线程</a>之间共享的SSL会话高速缓存中，并由<a href="ngx_http_ssl_module.html#ssl_session_cache">ssl_session_cache</a>指令配置。  一兆字节的缓存包含大约4000个会话。  默认缓存超时为5分钟。  可以使用<a href="ngx_http_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a>指令增加它。  以下是针对具有10兆字节共享会话缓存的多核系统优化的示例配置： </p>
<pre class="notranslate"> **worker_processes auto** ;

http {
    **ssl_session_cache   shared:SSL:10m** ;
    **ssl_session_timeout 10m** ;

    server {
        listen              443 ssl;
        server_name         www.example.com;
        **keepalive_timeout   70** ;

        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
</pre>



<h4 id="SSL证书链"><a href="#SSL证书链" class="headerlink" title="SSL证书链"></a>SSL证书链</h4><p>  某些浏览器可能会抱怨由知名证书颁发机构签名的证书，而其他浏览器可能会毫无问题地接受证书。  发生这种情况是因为颁发机构使用中间证书对服务器证书进行了签名，该中间证书不存在于与特定浏览器一起分发的知名可信证书颁发机构的证书库中。  在这种情况下，授权机构提供一组链式证书，这些证书应连接到签名的服务器证书。  服务器证书必须出现在组合文件中的链接证书之前： </p>
<pre class="notranslate">$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt
</pre>

<p>  生成的文件应该在<a href="ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a>指令中使用： </p>
<pre class="notranslate">server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.chained.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
</pre>

<p>  如果服务器证书和软件包已按错误的顺序连接，则nginx将无法启动并显示错误消息： </p>
<pre class="notranslate">SSL_CTX_use_PrivateKey_file(" ... /www.example.com.key") failed
   (SSL: error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch)
</pre>

<p>  因为nginx试图将私钥与bundle的第一个证书而不是服务器证书一起使用。 </p>
<p>  浏览器通常存储他们收到的中间证书，并由受信任的权威机构签名，因此主动使用的浏览器可能已经拥有所需的中间证书，并且可能不会抱怨没有链接束发送的证书。  要确保服务器发送完整的证书链，可以使用<code>openssl</code>命令行实用程序，例如： </p>
<pre class="notranslate">$ openssl s_client -connect www.godaddy.com:443
...
Certificate chain
 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US
     /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc
     /OU=MIS Department/ **CN=www.GoDaddy.com**
     /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b)
   i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
   i:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
 2 s:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
   i:/L=ValiCert Validation Network/O= **ValiCert, Inc.**
     /OU=ValiCert Class 2 Policy Validation Authority
     /CN=http://www.valicert.com//emailAddress=info@valicert.com
...
</pre>



<blockquote>
<p>  在使用<a href="#sni">SNI</a>测试配置时，指定<code>-servername</code>选项很重要，因为默认情况下<code>openssl</code>不使用SNI。 </p>
</blockquote>
<p>  在该示例中， <code>www.GoDaddy.com</code>服务器证书＃0的主题（“ <em>s</em> ”）由发行者（“ <em>i</em> ”）签名，发行者本身是证书＃1的主题，其由发行者本身签署。是证书＃2的主题，由知名发行人<em>ValiCert，Inc。签署，</em>其证书存储在浏览器的内置证书库（位于Jack建造的房屋中）中。 </p>
<p>  如果尚未添加证书包，则仅显示服务器证书＃0。 </p>
<h4 id="单个HTTP-HTTPS服务器"><a href="#单个HTTP-HTTPS服务器" class="headerlink" title="单个HTTP / HTTPS服务器"></a>单个HTTP / HTTPS服务器</h4><p>  可以配置处理HTTP和HTTPS请求的单个服务器： </p>
<pre class="notranslate">server {
    listen              80;
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
</pre>



<blockquote>
<p>  在0.7.14之前，无法为个别侦听套接字选择性地启用SSL，如上所示。  只能使用<a href="ngx_http_ssl_module.html#ssl">ssl</a>指令为整个服务器启用<a href="ngx_http_ssl_module.html#ssl">SSL</a> ，从而无法设置单个HTTP / HTTPS服务器。  添加了<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数来解决此问题。  因此不鼓励在现代版本中使用<a href="ngx_http_ssl_module.html#ssl">ssl</a>指令。 </p>
</blockquote>
<h4 id="基于名称的HTTPS服务器"><a href="#基于名称的HTTPS服务器" class="headerlink" title="基于名称的HTTPS服务器"></a>基于名称的HTTPS服务器</h4><p>  配置两个或多个侦听单个IP地址的HTTPS服务器时会出现一个常见问题： </p>
<pre class="notranslate">server {
    listen          443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
</pre>

<p>  使用此配置，浏览器接收默认服务器的证书，即<code>www.example.com</code>无论请求的服务器名称如何。  这是由SSL协议行为引起的。  在浏览器发送HTTP请求之前建立SSL连接，并且nginx不知道所请求服务器的名称。  因此，它可能只提供默认服务器的证书。 </p>
<p>  解决此问题的最古老，最强大的方法是为每个HTTPS服务器分配一个单独的IP地址： </p>
<pre class="notranslate">server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
</pre>



<h4 id="具有多个名称的SSL证书"><a href="#具有多个名称的SSL证书" class="headerlink" title="具有多个名称的SSL证书"></a>具有多个名称的SSL证书</h4><p>  还有其他方法允许在多个HTTPS服务器之间共享单个IP地址。  但是，所有这些都有它们的缺点。  一种方法是在SubjectAltName证书字段中使用具有多个名称的证书，例如<code>www.example.com</code>和<code>www.example.org</code> 。  但是，SubjectAltName字段长度是有限的。 </p>
<p>  另一种方法是使用带有通配符名称的证书，例如<code>*.example.org</code> 。  通配符证书可保护指定域的所有子域，但仅限于一个级别。  此证书与<code>www.example.org</code>匹配，但与<code>example.org</code>和<code>www.sub.example.org</code>不匹配。  这两种方法也可以组合使用。  证书可以在SubjectAltName字段中包含完全和通配符名称，例如<code>example.org</code>和<code>*.example.org</code> 。 </p>
<p>  最好将具有多个名称的证书文件及其私钥文件放在配置的<em>http</em>级别，以在所有服务器中继承其单个内存副本： </p>
<pre class="notranslate">ssl_certificate     common.crt;
ssl_certificate_key common.key;

server {
    listen          443 ssl;
    server_name     www.example.com;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ...
}
</pre>



<h4 id="服务器名称指示"><a href="#服务器名称指示" class="headerlink" title="服务器名称指示"></a>服务器名称指示</h4><p>  在单个IP地址上运行多个HTTPS服务器的更通用的解决方案是<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">TLS服务器名称指示扩展</a> （SNI，RFC 6066），它允许浏览器在SSL握手期间传递请求的服务器名称，因此服务器将知道哪个它应该用于连接的证书。  目前大多数现代浏览器都<a href="http://en.wikipedia.org/wiki/Server_Name_Indication#Support" target="_blank" rel="noopener">支持</a> SNI，但某些老客户或特殊客户可能无法使用。 </p>
<blockquote>
<p>  只有域名可以在SNI中传递，但是如果请求包含文字IP地址，某些浏览器可能会错误地传递服务器的IP地址作为其名称。  人们不应该依赖于此。 </p>
</blockquote>
<p>  为了在nginx中使用SNI，必须在构建nginx二进制文件的OpenSSL库以及在运行时动态链接到的库中支持它。  如果使用配置选项<nobr>“–enable-tlsext”</nobr>构建，OpenSSL支持自0.9.8f版本以来的SNI <nobr>。</nobr>  自OpenSSL 0.9.8j以来，默认情况下启用此选项。  如果nginx是使用SNI支持构建的，那么nginx将在使用“-V”开关运行时显示： </p>
<pre class="notranslate">$ nginx -V
...
TLS SNI support enabled
...
</pre>

<p>  但是，如果启用SNI的nginx动态链接到没有SNI支持的OpenSSL库，nginx会显示警告： </p>
<pre class="notranslate">nginx was built with SNI support, however, now it is linked
dynamically to an OpenSSL library which has no tlsext support,
therefore SNI is not available
</pre>



<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>自0.8.21和0.7.62以来，“-V”开关显示SNI支持状态。 -   自0.7.14起，支持<a href="ngx_http_core_module.html#listen">listen</a>指令的<code>ssl</code>参数。  在0.8.21之前，它只能与<code>default</code>参数一起指定。 -   自0.5.23以来，SNI一直受到支持。 -   自0.5.6以来一直支持共享SSL会话缓存。 </li>
</ul>
<ul>
<li>版本1.9.1及更高版本：默认的SSL协议是TLSv1，TLSv1.1和TLSv1.2（如果OpenSSL库支持）。 -   版本0.7.65,0.8.19及更高版本：默认的SSL协议是SSLv3，TLSv1，TLSv1.1和TLSv1.2（如果受OpenSSL库支持）。 -   版本0.7.64,0.8.18及更早版本：默认的SSL协议是SSLv2，SSLv3和TLSv1。 </li>
</ul>
<ul>
<li>版本1.0.5及更高版本：默认的SSL密码为“ <code>HIGH:!aNULL:!MD5</code> ”。 -   版本0.7.65,0.8.20及更高版本：默认SSL密码为“ <code>HIGH:!ADH:!MD5</code> ”。 -   版本0.8.19：默认SSL密码为“ <code>ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM</code> ”。 -   版本0.7.64,0.8.18及更早版本：默认的SSL密码是 <br>   “ <code>ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</code> ”。 </li>
</ul>
<td align="right" class="notranslate">written by Igor Sysoev<br>edited by Brian Mercer<br></td>



]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dev/development_guide-nginx中文手册]]></title>
      <url>/ngx/dev/development_guide.html</url>
      <content type="html"><![CDATA[<p>dev,development_guide<br><a id="more"></a></p>
<h2 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h2><td align="left" class="notranslate"> <a href="#introduction">Introduction</a> <br>     <a href="#code_layout">Code layout</a> <br>     <a href="#include_files">Include files</a> <br>     <a href="#integers">Integers</a> <br>     <a href="#common_return_codes">Common return codes</a> <br>     <a href="#error_handling">Error handling</a> <br> <a href="#strings">Strings</a> <br>     <a href="#overview">Overview</a> <br>     <a href="#formatting">Formatting</a> <br>     <a href="#numeric_conversion">Numeric conversion</a> <br>     <a href="#regex">Regular expressions</a> <br> <a href="#time">Time</a> <br> <a href="#containers">Containers</a> <br>     <a href="#array">Array</a> <br>     <a href="#list">List</a> <br>     <a href="#queue">Queue</a> <br>     <a href="#red_black_tree">Red-Black tree</a> <br>     <a href="#hash">Hash</a> <br> <a href="#memory_management">Memory management</a> <br>     <a href="#heap">Heap</a> <br>     <a href="#pool">Pool</a> <br>     <a href="#shared_memory">Shared memory</a> <br> <a href="#logging">Logging</a> <br> <a href="#cycle">Cycle</a> <br> <a href="#buffer">Buffer</a> <br> <a href="#networking">Networking</a> <br>     <a href="#connection">Connection</a> <br> <a href="#events">Events</a> <br>     <a href="#event">Event</a> <br>     <a href="#i_o_events">I/O events</a> <br>     <a href="#timer_events">Timer events</a> <br>     <a href="#posted_events">Posted events</a> <br>     <a href="#event_loop">Event loop</a> <br> <a href="#processes">Processes</a> <br> <a href="#threads">Threads</a> <br> <a href="#Modules">Modules</a> <br>     <a href="#adding_new_modules">Adding new modules</a> <br>     <a href="#core_modules">Core Modules</a> <br>     <a href="#config_directives">Configuration Directives</a> <br> <a href="#http">HTTP</a> <br>     <a href="#http_connection">Connection</a> <br>     <a href="#http_request">Request</a> <br>     <a href="#http_conf">Configuration</a> <br>     <a href="#http_phases">Phases</a> <br>     <a href="#http_variables">Variables</a> <br>     <a href="#http_complex_values">Complex values</a> <br>     <a href="#http_request_redirection">Request redirection</a> <br>     <a href="#http_subrequests">Subrequests</a> <br>     <a href="#http_request_finalization">Request finalization</a> <br>     <a href="#http_request_body">Request body</a> <br>     <a href="#http_response">Response</a> <br>     <a href="#http_response_body">Response body</a> <br>     <a href="#http_body_filters">Body filters</a> <br>     <a href="#http_building_filter_modules">Building filter modules</a> <br>     <a href="#http_body_buffers_reuse">Buffer reuse</a> <br>     <a href="#http_load_balancing">Load balancing</a> <br> <a href="#examples">Examples</a> <br> <a href="#code_style">Code style</a> <br>     <a href="#code_style_general_rules">General rules</a> <br>     <a href="#code_style_files">Files</a> <br>     <a href="#code_style_comments">Comments</a> <br>     <a href="#code_style_preprocessor">Preprocessor</a> <br>     <a href="#code_style_types">Types</a> <br>     <a href="#code_style_variables">Variables</a> <br>     <a href="#code_style_functions">Functions</a> <br>     <a href="#code_style_expressions">Expressions</a> <br>     <a href="#code_style_conditionals_and_loops">Conditionals and Loops</a> <br>     <a href="#code_style_labels">Labels</a> <br></td>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h4 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h4><ul>
<li><p><code>auto</code> - 构建脚本 -  <code>src</code> <ul class="compact"> <li>   <code>core</code> - 基本类型和函数 - 字符串，数组，日志，池等。 -    <code>event</code> - 事件核心 <ul class="compact"><li>   <code>modules</code> - 事件通知模块： <code>epoll</code> ， <code>kqueue</code> ， <code>select</code>等。 -    <code>modules</code> - 其他HTTP模块 -    <code>v2</code> -  HTTP / 2 -  <code>unix</code>  -  <code>win32</code>  </li></ul></li></ul></p>
<h4 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h4><p>以下两个<code>#include</code>语句必须出现在每个nginx文件的开头： </p>
</li>
</ul>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
</pre>

<p>  除此之外，HTTP代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_http.h&gt;
</pre>

<p>  邮件代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_mail.h&gt;
</pre>

<p>  流代码应包括 </p>
<pre class="notranslate">#include &lt;ngx_stream.h&gt;
</pre>

<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>  出于一般目的，nginx代码使用两种整数类型， <code>ngx_int_t</code>和<code>ngx_uint_t</code> ，它们分别是<code>intptr_t</code>和<code>uintptr_t</code> typedef。 </p>
<h4 id="常见的返回码"><a href="#常见的返回码" class="headerlink" title="常见的返回码"></a>常见的返回码</h4><p>   nginx中的大多数函数返回以下代码： </p>
<ul>
<li><p><code>NGX_OK</code> - 操作成功。 -    <code>NGX_ERROR</code> - 操作失败。 -    <code>NGX_AGAIN</code> - 操作不完整;  再次调用该函数。 -    <code>NGX_DECLINED</code> - 例如，操作被拒绝，因为它在配置中被禁用。  这绝不是一个错误。 -    <code>NGX_BUSY</code> - 资源不可用。 -    <code>NGX_DONE</code> - 操作完成或在其他地方继续。  也用作替代成功代码。 -    <code>NGX_ABORT</code> - 功能已中止。  也用作替代错误代码。 </p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p><code>ngx_errno</code>宏返回上一个系统错误代码。  它映射到POSIX平台上的<code>errno</code>和Windows中的<code>GetLastError()</code>调用。   <code>ngx_socket_errno</code>宏返回最后一个套接字错误号。  与<code>ngx_errno</code>宏一样，它映射到POSIX平台上的<code>errno</code> 。  它映射到Windows上的<code>WSAGetLastError()</code>调用。   <code>ngx_socket_errno</code>多次访问<code>ngx_errno</code>或<code>ngx_socket_errno</code>的值可能会导致性能问题。  如果可能多次使用错误值，请将其存储在<code>ngx_err_t</code>类型的本地变量中。  要设置错误，请使用<code>ngx_set_errno(errno)</code>和<code>ngx_set_socket_errno(errno)</code>宏。 </p>
<p><code>ngx_errno</code>和<code>ngx_socket_errno</code>的值可以传递给日志函数<code>ngx_log_error()</code>和<code>ngx_log_debugX()</code> ，在这种情况下，系统错误文本将添加到日志消息中。 </p>
<p>使用<code>ngx_errno</code>示例： </p>
</li>
</ul>
<pre class="notranslate">void
ngx_my_kill(ngx_pid_t pid, ngx_log_t *log, int signo)
{
    ngx_err_t  err;

    if (kill(pid, signo) == -1) {
        err = ngx_errno;

        ngx_log_error(NGX_LOG_ALERT, log, err, "kill(%P, %d) failed", pid, signo);

        if (err == NGX_ESRCH) {
            return 2;
        }

        return 1;
    }

    return 0;
}
</pre>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p>  对于C字符串，nginx使用无符号字符类型指针<code>u_char *</code> 。 </p>
<p>   nginx字符串类型<code>ngx_str_t</code>定义如下： </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p>   <code>len</code>字段保存字符串长度， <code>data</code>保存字符串数据。  保存在<code>ngx_str_t</code>中的<code>ngx_str_t</code>在<code>len</code>字节之后可能会或可能不会以空值终止。  在大多数情况下，事实并非如此。  但是，在代码的某些部分（例如，在解析配置时），已知<code>ngx_str_t</code>对象以空值终止，这简化了字符串比较并使字符串更容易传递给系统调用。 </p>
<p>   nginx中的字符串操作在<code>src/core/ngx_string.h</code>中声明。其中一些是围绕标准C函数的包装器： </p>
<ul>
<li><code>ngx_strcmp()</code>  -  <code>ngx_strncmp()</code>  -  <code>ngx_strstr()</code>  -  <code>ngx_strlen()</code>  -  <code>ngx_strchr()</code>  -  <code>ngx_memcmp()</code>  -  <code>ngx_memset()</code>  -  <code>ngx_memcpy()</code>  -  <code>ngx_memmove()</code>  </li>
</ul>
<p>  其他字符串函数是特定于nginx的 </p>
<ul>
<li><code>ngx_memzero()</code> - 用零填充内存。 -    <code>ngx_explicit_memzero()</code> - 与<code>ngx_memzero()</code>相同，但编译器的死存储消除优化永远不会删除此调用。  此功能可用于清除密码和密钥等敏感数据。 -    <code>ngx_cpymem()</code> - 与<code>ngx_memcpy()</code>相同，但返回最终目标地址这个可以方便地连续添加多个字符串。 -    <code>ngx_movemem()</code> - 与<code>ngx_memmove()</code>相同，但返回最终目标地址。 -    <code>ngx_strlchr()</code> - 搜索字符串中的字符，由两个指针分隔。 </li>
</ul>
<p>  以下函数执行大小写转换和比较： </p>
<ul>
<li><code>ngx_tolower()</code>  -  <code>ngx_toupper()</code>  -  <code>ngx_strlow()</code>  -  <code>ngx_strcasecmp()</code>  -  <code>ngx_strncasecmp()</code>  </li>
</ul>
<p>  以下宏简化了字符串初始化： </p>
<ul>
<li><p><code>ngx_string(text)</code> - 来自C字符串文字<code>text</code>的<code>ngx_str_t</code>类型的静态初始值设定项 -    <code>ngx_null_string</code> - <code>ngx_str_t</code>类型的静态空字符串初始值设定项 -    <code>ngx_str_set(str, text)</code> - 使用C字符串文字<code>text</code>初始化<code>ngx_str_t *</code> type的字符串<code>str</code> -    <code>ngx_str_null(str)</code> - 使用空字符串初始化<code>ngx_str_t *</code> type的字符串<code>str</code> </p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>以下格式化函数支持特定于nginx的类型： </p>
</li>
</ul>
<ul>
<li><code>ngx_sprintf(buf, fmt, ...)</code>  -  <code>ngx_snprintf(buf, max, fmt, ...)</code>  -  <code>ngx_slprintf(buf, last, fmt, ...)</code>  -  <code>ngx_vslprintf(buf, last, fmt, args)</code>  -  <code>ngx_vsnprintf(buf, max, fmt, args)</code>  </li>
</ul>
<p>  这些函数支持的格式化选项的完整列表位于<code>src/core/ngx_string.c</code> 。  他们之中有一些是： </p>
<ul>
<li><p><code>%O</code> - <code>off_t</code> -    <code>%T</code> - <code>time_t</code> -    <code>%z</code> - <code>ssize_t</code> -    <code>%i</code> - <code>ngx_int_t</code> -    <code>%p</code> - <code>void *</code> -    <code>%V</code> - <code>ngx_str_t *</code> -    <code>%s</code> - <code>u_char *</code> （以null结尾） -    <code>%*s</code> - <code>size_t + u_char *</code><br>您可以在大多数类型上添加前缀以使其无符号。  要将输出转换为十六进制，请使用<code>X</code>或<code>x</code> 。 </p>
<p>例如： </p>
</li>
</ul>
<pre class="notranslate">u_char      buf[NGX_INT_T_LEN];
size_t      len;
ngx_uint_t  n;

/* set n here */

len = ngx_sprintf(buf, "%ui", n) — buf;
</pre>



<h4 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h4><p>  在nginx中实现了几个用于数值转换的函数。  前四个每个都将给定长度的字符串转换为指定类型的正整数。  它们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atoi(line, n)</code> - <code>ngx_int_t</code> -    <code>ngx_atosz(line, n)</code> - <code>ssize_t</code> -    <code>ngx_atoof(line, n)</code> - <code>off_t</code> -    <code>ngx_atotm(line, n)</code> - <code>time_t</code> </li>
</ul>
<p>  还有两个额外的数字转换函数。  与前四个一样，他们在出错时返回<code>NGX_ERROR</code> 。 </p>
<ul>
<li><code>ngx_atofp(line, n, point)</code> - 将给定长度的固定点浮点数转换为<code>ngx_int_t</code>类型的正整数。  结果左移小数点位置。  数字的字符串表示形式预计不会超过小数位数。  例如， <code>ngx_atofp(&quot;10.5&quot;, 4, 2)</code>返回<code>1050</code> 。 -    <code>ngx_hextoi(line, n)</code> - 将正整数的十六进制表示形式转换为<code>ngx_int_t</code> 。 </li>
</ul>
<h4 id="常用表达"><a href="#常用表达" class="headerlink" title="常用表达"></a>常用表达</h4><p>   nginx中的正则表达式接口是<a href="http://www.pcre.org" target="_blank" rel="noopener">PCRE</a>库的包装器。  相应的头文件是<code>src/core/ngx_regex.h</code> 。 </p>
<p>  要使用正则表达式进行字符串匹配，首先需要编译它，这通常在配置阶段完成。  请注意，由于PCRE支持是可选的，因此使用该接口的所有代码都必须受到周围<code>NGX_PCRE</code>宏的保护： </p>
<pre class="notranslate">#if (NGX_PCRE)
ngx_regex_t          *re;
ngx_regex_compile_t   rc;

u_char                errstr[NGX_MAX_CONF_ERRSTR];

ngx_str_t  value = ngx_string("message (\\d\\d\\d).*Codeword is '(?&lt;cw&gt;\\w+)'");

ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t));

rc.pattern = value;
rc.pool = cf-&gt;pool;
rc.err.len = NGX_MAX_CONF_ERRSTR;
rc.err.data = errstr;
/* rc.options are passed as is to pcre_compile() */

if (ngx_regex_compile(&amp;rc) != NGX_OK) {
    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V", &amp;rc.err);
    return NGX_CONF_ERROR;
}

re = rc.regex;
#endif
</pre>

<p>  编译成功后， <code>ngx_regex_compile_t</code>结构中的<code>ngx_regex_compile_t</code>和<code>named_captures</code>字段<code>ngx_regex_compile_t</code>包含正则表达式中的所有捕获和命名捕获的计数。 </p>
<p>  然后可以使用编译的正则表达式来匹配字符串： </p>
<pre class="notranslate">ngx_int_t  n;
int        captures[(1 + rc.captures) * 3];

ngx_str_t input = ngx_string("This is message 123. Codeword is 'foobar'.");

n = ngx_regex_exec(re, &amp;input, captures, (1 + rc.captures) * 3);
if (n &gt;= 0) {
    /* string matches expression */

} else if (n == NGX_REGEX_NO_MATCHED) {
    /* no match was found */

} else {
    /* some error */
    ngx_log_error(NGX_LOG_ALERT, log, 0, ngx_regex_exec_n " failed: %i", n);
}
</pre>

<p>   <code>ngx_regex_exec()</code>的参数是编译的正则表达式<code>re</code> ，匹配<code>s</code>的字符串，用于保存找到的任何<code>captures</code>的可选整数数组以及数组的<code>size</code> 。  根据<a href="http://www.pcre.org/original/doc/html/pcreapi.html" target="_blank" rel="noopener">PCRE API的</a>要求， <code>captures</code>数组的大小必须是三的倍数。  在该示例中，大小是根据匹配的字符串本身的总捕获数加<code>1</code> 。 </p>
<p>  如果有匹配，则可以按如下方式访问捕获： </p>
<pre class="notranslate">u_char     *p;
size_t      size;
ngx_str_t   name, value;

/* all captures */
for (i = 0; i &lt; n * 2; i += 2) {
    value.data = input.data + captures[i];
    value.len = captures[i + 1] — captures[i];
}

/* accessing named captures */

size = rc.name_size;
p = rc.names;

for (i = 0; i &lt; rc.named_captures; i++, p += size) {

    /* capture name */
    name.data = &amp;p[2];
    name.len = ngx_strlen(name.data);

    n = 2 * ((p[0] &lt;&lt; 8) + p[1]);

    /* captured value */
    value.data = &amp;input.data[captures[n]];
    value.len = captures[n + 1] — captures[n];
}
</pre>



<p>   <code>ngx_regex_exec_array()</code>函数接受<code>ngx_regex_elt_t</code>元素的数组（它们只是具有关联名称的已编译正则表达式），要匹配的字符串和日志。  该函数将表达式从数组应用到字符串，直到找到匹配或不再有表达式为止。  当匹配时返回值为<code>NGX_OK</code> ，否则<code>NGX_ERROR</code> ，如果出错则返回值为<code>NGX_OK</code> 。 </p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>   <code>ngx_time_t</code>结构表示具有三种不同类型的时间，包括秒，毫秒和GMT偏移量： </p>
<pre class="notranslate">typedef struct {
    time_t      sec;
    ngx_uint_t  msec;
    ngx_int_t   gmtoff;
} ngx_time_t;
</pre>

<p>   <code>ngx_tm_t</code>结构是UNIX平台上的<code>struct tm</code>和Windows上的<code>SYSTEMTIME</code>的别名。 </p>
<p>  要获得当前时间，通常可以访问其中一个可用的全局变量，表示所需格式的缓存时间值。 </p>
<p>  可用的字符串表示形式为： </p>
<ul>
<li><code>ngx_cached_err_log_time</code> - 用于错误日志条目： <code>&quot;1970/09/28 12:00:00&quot;</code> -    <code>ngx_cached_http_log_time</code> - 用于HTTP访问日志条目： <code>&quot;28/Sep/1970:12:00:00 +0600&quot;</code> -    <code>ngx_cached_syslog_time</code> - 用于syslog条目： <code>&quot;Sep 28 12:00:00&quot;</code> -    <code>ngx_cached_http_time</code> - 用于HTTP标头： <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> -    <code>ngx_cached_http_log_iso8601</code> -  ISO 8601标准格式： <code>&quot;1970-09-28T12:00:00+06:00&quot;</code> </li>
</ul>
<p>   <code>ngx_time()</code>和<code>ngx_timeofday()</code>宏以秒为单位返回当前时间值，是访问缓存时间值的首选方法。 </p>
<p>  要显式获取时间，请使用<code>ngx_gettimeofday()</code> ，它更新其参数（指向<code>struct timeval</code>指针）。  当nginx从系统调用返回到事件循环时，时间总是更新。  要立即更新时间，请在信号处理程序上下文中更新时间时调用<code>ngx_time_update()</code>或<code>ngx_time_sigsafe_update()</code> 。 </p>
<p>  以下函数将<code>time_t</code>转换为指示的细分时间表示。  每对中的第一个函数将<code>time_t</code>转换为<code>ngx_tm_t</code> ，将第二个函数（使用<code>_libc_</code> infix）转换为<code>struct tm</code> ： </p>
<ul>
<li><code>ngx_gmtime(), ngx_libc_gmtime()</code> - 以UTC表示的时间 -    <code>ngx_localtime(), ngx_libc_localtime()</code> - 相对于本地时区表示的时间<br><code>ngx_http_time(buf, time)</code>函数返回适合在HTTP头中使用的字符串表示（例如， <code>&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</code> ）。   <code>ngx_http_cookie_time(buf, time)</code>返回一个字符串表示函数，返回一个适合HTTP cookie的字符串表示（ <code>&quot;Thu, 31-Dec-37 23:55:55 GMT&quot;</code> ）。 </li>
</ul>
<h4 id="集装箱"><a href="#集装箱" class="headerlink" title="集装箱"></a>集装箱</h4><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>   nginx数组类型<code>ngx_array_t</code>定义如下 </p>
<pre class="notranslate">typedef struct {
    void        *elts;
    ngx_uint_t   nelts;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *pool;
} ngx_array_t;
</pre>

<p>   <code>elts</code>字段中提供了数组的元素。   <code>nelts</code>字段包含元素的数量。   <code>size</code>字段保存单个元素的大小，并在初始化数组时设置。 </p>
<p>  使用<code>ngx_array_create(pool, n, size)</code>调用在池中创建数组，并使用<code>ngx_array_init(array, pool, n, size)</code>调用来初始化已分配的数组对象。 </p>
<pre class="notranslate">ngx_array_t  *a, b;

/* create an array of strings with preallocated memory for 10 elements */
a = ngx_array_create(pool, 10, sizeof(ngx_str_t));

/* initialize string array for 10 elements */
ngx_array_init(&amp;b, pool, 10, sizeof(ngx_str_t));
</pre>

<p>  使用以下函数将元素添加到数组： </p>
<ul>
<li><code>ngx_array_push(a)</code>添加一个尾部元素并返回指向它的指针 -    <code>ngx_array_push_n(a, n)</code>添加<code>n</code>尾部元素并返回指向第一个元素的指针 </li>
</ul>
<p>  如果当前分配的内存量不足以容纳新元素，则分配新的内存块并将现有元素复制到其中。  新内存块通常是现有内存块的两倍。 </p>
<pre class="notranslate">s = ngx_array_push(a);
ss = ngx_array_push_n(&amp;b, 3);
</pre>

<h4 id="名单"><a href="#名单" class="headerlink" title="名单"></a>名单</h4><p>  在nginx中，列表是一系列数组，针对插入可能大量的项进行了优化。   <code>ngx_list_t</code>列表类型定义如下： </p>
<pre class="notranslate">typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p>  实际项目存储在列表部分中，其定义如下： </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};
</pre>

<p>  在使用之前，必须通过调用<code>ngx_list_init(list, pool, n, size)</code>或通过调用<code>ngx_list_create(pool, n, size)</code>创建列表来初始化<code>ngx_list_init(list, pool, n, size)</code> 。  这两个函数都将单个项的大小和每个列表部分的项数作为参数。  要将项添加到列表，请使用<code>ngx_list_push(list)</code>函数。  要迭代这些项，请直接访问列表字段，如示例所示： </p>
<pre class="notranslate">ngx_str_t        *v;
ngx_uint_t        i;
ngx_list_t       *list;
ngx_list_part_t  *part;

list = ngx_list_create(pool, 100, sizeof(ngx_str_t));
if (list == NULL) { /* error */ }

/* add items to the list */

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "foo");

v = ngx_list_push(list);
if (v == NULL) { /* error */ }
ngx_str_set(v, "bar");

/* iterate over the list */

part = &amp;list-&gt;part;
v = part-&gt;elts;

for (i = 0; /* void */; i++) {

    if (i &gt;= part-&gt;nelts) {
        if (part-&gt;next == NULL) {
            break;
        }

        part = part-&gt;next;
        v = part-&gt;elts;
        i = 0;
    }

    ngx_do_smth(&amp;v[i]);
}
</pre>

<p>  列表主要用于HTTP输入和输出标头。 </p>
<p>  列表不支持删除项目。  但是，在需要时，项目可以在内部被标记为缺失，而不会实际从列表中删除。  例如，要将HTTP输出标头（存储为<code>ngx_table_elt_t</code>对象）标记为缺失，请将<code>ngx_table_elt_t</code>的<code>hash</code>字段设置为零。  迭代标题时，显式跳过以这种方式标记的项目。 </p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>  在nginx中，队列是一个侵入式双向链表，每个节点定义如下： </p>
<pre class="notranslate">typedef struct ngx_queue_s  ngx_queue_t;

struct ngx_queue_s {
    ngx_queue_t  *prev;
    ngx_queue_t  *next;
};
</pre>

<p>  头队列节点未与任何数据链接。  使用前，请使用<code>ngx_queue_init(q)</code>调用初始化列表头。  队列支持以下操作： </p>
<ul>
<li><code>ngx_queue_insert_head(h, x)</code> ， <code>ngx_queue_insert_tail(h, x)</code> - 插入新节点 -    <code>ngx_queue_remove(x)</code> - 删除队列节点 -    <code>ngx_queue_split(h, q, n)</code> - 在一个节点上拆分队列，将队列尾部返回到一个单独的队列中 -    <code>ngx_queue_add(h, n)</code> - 将第二个队列添加到第一个队列 -    <code>ngx_queue_head(h)</code> ， <code>ngx_queue_last(h)</code> - 获取第一个或最后一个队列节点 -    <code>ngx_queue_sentinel(h)</code> - 获取队列sentinel对象以结束迭代 -    <code>ngx_queue_data(q, type, link)</code> - 获取对队列节点数据结构开头的引用，考虑其中的队列字段偏移量 </li>
</ul>
<p>  一个例子： </p>
<pre class="notranslate">typedef struct {
    ngx_str_t    value;
    ngx_queue_t  queue;
} ngx_foo_t;

ngx_foo_t    *f;
ngx_queue_t   values, *q;

ngx_queue_init(&amp;values);

f = ngx_palloc(pool, sizeof(ngx_foo_t));
if (f == NULL) { /* error */ }
ngx_str_set(&amp;f-&gt;value, "foo");

ngx_queue_insert_tail(&amp;values, &amp;f-&gt;queue);

/* insert more nodes here */

for (q = ngx_queue_head(&amp;values);
     q != ngx_queue_sentinel(&amp;values);
     q = ngx_queue_next(q))
{
    f = ngx_queue_data(q, ngx_foo_t, queue);

    ngx_do_smth(&amp;f-&gt;value);
}
</pre>

<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>   <code>src/core/ngx_rbtree.h</code>头文件提供了对红黑树的有效实现的访问。 </p>
<pre class="notranslate">typedef struct {
    ngx_rbtree_t       rbtree;
    ngx_rbtree_node_t  sentinel;

    /* custom per-tree data here */
} my_tree_t;

typedef struct {
    ngx_rbtree_node_t  rbnode;

    /* custom per-node data */
    foo_t              val;
} my_node_t;
</pre>

<p>  要处理整个树，需要两个节点：root和sentinel。  通常，它们会添加到自定义结构中，允许您将数据组织到树中，其中树叶包含指向或嵌入数据的链接。 </p>
<p>  要初始化树： </p>
<pre class="notranslate">my_tree_t  root;

ngx_rbtree_init(&amp;root.rbtree, &amp;root.sentinel, insert_value_function);
</pre>

<p>  要遍历树并插入新值，请使用“ <code>insert_value</code> ”函数。  例如， <code>ngx_str_rbtree_insert_value</code>函数处理<code>ngx_str_t</code>类型。  它的参数是指向插入的根节点，要添加的新创建的节点以及树的标记的指针。 </p>
<pre class="notranslate">void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp,
                                 ngx_rbtree_node_t *node,
                                 ngx_rbtree_node_t *sentinel)
</pre>

<p>  遍历非常简单，可以使用以下查找函数模式进行演示： </p>
<pre class="notranslate">my_node_t *
my_rbtree_lookup(ngx_rbtree_t *rbtree, foo_t *val, uint32_t hash)
{
    ngx_int_t           rc;
    my_node_t          *n;
    ngx_rbtree_node_t  *node, *sentinel;

    node = rbtree-&gt;root;
    sentinel = rbtree-&gt;sentinel;

    while (node != sentinel) {

        n = (my_node_t *) node;

        if (hash != node-&gt;key) {
            node = (hash &lt; node-&gt;key) ? node-&gt;left : node-&gt;right;
            continue;
        }

        rc = compare(val, node-&gt;val);

        if (rc &lt; 0) {
            node = node-&gt;left;
            continue;
        }

        if (rc &gt; 0) {
            node = node-&gt;right;
            continue;
        }

        return n;
    }

    return NULL;
}
</pre>

<p>   <code>compare()</code>函数是一个经典的比较器函数，它返回一个小于，等于或大于零的值。  为了加速查找并避免比较可能很大的用户对象，使用整数哈希字段。 </p>
<p>  要将节点添加到树，请分配新节点，对其进行初始化并调用<code>ngx_rbtree_insert()</code> ： </p>
<pre class="notranslate">    my_node_t          *my_node;
    ngx_rbtree_node_t  *node;

    my_node = ngx_palloc(...);
    init_custom_data(&amp;my_node-&gt;val);

    node = &amp;my_node-&gt;rbnode;
    node-&gt;key = create_key(my_node-&gt;val);

    ngx_rbtree_insert(&amp;root-&gt;rbtree, node);
</pre>

<p>  要删除节点，请调用<code>ngx_rbtree_delete()</code>函数： </p>
<pre class="notranslate">ngx_rbtree_delete(&amp;root-&gt;rbtree, node);
</pre>

<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>  散列表函数在<code>src/core/ngx_hash.h</code> 。  支持精确匹配和通配符匹配。  后者需要额外的设置，并在下面的单独部分中描述。 </p>
<p>  在初始化哈希之前，您需要知道它将保留的元素数量，以便nginx可以最佳地构建它。  需要配置的两个参数是<code>max_size</code>和<code>bucket_size</code> ，详见单独的<a href="hash.html">文档</a> 。  它们通常可由用户配置。  散列初始化设置与<code>ngx_hash_init_t</code>类型一起存储，散列本身为<code>ngx_hash_t</code> ： </p>
<pre class="notranslate">ngx_hash_t       foo_hash;
ngx_hash_init_t  hash;

hash.hash = &amp;foo_hash;
hash.key = ngx_hash_key;
hash.max_size = 512;
hash.bucket_size = ngx_align(64, ngx_cacheline_size);
hash.name = "foo_hash";
hash.pool = cf-&gt;pool;
hash.temp_pool = cf-&gt;temp_pool;
</pre>

<p>   <code>key</code>是指向函数的指针，该函数从字符串创建哈希整数键。  有两个通用的密钥创建函数： <code>ngx_hash_key(data, len)</code>和<code>ngx_hash_key_lc(data, len)</code> 。  后者将字符串转换为全部小写字符，因此传递的字符串必须是可写的。  如果不是这样，将<code>NGX_HASH_READONLY_KEY</code>标志传递给函数，初始化密钥数组（见下文）。 </p>
<p>  散列键存储在<code>ngx_hash_keys_arrays_t</code> ，并使用<code>ngx_hash_keys_array_init(arr, type)</code>初始化：第二个参数（ <code>type</code> ）控制为散列预分配的资源量，可以是<code>NGX_HASH_SMALL</code>或<code>NGX_HASH_LARGE</code> 。  如果您希望散列包含数千个元素，则后者是合适的。 </p>
<pre class="notranslate">ngx_hash_keys_arrays_t  foo_keys;

foo_keys.pool = cf-&gt;pool;
foo_keys.temp_pool = cf-&gt;temp_pool;

ngx_hash_keys_array_init(&amp;foo_keys, NGX_HASH_SMALL);
</pre>



<p>  要将键插入哈希键数组，请使用<code>ngx_hash_add_key(keys_array, key, value, flags)</code>函数： </p>
<pre class="notranslate">ngx_str_t k1 = ngx_string("key1");
ngx_str_t k2 = ngx_string("key2");

ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;my_data_ptr_1, NGX_HASH_READONLY_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;my_data_ptr_2, NGX_HASH_READONLY_KEY);
</pre>



<p>  要构建哈希表，请调用<code>ngx_hash_init(hinit, key_names, nelts)</code>函数： </p>
<pre class="notranslate">ngx_hash_init(&amp;hash, foo_keys.keys.elts, foo_keys.keys.nelts);
</pre>

<p>  如果<code>max_size</code>或<code>bucket_size</code>参数不够大，则该函数失败。 </p>
<p>  构建哈希时，使用<code>ngx_hash_find(hash, key, name, len)</code>函数查找元素： </p>
<pre class="notranslate">my_data_t   *data;
ngx_uint_t   key;

key = ngx_hash_key(k1.data, k1.len);

data = ngx_hash_find(&amp;foo_hash, key, k1.data, k1.len);
if (data == NULL) {
    /* key not found */
}
</pre>



<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><p>  要创建使用通配符的哈希，请使用<code>ngx_hash_combined_t</code>类型。  它包括上面描述的散列类型，并有两个额外的键数组： <code>dns_wc_head</code>和<code>dns_wc_tail</code> 。  基本属性的初始化类似于常规哈希： </p>
<pre class="notranslate">ngx_hash_init_t      hash
ngx_hash_combined_t  foo_hash;

hash.hash = &amp;foo_hash.hash;
hash.key = ...;
</pre>



<p>  可以使用<code>NGX_HASH_WILDCARD_KEY</code>标志添加通配符键： </p>
<pre class="notranslate">/* k1 = ".example.org"; */
/* k2 = "foo.*";        */
ngx_hash_add_key(&amp;foo_keys, &amp;k1, &amp;data1, NGX_HASH_WILDCARD_KEY);
ngx_hash_add_key(&amp;foo_keys, &amp;k2, &amp;data2, NGX_HASH_WILDCARD_KEY);
</pre>

<p>  该函数识别通配符并将键添加到相应的数组中。  有关通配符语法和匹配算法的说明，请参阅<a href="http/ngx_http_map_module.html#map">映射</a>模块文档。 </p>
<p>  根据添加的键的内容，您可能需要初始化最多三个键阵列：一个用于精确匹配（如上所述），另外两个用于从字符串的头部或尾部开始匹配： </p>
<pre class="notranslate">if (foo_keys.dns_wc_head.nelts) {

    ngx_qsort(foo_keys.dns_wc_head.elts,
              (size_t) foo_keys.dns_wc_head.nelts,
              sizeof(ngx_hash_key_t),
              cmp_dns_wildcards);

    hash.hash = NULL;
    hash.temp_pool = pool;

    if (ngx_hash_wildcard_init(&amp;hash, foo_keys.dns_wc_head.elts,
                               foo_keys.dns_wc_head.nelts)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    foo_hash.wc_head = (ngx_hash_wildcard_t *) hash.hash;
}
</pre>

<p>  需要对keys数组进行排序，并且必须将初始化结果添加到组合哈希中。   <code>dns_wc_tail</code>数组的初始化类似地完成。 </p>
<p>  组合哈希中的查找由<code>ngx_hash_find_combined(chash, key, name, len)</code> ： </p>
<pre class="notranslate">/* key = "bar.example.org"; — will match ".example.org" */
/* key = "foo.example.com"; — will match "foo.*"        */

hkey = ngx_hash_key(key.data, key.len);
res = ngx_hash_find_combined(&amp;foo_hash, hkey, key.data, key.len);
</pre>



<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>  要从系统堆分配内存，请使用以下函数： </p>
<ul>
<li><code>ngx_alloc(size, log)</code> - 从系统堆分配内存。  这是<code>malloc()</code>的包装，具有日志记录支持。  分配错误和调试信息将记录到<code>log</code> 。 -    <code>ngx_calloc(size, log)</code> - 从系统堆分配内存，如<code>ngx_alloc()</code> ，但在分配后用零填充内存。 -    <code>ngx_memalign(alignment, size, log)</code> - 从系统堆中分配对齐的内存。  这是提供该功能的那些平台上<code>posix_memalign()</code>的包装器。  否则，实现将回<code>ngx_alloc()</code> ，它提供了最大的对齐。 -    <code>ngx_free(p)</code> - 免费分配的内存。  这是<code>free()</code>的包装器 </li>
</ul>
<h4 id="池"><a href="#池" class="headerlink" title="池"></a>池</h4><p>  大多数nginx分配都是在池中完成的。  当池被销毁时，nginx池中分配的内存将自动释放。  这提供了良好的分配性能并使内存控制变得容易。 </p>
<p>  池内部在连续的内存块中分配对象。  块已满后，将分配一个新块并将其添加到池内存块列表中。  当请求的分配太大而无法容纳到块中时，请求将被转发到系统分配器，并且返回的指针将存储在池中以进一步解除分配。 </p>
<p>   nginx池的类型是<code>ngx_pool_t</code> 。  支持以下操作： </p>
<ul>
<li><code>ngx_create_pool(size, log)</code> - 创建具有指定块大小的池。  返回的池对象也在池中分配。   <code>size</code>至少应为<code>NGX_MIN_POOL_SIZE</code>和<code>NGX_MIN_POOL_SIZE</code>的倍数。 -    <code>ngx_destroy_pool(pool)</code> - 释放所有池内存，包括池对象本身。 -    <code>ngx_palloc(pool, size)</code> - 从指定的池中分配对齐的内存。 -    <code>ngx_pcalloc(pool, size)</code> - 从指定的池中分配对齐的内存并用零填充它。 -    <code>ngx_pnalloc(pool, size)</code> - 从指定的池中分配未对齐的内存。  主要用于分配字符串。 -    <code>ngx_pfree(pool, p)</code> - 以前在指定池中分配的<code>ngx_pfree(pool, p)</code>内存。  只能释放由转发到系统分配器的请求产生的分配。 </li>
</ul>
<pre class="notranslate">u_char      *p;
ngx_str_t   *s;
ngx_pool_t  *pool;

pool = ngx_create_pool(1024, log);
if (pool == NULL) { /* error */ }

s = ngx_palloc(pool, sizeof(ngx_str_t));
if (s == NULL) { /* error */ }
ngx_str_set(s, "foo");

p = ngx_pnalloc(pool, 3);
if (p == NULL) { /* error */ }
ngx_memcpy(p, "foo", 3);
</pre>

<p>  链接（ <code>ngx_chain_t</code> ）在nginx中被主动使用，因此nginx池实现提供了重用它们的方法。   <code>ngx_pool_t</code>的<code>chain</code>字段保留了先前分配的链接列表，可以重用。  要在池中有效分配链路链接，请使用<code>ngx_alloc_chain_link(pool)</code>功能。  此函数在池列表中查找自由链链接，并在池列表为空时分配新的链链接。  要释放链接，请调用<code>ngx_free_chain(pool, cl)</code>函数。 </p>
<p>  清理处理程序可以在池中注册。  清理处理程序是一个带有参数的回调函数，该函数在销毁池时调用。  池通常绑定到特定的nginx对象（如HTTP请求），并在对象到达其生命周期结束时被销毁。  注册池清理是释放资源，关闭文件描述符或对与主对象关联的共享数据进行最终调整的便捷方式。 </p>
<p>  要注册池清理，请调用<code>ngx_pool_cleanup_add(pool, size)</code> ，它返回一个要由调用者填写的<code>ngx_pool_cleanup_t</code>指针。  使用<code>size</code>参数为清理处理程序分配上下文。 </p>
<pre class="notranslate">ngx_pool_cleanup_t  *cln;

cln = ngx_pool_cleanup_add(pool, 0);
if (cln == NULL) { /* error */ }

cln-&gt;handler = ngx_my_cleanup;
cln-&gt;data = "foo";

...

static void
ngx_my_cleanup(void *data)
{
    u_char  *msg = data;

    ngx_do_smth(msg);
}
</pre>

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>   nginx使用共享内存在进程之间共享公共数据。   <code>ngx_shared_memory_add(cf, name, size, tag)</code>函数将新的共享内存条目<code>ngx_shm_zone_t</code>到循环中。  该函数接收区域的<code>name</code>和<code>size</code> 。  每个共享区域必须具有唯一名称。  如果已存在具有提供的<code>name</code>和<code>tag</code>的共享区域条目，则重用现有区域条目。  如果具有相同名称的现有条目具有不同的标记，则该函数将失败并显示错误。  通常，模块结构的地址作为<code>tag</code>传递，从而可以在一个nginx模块中按名称重用共享区域。 </p>
<p>  共享内存条目结构<code>ngx_shm_zone_t</code>具有以下字段： </p>
<ul>
<li><code>init</code> - 初始化回调，在共享区域映射到实际内存后调用 -    <code>data</code> - 数据上下文，用于将任意数据传递给<code>init</code>回调 -    <code>noreuse</code> - 禁用旧循环重用共享区域的标志 -    <code>tag</code> - 共享区域标记 -    <code>shm</code> - 类型为<code>ngx_shm_t</code>的特定于平台的对象，至少包含以下字段： <ul class="compact"><li>   <code>addr</code> - 映射共享内存地址，最初为NULL -    <code>size</code> - 共享内存大小 -    <code>name</code> - 共享内存名称 -    <code>log</code> - 共享内存日志 -    <code>exists</code> - 表示共享内存的标志是从主进程继承的（特定于Windows） </li>
</ul>
<p>  解析配置后，共享区域条目将映射到<code>ngx_init_cycle()</code>实际内存。  在POSIX系统上， <code>mmap()</code> syscall用于创建共享匿名映射。  在Windows上，使用<code>CreateFileMapping()</code> / <code>MapViewOfFileEx()</code>对。 </p>
<p>  对于在共享内存中分配，nginx提供slab池<code>ngx_slab_pool_t</code>类型。  在每个nginx共享区域中自动创建用于分配内存的slab池。  该池位于共享区域的开头，可以通过表达式<code>(ngx_slab_pool_t *) shm_zone-&amp;gt;shm.addr</code> 。  要在共享区域中分配内存，请调用<code>ngx_slab_alloc(pool, size)</code>或<code>ngx_slab_calloc(pool, size)</code> 。  要释放内存，请调用<code>ngx_slab_free(pool, p)</code> 。 </p>
<p>   Slab池将所有共享区域划分为页面。  每个页面用于分配相同大小的对象。  指定的大小必须是2的幂，并且大于8字节的最小大小。  不合格的值被四舍五入。  每个页面的位掩码跟踪正在使用哪些块以及哪些块可以自由分配。  对于大于半页（通常为2048字节）的大小，一次分配整个页面 </p>
<p>  要保护共享内存中的数据不受并发访问影响，请使用<code>ngx_slab_pool_t</code>的<code>mutex</code>字段中提供的<code>mutex</code> 。  在分配和释放内存时，板块池最常使用互斥锁，但它可用于保护共享区域中分配的任何其他用户数据结构。  要锁定或解锁互斥锁，请分别调用<code>ngx_shmtx_lock(&amp;amp;shpool-&amp;gt;mutex)</code>或<code>ngx_shmtx_unlock(&amp;amp;shpool-&amp;gt;mutex)</code> 。 </p>
<pre class="notranslate">ngx_str_t        name;
ngx_foo_ctx_t   *ctx;
ngx_shm_zone_t  *shm_zone;

ngx_str_set(&amp;name, "foo");

/* allocate shared zone context */
ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_foo_ctx_t));
if (ctx == NULL) {
    /* error */
}

/* add an entry for 64k shared zone */
shm_zone = ngx_shared_memory_add(cf, &amp;name, 65536, &amp;ngx_foo_module);
if (shm_zone == NULL) {
    /* error */
}

/* register init callback and context */
shm_zone-&gt;init = ngx_foo_init_zone;
shm_zone-&gt;data = ctx;


...


static ngx_int_t
ngx_foo_init_zone(ngx_shm_zone_t *shm_zone, void *data)
{
    ngx_foo_ctx_t  *octx = data;

    size_t            len;
    ngx_foo_ctx_t    *ctx;
    ngx_slab_pool_t  *shpool;

    value = shm_zone-&gt;data;

    if (octx) {
        /* reusing a shared zone from old cycle */
        ctx-&gt;value = octx-&gt;value;
        return NGX_OK;
    }

    shpool = (ngx_slab_pool_t *) shm_zone-&gt;shm.addr;

    if (shm_zone-&gt;shm.exists) {
        /* initialize shared zone context in Windows nginx worker */
        ctx-&gt;value = shpool-&gt;data;
        return NGX_OK;
    }

    /* initialize shared zone */

    ctx-&gt;value = ngx_slab_alloc(shpool, sizeof(ngx_uint_t));
    if (ctx-&gt;value == NULL) {
        return NGX_ERROR;
    }

    shpool-&gt;data = ctx-&gt;value;

    return NGX_OK;
}
</pre>

<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>  对于日志记录，nginx使用<code>ngx_log_t</code>对象。   nginx记录器支持几种类型的输出： </p>
<ul>
<li>stderr  - 记录到标准错误（stderr） -    file  - 记录到文件 -    syslog  - 记录到syslog -    memory  - 记录到内部存储器以用于开发目的;  稍后可以使用调试器访问内存 </li>
</ul>
<p>  记录器实例可以是记录器链，使用<code>next</code>字段相互链接。  在这种情况下，每条消息都写入链中的所有记录器。 </p>
<p>  对于每个记录器，严重性级别控制将哪些消息写入日志（仅记录分配了该级别或更高级别的事件）。  支持以下严重性级别： </p>
<ul>
<li><code>NGX_LOG_EMERG</code>  -  <code>NGX_LOG_ALERT</code>  -  <code>NGX_LOG_CRIT</code>  -  <code>NGX_LOG_ERR</code>  -  <code>NGX_LOG_WARN</code>  -  <code>NGX_LOG_NOTICE</code>  -  <code>NGX_LOG_INFO</code>  -  <code>NGX_LOG_DEBUG</code>  </li>
</ul>
<p>  对于调试日志记录，还会检查调试掩码。  调试掩码是： </p>
<ul>
<li><code>NGX_LOG_DEBUG_CORE</code>  -  <code>NGX_LOG_DEBUG_ALLOC</code>  -  <code>NGX_LOG_DEBUG_MUTEX</code>  -  <code>NGX_LOG_DEBUG_EVENT</code>  -  <code>NGX_LOG_DEBUG_HTTP</code>  -  <code>NGX_LOG_DEBUG_MAIL</code>  -  <code>NGX_LOG_DEBUG_STREAM</code>  </li>
</ul>
<p>  通常，记录器是由<code>error_log</code>指令中的现有nginx代码创建的，几乎在循环，配置，客户端连接和其他对象的每个处理阶段都可用。 </p>
<p>   Nginx提供以下日志记录宏： </p>
<ul>
<li><code>ngx_log_error(level, log, err, fmt, ...)</code> - 错误记录 -    <code>ngx_log_debug0(level, log, err, fmt)</code> ， <code>ngx_log_debug1(level, log, err, fmt, arg1)</code>等 - 使用最多八个支持的格式化参数调试日志记录 </li>
</ul>
<p>  日志消息在堆栈中的大小为<code>NGX_MAX_ERROR_STR</code> （当前为2048字节）的缓冲区中格式化。  该消息前面附有严重性级别，进程ID（PID），连接ID（存储在<code>log-&amp;gt;connection</code> ）和系统错误文本。  对于非调试消息，还调用<code>log-&amp;gt;handler</code>以将更多特定信息添加到日志消息中。   HTTP模块将<code>ngx_http_log_error()</code>函数设置为日志处理程序，以记录客户端和服务器地址，当前操作（存储在<code>log-&amp;gt;action</code> ），客户端请求行，服务器名称等。 </p>
<pre class="notranslate">/* specify what is currently done */
log-&gt;action = "sending mp4 to client";

/* error and debug log */
ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0, "client prematurely
              closed connection");

ngx_log_debug2(NGX_LOG_DEBUG_HTTP, mp4-&gt;file.log, 0,
               "mp4 start:%ui, length:%ui", mp4-&gt;start, mp4-&gt;length);
</pre>

<p>  上面的示例导致日志条目如下： </p>
<pre class="notranslate">2016/09/16 22:08:52 [info] 17445#0: *1 client prematurely closed connection while
sending mp4 to client, client: 127.0.0.1, server: , request: "GET /file.mp4 HTTP/1.1"
2016/09/16 23:28:33 [debug] 22140#0: *1 mp4 start:0, length:10000
</pre>

<h4 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h4><p>  循环对象存储从特定配置创建的nginx运行时上下文。  它的类型是<code>ngx_cycle_t</code> 。  当前循环由<code>ngx_cycle</code>全局变量引用，并在nginx worker启动时继承。  每次重新加载nginx配置时，都会从新的nginx配置创建一个新的循环;  成功创建新循环后，通常会删除旧循环。 </p>
<p>  循环由<code>ngx_init_cycle()</code>函数创建，该函数将前一个循环作为其参数。  该函数定位上一个循环的配置文件，并从前一个循环继承尽可能多的资源。  称为“初始循环”的占位符循环创建为nginx启动，然后由从配置构建的实际循环替换。 </p>
<p>  该周期的成员包括： </p>
<ul>
<li><code>pool</code> - 自行车游泳池  为每个新周期创建。 -    <code>log</code> - 循环日志。  最初从旧循环继承，在读取配置后将其设置为指向<code>new_log</code> 。 -    <code>new_log</code> - 由配置创建的循环日志。  它受根范围<code>error_log</code>指令的影响。 -    <code>connections</code> ， <code>connection_n</code> - 类型为<code>ngx_connection_t</code>的连接数组，由事件模块在初始化每个nginx worker时创建。   nginx配置中的<code>worker_connections</code>指令设置连接数<code>connection_n</code> 。 -    <code>free_connections</code> ， <code>free_connection_n</code> - 当前可用连接的列表和数量。  如果没有可用的连接，则nginx工作程序拒绝接受新客户端或连接到上游服务器。 -    <code>files</code> ， <code>files_n</code> - 用于将文件描述符映射到nginx连接的数组。  该映射由具有<code>NGX_USE_FD_EVENT</code>标志的事件模块使用（当前，它是<code>poll</code>和<code>devpoll</code> ）。 -    <code>conf_ctx</code> - 核心模块配置数组。  在读取nginx配置文件期间创建并填充配置。 -    <code>modules</code> ， <code>modules_n</code> - 由当前配置加载的<code>ngx_module_t</code>类型的模块数组，包括静态和动态模块。 -    <code>listening</code> - <code>ngx_listening_t</code>类型的侦听对象数组。  通常通过调用<code>ngx_create_listening()</code>函数的不同模块的<code>listen</code>指令添加侦听对象。  侦听套接字是基于侦听对象创建的。 -    <code>paths</code> - <code>ngx_path_t</code>类型的路径数组。  通过从将在某些目录上运行的模块调用函数<code>ngx_add_path()</code>来添加路径。  这些目录是在读取配置后由nginx创建的，如果缺少的话。  此外，可以为每个路径添加两个处理程序： <ul class="compact"><li>   path loader  - 在启动或重新加载nginx后，仅在60秒内执行一次。  通常，加载程序读取目录并将数据存储在nginx共享内存中。  从专用的nginx进程“nginx缓存加载器”调用该处理程序。 -   路径管理器 - 定期执行。  通常，管理器从目录中删除旧文件并更新nginx内存以反映更改。  处理程序从专用的“nginx缓存管理器”进程调用。 </li>
</ul>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>  对于输入/输出操作，nginx提供缓冲区类型<code>ngx_buf_t</code> 。  通常，它用于保存要写入目标或从源读取的数据。  缓冲区可以引用内存或文件中的数据，从技术上讲，缓冲区可以同时引用这两个数据。  缓冲区的内存是单独分配的，与缓冲区结构<code>ngx_buf_t</code> 。 </p>
<p>   <code>ngx_buf_t</code>结构包含以下字段： </p>
<ul>
<li><code>start</code> ， <code>end</code> - 为缓冲区分配的内存块的边界。 -    <code>pos</code> ， <code>last</code> - 内存缓冲区的边界;  通常是一个<code>start</code>的子范围.. <code>end</code> 。 -    <code>file_pos</code> ， <code>file_last</code> - 文件缓冲区的边界，表示为从文件开头的偏移量。 -    <code>tag</code> - 用于区分缓冲区的唯一值;  由不同的nginx模块创建，通常用于缓冲区重用。 -    <code>file</code> - 文件对象。 -    <code>temporary</code> - 指示缓冲区引用可写内存的标志。 -    <code>memory</code> - 指示缓冲区引用只读<code>memory</code>标志。 -    <code>in_file</code> - 指示缓冲区引用文件中数据的标志。 -    <code>flush</code> - 表示需要刷新缓冲区之前的所有数据的标志。 -    <code>recycled</code> - 表示缓冲区可以重用并需要尽快使用的标志。 -    <code>sync</code> - 表示缓冲区不携带数据或<code>flush</code>或<code>last_buf</code>等特殊信号的<code>last_buf</code> 。  默认情况下，nginx认为这样的缓冲区是一个错误条件，但是这个标志告诉nginx跳过错误检查。 -    <code>last_buf</code> - 表示缓冲区是输出中的最后一个的标志。 -    <code>last_in_chain</code> - 表示请求或子请求中不再有数据缓冲区的标志。 -    <code>shadow</code> - 引用与当前缓冲区相关的另一个（“shadow”）缓冲区，通常是缓冲区使用阴影中的数据。  消耗缓冲区时，通常还将阴影缓冲区标记为已消耗。 -    <code>last_shadow</code> - 指示缓冲区是引用特定影子缓冲区的最后一个缓冲区的标志。 -    <code>temp_file</code> - 指示缓冲区位于临时文件中的标志。 </li>
</ul>
<p>  对于输入和输出操作，缓冲区链接在一起。  链是<code>ngx_chain_t</code>类型的链序列，定义如下： </p>
<pre class="notranslate">typedef struct ngx_chain_s  ngx_chain_t;

struct ngx_chain_s {
    ngx_buf_t    *buf;
    ngx_chain_t  *next;
};
</pre>

<p>  每个链节都保持对其缓冲区的引用和对下一个链节的引用。 </p>
<p>  使用缓冲区和链的示例： </p>
<pre class="notranslate">ngx_chain_t *
ngx_get_my_chain(ngx_pool_t *pool)
{
    ngx_buf_t    *b;
    ngx_chain_t  *out, *cl, **ll;

    /* first buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_calloc_buf(pool);
    if (b == NULL) { /* error */ }

    b-&gt;start = (u_char *) "foo";
    b-&gt;pos = b-&gt;start;
    b-&gt;end = b-&gt;start + 3;
    b-&gt;last = b-&gt;end;
    b-&gt;memory = 1; /* read-only memory */

    cl-&gt;buf = b;
    out = cl;
    ll = &amp;cl-&gt;next;

    /* second buf */
    cl = ngx_alloc_chain_link(pool);
    if (cl == NULL) { /* error */ }

    b = ngx_create_temp_buf(pool, 3);
    if (b == NULL) { /* error */ }

    b-&gt;last = ngx_cpymem(b-&gt;last, "foo", 3);

    cl-&gt;buf = b;
    cl-&gt;next = NULL;
    *ll = cl;

    return out;
}
</pre>

<h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>  连接类型<code>ngx_connection_t</code>是套接字描述符的包装器。  它包括以下字段： </p>
<ul>
<li><code>fd</code> - 套接字描述符 -    <code>data</code> - 任意连接上下文。  通常，它是指向在连接之上构建的更高级别对象的指针，例如HTTP请求或Stream会话。 -    <code>read</code> ， <code>write</code> - 读取和写入连接事件。 -    <code>recv</code> ， <code>send</code> ， <code>recv_chain</code> ， <code>send_chain</code> - 连接的I / O操作。 -    <code>pool</code> - 连接池。 -    <code>log</code> - 连接日志。 -    <code>sockaddr</code> ， <code>socklen</code> ， <code>addr_text</code> - 二进制和文本形式的远程套接字地址。 -    <code>local_sockaddr</code> ， <code>local_socklen</code> - 二进制形式的本地套接字地址。  最初，这些字段为空。  使用<code>ngx_connection_local_sockaddr()</code>函数获取本地套接字地址。 -    <code>proxy_protocol_addr</code> ， <code>proxy_protocol_port</code> -  PROXY协议客户端地址和端口，如果为连接启用了PROXY协议。 -    <code>ssl</code> - 连接的SSL上下文。 -    <code>reusable</code> - 指示连接处于允许重用的状态的标志。 -    <code>close</code> - 表示正在重用连接并需要<code>close</code>标志。 </li>
</ul>
<p>   nginx连接可以透明地封装SSL层。  在这种情况下，连接的<code>ssl</code>字段包含指向<code>ngx_ssl_connection_t</code>结构的指针，保留连接的所有SSL相关数据，包括<code>SSL_CTX</code>和<code>SSL</code> 。   <code>recv</code> ， <code>send</code> ， <code>recv_chain</code>和<code>send_chain</code>处理程序也设置为启用SSL的函数。 </p>
<p>   nginx配置中的<code>worker_connections</code>指令限制了每个nginx worker的连接数。  当工人启动并存储在循环对象的<code>connections</code>字段中时，所有连接结构都是预先创建的。  要检索连接结构，请使用<code>ngx_get_connection(s, log)</code>函数。  它需要一个套接字描述符作为其参数，它需要包装在一个连接结构中。 </p>
<p> Because the number of connections per worker is limited, nginx provides a way to grab connections that are currently in use. To enable or disable reuse of a connection, call the <code>ngx_reusable_connection(c, reusable)</code> function. Calling <code>ngx_reusable_connection(c, 1)</code> sets the <code>reuse</code> flag in the connection structure and inserts the connection into the <code>reusable_connections_queue</code> of the cycle. Whenever <code>ngx_get_connection()</code> finds out there are no available connections in the cycle’s <code>free_connections</code> list, it calls <code>ngx_drain_connections()</code> to release a specific number of reusable connections. For each such connection, the <code>close</code> flag is set and its read handler is called which is supposed to free the connection by calling <code>ngx_close_connection(c)</code> and make it available for reuse. To exit the state when a connection can be reused <code>ngx_reusable_connection(c, 0)</code> is called. HTTP client connections are an example of reusable connections in nginx; they are marked as reusable until the first request byte is received from the client. </p>
<h4 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p> Event object <code>ngx_event_t</code> in nginx provides a mechanism for notification that a specific event has occurred. </p>
<p> Fields in <code>ngx_event_t</code> include: </p>
<ul>
<li><code>data</code> — Arbitrary event context used in event handlers, usually as pointer to a connection related to the event. -  <code>handler</code> — Callback function to be invoked when the event happens. -  <code>write</code> — Flag indicating a write event. Absence of the flag indicates a read event. -  <code>active</code> — Flag indicating that the event is registered for receiving I/O notifications, normally from notification mechanisms like <code>epoll</code> , <code>kqueue</code> , <code>poll</code> . -  <code>ready</code> — Flag indicating that the event has received an I/O notification. -  <code>delayed</code> — Flag indicating that I/O is delayed due to rate limiting. -  <code>timer</code> — Red-black tree node for inserting the event into the timer tree. -  <code>timer_set</code> — Flag indicating that the event timer is set and not yet expired. -  <code>timedout</code> — Flag indicating that the event timer has expired. -  <code>eof</code> — Flag indicating that EOF occurred while reading data. -  <code>pending_eof</code> — Flag indicating that EOF is pending on the socket, even though there may be some data available before it. The flag is delivered via the <code>EPOLLRDHUP</code> <code>epoll</code> event or <code>EV_EOF</code> <code>kqueue</code> flag. -  <code>error</code> — Flag indicating that an error occurred during reading (for a read event) or writing (for a write event). -  <code>cancelable</code> — Timer event flag indicating that the event should be ignored while shutting down the worker. Graceful worker shutdown is delayed until there are no non-cancelable timer events scheduled. -  <code>posted</code> — Flag indicating that the event is posted to a queue. -  <code>queue</code> — Queue node for posting the event to a queue. </li>
</ul>
<h4 id="I-O-events"><a href="#I-O-events" class="headerlink" title="I/O events"></a>I/O events</h4><p> Each connection obtained by calling the <code>ngx_get_connection()</code> function has two attached events, <code>c-&amp;gt;read</code> and <code>c-&amp;gt;write</code> , which are used for receiving notification that the socket is ready for reading or writing. All such events operate in Edge-Triggered mode, meaning that they only trigger notifications when the state of the socket changes. For example, doing a partial read on a socket does not make nginx deliver a repeated read notification until more data arrives on the socket. Even when the underlying I/O notification mechanism is essentially Level-Triggered ( <code>poll</code> , <code>select</code> etc), nginx converts the notifications to Edge-Triggered. To make nginx event notifications consistent across all notifications systems on different platforms, the functions <code>ngx_handle_read_event(rev, flags)</code> and <code>ngx_handle_write_event(wev, lowat)</code> must be called after handling an I/O socket notification or calling any I/O functions on that socket. Normally, the functions are called once at the end of each read or write event handler. </p>
<h4 id="Timer-events"><a href="#Timer-events" class="headerlink" title="Timer events"></a>Timer events</h4><p> An event can be set to send a notification when a timeout expires. The timer used by events counts milliseconds since some unspecified point in the past truncated to <code>ngx_msec_t</code> type. Its current value can be obtained from the <code>ngx_current_msec</code> variable. </p>
<p> The function <code>ngx_add_timer(ev, timer)</code> sets a timeout for an event, <code>ngx_del_timer(ev)</code> deletes a previously set timeout. The global timeout red-black tree <code>ngx_event_timer_rbtree</code> stores all timeouts currently set. The key in the tree is of type <code>ngx_msec_t</code> and is the time when the event occurs. The tree structure enables fast insertion and deletion operations, as well as access to the nearest timeouts, which nginx uses to find out how long to wait for I/O events and for expiring timeout events. </p>
<h4 id="Posted-events"><a href="#Posted-events" class="headerlink" title="Posted events"></a>Posted events</h4><p> An event can be posted which means that its handler will be called at some point later within the current event loop iteration. Posting events is a good practice for simplifying code and escaping stack overflows. Posted events are held in a post queue. The <code>ngx_post_event(ev, q)</code> mscro posts the event <code>ev</code> to the post queue <code>q</code> . The <code>ngx_delete_posted_event(ev)</code> macro deletes the event <code>ev</code> from the queue it’s currently posted in. Normally, events are posted to the <code>ngx_posted_events</code> queue, which is processed late in the event loop — after all I/O and timer events are already handled. The function <code>ngx_event_process_posted()</code> is called to process an event queue. It calls event handlers until the queue is not empty. This means that a posted event handler can post more events to be processed within the current event loop iteration. </p>
<p>  一个例子： </p>
<pre class="notranslate">void
ngx_my_connection_read(ngx_connection_t *c)
{
    ngx_event_t  *rev;

    rev = c-&gt;read;

    ngx_add_timer(rev, 1000);

    rev-&gt;handler = ngx_my_read_handler;

    ngx_my_read(rev);
}


void
ngx_my_read_handler(ngx_event_t *rev)
{
    ssize_t            n;
    ngx_connection_t  *c;
    u_char             buf[256];

    if (rev-&gt;timedout) { /* timeout expired */ }

    c = rev-&gt;data;

    while (rev-&gt;ready) {
        n = c-&gt;recv(c, buf, sizeof(buf));

        if (n == NGX_AGAIN) {
            break;
        }

        if (n == NGX_ERROR) { /* error */ }

        /* process buf */
    }

    if (ngx_handle_read_event(rev, 0) != NGX_OK) { /* error */ }
}
</pre>

<h4 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h4><p> Except for the nginx master process, all nginx processes do I/O and so have an event loop. (The nginx master process instead spends most of its time in the <code>sigsuspend()</code> call waiting for signals to arrive.) The nginx event loop is implemented in the <code>ngx_process_events_and_timers()</code> function, which is called repeatedly until the process exits. </p>
<p> The event loop has the following stages: </p>
<ul>
<li>Find the timeout that is closest to expiring, by calling <code>ngx_event_find_timer()</code> . This function finds the leftmost node in the timer tree and returns the number of milliseconds until the node expires. -  Process I/O events by calling a handler, specific to the event notification mechanism, chosen by nginx configuration. This handler waits for at least one I/O event to happen, but only until the next timeout expires. When a read or write event occurs, the <code>ready</code> flag is set and the event’s handler is called. For Linux, the <code>ngx_epoll_process_events()</code> handler is normally used, which calls <code>epoll_wait()</code> to wait for I/O events. -  Expire timers by calling <code>ngx_event_expire_timers()</code> . The timer tree is iterated from the leftmost element to the right until an unexpired timeout is found. For each expired node the <code>timedout</code> event flag is set, the <code>timer_set</code> flag is reset, and the event handler is called -  Process posted events by calling <code>ngx_event_process_posted()</code> . The function repeatedly removes the first element from the posted events queue and calls the element’s handler, until the queue is empty. </li>
</ul>
<p> All nginx processes handle signals as well. Signal handlers only set global variables which are checked after the <code>ngx_process_events_and_timers()</code> call. </p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p> There are several types of processes in nginx. The type of a process is kept in the <code>ngx_process</code> global variable, and is one of the following: </p>
<ul>
<li><code>NGX_PROCESS_MASTER</code> — The master process, which reads the NGINX configuration, creates cycles, and starts and controls child processes. It does not perform any I/O and responds only to signals. Its cycle function is <code>ngx_master_process_cycle()</code> . -  <code>NGX_PROCESS_WORKER</code> — The worker process, which handles client connections. It is started by the master process and responds to its signals and channel commands as well. Its cycle function is <code>ngx_worker_process_cycle()</code> . There can be multiple worker processes, as configured by the <code>worker_processes</code> directive. -  <code>NGX_PROCESS_SINGLE</code> — The single process, which exists only in <code>master_process off</code> mode, and is the only process running in that mode. It creates cycles (like the master process does) and handles client connections (like the worker process does). Its cycle function is <code>ngx_single_process_cycle()</code> . -  <code>NGX_PROCESS_HELPER</code> — The helper process, of which currently there are two types: cache manager and cache loader. The cycle function for both is <code>ngx_cache_manager_process_cycle()</code> .<br>The nginx processes handle the following signals: </li>
<li><code>NGX_SHUTDOWN_SIGNAL</code> ( <code>SIGQUIT</code> on most systems) — Gracefully shutdown. Upon receiving this signal, the master process sends a shutdown signal to all child processes. When no child processes are left, the master destroys the cycle pool and exits. When a worker process receives this signal, it closes all listening sockets and waits until there are no non-cancelable events scheduled, then destroys the cycle pool and exits. When the cache manager or the cache loader process receives this signal, it exits immediately. The <code>ngx_quit</code> variable is set to <code>1</code> when a process receives this signal, and is immediately reset after being processed. The <code>ngx_exiting</code> variable is set to <code>1</code> while a worker process is in the shutdown state. -  <code>NGX_TERMINATE_SIGNAL</code> ( <code>SIGTERM</code> on most systems) — Terminate. Upon receiving this signal, the master process sends a terminate signal to all child processes. If a child process does not exit within 1 second, the master process sends the <code>SIGKILL</code> signal to kill it. When no child processes are left, the master process destroys the cycle pool and exits. When a worker process, the cache manager process or the cache loader process receives this signal, it destroys the cycle pool and exits. The variable <code>ngx_terminate</code> is set to <code>1</code> when this signal is received. -  <code>NGX_NOACCEPT_SIGNAL</code> ( <code>SIGWINCH</code> on most systems) - Shut down all worker and helper processes. Upon receiving this signal, the master process shuts down its child processes. If a previously started new nginx binary exits, the child processes of the old master are started again. When a worker process receives this signal, it shuts down in debug mode set by the <code>debug_points</code> directive. -  <code>NGX_RECONFIGURE_SIGNAL</code> ( <code>SIGHUP</code> on most systems) - Reconfigure. Upon receiving this signal, the master process re-reads the configuration and creates a new cycle based on it. If the new cycle is created successfully, the old cycle is deleted and new child processes are started. Meanwhile, the old child processes receive the <code>NGX_SHUTDOWN_SIGNAL</code> signal. In single-process mode, nginx creates a new cycle, but keeps the old one until there are no longer clients with active connections tied to it. The worker and helper processes ignore this signal. -  <code>NGX_REOPEN_SIGNAL</code> ( <code>SIGUSR1</code> on most systems) — Reopen files. The master process sends this signal to workers, which reopen all <code>open_files</code> related to the cycle. -  <code>NGX_CHANGEBIN_SIGNAL</code> ( <code>SIGUSR2</code> on most systems) — Change the nginx binary. The master process starts a new nginx binary and passes in a list of all listen sockets. The text-format list, passed in the <code>“NGINX”</code> environment variable, consists of descriptor numbers separated with semicolons. The new nginx binary reads the <code>“NGINX”</code> variable and adds the sockets to its init cycle. Other processes ignore this signal.<br>While all nginx worker processes are able to receive and properly handle POSIX signals, the master process does not use the standard <code>kill()</code> syscall to pass signals to workers and helpers. Instead, nginx uses inter-process socket pairs which allow sending messages between all nginx processes. Currently, however, messages are only sent from the master to its children. The messages carry the standard signals. </li>
</ul>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p> It is possible to offload into a separate thread tasks that would otherwise block the nginx worker process. For example, nginx can be configured to use threads to perform <a href="http/ngx_http_core_module.html#aio">file I/O</a> . Another use case is a library that doesn’t have asynchronous interface and thus cannot be normally used with nginx. Keep in mind that the threads interface is a helper for the existing asynchronous approach to processing client connections, and by no means intended as a replacement. </p>
<p> To deal with synchronization, the following wrappers over <code>pthreads</code> primitives are available: </p>
<ul>
<li><code>typedef pthread_mutex_t ngx_thread_mutex_t;</code> <ul class="compact"> <li> <code>ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>   -  <code>ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log);</code>  -  <code>ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx, ngx_log_t *log);</code>  </li>
</ul>
<p> Instead of creating a new thread for each task, nginx implements a <a href="ngx_core_module.html#thread_pool">thread_pool</a> strategy. Multiple thread pools may be configured for different purposes (for example, performing I/O on different sets of disks). Each thread pool is created at startup and contains a limited number of threads that process a queue of tasks. When a task is completed, a predefined completion handler is called. </p>
<p> The <code>src/core/ngx_thread_pool.h</code> header file contains relevant definitions: </p>
<pre class="notranslate">struct ngx_thread_task_s {
    ngx_thread_task_t   *next;
    ngx_uint_t           id;
    void                *ctx;
    void               (*handler)(void *data, ngx_log_t *log);
    ngx_event_t          event;
};

typedef struct ngx_thread_pool_s  ngx_thread_pool_t;

ngx_thread_pool_t *ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name);
ngx_thread_pool_t *ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name);

ngx_thread_task_t *ngx_thread_task_alloc(ngx_pool_t *pool, size_t size);
ngx_int_t ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task);

</pre>

<p> At configuration time, a module willing to use threads has to obtain a reference to a thread pool by calling <code>ngx_thread_pool_add(cf, name)</code> , which either creates a new thread pool with the given <code>name</code> or returns a reference to the pool with that name if it already exists. </p>
<p> To add a <code>task</code> into a queue of a specified thread pool <code>tp</code> at runtime, use the <code>ngx_thread_task_post(tp, task)</code> function. To execute a function in a thread, pass parameters and setup a completion handler using the <code>ngx_thread_task_t</code> structure: </p>
<pre class="notranslate">typedef struct {
    int    foo;
} my_thread_ctx_t;


static void
my_thread_func(void *data, ngx_log_t *log)
{
    my_thread_ctx_t *ctx = data;

    /* this function is executed in a separate thread */
}


static void
my_thread_completion(ngx_event_t *ev)
{
    my_thread_ctx_t *ctx = ev-&gt;data;

    /* executed in nginx event loop */
}


ngx_int_t
my_task_offload(my_conf_t *conf)
{
    my_thread_ctx_t    *ctx;
    ngx_thread_task_t  *task;

    task = ngx_thread_task_alloc(conf-&gt;pool, sizeof(my_thread_ctx_t));
    if (task == NULL) {
        return NGX_ERROR;
    }

    ctx = task-&gt;ctx;

    ctx-&gt;foo = 42;

    task-&gt;handler = my_thread_func;
    task-&gt;event.handler = my_thread_completion;
    task-&gt;event.data = ctx;

    if (ngx_thread_task_post(conf-&gt;thread_pool, task) != NGX_OK) {
        return NGX_ERROR;
    }

    return NGX_OK;
}
</pre>



<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><h4 id="Adding-new-modules"><a href="#Adding-new-modules" class="headerlink" title="Adding new modules"></a>Adding new modules</h4><p> Each standalone nginx module resides in a separate directory that contains at least two files: <code>config</code> and a file with the module source code. The <code>config</code> file contains all information needed for nginx to integrate the module, for example: </p>
<pre class="notranslate">ngx_module_type=CORE
ngx_module_name=ngx_foo_module
ngx_module_srcs="$ngx_addon_dir/ngx_foo_module.c"

. auto/module

ngx_addon_name=$ngx_module_name
</pre>

<p> The <code>config</code> file is a POSIX shell script that can set and access the following variables: </p>
<ul>
<li><code>ngx_module_type</code> — Type of module to build. Possible values are <code>CORE</code> , <code>HTTP</code> , <code>HTTP_FILTER</code> , <code>HTTP_INIT_FILTER</code> , <code>HTTP_AUX_FILTER</code> , <code>MAIL</code> , <code>STREAM</code> , or <code>MISC</code> . -  <code>ngx_module_name</code> — Module names. To build multiple modules from a set of source files, specify a whitespace-separated list of names. The first name indicates the name of the output binary for the dynamic module. The names in the list must match the names used in the source code. -  <code>ngx_addon_name</code> — Name of the module as it appears in output on the console from the configure script. -  <code>ngx_module_srcs</code> — Whitespace-separated list of source files used to compile the module. The <code>$ngx_addon_dir</code> variable can be used to represent the path to the module directory. -  <code>ngx_module_incs</code> — Include paths required to build the module -  <code>ngx_module_deps</code> — Whitespace-separated list of the module’s dependencies. Usually, it is the list of header files. -  <code>ngx_module_libs</code> — Whitespace-separated list of libraries to link with the module. For example, use <code>ngx_module_libs=-lpthread</code> to link <code>libpthread</code> library. The following macros can be used to link against the same libraries as nginx: <code>LIBXSLT</code> , <code>LIBGD</code> , <code>GEOIP</code> , <code>PCRE</code> , <code>OPENSSL</code> , <code>MD5</code> , <code>SHA1</code> , <code>ZLIB</code> , and <code>PERL</code> . -  <code>ngx_module_link</code> — Variable set by the build system to <code>DYNAMIC</code> for a dynamic module or <code>ADDON</code> for a static module and used to determine different actions to perform depending on linking type. -  <code>ngx_module_order</code> — Load order for the module; useful for the <code>HTTP_FILTER</code> and <code>HTTP_AUX_FILTER</code> module types. The format for this option is a whitespace-separated list of modules. All modules in the list following the current module’s name end up after it in the global list of modules, which sets up the order for modules initialization. For filter modules later initialization means earlier execution.  The following modules are typically used as references. The <code>ngx_http_copy_filter_module</code> reads the data for other filter modules and is placed near the bottom of the list so that it is one of the first to be executed. The <code>ngx_http_write_filter_module</code> writes the data to the client socket and is placed near the top of the list, and is the last to be executed.  By default, filter modules are placed before the <code>ngx_http_copy_filter</code> in the module list so that the filter handler is executed after the copy filter handler. For other module types the default is the empty string.<br>To compile a module into nginx statically, use the <code>--add-module=/path/to/module</code> argument to the configure script. To compile a module for later dynamic loading into nginx, use the <code>--add-dynamic-module=/path/to/module</code> argument. </li>
</ul>
<h4 id="Core-Modules"><a href="#Core-Modules" class="headerlink" title="Core Modules"></a>Core Modules</h4><p> Modules are the building blocks of nginx, and most of its functionality is implemented as modules. The module source file must contain a global variable of type <code>ngx_module_t</code> , which is defined as follows: </p>
<pre class="notranslate">struct ngx_module_s {

    /* private part is omitted */

    void                 *ctx;
    ngx_command_t        *commands;
    ngx_uint_t            type;

    ngx_int_t           (*init_master)(ngx_log_t *log);

    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
    void                (*exit_thread)(ngx_cycle_t *cycle);
    void                (*exit_process)(ngx_cycle_t *cycle);

    void                (*exit_master)(ngx_cycle_t *cycle);

    /* stubs for future extensions are omitted */
};
</pre>

<p> The omitted private part includes the module version and a signature and is filled using the predefined macro <code>NGX_MODULE_V1</code> . </p>
<p> Each module keeps its private data in the <code>ctx</code> field, recognizes the configuration directives, specified in the <code>commands</code> array, and can be invoked at certain stages of nginx lifecycle. The module lifecycle consists of the following events: </p>
<ul>
<li><p>Configuration directive handlers are called as they appear in configuration files in the context of the master process. -  After the configuration is parsed successfully, <code>init_module</code> handler is called in the context of the master process. The <code>init_module</code> handler is called in the master process each time a configuration is loaded. -  The master process creates one or more worker processes and the <code>init_process</code> handler is called in each of them. -  When a worker process receives the shutdown or terminate command from the master, it invokes the <code>exit_process</code> handler. -  The master process calls the <code>exit_master</code> handler before exiting.<br>Because threads are used in nginx only as a supplementary I/O facility with its own API, <code>init_thread</code> and <code>exit_thread</code> handlers are not currently called. There is also no <code>init_master</code> handler, because it would be unnecessary overhead. </p>
<p>The module <code>type</code> defines exactly what is stored in the <code>ctx</code> field. Its value is one of the following types: </p>
</li>
<li><p><code>NGX_CORE_MODULE</code>  -  <code>NGX_EVENT_MODULE</code>  -  <code>NGX_HTTP_MODULE</code>  -  <code>NGX_MAIL_MODULE</code>  -  <code>NGX_STREAM_MODULE</code><br>The <code>NGX_CORE_MODULE</code> is the most basic and thus the most generic and most low-level type of module. The other module types are implemented on top of it and provide a more convenient way to deal with corresponding domains, like handling events or HTTP requests. </p>
<p>The set of core modules includes <code>ngx_core_module</code> , <code>ngx_errlog_module</code> , <code>ngx_regex_module</code> , <code>ngx_thread_pool_module</code> and <code>ngx_openssl_module</code> modules. The HTTP module, the stream module, the mail module and event modules are core modules too. The context of a core module is defined as: </p>
</li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_str_t             name;
    void               *(*create_conf)(ngx_cycle_t *cycle);
    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;
</pre>

<p> where the <code>name</code> is a module name string, <code>create_conf</code> and <code>init_conf</code> are pointers to functions that create and initialize module configuration respectively. For core modules, nginx calls <code>create_conf</code> before parsing a new configuration and <code>init_conf</code> after all configuration is parsed successfully. The typical <code>create_conf</code> function allocates memory for the configuration and sets default values. </p>
<p> For example, a simplistic module called <code>ngx_foo_module</code> might look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author.
 */


#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;


typedef struct {
    ngx_flag_t  enable;
} ngx_foo_conf_t;


static void *ngx_foo_create_conf(ngx_cycle_t *cycle);
static char *ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf);

static char *ngx_foo_enable(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_enable_post = { ngx_foo_enable };


static ngx_command_t  ngx_foo_commands[] = {

    { ngx_string("foo_enabled"),
      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      0,
      offsetof(ngx_foo_conf_t, enable),
      &amp;ngx_foo_enable_post },

      ngx_null_command
};


static ngx_core_module_t  ngx_foo_module_ctx = {
    ngx_string("foo"),
    ngx_foo_create_conf,
    ngx_foo_init_conf
};


ngx_module_t  ngx_foo_module = {
    NGX_MODULE_V1,
    &amp;ngx_foo_module_ctx,                   /* module context */
    ngx_foo_commands,                      /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static void *
ngx_foo_create_conf(ngx_cycle_t *cycle)
{
    ngx_foo_conf_t  *fcf;

    fcf = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_foo_conf_t));
    if (fcf == NULL) {
        return NULL;
    }

    fcf-&gt;enable = NGX_CONF_UNSET;

    return fcf;
}


static char *
ngx_foo_init_conf(ngx_cycle_t *cycle, void *conf)
{
    ngx_foo_conf_t *fcf = conf;

    ngx_conf_init_value(fcf-&gt;enable, 0);

    return NGX_CONF_OK;
}


static char *
ngx_foo_enable(ngx_conf_t *cf, void *post, void *data)
{
    ngx_flag_t  *fp = data;

    if (*fp == 0) {
        return NGX_CONF_OK;
    }

    ngx_log_error(NGX_LOG_NOTICE, cf-&gt;log, 0, "Foo Module is enabled");

    return NGX_CONF_OK;
}
</pre>



<h4 id="Configuration-Directives"><a href="#Configuration-Directives" class="headerlink" title="Configuration Directives"></a>Configuration Directives</h4><p> The <code>ngx_command_t</code> type defines a single configuration directive. Each module that supports configuration provides an array of such structures that describe how to process arguments and what handlers to call: </p>
<pre class="notranslate">typedef struct ngx_command_s  ngx_command_t;

struct ngx_command_s {
    ngx_str_t             name;
    ngx_uint_t            type;
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    ngx_uint_t            conf;
    ngx_uint_t            offset;
    void                 *post;
};
</pre>

<p> Terminate the array with the special value <code>ngx_null_command</code> . The <code>name</code> is the name of a directive as it appears in the configuration file, for example “worker_processes” or “listen”. The <code>type</code> is a bit-field of flags that specify the number of arguments the directive takes, its type, and the context in which it appears. The flags are: </p>
<ul>
<li><code>NGX_CONF_NOARGS</code> — Directive takes no arguments. -  <code>NGX_CONF_1MORE</code> — Directive takes one or more arguments. -  <code>NGX_CONF_2MORE</code> — Directive takes two or more arguments. -  <code>NGX_CONF_TAKE1</code> .. <code>NGX_CONF_TAKE7</code> — Directive takes exactly the indicated number of arguments. -  <code>NGX_CONF_TAKE12</code> , <code>NGX_CONF_TAKE13</code> , <code>NGX_CONF_TAKE23</code> , <code>NGX_CONF_TAKE123</code> , <code>NGX_CONF_TAKE1234</code> — Directive may take different number of arguments. Options are limited to the given numbers. For example, <code>NGX_CONF_TAKE12</code> means it takes one or two arguments.<br>The flags for directive types are: </li>
<li><code>NGX_CONF_BLOCK</code> — Directive is a block, that is, it can contain other directives within its opening and closing braces, or even implement its own parser to handle contents inside. -  <code>NGX_CONF_FLAG</code> — Directive takes a boolean value, either <code>on</code> or <code>off</code> .<br>A directive’s context defines where it may appear in the configuration: </li>
<li><p><code>NGX_MAIN_CONF</code> — In the top level context. -  <code>NGX_HTTP_MAIN_CONF</code> — In the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF</code> — In a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF</code> — In a <code>location</code> block within the <code>http</code> block. -  <code>NGX_HTTP_UPS_CONF</code> — In an <code>upstream</code> block within the <code>http</code> block. -  <code>NGX_HTTP_SIF_CONF</code> — In an <code>if</code> block within a <code>server</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LIF_CONF</code> — In an <code>if</code> block within a <code>location</code> block in the <code>http</code> block. -  <code>NGX_HTTP_LMT_CONF</code> — In a <code>limit_except</code> block within the <code>http</code> block. -  <code>NGX_STREAM_MAIN_CONF</code> — In the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF</code> — In a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_STREAM_UPS_CONF</code> — In an <code>upstream</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF</code> — In the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF</code> — In a <code>server</code> block within the <code>mail</code> block. -  <code>NGX_EVENT_CONF</code> — In the <code>event</code> block. -  <code>NGX_DIRECT_CONF</code> — Used by modules that don’t create a hierarchy of contexts and only have one global configuration. This configuration is passed to the handler as the <code>conf</code> argument.<br>The configuration parser uses these flags to throw an error in case of a misplaced directive and calls directive handlers supplied with a proper configuration pointer, so that the same directives in different locations can store their values in distinct places. </p>
<p>The <code>set</code> field defines a handler that processes a directive and stores parsed values into the corresponding configuration. There’s a number of functions that perform common conversions: </p>
</li>
<li><code>ngx_conf_set_flag_slot</code> — Converts the literal strings <code>on</code> and <code>off</code> into an <code>ngx_flag_t</code> value with values 1 or 0, respectively. -  <code>ngx_conf_set_str_slot</code> — Stores a string as a value of the <code>ngx_str_t</code> type. -  <code>ngx_conf_set_str_array_slot</code> — Appends a value to an array <code>ngx_array_t</code> of strings <code>ngx_str_t</code> . The array is created if does not already exist. -  <code>ngx_conf_set_keyval_slot</code> — Appends a key-value pair to an array <code>ngx_array_t</code> of key-value pairs <code>ngx_keyval_t</code> . The first string becomes the key and the second the value. The array is created if it does not already exist. -  <code>ngx_conf_set_num_slot</code> — Converts a directive’s argument to an <code>ngx_int_t</code> value. -  <code>ngx_conf_set_size_slot</code> — Converts a <a href="syntax.html">size</a> to a <code>size_t</code> value expressed in bytes. -  <code>ngx_conf_set_off_slot</code> — Converts an <a href="syntax.html">offset</a> to an <code>off_t</code> value expressed in bytes. -  <code>ngx_conf_set_msec_slot</code> — Converts a <a href="syntax.html">time</a> to an <code>ngx_msec_t</code> value expressed in milliseconds. -  <code>ngx_conf_set_sec_slot</code> — Converts a <a href="syntax.html">time</a> to a <code>time_t</code> value expressed in in seconds. -  <code>ngx_conf_set_bufs_slot</code> — Converts the two supplied arguments into an <code>ngx_bufs_t</code> object that holds the number and <a href="syntax.html">size</a> of buffers. -  <code>ngx_conf_set_enum_slot</code> — Converts the supplied argument into an <code>ngx_uint_t</code> value. The null-terminated array of <code>ngx_conf_enum_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding integer values. -  <code>ngx_conf_set_bitmask_slot</code> — Converts the supplied arguments into an <code>ngx_uint_t</code> value. The mask values for each argument are ORed producing the result. The null-terminated array of <code>ngx_conf_bitmask_t</code> passed in the <code>post</code> field defines the acceptable strings and corresponding mask values. -  <code>set_path_slot</code> — Converts the supplied arguments to an <code>ngx_path_t</code> value and performs all required initializations. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_temp_path">proxy_temp_path</a> directive. -  <code>set_access_slot</code> — Converts the supplied arguments to a file permissions mask. For details, see the documentation for the <a href="http/ngx_http_proxy_module.html#proxy_store_access">proxy_store_access</a> directive. </li>
</ul>
<p> The <code>conf</code> field defines which configuration structure is passed to the directory handler. Core modules only have the global configuration and set <code>NGX_DIRECT_CONF</code> flag to access it. Modules like HTTP, Stream or Mail create hierarchies of configurations. For example, a module’s configuration is created for <code>server</code> , <code>location</code> and <code>if</code> scopes. </p>
<ul>
<li><code>NGX_HTTP_MAIN_CONF_OFFSET</code> — Configuration for the <code>http</code> block. -  <code>NGX_HTTP_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>http</code> block. -  <code>NGX_HTTP_LOC_CONF_OFFSET</code> — Configuration for a <code>location</code> block within the <code>http</code> . -  <code>NGX_STREAM_MAIN_CONF_OFFSET</code> — Configuration for the <code>stream</code> block. -  <code>NGX_STREAM_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>stream</code> block. -  <code>NGX_MAIL_MAIN_CONF_OFFSET</code> — Configuration for the <code>mail</code> block. -  <code>NGX_MAIL_SRV_CONF_OFFSET</code> — Configuration for a <code>server</code> block within the <code>mail</code> block. </li>
</ul>
<p> The <code>offset</code> defines the offset of a field in a module configuration structure that holds values for this particular directive. The typical use is to employ the <code>offsetof()</code> macro. </p>
<p> The <code>post</code> field has two purposes: it may be used to define a handler to be called after the main handler has completed, or to pass additional data to the main handler. In the first case, the <code>ngx_conf_post_t</code> structure needs to be initialized with a pointer to the handler, for example: </p>
<pre class="notranslate">static char *ngx_do_foo(ngx_conf_t *cf, void *post, void *data);
static ngx_conf_post_t  ngx_foo_post = { ngx_do_foo };
</pre>

<p> The <code>post</code> argument is the <code>ngx_conf_post_t</code> object itself, and the <code>data</code> is a pointer to the value, converted from arguments by the main handler with the appropriate type. </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h4 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h4><p> Each HTTP client connection runs through the following stages: </p>
<ul>
<li><p><code>ngx_event_accept()</code> accepts a client TCP connection. This handler is called in response to a read notification on a listen socket. A new <code>ngx_connecton_t</code> object is created at this stage to wrap the newly accepted client socket. Each nginx listener provides a handler to pass the new connection object to. For HTTP connections it’s <code>ngx_http_init_connection(c)</code> . -  <code>ngx_http_init_connection()</code> performs early initialization of the HTTP connection. At this stage an <code>ngx_http_connection_t</code> object is created for the connection and its reference is stored in the connection’s <code>data</code> field. Later it will be replaced by an HTTP request object. A PROXY protocol parser and the SSL handshake are started at this stage as well. -  <code>ngx_http_wait_request_handler()</code> read event handler is called when data is available on the client socket. At this stage an HTTP request object <code>ngx_http_request_t</code> is created and set to the connection’s <code>data</code> field. -  <code>ngx_http_process_request_line()</code> read event handler reads client request line. The handler is set by <code>ngx_http_wait_request_handler()</code> . The data is read into connection’s <code>buffer</code> . The size of the buffer is initially set by the directive <a href="http/ngx_http_core_module.html#client_header_buffer_size">client_header_buffer_size</a> . The entire client header is supposed to fit in the buffer. If the initial size is not sufficient, a bigger buffer is allocated, with the capacity set by the <code>large_client_header_buffers</code> directive. -  <code>ngx_http_process_request_headers()</code> read event handler, is set after <code>ngx_http_process_request_line()</code> to read the client request header. -  <code>ngx_http_core_run_phases()</code> is called when the request header is completely read and parsed. This function runs request phases from <code>NGX_HTTP_POST_READ_PHASE</code> to <code>NGX_HTTP_CONTENT_PHASE</code> . The last phase is intended to generate a response and pass it along the filter chain. The response is not necessarily sent to the client at this phase. It might remain buffered and be sent at the finalization stage. -  <code>ngx_http_finalize_request()</code> is usually called when the request has generated all the output or produced an error. In the latter case an appropriate error page is looked up and used as the response. If the response is not completely sent to the client by this point, an HTTP writer <code>ngx_http_writer()</code> is activated to finish sending outstanding data. -  <code>ngx_http_finalize_connection()</code> is called when the complete response has been sent to the client and the request can be destroyed. If the client connection keepalive feature is enabled, <code>ngx_http_set_keepalive()</code> is called, which destroys the current request and waits for the next request on the connection. Otherwise, <code>ngx_http_close_request()</code> destroys both the request and the connection. </p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>For each client HTTP request the <code>ngx_http_request_t</code> object is created. Some of the fields of this object are: </p>
</li>
<li><p><code>connection</code> — Pointer to a <code>ngx_connection_t</code> client connection object. Several requests can reference the same connection object at the same time - one main request and its subrequests. After a request is deleted, a new request can be created on the same connection.  Note that for HTTP connections <code>ngx_connection_t</code> ‘s <code>data</code> field points back to the request. Such requests are called active, as opposed to the other requests tied to the connection. An active request is used to handle client connection events and is allowed to output its response to the client. Normally, each request becomes active at some point so that it can send its output. -  <code>ctx</code> — Array of HTTP module contexts. Each module of type <code>NGX_HTTP_MODULE</code> can store any value (normally, a pointer to a structure) in the request. The value is stored in the <code>ctx</code> array at the module’s <code>ctx_index</code> position. The following macros provide a convenient way to get and set request contexts: <ul class="compact"><li> <code>ngx_http_get_module_ctx(r, module)</code> — Returns the <code>module</code> ‘s context -  <code>ngx_http_set_ctx(r, c, module)</code> — Sets <code>c</code> as the <code>module</code> ‘s context<br><code>posted_requests</code> — List of requests to be started or resumed, which is done by calling the request’s <code>write_event_handler</code> . Normally, this handler holds the request main function, which at first runs request phases and then produces the output. </li></ul></p>
<p>A request is usually posted by the <code>ngx_http_post_request(r, NULL)</code> call. It is always posted to the main request <code>posted_requests</code> list. The function <code>ngx_http_run_posted_requests(c)</code> runs all requests that are posted in the main request of the passed connection’s active request. All event handlers call <code>ngx_http_run_posted_requests</code> , which can lead to new posted requests. Normally, it is called after invoking a request’s read or write handler. </p>
<p><code>keepalive</code> — Flag indicating whether client connection keepalive is supported. The value is inferred from the HTTP version and the value of the “Connection” header. </p>
</li>
</ul>
<h4 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h4><p> Each HTTP module can have three types of configuration: </p>
<ul>
<li>Main configuration — Applies to the entire <code>http</code> block. Functions as global settings for a module. -  Server configuration — Applies to a single <code>server</code> block. Functions as server-specific settings for a module. -  Location configuration — Applies to a single <code>location</code> , <code>if</code> or <code>limit_except</code> block. Functions as location-specific settings for a module.<br>Configuration structures are created at the nginx configuration stage by calling functions, which allocate the structures, initialize them and merge them. The following example shows how to create a simple location configuration for a module. The configuration has one setting, <code>foo</code> , of type unsigned integer. </li>
</ul>
<pre class="notranslate">typedef struct {
    ngx_uint_t  foo;
} ngx_http_foo_loc_conf_t;


static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    NULL,                                  /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    ngx_http_foo_create_loc_conf,          /* create location configuration */
    ngx_http_foo_merge_loc_conf            /* merge location configuration */
};


static void *
ngx_http_foo_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_foo_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_foo_loc_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    conf-&gt;foo = NGX_CONF_UNSET_UINT;

    return conf;
}


static char *
ngx_http_foo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_foo_loc_conf_t *prev = parent;
    ngx_http_foo_loc_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf-&gt;foo, prev-&gt;foo, 1);
}
</pre>

<p> As seen in the example, the <code>ngx_http_foo_create_loc_conf()</code> function creates a new configuration structure, and <code>ngx_http_foo_merge_loc_conf()</code> merges a configuration with configuration from a higher level. In fact, server and location configuration do not exist only at the server and location levels, but are also created for all levels above them. Specifically, a server configuration is also created at the main level and location configurations are created at the main, server, and location levels. These configurations make it possible to specify server- and location-specific settings at any level of an nginx configuration file. Eventually configurations are merged down. A number of macros like <code>NGX_CONF_UNSET</code> and <code>NGX_CONF_UNSET_UINT</code> are provided for indicating a missing setting and ignoring it while merging. Standard nginx merge macros like <code>ngx_conf_merge_value()</code> and <code>ngx_conf_merge_uint_value()</code> provide a convenient way to merge a setting and set the default value if none of the configurations provided an explicit value. For complete list of macros for different types, see <code>src/core/ngx_conf_file.h</code> . </p>
<p> The following macros are available. for accessing configuration for HTTP modules at configuration time. They all take <code>ngx_conf_t</code> reference as the first argument. </p>
<ul>
<li><code>ngx_http_conf_get_module_main_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_srv_conf(cf, module)</code>  -  <code>ngx_http_conf_get_module_loc_conf(cf, module)</code><br>The following example gets a pointer to a location configuration of standard nginx core module <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> and replaces the location content handler kept in the <code>handler</code> field of the structure. </li>
</ul>
<pre class="notranslate">static ngx_int_t ngx_http_foo_handler(ngx_http_request_t *r);


static ngx_command_t  ngx_http_foo_commands[] = {

    { ngx_string("foo"),
      NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
      ngx_http_foo,
      0,
      0,
      NULL },

      ngx_null_command
};


static char *
ngx_http_foo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_bar_handler;

    return NGX_CONF_OK;
}
</pre>

<p> The following macros are available for accessing configuration for HTTP modules at runtime. </p>
<ul>
<li><code>ngx_http_get_module_main_conf(r, module)</code>  -  <code>ngx_http_get_module_srv_conf(r, module)</code>  -  <code>ngx_http_get_module_loc_conf(r, module)</code><br>These macros receive a reference to an HTTP request <code>ngx_http_request_t</code> . The main configuration of a request never changes. Server configuration can change from the default after the virtual server for the request is chosen. Location configuration selected for processing a request can change multiple times as a result of a rewrite operation or internal redirect. The following example shows how to access a module’s HTTP configuration at runtime. </li>
</ul>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_http_foo_loc_conf_t  *flcf;

    flcf = ngx_http_get_module_loc_conf(r, ngx_http_foo_module);

    ...
}
</pre>

<h4 id="相"><a href="#相" class="headerlink" title="相"></a>相</h4><p> Each HTTP request passes through a sequence of phases. In each phase a distinct type of processing is performed on the request. Module-specific handlers can be registered in most phases, and many standard nginx modules register their phase handlers as a way to get called at a specific stage of request processing. Phases are processed successively and the phase handlers are called once the request reaches the phase. Following is the list of nginx HTTP phases. </p>
<ul>
<li><code>NGX_HTTP_POST_READ_PHASE</code> — First phase. The <a href="http/ngx_http_realip_module.html">ngx_http_realip_module</a> registers its handler at this phase to enable substitution of client addresses before any other module is invoked. -  <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> — Phase where rewrite directives defined in a <code>server</code> block (but outside a <code>location</code> block) are processed. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> installs its handler at this phase. -  <code>NGX_HTTP_FIND_CONFIG_PHASE</code> — Special phase where a location is chosen based on the request URI. Before this phase, the default location for the relevant virtual server is assigned to the request, and any module requesting a location configuration receives the configuration for the default server location. This phase a assigns a new location to the request. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_REWRITE_PHASE</code> — Same as <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> , but for rewrite rules defined in the location, chosen in the previous phase. -  <code>NGX_HTTP_POST_REWRITE_PHASE</code> — Special phase where the request is redirected to a new location if its URI changed during a rewrite. This is implemented by the request going through the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> again. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PREACCESS_PHASE</code> — A common phase for different types of handlers, not associated with access control. The standard nginx modules <a href="http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a> and <a href="http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a> register their handlers at this phase. -  <code>NGX_HTTP_ACCESS_PHASE</code> — Phase where it is verified that the client is authorized to make the request. Standard nginx modules such as <a href="http/ngx_http_access_module.html">ngx_http_access_module</a> and <a href="http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> register their handlers at this phase. By default the client must pass the authorization check of all handlers registered at this phase for the request to continue to the next phase. The <a href="http/ngx_http_core_module.html#satisfy">satisfy</a> directive, can be used to permit processing to continue if any of the phase handlers authorizes the client. -  <code>NGX_HTTP_POST_ACCESS_PHASE</code> — Special phase where the <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> directive is processed. If some access phase handlers denied access and none explicitly allowed it, the request is finalized. No additional handlers can be registered at this phase. -  <code>NGX_HTTP_PRECONTENT_PHASE</code> — Phase for handlers to be called prior to generating content. Standard modules such as <a href="http/ngx_http_core_module.html#try_files">ngx_http_try_files_module</a> and <a href="http/ngx_http_mirror_module.html">ngx_http_mirror_module</a> register their handlers at this phase. -  <code>NGX_HTTP_CONTENT_PHASE</code> — Phase where the response is normally generated. Multiple nginx standard modules register their handlers at this phase, including <a href="http/ngx_http_index_module.html">ngx_http_index_module</a> or <code>ngx_http_static_module</code> . They are called sequentially until one of them produces the output. It’s also possible to set content handlers on a per-location basis. If the <a href="http/ngx_http_core_module.html">ngx_http_core_module</a> ‘s location configuration has <code>handler</code> set, it is called as the content handler and the handlers installed at this phase are ignored. -  <code>NGX_HTTP_LOG_PHASE</code> — Phase where request logging is performed. Currently, only the <a href="http/ngx_http_log_module.html">ngx_http_log_module</a> registers its handler at this stage for access logging. Log phase handlers are called at the very end of request processing, right before freeing the request.<br>Following is the example of a preaccess phase handler. </li>
</ul>
<pre class="notranslate">static ngx_http_module_t  ngx_http_foo_module_ctx = {
    NULL,                                  /* preconfiguration */
    ngx_http_foo_init,                     /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


static ngx_int_t
ngx_http_foo_handler(ngx_http_request_t *r)
{
    ngx_str_t  *ua;

    ua = r-&gt;headers_in-&gt;user_agent;

    if (ua == NULL) {
        return NGX_DECLINED;
    }

    /* reject requests with "User-Agent: foo" */
    if (ua-&gt;value.len == 3 &amp;&amp; ngx_strncmp(ua-&gt;value.data, "foo", 3) == 0) {
        return NGX_HTTP_FORBIDDEN;
    }

    return NGX_DECLINED;
}


static ngx_int_t
ngx_http_foo_init(ngx_conf_t *cf)
{
    ngx_http_handler_pt        *h;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);

    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    *h = ngx_http_foo_handler;

    return NGX_OK;
}
</pre>

<p> Phase handlers are expected to return specific codes: </p>
<ul>
<li><code>NGX_OK</code> — Proceed to the next phase. -  <code>NGX_DECLINED</code> — Proceed to the next handler of the current phase. If the current handler is the last in the current phase, move to the next phase. -  <code>NGX_AGAIN</code> , <code>NGX_DONE</code> — Suspend phase handling until some future event which can be an asynchronous I/O operation or just a delay, for example. It is assumed, that phase handling will be resumed later by calling <code>ngx_http_core_run_phases()</code> . -  Any other value returned by the phase handler is treated as a request finalization code, in particular, an HTTP response code. The request is finalized with the code provided.<br>For some phases, return codes are treated in a slightly different way. At the content phase, any return code other that <code>NGX_DECLINED</code> is considered a finalization code. Any return code from the location content handlers is considered a finalization code. At the access phase, in <a href="http/ngx_http_core_module.html#satisfy">satisfy any</a> mode, any return code other than <code>NGX_OK</code> , <code>NGX_DECLINED</code> , <code>NGX_AGAIN</code> , <code>NGX_DONE</code> is considered a denial. If no subsequent access handlers allow or deny access with a different code, the denial code will become the finalization code. </li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h4 id="Accessing-existing-variables"><a href="#Accessing-existing-variables" class="headerlink" title="Accessing existing variables"></a>Accessing existing variables</h4><p> Variables can be referenced by index (this is the most common method) or name (see <a href="#http_creating_variables">below</a> ). The index is created at configuration stage, when a variable is added to the configuration. To obtain the variable index, use <code>ngx_http_get_variable_index()</code> : </p>
<pre class="notranslate">ngx_str_t  name;  /* ngx_string("foo") */
ngx_int_t  index;

index = ngx_http_get_variable_index(cf, &amp;name);
</pre>

<p> Here, <code>cf</code> is a pointer to nginx configuration and <code>name</code> points to a string containing the variable name. The function returns <code>NGX_ERROR</code> on error or a valid index otherwise, which is typically stored somewhere in the module’s configuration for future use. </p>
<p> All HTTP variables are evaluated in the context of a given HTTP request, and results are specific to and cached in that HTTP request. All functions that evaluate variables return the <code>ngx_http_variable_value_t</code> type, representing the variable value: </p>
<pre class="notranslate">typedef ngx_variable_value_t  ngx_http_variable_value_t;

typedef struct {
    unsigned    len:28;

    unsigned    valid:1;
    unsigned    no_cacheable:1;
    unsigned    not_found:1;
    unsigned    escape:1;

    u_char     *data;
} ngx_variable_value_t;
</pre>

<p>  哪里： </p>
<ul>
<li><code>len</code> — The length of the value -  <code>data</code> — The value itself -  <code>valid</code> — The value is valid -  <code>not_found</code> — The variable was not found and thus the <code>data</code> and <code>len</code> fields are irrelevant; this can happen, for example, with variables like <code>$arg_foo</code> when a corresponding argument was not passed in a request -  <code>no_cacheable</code> — Do not cache result -  <code>escape</code> — Used internally by the logging module to mark values that require escaping on output. </li>
</ul>
<p> The <code>ngx_http_get_flushed_variable()</code> and <code>ngx_http_get_indexed_variable()</code> functions are used to obtain the value of a variable. They have the same interface - accepting an HTTP request <code>r</code> as a context for evaluating the variable and an <code>index</code> that identifies it. An example of typical usage: </p>
<pre class="notranslate">ngx_http_variable_value_t  *v;

v = ngx_http_get_flushed_variable(r, index);

if (v == NULL || v-&gt;not_found) {
    /* we failed to get value or there is no such variable, handle it */
    return NGX_ERROR;
}

/* some meaningful value is found */
</pre>

<p> The difference between functions is that the <code>ngx_http_get_indexed_variable()</code> returns a cached value and <code>ngx_http_get_flushed_variable()</code> flushes the cache for non-cacheable variables. </p>
<p> Some modules, such as SSI and Perl, need to deal with variables for which the name is not known at configuration time. An index therefore cannot be used to access them, but the <code>ngx_http_get_variable(r, name, key)</code> function is available. It searches for a variable with a given <code>name</code> and its hash <code>key</code> derived from the name. </p>
<h4 id="Creating-variables"><a href="#Creating-variables" class="headerlink" title="Creating variables"></a>Creating variables</h4><p> To create a variable, use the <code>ngx_http_add_variable()</code> function. It takes as arguments a configuration (where the variable is registered), the variable name and flags that control the function’s behaviour: </p>
<ul>
<li><code>NGX_HTTP_VAR_CHANGEABLE</code> — Enables redefinition of the variable: there is no conflict if another module defines a variable with the same name. This allows the <a href="http/ngx_http_rewrite_module.html#set">set</a> directive to override variables. -  <code>NGX_HTTP_VAR_NOCACHEABLE</code> — Disables caching, which is useful for variables such as <code>$time_local</code> . -  <code>NGX_HTTP_VAR_NOHASH</code> — Indicates that this variable is only accessible by index, not by name. This is a small optimization for use when it is known that the variable is not needed in modules like SSI or Perl. -  <code>NGX_HTTP_VAR_PREFIX</code> — The name of the variable is a prefix. In this case, a handler must implement additional logic to obtain the value of a specific variable. For example, all “ <code>arg_</code> ” variables are processed by the same handler, which performs lookup in request arguments and returns the value of a specific argument.<br>The function returns NULL in case of error or a pointer to <code>ngx_http_variable_t</code> otherwise: </li>
</ul>
<pre class="notranslate">struct ngx_http_variable_s {
    ngx_str_t                     name;
    ngx_http_set_variable_pt      set_handler;
    ngx_http_get_variable_pt      get_handler;
    uintptr_t                     data;
    ngx_uint_t                    flags;
    ngx_uint_t                    index;
};
</pre>

<p> The <code>get</code> and <code>set</code> handlers are called to obtain or set the variable value, <code>data</code> is passed to variable handlers, and <code>index</code> holds assigned variable index used to reference the variable. </p>
<p> Usually, a null-terminated static array of <code>ngx_http_variable_t</code> structures is created by a module and processed at the preconfiguration stage to add variables into the configuration, for example: </p>
<pre class="notranslate">static ngx_http_variable_t  ngx_http_foo_vars[] = {

    { ngx_string("foo_v1"), NULL, ngx_http_foo_v1_variable, 0, 0, 0 },

      ngx_http_null_variable
};

static ngx_int_t
ngx_http_foo_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var, *v;

    for (v = ngx_http_foo_vars; v-&gt;name.len; v++) {
        var = ngx_http_add_variable(cf, &amp;v-&gt;name, v-&gt;flags);
        if (var == NULL) {
            return NGX_ERROR;
        }

        var-&gt;get_handler = v-&gt;get_handler;
        var-&gt;data = v-&gt;data;
    }

    return NGX_OK;
}
</pre>

<p> This function in the example is used to initialize the <code>preconfiguration</code> field of the HTTP module context and is called before the parsing of HTTP configuration, so that the parser can refer to these variables. </p>
<p> The <code>get</code> handler is responsible for evaluating a variable in the context of a specific request, for example: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_variable_connection(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    u_char  *p;

    p = ngx_pnalloc(r-&gt;pool, NGX_ATOMIC_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;len = ngx_sprintf(p, "%uA", r-&gt;connection-&gt;number) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;
    v-&gt;data = p;

    return NGX_OK;
}
</pre>

<p> It returns <code>NGX_ERROR</code> in case of internal error (for example, failed memory allocation) or <code>NGX_OK</code> otherwise. To learn the status of variable evaluation, inspect the flags in <code>ngx_http_variable_value_t</code> (see the description <a href="#http_existing_variables">above</a> ). </p>
<p> The <code>set</code> handler allows setting the property referenced by the variable. For example, the set handler of the <code>$limit_rate</code> variable modifies the request’s <code>limit_rate</code> field: </p>
<pre class="notranslate">...
{ ngx_string("limit_rate"), ngx_http_variable_request_set_size,
  ngx_http_variable_request_get_size,
  offsetof(ngx_http_request_t, limit_rate),
  NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE, 0 },
...

static void
ngx_http_variable_request_set_size(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ssize_t    s, *sp;
    ngx_str_t  val;

    val.len = v-&gt;len;
    val.data = v-&gt;data;

    s = ngx_parse_size(&amp;val);

    if (s == NGX_ERROR) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                      "invalid size \"%V\"", &amp;val);
        return;
    }

    sp = (ssize_t *) ((char *) r + data);

    *sp = s;

    return;
}
</pre>



<h4 id="Complex-values"><a href="#Complex-values" class="headerlink" title="Complex values"></a>Complex values</h4><p> A complex value, despite its name, provides an easy way to evaluate expressions which can contain text, variables, and their combination. </p>
<p> The complex value description in <code>ngx_http_compile_complex_value</code> is compiled at the configuration stage into <code>ngx_http_complex_value_t</code> which is used at runtime to obtain results of expression evaluation. </p>
<pre class="notranslate">ngx_str_t                         *value;
ngx_http_complex_value_t           cv;
ngx_http_compile_complex_value_t   ccv;

value = cf-&gt;args-&gt;elts; /* directive arguments */

ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

ccv.cf = cf;
ccv.value = &amp;value[1];
ccv.complex_value = &amp;cv;
ccv.zero = 1;
ccv.conf_prefix = 1;

if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
    return NGX_CONF_ERROR;
}
</pre>

<p> Here, <code>ccv</code> holds all parameters that are required to initialize the complex value <code>cv</code> : </p>
<ul>
<li><p><code>cf</code> — Configuration pointer -  <code>value</code> — String to be parsed (input) -  <code>complex_value</code> — Compiled value (output) -  <code>zero</code> — Flag that enables zero-terminating value -  <code>conf_prefix</code> — Prefixes the result with the configuration prefix (the directory where nginx is currently looking for configuration) -  <code>root_prefix</code> — Prefixes the result with the root prefix (the normal nginx installation prefix)<br>The <code>zero</code> flag is useful when results are to be passed to libraries that require zero-terminated strings, and prefixes are handy when dealing with filenames. </p>
<p>Upon successful compilation, <code>cv.lengths</code> contains information about the presence of variables in the expression. The NULL value means that the expression contained static text only, and so can be stored in a simple string rather than as a complex value. </p>
<p>The <code>ngx_http_set_complex_value_slot()</code> is a convenient function used to initialize a complex value completely in the directive declaration itself. </p>
<p>At runtime, a complex value can be calculated using the <code>ngx_http_complex_value()</code> function: </p>
</li>
</ul>
<pre class="notranslate">ngx_str_t  res;

if (ngx_http_complex_value(r, &amp;cv, &amp;res) != NGX_OK) {
    return NGX_ERROR;
}
</pre>

<p> Given the request <code>r</code> and previously compiled value <code>cv</code> , the function evaluates the expression and writes the result to <code>res</code> . </p>
<h4 id="Request-redirection"><a href="#Request-redirection" class="headerlink" title="Request redirection"></a>Request redirection</h4><p> An HTTP request is always connected to a location via the <code>loc_conf</code> field of the <code>ngx_http_request_t</code> structure. This means that at any point the location configuration of any module can be retrieved from the request by calling <code>ngx_http_get_module_loc_conf(r, module)</code> . Request location can change several times during the request’s lifetime. Initially, a default server location of the default server is assigned to a request. If the request switches to a different server (chosen by the HTTP “Host” header or SSL SNI extension), the request switches to the default location of that server as well. The next change of the location takes place at the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> request phase. At this phase a location is chosen by request URI among all non-named locations configured for the server. The <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> can change the request URI at the <code>NGX_HTTP_REWRITE_PHASE</code> request phase as a result of the <a href="http/ngx_http_rewrite_module.html#rewrite">rewrite</a> directive and send the request back to the <code>NGX_HTTP_FIND_CONFIG_PHASE</code> phase for selection of a new location based on the new URI. </p>
<p> It is also possible to redirect a request to a new location at any point by calling one of <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> . </p>
<p> The <code>ngx_http_internal_redirect(r, uri, args)</code> function changes the request URI and returns the request to the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. The request proceeds with a server default location. Later at <code>NGX_HTTP_FIND_CONFIG_PHASE</code> a new location is chosen based on the new request URI. </p>
<p> The following example performs an internal redirect with the new request arguments. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_redirect(ngx_http_request_t *r)
{
    ngx_str_t  uri, args;

    ngx_str_set(&amp;uri, "/foo");
    ngx_str_set(&amp;args, "bar=1");

    return ngx_http_internal_redirect(r, &amp;uri, &amp;args);
}
</pre>

<p> The function <code>ngx_http_named_location(r, name)</code> redirects a request to a named location. The name of the location is passed as the argument. The location is looked up among all named locations of the current server, after which the requests switches to the <code>NGX_HTTP_REWRITE_PHASE</code> phase. </p>
<p> The following example performs a redirect to a named location @foo. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_named_redirect(ngx_http_request_t *r)
{
    ngx_str_t  name;

    ngx_str_set(&amp;name, "foo");

    return ngx_http_named_location(r, &amp;name);
}
</pre>

<p> Both functions - <code>ngx_http_internal_redirect(r, uri, args)</code> and <code>ngx_http_named_location(r, name)</code> can be called when nginx modules have already stored some contexts in a request’s <code>ctx</code> field. It’s possible for these contexts to become inconsistent with the new location configuration. To prevent inconsistency, all request contexts are erased by both redirect functions. </p>
<p> Calling <code>ngx_http_internal_redirect(r, uri, args)</code> or <code>ngx_http_named_location(r, name)</code> increases the request <code>count</code> . For consistent request reference counting, call <code>ngx_http_finalize_request(r, NGX_DONE)</code> after redirecting the request. This will finalize current request code path and decrease the counter. </p>
<p> Redirected and rewritten requests become internal and can access the <a href="http/ngx_http_core_module.html#internal">internal</a> locations. Internal requests have the <code>internal</code> flag set. </p>
<h4 id="Subrequests"><a href="#Subrequests" class="headerlink" title="Subrequests"></a>Subrequests</h4><p> Subrequests are primarily used to insert output of one request into another, possibly mixed with other data. A subrequest looks like a normal request, but shares some data with its parent. In particular, all fields related to client input are shared because a subrequest does not receive any other input from the client. The request field <code>parent</code> for a subrequest contains a link to its parent request and is NULL for the main request. The field <code>main</code> contains a link to the main request in a group of requests. </p>
<p> A subrequest starts in the <code>NGX_HTTP_SERVER_REWRITE_PHASE</code> phase. It passes through the same subsequent phases as a normal request and is assigned a location based on its own URI. </p>
<p> The output header in a subrequest is always ignored. The <code>ngx_http_postpone_filter</code> places the subrequest’s output body in the right position relative to other data produced by the parent request. </p>
<p> Subrequests are related to the concept of active requests. A request <code>r</code> is considered active if <code>c-&amp;gt;data == r</code> , where <code>c</code> is the client connection object. At any given point, only the active request in a request group is allowed to output its buffers to the client. An inactive request can still send its output to the filter chain, but it does not pass beyond the <code>ngx_http_postpone_filter</code> and remains buffered by that filter until the request becomes active. Here are some rules of request activation: </p>
<ul>
<li>Initially, the main request is active. -  The first subrequest of an active request becomes active right after creation. -  The <code>ngx_http_postpone_filter</code> activates the next request in the active request’s subrequest list, once all data prior to that request are sent. -  When a request is finalized, its parent is activated.<br>Create a subrequest by calling the function <code>ngx_http_subrequest(r, uri, args, psr, ps, flags)</code> , where <code>r</code> is the parent request, <code>uri</code> and <code>args</code> are the URI and arguments of the subrequest, <code>psr</code> is the output parameter, which receives the newly created subrequest reference, <code>ps</code> is a callback object for notifying the parent request that the subrequest is being finalized, and <code>flags</code> is bitmask of flags. The following flags are available: </li>
<li><code>NGX_HTTP_SUBREQUEST_IN_MEMORY</code> - Output is not sent to the client, but rather stored in memory. The flag only affects subrequests which are processed by one of the proxying modules. After a subrequest is finalized its output is available in a <code>r-&amp;gt;upstream-&amp;gt;buffer</code> of type <code>ngx_buf_t</code> . -  <code>NGX_HTTP_SUBREQUEST_WAITED</code> - The subrequest’s <code>done</code> flag is set even if the subrequest is not active when it is finalized. This subrequest flag is used by the SSI filter. -  <code>NGX_HTTP_SUBREQUEST_CLONE</code> - The subrequest is created as a clone of its parent. It is started at the same location and proceeds from the same phase as the parent request.<br>The following example creates a subrequest with the URI of <code>/foo</code> . </li>
</ul>
<pre class="notranslate">ngx_int_t            rc;
ngx_str_t            uri;
ngx_http_request_t  *sr;

...

ngx_str_set(&amp;uri, "/foo");

rc = ngx_http_subrequest(r, &amp;uri, NULL, &amp;sr, NULL, 0);
if (rc == NGX_ERROR) {
    /* error */
}
</pre>

<p> This example clones the current request and sets a finalization callback for the subrequest. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_clone(ngx_http_request_t *r)
{
    ngx_http_request_t          *sr;
    ngx_http_post_subrequest_t  *ps;

    ps = ngx_palloc(r-&gt;pool, sizeof(ngx_http_post_subrequest_t));
    if (ps == NULL) {
        return NGX_ERROR;
    }

    ps-&gt;handler = ngx_http_foo_subrequest_done;
    ps-&gt;data = "foo";

    return ngx_http_subrequest(r, &amp;r-&gt;uri, &amp;r-&gt;args, &amp;sr, ps,
                               NGX_HTTP_SUBREQUEST_CLONE);
}


ngx_int_t
ngx_http_foo_subrequest_done(ngx_http_request_t *r, void *data, ngx_int_t rc)
{
    char  *msg = (char *) data;

    ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  "done subrequest r:%p msg:%s rc:%i", r, msg, rc);

    return rc;
}
</pre>

<p> Subrequests are normally created in a body filter, in which case their output can be treated like the output from any explicit request. This means that eventually the output of a subrequest is sent to the client, after all explicit buffers that are passed before subrequest creation and before any buffers that are passed after creation. This ordering is preserved even for large hierarchies of subrequests. The following example inserts output from a subrequest after all request data buffers, but before the final buffer with the <code>last_buf</code> flag. </p>
<pre class="notranslate">ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_uint_t                  last;
    ngx_chain_t                *cl, out;
    ngx_http_request_t         *sr;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    last = 0;

    for (cl = in; cl; cl = cl-&gt;next) {
        if (cl-&gt;buf-&gt;last_buf) {
            cl-&gt;buf-&gt;last_buf = 0;
            cl-&gt;buf-&gt;last_in_chain = 1;
            cl-&gt;buf-&gt;sync = 1;
            last = 1;
        }
    }

    /* Output explicit output buffers */

    rc = ngx_http_next_body_filter(r, in);

    if (rc == NGX_ERROR || !last) {
        return rc;
    }

    /*
     * Create the subrequest.  The output of the subrequest
     * will automatically be sent after all preceding buffers,
     * but before the last_buf buffer passed later in this function.
     */

    if (ngx_http_subrequest(r, ctx-&gt;uri, NULL, &amp;sr, NULL, 0) != NGX_OK) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, NULL, ngx_http_foo_filter_module);

    /* Output the final buffer with the last_buf flag */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = 1;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<p> A subrequest can also be created for other purposes than data output. For example, the <a href="http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> module creates a subrequest at the <code>NGX_HTTP_ACCESS_PHASE</code> phase. To disable output at this point, the <code>header_only</code> flag is set on the subrequest. This prevents the subrequest body from being sent to the client. Note that the subrequest’s header is never sent to the client. The result of the subrequest can be analyzed in the callback handler. </p>
<h4 id="Request-finalization"><a href="#Request-finalization" class="headerlink" title="Request finalization"></a>Request finalization</h4><p> An HTTP request is finalized by calling the function <code>ngx_http_finalize_request(r, rc)</code> . It is usually finalized by the content handler after all output buffers are sent to the filter chain. At this point all of the output might not be sent to the client, with some of it remaining buffered somewhere along the filter chain. If it is, the <code>ngx_http_finalize_request(r, rc)</code> function automatically installs a special handler <code>ngx_http_writer(r)</code> to finish sending the output. A request is also finalized in case of an error or if a standard HTTP response code needs to be returned to the client. </p>
<p> The function <code>ngx_http_finalize_request(r, rc)</code> expects the following <code>rc</code> values: </p>
<ul>
<li><p><code>NGX_DONE</code> - Fast finalization. Decrement the request <code>count</code> and destroy the request if it reaches zero. The client connection can be used for more requests after the current request is destroyed. -  <code>NGX_ERROR</code> , <code>NGX_HTTP_REQUEST_TIME_OUT</code> ( <code>408</code> ), <code>NGX_HTTP_CLIENT_CLOSED_REQUEST</code> ( <code>499</code> ) - Error finalization. Terminate the request as soon as possible and close the client connection. -  <code>NGX_HTTP_CREATED</code> ( <code>201</code> ), <code>NGX_HTTP_NO_CONTENT</code> ( <code>204</code> ), codes greater than or equal to <code>NGX_HTTP_SPECIAL_RESPONSE</code> ( <code>300</code> ) - Special response finalization. For these values nginx either sends to the client a default response page for the code or performs the internal redirect to an <a href="http/ngx_http_core_module.html#error_page">error_page</a> location if that is configured for the code. -  Other codes are considered successful finalization codes and might activate the request writer to finish sending the response body. Once the body is completely sent, the request <code>count</code> is decremented. If it reaches zero, the request is destroyed, but the client connection can still be used for other requests. If <code>count</code> is positive, there are unfinished activities within the request, which will be finalized at a later point. </p>
<h4 id="Request-body"><a href="#Request-body" class="headerlink" title="Request body"></a>Request body</h4><p>For dealing with the body of a client request, nginx provides the <code>ngx_http_read_client_request_body(r, post_handler)</code> and <code>ngx_http_discard_request_body(r)</code> functions. The first function reads the request body and makes it available via the <code>request_body</code> request field. The second function instructs nginx to discard (read and ignore) the request body. One of these functions must be called for every request. Normally, the content handler makes the call. </p>
<p>Reading or discarding the client request body from a subrequest is not allowed. It must always be done in the main request. When a subrequest is created, it inherits the parent’s <code>request_body</code> object which can be used by the subrequest if the main request has previously read the request body. </p>
<p>The function <code>ngx_http_read_client_request_body(r, post_handler)</code> starts the process of reading the request body. When the body is completely read, the <code>post_handler</code> callback is called to continue processing the request. If the request body is missing or has already been read, the callback is called immediately. The function <code>ngx_http_read_client_request_body(r, post_handler)</code> allocates the <code>request_body</code> request field of type <code>ngx_http_request_body_t</code> . The field <code>bufs</code> of this object keeps the result as a buffer chain. The body can be saved in memory buffers or file buffers, if the capacity specified by the <a href="http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a> directive is not enough to fit the entire body in memory. </p>
<p>The following example reads a client request body and returns its size. </p>
</li>
</ul>
<pre class="notranslate">ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t  rc;

    rc = ngx_http_read_client_request_body(r, ngx_http_foo_init);

    if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) {
        /* error */
        return rc;
    }

    return NGX_DONE;
}


void
ngx_http_foo_init(ngx_http_request_t *r)
{
    off_t         len;
    ngx_buf_t    *b;
    ngx_int_t     rc;
    ngx_chain_t  *in, out;

    if (r-&gt;request_body == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    len = 0;

    for (in = r-&gt;request_body-&gt;bufs; in; in = in-&gt;next) {
        len += ngx_buf_size(in-&gt;buf);
    }

    b = ngx_create_temp_buf(r-&gt;pool, NGX_OFF_T_LEN);
    if (b == NULL) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return;
    }

    b-&gt;last = ngx_sprintf(b-&gt;pos, "%O", len);
    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = b-&gt;last - b-&gt;pos;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        ngx_http_finalize_request(r, rc);
        return;
    }

    out.buf = b;
    out.next = NULL;

    rc = ngx_http_output_filter(r, &amp;out);

    ngx_http_finalize_request(r, rc);
}
</pre>

<p> The following fields of the request determine how the request body is read: </p>
<ul>
<li><code>request_body_in_single_buf</code> - Read the body to a single memory buffer. -  <code>request_body_in_file_only</code> - Always read the body to a file, even if fits in the memory buffer. -  <code>request_body_in_persistent_file</code> - Do not unlink the file immediately after creation. A file with this flag can be moved to another directory. -  <code>request_body_in_clean_file</code> - Unlink the file when the request is finalized. This can be useful when a file was supposed to be moved to another directory but was not moved for some reason. -  <code>request_body_file_group_access</code> - Enable group access to the file by replacing the default 0600 access mask with 0660. -  <code>request_body_file_log_level</code> - Severity level at which to log file errors. -  <code>request_body_no_buffering</code> - Read the request body without buffering.<br>The <code>request_body_no_buffering</code> flag enables the unbuffered mode of reading a request body. In this mode, after calling <code>ngx_http_read_client_request_body()</code> , the <code>bufs</code> chain might keep only a part of the body. To read the next part, call the <code>ngx_http_read_unbuffered_request_body(r)</code> function. The return value <code>NGX_AGAIN</code> and the request flag <code>reading_body</code> indicate that more data is available. If <code>bufs</code> is NULL after calling this function, there is nothing to read at the moment. The request callback <code>read_event_handler</code> will be called when the next part of request body is available. </li>
</ul>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p> In nginx an HTTP response is produced by sending the response header followed by the optional response body. Both header and body are passed through a chain of filters and eventually get written to the client socket. An nginx module can install its handler into the header or body filter chain and process the output coming from the previous handler. </p>
<h4 id="Response-header"><a href="#Response-header" class="headerlink" title="Response header"></a>Response header</h4><p> The <code>ngx_http_send_header(r)</code> function sends the output header. Do not call this function until <code>r-&amp;gt;headers_out</code> contains all of the data required to produce the HTTP response header. The <code>status</code> field in <code>r-&amp;gt;headers_out</code> must always be set. If the response status indicates that a response body follows the header, <code>content_length_n</code> can be set as well. The default value for this field is <code>-1</code> , which means that the body size is unknown. In this case, chunked transfer encoding is used. To output an arbitrary header, append the <code>headers</code> list. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_foo_content_handler(ngx_http_request_t *r)
{
    ngx_int_t         rc;
    ngx_table_elt_t  *h;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    /* X-Foo: foo */

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    ...
}
</pre>

<h4 id="Header-filters"><a href="#Header-filters" class="headerlink" title="Header filters"></a>Header filters</h4><p> The <code>ngx_http_send_header(r)</code> function invokes the header filter chain by calling the first header filter handler stored in the <code>ngx_http_top_header_filter</code> variable. It’s assumed that every header handler calls the next handler in the chain until the final handler <code>ngx_http_header_filter(r)</code> is called. The final header handler constructs the HTTP response based on <code>r-&amp;gt;headers_out</code> and passes it to the <code>ngx_http_writer_filter</code> for output. </p>
<p> To add a handler to the header filter chain, store its address in the global variable <code>ngx_http_top_header_filter</code> at configuration time. The previous handler address is normally stored in a static variable in a module and is called by the newly added handler before exiting. </p>
<p> The following example of a header filter module adds the HTTP header “ <code>X-Foo: foo</code> “ to every response with status <code>200</code> . </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


static ngx_int_t ngx_http_foo_header_filter(ngx_http_request_t *r);
static ngx_int_t ngx_http_foo_header_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_foo_header_filter_module_ctx = {
    NULL,                                   /* preconfiguration */
    ngx_http_foo_header_filter_init,        /* postconfiguration */

    NULL,                                   /* create main configuration */
    NULL,                                   /* init main configuration */

    NULL,                                   /* create server configuration */
    NULL,                                   /* merge server configuration */

    NULL,                                   /* create location configuration */
    NULL                                    /* merge location configuration */
};


ngx_module_t  ngx_http_foo_header_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_foo_header_filter_module_ctx, /* module context */
    NULL,                                   /* module directives */
    NGX_HTTP_MODULE,                        /* module type */
    NULL,                                   /* init master */
    NULL,                                   /* init module */
    NULL,                                   /* init process */
    NULL,                                   /* init thread */
    NULL,                                   /* exit thread */
    NULL,                                   /* exit process */
    NULL,                                   /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;


static ngx_int_t
ngx_http_foo_header_filter(ngx_http_request_t *r)
{
    ngx_table_elt_t  *h;

    /*
     * The filter handler adds "X-Foo: foo" header
     * to every HTTP 200 response
     */

    if (r-&gt;headers_out.status != NGX_HTTP_OK) {
        return ngx_http_next_header_filter(r);
    }

    h = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (h == NULL) {
        return NGX_ERROR;
    }

    h-&gt;hash = 1;
    ngx_str_set(&amp;h-&gt;key, "X-Foo");
    ngx_str_set(&amp;h-&gt;value, "foo");

    return ngx_http_next_header_filter(r);
}


static ngx_int_t
ngx_http_foo_header_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_foo_header_filter;

    return NGX_OK;
}
</pre>

<h4 id="Response-body"><a href="#Response-body" class="headerlink" title="Response body"></a>Response body</h4><p> To send the response body, call the <code>ngx_http_output_filter(r, cl)</code> function. The function can be called multiple times. Each time, it sends a part of the response body in the form of a buffer chain. Set the <code>last_buf</code> flag in the last body buffer. </p>
<p> The following example produces a complete HTTP response with “foo” as its body. For the example to work as subrequest as well as a main request, the <code>last_in_chain</code> flag is set in the last buffer of the output. The <code>last_buf</code> flag is set only for the main request because the last buffer for a subrequest does not end the entire output. </p>
<pre class="notranslate">static ngx_int_t
ngx_http_bar_content_handler(ngx_http_request_t *r)
{
    ngx_int_t     rc;
    ngx_buf_t    *b;
    ngx_chain_t   out;

    /* send header */

    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 3;

    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return rc;
    }

    /* send body */

    b = ngx_calloc_buf(r-&gt;pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b-&gt;last_buf = (r == r-&gt;main) ? 1: 0;
    b-&gt;last_in_chain = 1;

    b-&gt;memory = 1;

    b-&gt;pos = (u_char *) "foo";
    b-&gt;last = b-&gt;pos + 3;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &amp;out);
}
</pre>

<h4 id="Body-filters"><a href="#Body-filters" class="headerlink" title="Body filters"></a>Body filters</h4><p> The function <code>ngx_http_output_filter(r, cl)</code> invokes the body filter chain by calling the first body filter handler stored in the <code>ngx_http_top_body_filter</code> variable. It’s assumed that every body handler calls the next handler in the chain until the final handler <code>ngx_http_write_filter(r, cl)</code> is called. </p>
<p> A body filter handler receives a chain of buffers. The handler is supposed to process the buffers and pass a possibly new chain to the next handler. It’s worth noting that the chain links <code>ngx_chain_t</code> of the incoming chain belong to the caller, and must not be reused or changed. Right after the handler completes, the caller can use its output chain links to keep track of the buffers it has sent. To save the buffer chain or to substitute some buffers before passing to the next filter, a handler needs to allocate its own chain links. </p>
<p> Following is an example of a simple body filter that counts the number of bytes in the body. The result is available as the <code>$counter</code> variable which can be used in the access log. </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


typedef struct {
    off_t  count;
} ngx_http_counter_filter_ctx_t;


static ngx_int_t ngx_http_counter_body_filter(ngx_http_request_t *r,
    ngx_chain_t *in);
static ngx_int_t ngx_http_counter_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data);
static ngx_int_t ngx_http_counter_add_variables(ngx_conf_t *cf);
static ngx_int_t ngx_http_counter_filter_init(ngx_conf_t *cf);


static ngx_http_module_t  ngx_http_counter_filter_module_ctx = {
    ngx_http_counter_add_variables,        /* preconfiguration */
    ngx_http_counter_filter_init,          /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


ngx_module_t  ngx_http_counter_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_counter_filter_module_ctx,   /* module context */
    NULL,                                  /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_body_filter_pt  ngx_http_next_body_filter;

static ngx_str_t  ngx_http_counter_name = ngx_string("counter");


static ngx_int_t
ngx_http_counter_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_chain_t                    *cl;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_counter_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_counter_filter_module);
    }

    for (cl = in; cl; cl = cl-&gt;next) {
        ctx-&gt;count += ngx_buf_size(cl-&gt;buf);
    }

    return ngx_http_next_body_filter(r, in);
}


static ngx_int_t
ngx_http_counter_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
    uintptr_t data)
{
    u_char                         *p;
    ngx_http_counter_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_counter_filter_module);
    if (ctx == NULL) {
        v-&gt;not_found = 1;
        return NGX_OK;
    }

    p = ngx_pnalloc(r-&gt;pool, NGX_OFF_T_LEN);
    if (p == NULL) {
        return NGX_ERROR;
    }

    v-&gt;data = p;
    v-&gt;len = ngx_sprintf(p, "%O", ctx-&gt;count) - p;
    v-&gt;valid = 1;
    v-&gt;no_cacheable = 0;
    v-&gt;not_found = 0;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_add_variables(ngx_conf_t *cf)
{
    ngx_http_variable_t  *var;

    var = ngx_http_add_variable(cf, &amp;ngx_http_counter_name, 0);
    if (var == NULL) {
        return NGX_ERROR;
    }

    var-&gt;get_handler = ngx_http_counter_variable;

    return NGX_OK;
}


static ngx_int_t
ngx_http_counter_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_counter_body_filter;

    return NGX_OK;
}
</pre>

<h4 id="Building-filter-modules"><a href="#Building-filter-modules" class="headerlink" title="Building filter modules"></a>Building filter modules</h4><p> When writing a body or header filter, pay special attention to the filter’s position in the filter order. There’s a number of header and body filters registered by nginx standard modules. The nginx standard modules register a number of head and body filters and it’s important to register a new filter module in the right place with respect to them. Normally, modules register filters in their postconfiguration handlers. The order in which filters are called during processing is obviously the reverse of the order in which they are registered. </p>
<p> For third-party filter modules nginx provides a special slot <code>HTTP_AUX_FILTER_MODULES</code> . To register a filter module in this slot, set the <code>ngx_module_type</code> variable to <code>HTTP_AUX_FILTER</code> in the module’s configuration. </p>
<p> The following example shows a filter module config file assuming for a module with just one source file, <code>ngx_http_foo_filter_module.c</code> . </p>
<pre class="notranslate">ngx_module_type=HTTP_AUX_FILTER
ngx_module_name=ngx_http_foo_filter_module
ngx_module_srcs="$ngx_addon_dir/ngx_http_foo_filter_module.c"

. auto/module
</pre>

<h4 id="Buffer-reuse"><a href="#Buffer-reuse" class="headerlink" title="Buffer reuse"></a>Buffer reuse</h4><p> When issuing or altering a stream of buffers, it’s often desirable to reuse the allocated buffers. A standard and widely adopted approach in nginx code is to keep two buffer chains for this purpose: <code>free</code> and <code>busy</code> . The <code>free</code> chain keeps all free buffers, which can be reused. The <code>busy</code> chain keeps all buffers sent by the current module that are still in use by some other filter handler. A buffer is considered in use if its size is greater than zero. Normally, when a buffer is consumed by a filter, its <code>pos</code> (or <code>file_pos</code> for a file buffer) is moved towards <code>last</code> ( <code>file_last</code> for a file buffer). Once a buffer is completely consumed, it’s ready to be reused. To add newly freed buffers to the <code>free</code> chain it’s enough to iterate over the <code>busy</code> chain and move the zero size buffers at the head of it to <code>free</code> . This operation is so common that there is a special function for it, <code>ngx_chain_update_chains(free, busy, out, tag)</code> . The function appends the output chain <code>out</code> to <code>busy</code> and moves free buffers from the top of <code>busy</code> to <code>free</code> . Only the buffers with the specified <code>tag</code> are reused. This lets a module reuse only the buffers that it allocated itself. </p>
<p> The following example is a body filter that inserts the string “foo” before each incoming buffer. The new buffers allocated by the module are reused if possible. Note that for this example to work properly, setting up a <a href="#http_header_filters">header filter</a> and resetting <code>content_length_n</code> to <code>-1</code> is also required, but the relevant code is not provided here. </p>
<pre class="notranslate">typedef struct {
    ngx_chain_t  *free;
    ngx_chain_t  *busy;
}  ngx_http_foo_filter_ctx_t;


ngx_int_t
ngx_http_foo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                   rc;
    ngx_buf_t                  *b;
    ngx_chain_t                *cl, *tl, *out, **ll;
    ngx_http_foo_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_foo_filter_module);
    if (ctx == NULL) {
        ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_foo_filter_ctx_t));
        if (ctx == NULL) {
            return NGX_ERROR;
        }

        ngx_http_set_ctx(r, ctx, ngx_http_foo_filter_module);
    }

    /* create a new chain "out" from "in" with all the changes */

    ll = &amp;out;

    for (cl = in; cl; cl = cl-&gt;next) {

        /* append "foo" in a reused buffer if possible */

        tl = ngx_chain_get_free_buf(r-&gt;pool, &amp;ctx-&gt;free);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        b = tl-&gt;buf;
        b-&gt;tag = (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module;
        b-&gt;memory = 1;
        b-&gt;pos = (u_char *) "foo";
        b-&gt;last = b-&gt;pos + 3;

        *ll = tl;
        ll = &amp;tl-&gt;next;

        /* append the next incoming buffer */

        tl = ngx_alloc_chain_link(r-&gt;pool);
        if (tl == NULL) {
            return NGX_ERROR;
        }

        tl-&gt;buf = cl-&gt;buf;
        *ll = tl;
        ll = &amp;tl-&gt;next;
    }

    *ll = NULL;

    /* send the new chain */

    rc = ngx_http_next_body_filter(r, out);

    /* update "busy" and "free" chains for reuse */

    ngx_chain_update_chains(r-&gt;pool, &amp;ctx-&gt;free, &amp;ctx-&gt;busy, &amp;out,
                            (ngx_buf_tag_t) &amp;ngx_http_foo_filter_module);

    return rc;
}
</pre>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> provides the basic functionality needed to pass requests to remote servers. Modules that implement specific protocols, such as HTTP or FastCGI, use this functionality. The module also provides an interface for creating custom load-balancing modules and implements a default round-robin method. </p>
<p> The <a href="http/ngx_http_upstream_module.html#least_conn">least_conn</a> and <a href="http/ngx_http_upstream_module.html#hash">hash</a> modules implement alternative load-balancing methods, but are actually implemented as extensions of the upstream round-robin module and share a lot of code with it, such as the representation of a server group. The <a href="http/ngx_http_upstream_module.html#keepalive">keepalive</a> module is an independent module that extends upstream functionality. </p>
<p> The <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> can be configured explicitly by placing the corresponding <a href="http/ngx_http_upstream_module.html#upstream">upstream</a> block into the configuration file, or implicitly by using directives such as <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> that accept a URL that gets evaluated at some point into a list of servers. The alternative load-balancing methods are available only with an explicit upstream configuration. The upstream module configuration has its own directive context <code>NGX_HTTP_UPS_CONF</code> . The structure is defined as follows: </p>
<pre class="notranslate">struct ngx_http_upstream_srv_conf_s {
    ngx_http_upstream_peer_t         peer;
    void                           **srv_conf;

    ngx_array_t                     *servers;  /* ngx_http_upstream_server_t */

    ngx_uint_t                       flags;
    ngx_str_t                        host;
    u_char                          *file_name;
    ngx_uint_t                       line;
    in_port_t                        port;
    ngx_uint_t                       no_port;  /* unsigned no_port:1 */

#if (NGX_HTTP_UPSTREAM_ZONE)
    ngx_shm_zone_t                  *shm_zone;
#endif
};
</pre>


<ul>
<li><code>srv_conf</code> — Configuration context of upstream modules. -  <code>servers</code> — Array of <code>ngx_http_upstream_server_t</code> , the result of parsing a set of <a href="http/ngx_http_upstream_module.html#server">server</a> directives in the <code>upstream</code> block. -  <code>flags</code> — Flags that mostly mark which features are supported by the load-balancing method. The features are configured as parameters of the <a href="http/ngx_http_upstream_module.html#server">server</a> directive: <ul class="compact"><li> <code>NGX_HTTP_UPSTREAM_CREATE</code> — Distinguishes explicitly defined upstreams from those that are automatically created by the <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> directive and “friends” (FastCGI, SCGI, etc.) -  <code>NGX_HTTP_UPSTREAM_WEIGHT</code> — The “ <code>weight</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_FAILS</code> — The “ <code>max_fails</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_FAIL_TIMEOUT</code> — The “ <code>fail_timeout</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_DOWN</code> — The “ <code>down</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_BACKUP</code> — The “ <code>backup</code> ” parameter is supported -  <code>NGX_HTTP_UPSTREAM_MAX_CONNS</code> — The “ <code>max_conns</code> ” parameter is supported <pre class="notranslate">typedef struct {
 ngx_http_upstream_init_pt        init_upstream;
 ngx_http_upstream_init_peer_pt   init;
 void                            *data;
} ngx_http_upstream_peer_t;
</pre></li>
<li><code>init_upstream(cf, us)</code> — Configuration-time method responsible for initializing a group of servers and initializing the <code>init()</code> method in case of success. A typical load-balancing module uses a list of servers in the <code>upstream</code> block to create an efficient data structure that it uses and saves its own configuration to the <code>data</code> field. -  <code>init(r, us)</code> — Initializes a per-request <code>ngx_http_upstream_peer_t.peer</code> structure that is used for load balancing (not to be confused with the <code>ngx_http_upstream_srv_conf_t.peer</code> described above which is per-upstream). It is passed as the <code>data</code> argument to all callbacks that deal with server selection. </li>
</ul>
<p> When nginx has to pass a request to another host for processing, it uses the configured load-balancing method to obtain an address to connect to. The method is obtained from the <code>ngx_http_upstream_t.peer</code> object of type <code>ngx_peer_connection_t</code> : </p>
<pre class="notranslate">struct ngx_peer_connection_s {
    ...

    struct sockaddr                 *sockaddr;
    socklen_t                        socklen;
    ngx_str_t                       *name;

    ngx_uint_t                       tries;

    ngx_event_get_peer_pt            get;
    ngx_event_free_peer_pt           free;
    ngx_event_notify_peer_pt         notify;
    void                            *data;

#if (NGX_SSL || NGX_COMPAT)
    ngx_event_set_peer_session_pt    set_session;
    ngx_event_save_peer_session_pt   save_session;
#endif

    ...
};
</pre>

<p> The structure has the following fields: </p>
<ul>
<li><code>sockaddr</code> , <code>socklen</code> , <code>name</code> — Address of the upstream server to connect to; this is the output parameter of a load-balancing method. -  <code>data</code> — The per-request data of a load-balancing method; keeps the state of the selection algorithm and usually includes the link to the upstream configuration. It is passed as an argument to all methods that deal with server selection (see <a href="#lb_method_get">below</a> ). -  <code>tries</code> — Allowed <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_tries">number</a> of attempts to connect to an upstream server. -  <code>get</code> , <code>free</code> , <code>notify</code> , <code>set_session</code> , and <code>save_session</code> - Methods of the load-balancing module, described below. </li>
</ul>
<p> All methods accept at least two arguments: a peer connection object <code>pc</code> and the <code>data</code> created by <code>ngx_http_upstream_srv_conf_t.peer.init()</code> . Note that it might differ from <code>pc.data</code> due to “chaining” of load-balancing modules. </p>
<ul>
<li><code>get(pc, data)</code> — The method called when the upstream module is ready to pass a request to an upstream server and needs to know its address. The method has to fill the <code>sockaddr</code> , <code>socklen</code> , and <code>name</code> fields of <code>ngx_peer_connection_t</code> structure. The return is one of: <ul class="compact"><li> <code>NGX_OK</code> — Server was selected. -  <code>NGX_ERROR</code> — Internal error occurred. -  <code>NGX_BUSY</code> — no servers are currently available. This can happen due to many reasons, including: the dynamic server group is empty, all servers in the group are in the failed state, or all servers in the group are already handling the maximum number of connections. -  <code>NGX_DONE</code> — the underlying connection was reused and there is no need to create a new connection to the upstream server. This value is set by the <code>keepalive</code> module. -  <code>NGX_PEER_FAILED</code> — Attempt was <a href="http/ngx_http_upstream_module.html#max_fails">unsuccessful</a> -  <code>NGX_PEER_NEXT</code> — A special case when upstream server returns codes <code>403</code> or <code>404</code> , which are not considered a <a href="http/ngx_http_upstream_module.html#max_fails">failure</a> . -  <code>NGX_PEER_KEEPALIVE</code> — Currently unused </li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p> The <a href="http://hg.nginx.org/nginx-dev-examples" target="_blank" rel="noopener">nginx-dev-examples</a> repository provides nginx module examples. </p>
<h4 id="Code-style"><a href="#Code-style" class="headerlink" title="Code style"></a>Code style</h4><h4 id="General-rules"><a href="#General-rules" class="headerlink" title="General rules"></a>General rules</h4><ul>
<li>maximum text width is 80 characters -  indentation is 4 spaces -  no tabs, no trailing spaces -  list elements on the same line are separated with spaces -  hexadecimal literals are lowercase -  file names, function and type names, and global variables have the <code>ngx_</code> or more specific prefix such as <code>ngx_http_</code> and <code>ngx_mail_</code> </li>
</ul>
<pre class="notranslate">size_t
ngx_utf8_length(u_char *p, size_t n)
{
    u_char  c, *last;
    size_t  len;

    last = p + n;

    for (len = 0; p &lt; last; len++) {

        c = *p;

        if (c &lt; 0x80) {
            p++;
            continue;
        }

        if (ngx_utf8_decode(&amp;p, n) &gt; 0x10ffff) {
            /* invalid UTF-8 */
            return n;
        }
    }

    return len;
}
</pre>



<h4 id="档"><a href="#档" class="headerlink" title="档"></a>档</h4><p> A typical source file may contain the following sections separated by two empty lines: </p>
<ul>
<li>copyright statements -   包括 -  preprocessor definitions -  type definitions -  function prototypes -  variable definitions -  function definitions </li>
</ul>
<p> Copyright statements look like this: </p>
<pre class="notranslate">/*
 * Copyright (C) Author Name
 * Copyright (C) Organization, Inc.
 */
</pre>

<p> If the file is modified significantly, the list of authors should be updated, the new author is added to the top. </p>
<p> The <code>ngx_config.h</code> and <code>ngx_core.h</code> files are always included first, followed by one of <code>ngx_http.h</code> , <code>ngx_stream.h</code> , or <code>ngx_mail.h</code> . Then follow optional external header files: </p>
<pre class="notranslate">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;

#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;
#include &lt;libxslt/xslt.h&gt;

#if (NGX_HAVE_EXSLT)
#include &lt;libexslt/exslt.h&gt;
#endif
</pre>



<p> Header files should include the so called “header protection”: </p>
<pre class="notranslate">#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_
#define _NGX_PROCESS_CYCLE_H_INCLUDED_
...
#endif /* _NGX_PROCESS_CYCLE_H_INCLUDED_ */
</pre>



<h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><ul>
<li>“ <code>//</code> ” comments are not used -  text is written in English, American spelling is preferred </li><li> multi-line comments are formatted like this: <blockquote class="example"><pre class="notranslate">/*<ul>
<li>The red-black tree code is based on the algorithm described in</li>
<li>the “Introduction to Algorithms” by Cormen, Leiserson and Rivest.<br><em>/<br></em></li></ul></pre></blockquote><blockquote class="example"><pre class="notranslate">/ find the server configuration for the address:port */<br></pre></blockquote></li><pre class="notranslate">/* find the server configuration for the address:port */
</pre>



</ul></li>
</ul>
</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p> Macro names start from <code>ngx_</code> or <code>NGX_</code> (or more specific) prefix. Macro names for constants are uppercase. Parameterized macros and macros for initializers are lowercase. The macro name and value are separated by at least two spaces: </p>
<pre class="notranslate">#define NGX_CONF_BUFFER  4096

#define ngx_buf_in_memory(b)  (b-&gt;temporary || b-&gt;memory || b-&gt;mmap)

#define ngx_buf_size(b)                                                      \
    (ngx_buf_in_memory(b) ? (off_t) (b-&gt;last - b-&gt;pos):                      \
                            (b-&gt;file_last - b-&gt;file_pos))

#define ngx_null_string  { 0, NULL }
</pre>

<p> Conditions are inside parentheses, negation is outside: </p>
<pre class="notranslate">#if (NGX_HAVE_KQUEUE)
...
#elif ((NGX_HAVE_DEVPOLL &amp;&amp; !(NGX_TEST_BUILD_DEVPOLL)) \
       || (NGX_HAVE_EVENTPORT &amp;&amp; !(NGX_TEST_BUILD_EVENTPORT)))
...
#elif (NGX_HAVE_EPOLL &amp;&amp; !(NGX_TEST_BUILD_EPOLL))
...
#elif (NGX_HAVE_POLL)
...
#else /* select */
...
#endif /* NGX_HAVE_KQUEUE */
</pre>



<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p> Type names end with the “ <code>_t</code> ” suffix. A defined type name is separated by at least two spaces: </p>
<pre class="notranslate">typedef ngx_uint_t  ngx_rbtree_key_t;
</pre>



<p> Structure types are defined using <code>typedef</code> . Inside structures, member types and names are aligned: </p>
<pre class="notranslate">typedef struct {
    size_t      len;
    u_char     *data;
} ngx_str_t;
</pre>

<p> Keep alignment identical among different structures in the file. A structure that points to itself has the name, ending with “ <code>_s</code> ”. Adjacent structure definitions are separated with two empty lines: </p>
<pre class="notranslate">typedef struct ngx_list_part_s  ngx_list_part_t;

struct ngx_list_part_s {
    void             *elts;
    ngx_uint_t        nelts;
    ngx_list_part_t  *next;
};


typedef struct {
    ngx_list_part_t  *last;
    ngx_list_part_t   part;
    size_t            size;
    ngx_uint_t        nalloc;
    ngx_pool_t       *pool;
} ngx_list_t;
</pre>

<p> Each structure member is declared on its own line: </p>
<pre class="notranslate">typedef struct {
    ngx_uint_t        hash;
    ngx_str_t         key;
    ngx_str_t         value;
    u_char           *lowcase_key;
} ngx_table_elt_t;
</pre>



<p> Function pointers inside structures have defined types ending with “ <code>_pt</code> ”: </p>
<pre class="notranslate">typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);
typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);
typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);

typedef struct {
    ngx_recv_pt        recv;
    ngx_recv_chain_pt  recv_chain;
    ngx_recv_pt        udp_recv;
    ngx_send_pt        send;
    ngx_send_pt        udp_send;
    ngx_send_chain_pt  udp_send_chain;
    ngx_send_chain_pt  send_chain;
    ngx_uint_t         flags;
} ngx_os_io_t;
</pre>



<p> Enumerations have types ending with “ <code>_e</code> ”: </p>
<pre class="notranslate">typedef enum {
    ngx_http_fastcgi_st_version = 0,
    ngx_http_fastcgi_st_type,
    ...
    ngx_http_fastcgi_st_padding
} ngx_http_fastcgi_state_e;
</pre>



<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p> Variables are declared sorted by length of a base type, then alphabetically. Type names and variable names are aligned. The type and name “columns” are separated with two spaces. Large arrays are put at the end of a declaration block: </p>
<pre class="notranslate">u_char                      |  | *rv, *p;
ngx_conf_t                  |  | *cf;
ngx_uint_t                  |  |  i, j, k;
unsigned int                |  |  len;
struct sockaddr             |  | *sa;
const unsigned char         |  | *data;
ngx_peer_connection_t       |  | *pc;
ngx_http_core_srv_conf_t    |  |**cscfp;
ngx_http_upstream_srv_conf_t|  | *us, *uscf;
u_char                      |  |  text[NGX_SOCKADDR_STRLEN];
</pre>



<p> Static and global variables may be initialized on declaration: </p>
<pre class="notranslate">static ngx_str_t  ngx_http_memcached_key = ngx_string("memcached_key");
</pre>



<pre class="notranslate">static ngx_uint_t  mday[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</pre>



<pre class="notranslate">static uint32_t  ngx_crc32_table16[] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    ...
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};
</pre>



<p> There is a bunch of commonly used type/name combinations: </p>
<pre class="notranslate">u_char                        *rv;
ngx_int_t                      rc;
ngx_conf_t                    *cf;
ngx_connection_t              *c;
ngx_http_request_t            *r;
ngx_peer_connection_t         *pc;
ngx_http_upstream_srv_conf_t  *us, *uscf;
</pre>



<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p> All functions (even static ones) should have prototypes. Prototypes include argument names. Long prototypes are wrapped with a single indentation on continuation lines: </p>
<pre class="notranslate">static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf);

static char *ngx_http_merge_servers(ngx_conf_t *cf,
    ngx_http_core_main_conf_t *cmcf, ngx_http_module_t *module,
    ngx_uint_t ctx_index);
</pre>

<p> The function name in a definition starts with a new line. The function body opening and closing braces are on separate lines. The body of a function is indented. There are two empty lines between functions: </p>
<pre class="notranslate">static ngx_int_t
ngx_http_find_virtual_server(ngx_http_request_t *r, u_char *host, size_t len)
{
    ...
}


static ngx_int_t
ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
    ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)
{
    ...
}
</pre>

<p> There is no space after the function name and opening parenthesis. Long function calls are wrapped such that continuation lines start from the position of the first function argument. If this is impossible, format the first continuation line such that it ends at position 79: </p>
<pre class="notranslate">ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
               "http header: \"%V: %V\"",
               &amp;h-&gt;key, &amp;h-&gt;value);

hc-&gt;busy = ngx_palloc(r-&gt;connection-&gt;pool,
                  cscf-&gt;large_client_header_buffers.num * sizeof(ngx_buf_t *));
</pre>

<p> The <code>ngx_inline</code> macro should be used instead of <code>inline</code> : </p>
<pre class="notranslate">static ngx_inline void ngx_cpuid(uint32_t i, uint32_t *buf);
</pre>



<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p> Binary operators except “ <code>.</code> ” and “ <code>−&amp;gt;</code> ” should be separated from their operands by one space. Unary operators and subscripts are not separated from their operands by spaces: </p>
<pre class="notranslate">width = width * 10 + (*fmt++ - '0');
</pre>



<pre class="notranslate">ch = (u_char) ((decoded &lt;&lt; 4) + (ch - '0'));
</pre>



<pre class="notranslate">r-&gt;exten.data = &amp;r-&gt;uri.data[i + 1];
</pre>



<p> Type casts are separated by one space from casted expressions. An asterisk inside type cast is separated with space from type name: </p>
<pre class="notranslate">len = ngx_sock_ntop((struct sockaddr *) sin6, p, len, 1);
</pre>



<p> If an expression does not fit into single line, it is wrapped. The preferred point to break a line is a binary operator. The continuation line is lined up with the start of expression: </p>
<pre class="notranslate">if (status == NGX_HTTP_MOVED_PERMANENTLY
    || status == NGX_HTTP_MOVED_TEMPORARILY
    || status == NGX_HTTP_SEE_OTHER
    || status == NGX_HTTP_TEMPORARY_REDIRECT
    || status == NGX_HTTP_PERMANENT_REDIRECT)
{
    ...
}
</pre>



<pre class="notranslate">p-&gt;temp_file-&gt;warn = "an upstream response is buffered "
                     "to a temporary file";
</pre>

<p> As a last resort, it is possible to wrap an expression so that the continuation line ends at position 79: </p>
<pre class="notranslate">hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, sizeof(ngx_hash_wildcard_t)
                                     + size * sizeof(ngx_hash_elt_t *));
</pre>

<p> The above rules also apply to sub-expressions, where each sub-expression has its own indentation level: </p>
<pre class="notranslate">if (((u-&gt;conf-&gt;cache_use_stale &amp; NGX_HTTP_UPSTREAM_FT_UPDATING)
     || c-&gt;stale_updating) &amp;&amp; !r-&gt;background
    &amp;&amp; u-&gt;conf-&gt;cache_background_update)
{
    ...
}
</pre>

<p> Sometimes, it is convenient to wrap an expression after a cast. In this case, the continuation line is indented: </p>
<pre class="notranslate">node = (ngx_rbtree_node_t *)
           ((u_char *) lr - offsetof(ngx_rbtree_node_t, color));
</pre>



<p> Pointers are explicitly compared to <code>NULL</code> (not <code>0</code> ): </p>
<pre class="notranslate">if (ptr != NULL) {
    ...
}
</pre>



<h4 id="Conditionals-and-Loops"><a href="#Conditionals-and-Loops" class="headerlink" title="Conditionals and Loops"></a>Conditionals and Loops</h4><p> The “ <code>if</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line, or on a dedicated line if the condition takes several lines. Closing brace is located on a dedicated line, optionally followed by “ <code>else if</code> / <code>else</code> ”. Usually, there is an empty line before the “ <code>else if</code> / <code>else</code> ” part: </p>
<pre class="notranslate">if (node-&gt;left == sentinel) {
    temp = node-&gt;right;
    subst = node;

} else if (node-&gt;right == sentinel) {
    temp = node-&gt;left;
    subst = node;

} else {
    subst = ngx_rbtree_min(node-&gt;right, sentinel);

    if (subst-&gt;left != sentinel) {
        temp = subst-&gt;left;

    } else {
        temp = subst-&gt;right;
    }
}
</pre>



<p> Similar formatting rules are applied to “ <code>do</code> ” and “ <code>while</code> ” loops: </p>
<pre class="notranslate">while (p &lt; last &amp;&amp; *p == ' ') {
    p++;
}
</pre>



<pre class="notranslate">do {
    ctx-&gt;node = rn;
    ctx = ctx-&gt;next;
} while (ctx);
</pre>



<p> The “ <code>switch</code> ” keyword is separated from the condition by one space. Opening brace is located on the same line. Closing brace is located on a dedicated line. The “ <code>case</code> ” keywords are lined up with “ <code>switch</code> ”: </p>
<pre class="notranslate">switch (ch) {
case '!':
    looked = 2;
    state = ssi_comment0_state;
    break;

case '&lt;':
    copy_end = p;
    break;

default:
    copy_end = p;
    looked = 0;
    state = ssi_start_state;
    break;
}
</pre>



<p> Most “ <code>for</code> ” loops are formatted like this: </p>
<pre class="notranslate">for (i = 0; i &lt; ccf-&gt;env.nelts; i++) {
    ...
}
</pre>



<pre class="notranslate">for (q = ngx_queue_head(locations);
     q != ngx_queue_sentinel(locations);
     q = ngx_queue_next(q))
{
    ...
}
</pre>

<p> If some part of the “ <code>for</code> ” statement is omitted, this is indicated by the “ <code>/* void */</code> ” comment: </p>
<pre class="notranslate">for (i = 0; /* void */ ; i++) {
    ...
}
</pre>

<p> A loop with an empty body is also indicated by the “ <code>/* void */</code> ” comment which may be put on the same line: </p>
<pre class="notranslate">for (cl = *busy; cl-&gt;next; cl = cl-&gt;next) { /* void */ }
</pre>

<p> An endless loop looks like this: </p>
<pre class="notranslate">for ( ;; ) {
    ...
}
</pre>



<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p> Labels are surrounded with empty lines and are indented at the previous level: </p>
<pre class="notranslate">    if (i == 0) {
        u-&gt;err = "host not found";
        goto failed;
    }

    u-&gt;addrs = ngx_pcalloc(pool, i * sizeof(ngx_addr_t));
    if (u-&gt;addrs == NULL) {
        goto failed;
    }

    u-&gt;naddrs = i;

    ...

    return NGX_OK;

failed:

    freeaddrinfo(res);
    return NGX_ERROR;
</pre>





</li></ul></li></ul></li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows-nginx中文手册]]></title>
      <url>/ngx/windows.html</url>
      <content type="html"><![CDATA[<p>windows<br><a id="more"></a></p>
<h2 id="适用于Windows的nginx"><a href="#适用于Windows的nginx" class="headerlink" title="适用于Windows的nginx"></a>适用于Windows的nginx</h2><td align="left" class="notranslate"> <a href="#known_issues">Known issues</a> <br> <a href="#possible_future_enhancements">Possible future enhancements</a> <br></td>

<p>  适用于Windows的nginx版本使用本机Win32 API（而不是Cygwin仿真层）。  目前仅使用<code>select()</code>连接处理方法，因此不应期望高性能和可伸缩性。  由于这个以及一些其他已知问题，nginx for Windows的版本被认为是<em>测试</em>版。  目前，除了XSLT过滤器，图像过滤器，GeoIP模块和嵌入式Perl语言之外，它提供的功能几乎与UNIX版本的nginx相同。 </p>
<p>  要安装nginx / Windows，请<a href="download.html">下载</a>最新的主线版本发行版（1.15.7），因为nginx的主线分支包含所有已知的修复程序。  然后解压缩发行版，转到nginx-1.15.7目录，然后运行<code>nginx</code> 。  以下是驱动器C：根目录的示例： </p>
<pre class="notranslate">cd c:\
unzip nginx-1.15.7.zip
cd nginx-1.15.7
start nginx
</pre>

<p>  运行<code>tasklist</code>命令行实用程序以查看nginx进程： </p>
<pre class="notranslate">C:\nginx-1.15.7&gt;tasklist /fi "imagename eq nginx.exe"

Image Name           PID Session Name     Session#    Mem Usage
=============== ======== ============== ========== ============
nginx.exe            652 Console                 0      2 780 K
nginx.exe           1332 Console                 0      3 112 K
</pre>

<p>  其中一个进程是主进程，另一个进程是工作进程。  如果nginx未启动，请在错误日志文件<code>logs\error.log</code>查找原因。  如果尚未创建日志文件，则应在Windows事件日志中报告其原因。  如果显示错误页面而不是预期页面，还要在<code>logs\error.log</code>文件中查找原因。 </p>
<p>   nginx / Windows使用运行它的目录作为配置中相对路径的前缀。  在上面的示例中，前缀为<code>C:\nginx-1.15.7\</code> 。  必须使用正斜杠以UNIX样式指定配置文件中的路径： </p>
<pre class="notranslate">access_log   logs/site.log;
root         C:/web/html;
</pre>



<p>   nginx / Windows作为标准控制台应用程序（而非服务）运行，可以使用以下命令进行管理： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">nginx -s stop</td><td class="notranslate">fast shutdown</td><br><td class="notranslate">nginx -s quit</td><td class="notranslate">graceful shutdown</td><br><tr><td class="notranslate">nginx -s reload</td><td class="notranslate"><br>changing configuration,<br>starting new worker processes with a new configuration,<br>graceful shutdown of old worker processes<br></td></tr><td class="notranslate">nginx -s reopen</td><td class="notranslate">re-opening log files</td><br></tbody></table>



</blockquote>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><ul>
<li>虽然可以启动几个工作人员，但实际上只有一个工作。 -   一个worker可以处理不超过1024个并发连接。 -   不支持UDP代理功能。 <h4 id="可能的未来增强功能"><a href="#可能的未来增强功能" class="headerlink" title="可能的未来增强功能"></a>可能的未来增强功能</h4></li>
<li>作为服务运行。 -   使用I / O完成端口作为连接处理方法。 -   在单个工作进程中使用多个工作线程。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[varindex-nginx中文手册]]></title>
      <url>/ngx/varindex.html</url>
      <content type="html"><![CDATA[<p>varindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的变量索引"><a href="#按字母顺序排列的变量索引" class="headerlink" title="按字母顺序排列的变量索引"></a>按字母顺序排列的变量索引</h2><p>   <a href="http/ngx_http_browser_module.html#var_ancient_browser">$ ancient_browser</a> <br>   <a href="http/ngx_http_core_module.html#var_arg_">$ arg_</a> <br>   <a href="http/ngx_http_core_module.html#var_args">的$ args</a> <br>   <a href="http/ngx_http_core_module.html#var_binary_remote_addr">$ binary_remote_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_binary_remote_addr">$ binary_remote_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_body_bytes_sent">$ body_bytes_sent</a> <br>   <a href="stream/ngx_stream_core_module.html#var_bytes_received">$ bytes_received</a> <br>   <a href="http/ngx_http_core_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_bytes_sent">$ bytes_sent</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_connection">$ connection</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_connection">$ connection</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_connection">$ connection</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_connection_requests">$ connection_requests</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_connection_requests">$ connection_requests</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_active">$ connections_active</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_reading">$ connections_reading</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_waiting">$ connections_waiting</a> <br>   <a href="http/ngx_http_stub_status_module.html#var_connections_writing">$ connections_writing</a> <br>   <a href="http/ngx_http_core_module.html#var_content_length">$ CONTENT_LENGTH</a> <br>   <a href="http/ngx_http_core_module.html#var_content_type">$ CONTENT_TYPE</a> <br>   <a href="http/ngx_http_core_module.html#var_cookie_">$ cookie_</a> <br>   <a href="http/ngx_http_ssi_module.html#var_date_gmt">$ date_gmt</a> <br>   <a href="http/ngx_http_ssi_module.html#var_date_local">$ DATE_LOCAL</a> <br>   <a href="http/ngx_http_core_module.html#var_document_root">$ DOCUMENT_ROOT</a> <br>   <a href="http/ngx_http_core_module.html#var_document_uri">$ DOCUMENT_URI</a> <br>   <a href="http/ngx_http_fastcgi_module.html#var_fastcgi_path_info">$ fastcgi_path_info</a> <br>   <a href="http/ngx_http_fastcgi_module.html#var_fastcgi_script_name">$ fastcgi_script_name</a> <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_area_code">$ geoip_area_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_area_code">$ geoip_area_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city">$ geoip_city</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city">$ geoip_city</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_continent_code">$ geoip_city_continent_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_continent_code">$ geoip_city_continent_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_code">$ geoip_city_country_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_code">$ geoip_city_country_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_code3">$ geoip_city_country_code3</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_code3">$ geoip_city_country_code3</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_city_country_name">$ geoip_city_country_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_city_country_name">$ geoip_city_country_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_code">$ geoip_country_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_code">$ geoip_country_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_code3">$ geoip_country_code3</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_code3">$ geoip_country_code3</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_country_name">$ geoip_country_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_country_name">$ geoip_country_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_dma_code">$ geoip_dma_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_dma_code">$ geoip_dma_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_latitude">$ geoip_latitude</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_latitude">$ geoip_latitude</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_longitude">$ geoip_longitude</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_longitude">$ geoip_longitude</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_org">$ geoip_org</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_org">$ geoip_org</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_postal_code">$ geoip_postal_code</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_postal_code">$ geoip_postal_code</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_region">$ geoip_region</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_region">$ geoip_region</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#var_geoip_region_name">$ geoip_region_name</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#var_geoip_region_name">$ geoip_region_name</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_gzip_module.html#var_gzip_ratio">$ gzip_ratio</a> <br>   <a href="http/ngx_http_core_module.html#var_host">$主机</a> <br>   <a href="http/ngx_http_core_module.html#var_hostname">$ hostname</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_hostname">$ hostname</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_v2_module.html#var_http2">$ http2</a> <br>   <a href="http/ngx_http_core_module.html#var_http_">$ HTTP</a> <br>   <a href="http/ngx_http_core_module.html#var_https">$ HTTPS</a> <br>   <a href="http/ngx_http_referer_module.html#var_invalid_referer">$ invalid_referer</a> <br>   <a href="http/ngx_http_core_module.html#var_is_args">$ is_args</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#var_jwt_claim_">$ jwt<em>claim</em></a> <br>   <a href="http/ngx_http_auth_jwt_module.html#var_jwt_header_">$ jwt<em>header</em></a> <br>   <a href="http/ngx_http_core_module.html#var_limit_rate">$ limit_rate</a> <br>   <a href="http/ngx_http_memcached_module.html#var_memcached_key">$ memcached_key</a> <br>   <a href="http/ngx_http_browser_module.html#var_modern_browser">$ modern_browser</a> <br>   <a href="http/ngx_http_core_module.html#var_msec">$ msec</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_msec">$ msec</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_msec">$ msec</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_browser_module.html#var_msie">$ MSIE</a> <br>   <a href="http/ngx_http_core_module.html#var_nginx_version">$ nginx_version</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_nginx_version">$ nginx_version</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_pid">$ pid</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_pid">$ pid</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_pipe">$ pipe</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_pipe">$ pipe</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_protocol">$协议</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_add_x_forwarded_for">$ proxy_add_x_forwarded_for</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_host">$ proxy_host使用</a> <br>   <a href="http/ngx_http_proxy_module.html#var_proxy_port">话$ proxy_port</a> <br>   <a href="http/ngx_http_core_module.html#var_proxy_protocol_addr">$ proxy_protocol_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_proxy_protocol_addr">$ proxy_protocol_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_proxy_protocol_port">$ proxy_protocol_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_proxy_protocol_port">$ proxy_protocol_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_query_string">$ QUERY_STRING</a> <br>   <a href="http/ngx_http_realip_module.html#var_realip_remote_addr">$ realip_remote_addr</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#var_realip_remote_addr">$ realip_remote_addr</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_realip_module.html#var_realip_remote_port">$ realip_remote_port</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#var_realip_remote_port">$ realip_remote_port</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_core_module.html#var_realpath_root">$ realpath_root</a> <br>   <a href="http/ngx_http_core_module.html#var_remote_addr">$ remote_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_remote_addr">$ remote_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_remote_port">$ remote_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_remote_port">$ remote_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_remote_user">$ REMOTE_USER</a> <br>   <a href="http/ngx_http_core_module.html#var_request">$请求</a> <br>   <a href="http/ngx_http_core_module.html#var_request_body">$ request_body</a> <br>   <a href="http/ngx_http_core_module.html#var_request_body_file">$ REQUEST_BODY_FILE</a> <br>   <a href="http/ngx_http_core_module.html#var_request_completion">$ request_completion</a> <br>   <a href="http/ngx_http_core_module.html#var_request_filename">$ REQUEST_FILENAME</a> <br>   <a href="http/ngx_http_core_module.html#var_request_id">$ REQUEST_ID</a> <br>   <a href="http/ngx_http_core_module.html#var_request_length">$ request_length</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_request_length">$ request_length</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_core_module.html#var_request_method">$ REQUEST_METHOD</a> <br>   <a href="http/ngx_http_core_module.html#var_request_time">$ request_time</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_request_time">$ request_time</a> （ngx_http_log_module） <br>   <a href="http/ngx_http_core_module.html#var_request_uri">$ REQUEST_URI</a> <br>   <a href="http/ngx_http_core_module.html#var_scheme">$方案</a> <br>   <a href="http/ngx_http_secure_link_module.html#var_secure_link">$ secure_link</a> <br>   <a href="http/ngx_http_secure_link_module.html#var_secure_link_expires">$ secure_link_expires</a> <br>   <a href="http/ngx_http_core_module.html#var_sent_http_">$ sent<em>http</em></a> <br>   <a href="http/ngx_http_core_module.html#var_sent_trailer_">$ sent<em>trailer</em></a> <br>   <a href="http/ngx_http_core_module.html#var_server_addr">$ server_addr</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_server_addr">$ server_addr</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_server_name">$ SERVER_NAME</a> <br>   <a href="http/ngx_http_core_module.html#var_server_port">$ server_port</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#var_server_port">$ server_port</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_server_protocol">$ SERVER_PROTOCOL</a> <br>   <a href="http/ngx_http_session_log_module.html#var_session_log_binary_id">$ session_log_binary_id</a> <br>   <a href="http/ngx_http_session_log_module.html#var_session_log_id">$ session_log_id</a> <br>   <a href="stream/ngx_stream_core_module.html#var_session_time">$ session_time</a> <br>   <a href="http/ngx_http_slice_module.html#var_slice_range">$ slice_range</a> <br>   <a href="http/ngx_http_spdy_module.html#var_spdy">$ SPDY</a> <br>   <a href="http/ngx_http_spdy_module.html#var_spdy_request_priority">$ spdy_request_priority</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_cipher">$ ssl_cipher</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_cipher">$ ssl_cipher</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_ciphers">$ ssl_ciphers</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_ciphers">$ ssl_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_cert">$ ssl_client_cert</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_cert">$ ssl_client_cert</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_escaped_cert">$ ssl_client_escaped_cert</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_fingerprint">$ ssl_client_fingerprint</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_fingerprint">$ ssl_client_fingerprint</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_i_dn">$ ssl_client_i_dn</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_i_dn">$ ssl_client_i_dn</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_i_dn_legacy">$ ssl_client_i_dn_legacy</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_raw_cert">$ ssl_client_raw_cert</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_raw_cert">$ ssl_client_raw_cert</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_s_dn">$ ssl_client_s_dn</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_s_dn">$ ssl_client_s_dn</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_s_dn_legacy">$ ssl_client_s_dn_legacy</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_serial">$ ssl_client_serial</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_serial">$ ssl_client_serial</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_end">$ ssl_client_v_end</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_end">$ ssl_client_v_end</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_remain">$ ssl_client_v_remain</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_remain">$ ssl_client_v_remain</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_v_start">$ ssl_client_v_start</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_v_start">$ ssl_client_v_start</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_client_verify">$ ssl_client_verify</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_client_verify">$ ssl_client_verify</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_curves">$ ssl_curves</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_curves">$ ssl_curves</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_early_data">$ ssl_early_data</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_alpn_protocols">$ ssl_preread_alpn_protocols</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_protocol">$ ssl_preread_protocol</a> <br>   <a href="stream/ngx_stream_ssl_preread_module.html#var_ssl_preread_server_name">$ ssl_preread_server_name</a> <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_protocol">$ ssl_protocol</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_protocol">$ ssl_protocol</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_server_name">$ ssl_server_name</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_server_name">$ ssl_server_name</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_session_id">$ ssl_session_id</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_session_id">$ ssl_session_id</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#var_ssl_session_reused">$ ssl_session_reused</a> （ngx_http_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#var_ssl_session_reused">$ ssl_session_reused</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_core_module.html#var_status">$ status</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_status">$ status</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_status">$ status</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rtt</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rttvar</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_snd_cwnd</a> <br>   <a href="http/ngx_http_core_module.html#var_tcpinfo_">$ tcpinfo_rcv_space</a> <br>   <a href="http/ngx_http_core_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_time_iso8601">$ time_iso8601</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#var_time_local">$ time_local</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_log_module.html#var_time_local">$ time_local</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_core_module.html#var_time_local">$ time_local</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_userid_module.html#var_uid_got">$ uid_got</a> <br>   <a href="http/ngx_http_userid_module.html#var_uid_reset">$ uid_reset</a> <br>   <a href="http/ngx_http_userid_module.html#var_uid_set">$ uid_set</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_addr">$ upstream_addr</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_addr">$ upstream_addr</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_bytes_received">$ upstream_bytes_received</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_bytes_received">$ upstream_bytes_received</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_bytes_sent">$ upstream_bytes_sent</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_bytes_sent">$ upstream_bytes_sent</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_cache_status">$ upstream_cache_status</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_connect_time">$ upstream_connect_time</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_connect_time">$ upstream_connect_time</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_cookie_">$ upstream<em>cookie</em></a> <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_first_byte_time">$ upstream_first_byte_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_header_time">$ upstream_header_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_http_">$ upstream<em>http</em></a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_queue_time">$ upstream_queue_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_response_length">$ upstream_response_length</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_response_time">$ upstream_response_time</a> <br>   <a href="stream/ngx_stream_upstream_module.html#var_upstream_session_time">$ upstream_session_time</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_status">$ upstream_status</a> <br>   <a href="http/ngx_http_upstream_module.html#var_upstream_trailer_">$ upstream<em>trailer</em></a> <br>   <a href="http/ngx_http_core_module.html#var_uri">$ URI</a> <br></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syslog-nginx中文手册]]></title>
      <url>/ngx/syslog.html</url>
      <content type="html"><![CDATA[<p>syslog<br><a id="more"></a></p>
<h2 id="记录到syslog"><a href="#记录到syslog" class="headerlink" title="记录到syslog"></a>记录到syslog</h2><p>   <a href="ngx_core_module.html#error_log">error_log</a>和<a href="http/ngx_http_log_module.html#access_log">access_log</a>指令支持记录到syslog。  以下参数配置到syslog的日志记录： </p>
<blockquote>
<p>  错误消息的严重性由nginx确定，因此在<code>error_log</code>指令中忽略该参数。 </p>
</blockquote>
<p>   syslog配置示例： </p>
<pre class="notranslate">error_log syslog:server=192.168.1.1 debug;

access_log syslog:server=unix:/var/log/nginx.sock,nohostname;
access_log syslog:server=[2001:db8::1]:12345,facility=local7,tag=nginx,severity=info combined;
</pre>





<blockquote>
<p>  从版本1.7.1开始，可以登录到syslog。  作为我们<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业订阅的</a>一部分，从1.5.3版开始，可以使用日志记录到syslog。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syntax-nginx中文手册]]></title>
      <url>/ngx/syntax.html</url>
      <content type="html"><![CDATA[<p>syntax<br><a id="more"></a></p>
<h2 id="配置文件测量单位"><a href="#配置文件测量单位" class="headerlink" title="配置文件测量单位"></a>配置文件测量单位</h2><p>  大小可以以字节，千字节（后缀<code>k</code>和<code>K</code> ）或兆字节（后缀<code>m</code>和<code>M</code> ）来指定，例如，“ <code>1024</code> ”，“ <code>8k</code> ”，“ <code>1m</code> ”。 </p>
<p>  也可以使用<code>g</code>或<code>G</code>后缀以千兆字节为<code>g</code>指定偏移量。 </p>
<p>  可以使用以下后缀以毫秒，秒，分钟，小时，天等指定时间间隔： </p>
<td width="20%" class="notranslate">ms</td><td class="notranslate">milliseconds</td><br><td width="20%" class="notranslate">s</td><td class="notranslate">seconds</td><br><td width="20%" class="notranslate">m</td><td class="notranslate">minutes</td><br><td width="20%" class="notranslate">h</td><td class="notranslate">hours</td><br><td width="20%" class="notranslate">d</td><td class="notranslate">days</td><br><td width="20%" class="notranslate">w</td><td class="notranslate">weeks</td><br><td width="20%" class="notranslate">M</td><td class="notranslate">months, 30 days</td><br><td width="20%" class="notranslate">y</td><td class="notranslate">years, 365 days</td>



<p>  通过按从最高有效到最低有序的顺序指定多个单元，可以将多个单元组合成单个值，并且可选地由空格分隔。  例如，“ <code>1h 30m</code> ”指定与“ <code>90m</code> ”或“ <code>5400s</code> ”相同的时间。  没有后缀的值表示秒。  建议始终指定后缀。 </p>
<p>  某些时间间隔只能以秒分辨率指定。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[switches-nginx中文手册]]></title>
      <url>/ngx/switches.html</url>
      <content type="html"><![CDATA[<p>switches<br><a id="more"></a></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>   nginx支持以下命令行参数： </p>
<ul>
<li><code>-?</code>   |   <code>-h</code> - 打印命令行参数的帮助。 -    <code>-c &lt;code class=&quot;notranslate&quot;&gt;*file*</code> - 使用备用配置<code>*file*</code>而不是默认文件。 </li><li>   <code>-g &lt;code class=&quot;notranslate&quot;&gt;*directives*</code> - 设置<a href="ngx_core_module.html">全局配置指令</a> ，例如， <blockquote class="example"><pre class="notranslate">nginx -g “pid /var/run/nginx.pid; worker_processes <code>sysctl -n hw.ncpu</code>;”<br></pre></blockquote></li>-    <code>-p &lt;code class=&quot;notranslate&quot;&gt;*prefix*</code> - 设置nginx路径前缀，即保留服务器文件的目录（默认值为<code>*/usr/local/nginx*</code> ）。 -    <code>-q</code> - 在配置测试期间禁止出现非错误消息。 -    <code>-s &lt;code class=&quot;notranslate&quot;&gt;*signal*</code> - 向主进程发送<em>信号</em> 。  参数<em>信号</em>可以是以下之一： <ul class="compact"><li>   <code>stop</code> - 快速关闭 -    <code>quit</code> - 优雅地关闭 -    <code>reload</code> - 重新加载配置，使用新配置启动新的工作进程，正常关闭旧的工作进程。 -    <code>reopen</code> - 重新打开日志文件 </li>
</ul>
</ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reference-nginx中文手册]]></title>
      <url>/ngx/reference.html</url>
      <content type="html"><![CDATA[<p>reference<br><a id="more"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><td align="left" class="notranslate"> <a href="#http_stream">nginx objects</a> <br>     <a href="#http">HTTP Request</a> <br>     <a href="#stream">Stream Session</a> <br> <a href="#core">Core</a> <br>     <a href="#string">String</a> <br>     <a href="#core_json">JSON</a> <br>     <a href="#crypto">Crypto</a> <br>     <a href="#njs_api_timers">Timers</a> <br>     <a href="#njs_api_fs">File System</a> <br></td>

<p>   <a href="index.html">njs</a>提供了扩展nginx功能的对象，方法和属性。 </p>
<h4 id="nginx对象"><a href="#nginx对象" class="headerlink" title="nginx对象"></a>nginx对象</h4><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>   HTTP请求对象仅在<a href="http/ngx_http_js_module.html">ngx_http_js_module</a>模块中可用。  对象的所有字符串属性都是<a href="#string">字节字符串</a> 。 </p>
<p>  例如，可以使用语法<code>headersIn.foo</code>或<code>headersIn[&#39;Foo&#39;]</code>访问<code>Foo</code>标头 </p>
<p>  例如，可以使用语法<code>headersOut.foo</code>或<code>headersOut[&#39;Foo&#39;]</code>访问<code>Foo</code>标头 </p>
<p>  可以指定重定向URL（对于代码301,302,303,307和308）或响应正文文本（对于其他代码）作为第二个参数 </p>
<p>  如果<code>options</code>是一个字符串，那么它包含子请求参数字符串。  否则， <code>options</code>应该是具有以下键的对象： </p>
<p>  完成<code>callback</code>接收子请求响应对象，其方法和属性与父请求对象相同。 </p>
<h4 id="流会话"><a href="#流会话" class="headerlink" title="流会话"></a>流会话</h4><p>  流会话对象仅在<a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a>模块中可用。  对象的所有字符串属性都是<a href="#string">字节字符串</a> 。 </p>
<blockquote>
<p>  在njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>之前，流会话对象具有一些当前<a href="#stream_obsolete">被删除的</a>属性。 </p>
</blockquote>
<p>   <code>event</code>可以是以下字符串之一： </p>
<p>  完成回调具有以下原型： <code>callback(data, flags)</code> ，其中<code>data</code>是字符串， <code>flags</code>是具有以下属性的对象： </p>
<h4 id="过时的属性"><a href="#过时的属性" class="headerlink" title="过时的属性"></a>过时的属性</h4><p>  这些属性已在njs <a href="njs/changes.html#njs0.2.4">0.2.4中</a>删除，并且与现有的njs代码不向后兼容。 </p>
<blockquote>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_deny">s.deny（）</a>方法。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，如果没有<a href="#s_allow">调用s.allow（）</a> ， <a href="#s_deny">s.deny（）</a> ， <a href="#s_decline">s.decline（）</a> ， <a href="#s_done">s.done（）</a>并且注册了回调， <a href="#s_deny">则会</a>实现相应的行为。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_send">s.send（）</a>方法进行编写。  对于读取，当前缓冲区可用作<code>event</code>回调的第一个参数。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_decline">s.decline（）</a>方法。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_on_callback_last">flags.last</a>属性。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，可以抛出适当的异常来报告错误。 </p>
<p>  从<a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应使用相应的<a href="#s_on">事件</a> （ <code>upload</code>或<code>download</code> ）来处理来自客户端的数据。 </p>
<p>  从njs <a href="njs/changes.html#njs0.2.4">0.2.4</a>开始，应该使用<a href="#s_allow">s.allow（）</a>方法。 </p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p>  有两种类型的字符串： <code>Unicode string</code> （默认）和<code>byte string</code> 。 </p>
<p>   <code>Unicode string</code>对应于包含Unicode字符的ECMAScript字符串。 </p>
<p>   <code>Byte strings</code>包含一系列字节。  它们用于将Unicode字符串序列化为外部数据，并从外部源反序列化。  例如， <a href="#string_toutf8">toUTF8（）</a>方法使用UTF8编码将Unicode字符串序列化为字节字符串： </p>
<pre class="notranslate">&gt;&gt; '£'.toUTF8().toString('hex')
'c2a3'  /* C2 A3 is the UTF8 representation of 00A3 ('£') code point */
</pre>

<p>   <a href="#string_tobytes">toBytes（）</a>方法将代码点最多为255的Unicode字符串序列化为字节字符串，否则返回<code>null</code> ： </p>
<pre class="notranslate">&gt;&gt; '£'.toBytes().toString('hex')
'a3'  /* a3 is a byte equal to 00A3 ('£') code point  */
</pre>

<p>  只有字节字符串可以转换为不同的编码。  例如，字符串不能直接编码为<code>hex</code> ： </p>
<pre class="notranslate">&gt;&gt; 'αβγδ'.toString('base64')
TypeError: argument must be a byte string
    at String.prototype.toString (native)
    at main (native)
</pre>

<p>  要将Unicode字符串转换为十六进制，首先应将其转换为字节字符串，然后转换为十六进制： </p>
<pre class="notranslate">&gt;&gt; 'αβγδ'.toUTF8().toString('base64')
'zrHOss6zzrQ='
</pre>



<pre class="notranslate">&gt;&gt; String.bytesFrom([0x62, 0x75, 0x66, 0x66, 0x65, 0x72])
'buffer'

&gt;&gt; String.bytesFrom('YnVmZmVy', 'base64')
'buffer'
</pre>

<pre class="notranslate">&gt;&gt; String.fromCharCode(97, 98, 99, 100)
'abcd'
</pre>

<pre class="notranslate">&gt;&gt; String.fromCodePoint(97, 98, 99, 100)
'abcd'
</pre>

<pre class="notranslate">&gt;&gt; 'ABCD'.codePointAt(3);
68
</pre>

<pre class="notranslate">&gt;&gt; "a".concat("b", "c")
'abc'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.endsWith('abc')
true
&gt;&gt; 'abca'.endsWith('abc')
false
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.includes('bc')
true
</pre>

<pre class="notranslate">&gt;&gt; 'abcdef'.indexOf('de', 2)
3
</pre>

<pre class="notranslate">&gt;&gt; "nginx".lastIndexOf("gi")
1
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.length
4
</pre>

<pre class="notranslate">&gt;&gt; 'nginx'.match( /ng/i )
'ng'
</pre>

<pre class="notranslate">&gt;&gt; '1234'.padEnd(8, 'abcd')
'1234abcd'
</pre>

<pre class="notranslate">&gt;&gt; '1234'.padStart(8, 'abcd')
'abcd1234'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.repeat(3)
'abcabcabc'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefgh'.replace('d', 1)
'abc1efgh'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefgh'.search('def')
3
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefghijklmno'.slice(NaN, 5)
'abcde'
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.split('')
[
 'a',
 'b',
 'c'
]
</pre>

<pre class="notranslate">&gt;&gt; 'abc'.startsWith('abc')
true
&gt; 'aabc'.startsWith('abc')
false
</pre>

<pre class="notranslate">&gt;&gt;  'abcdefghijklmno'.substr(3, 5)
'defgh'
</pre>

<pre class="notranslate">&gt;&gt; 'abcdefghijklmno'.substring(3, 5)
'de'
</pre>

<pre class="notranslate">&gt;&gt; 'ΑΒΓΔ'.toLowerCase()
'αβγδ'
</pre>

<p>  如果未指定<code>encoding</code> ，则返回ECMAScript中指定的Unicode字符串或字节字符串。 </p>
<p>   （特定于njs）如果指定了<code>encoding</code> ，则将<a href="#string_tobytes">字节字符串</a>编码为<code>hex</code> ， <code>base64</code>或<code>base64url</code> 。 </p>
<pre class="notranslate">&gt;&gt;  'αβγδ'.toUTF8().toString('base64url')
'zrHOss6zzrQ'
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.toUpperCase()
'ΑΒΓΔ'
</pre>

<pre class="notranslate">&gt;&gt; 'αβγδ'.toUTF8().length
8
&gt;&gt; 'αβγδ'.length
4
</pre>

<pre class="notranslate">&gt;&gt; '   abc  '.trim()
'abc'
</pre>

<pre class="notranslate">&gt;&gt; encodeURI('012αβγδ')
'012%CE%B1%CE%B2%CE%B3%CE%B4'
</pre>

<pre class="notranslate">&gt;&gt; encodeURIComponent('[@?=')
'%5B%40%3F%3D'
</pre>

<pre class="notranslate">&gt;&gt; decodeURI('012%CE%B1%CE%B2%CE%B3%CE%B4')
'012αβγδ'
</pre>

<pre class="notranslate">&gt;&gt; decodeURIComponent('%5B%40%3F%3D')
'[@?='
</pre>



<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>   <code>JSON</code>对象（ES 5.1）提供了将njs值转换为JSON格式和从JSON格式转换的函数。 </p>
<pre class="notranslate">&gt;&gt; var json = JSON.parse('{"a":1, "b":true}')
&gt;&gt; json.a
1

&gt;&gt; JSON.stringify(json)
'{"a":1,"b":true}'

&gt;&gt; JSON.stringify(json, undefined, 1)
'{\n "a": 1,\n "b": true\n}'

&gt;&gt; JSON.stringify({ x: [10, undefined, function(){}] })
'{"x":[10,null,null]}'

&gt;&gt; JSON.stringify({"a":1, "toJSON": function() {return "xxx"}})
'"xxx"'

# Example with function replacer

&gt;&gt; function replacer(key, value) {return (typeof value === 'string') ? undefined : value}
&gt;&gt;JSON.stringify({a:1, b:"b", c:true}, replacer)
'{"a":1,"c":true}'
</pre>



<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>   Crypto模块提供加密功能支持。   <code>require(&#39;crypto&#39;)</code>返回Crypto模块对象。 </p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><pre class="notranslate">&gt;&gt; var cr = require('crypto')
undefined

&gt;&gt; cr.createHash('sha1').update('A').update('B').digest('base64url')
'BtlFlCqiamG-GMPiK_GbvKjdK10'
</pre>



<h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><pre class="notranslate">&gt;&gt; var cr = require('crypto')
undefined

&gt;&gt; cr.createHmac('sha1', 'secret.key').update('AB').digest('base64url')
'Oglm93xn23_MkiaEq_e9u8zk374'
</pre>



<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><pre class="notranslate">function handler(v)
{
    // ...
}

t = setTimeout(handler, 12);

// ...

clearTimeout(t);
</pre>



<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>  文件系统模块提供文件操作。   <code>require(&#39;fs&#39;)</code>返回模块对象。 </p>
<pre class="notranslate">&gt;&gt; var fs = require('fs')
undefined
&gt;&gt; var file = fs.readFileSync('/file/path.tar.gz')
undefined
&gt;&gt; var gzipped = /^\x1f\x8b/.test(file); gzipped
true
</pre>

<pre class="notranslate">&gt;&gt; var fs = require('fs')
undefined
&gt;&gt; var file = fs.writeFileSync('hello.txt', 'Hello world')
undefined
</pre>



<h4 id="文件系统标志"><a href="#文件系统标志" class="headerlink" title="文件系统标志"></a>文件系统标志</h4><p>   <code>flag</code>选项可以接受以下值： </p>
<ul>
<li><code>a</code> - 打开要追加的文件。  如果文件不存在，则创建该文件 -    <code>ax</code> - 与<code>a</code>相同但如果文件已存在则失败 -    <code>a+</code> - 打开一个文件进行阅读和追加。  如果该文件不存在，则将创建该文件 -    <code>ax+</code> - 与<code>a+</code>相同但如果文件已经存在则失败 -    <code>as</code> - 打开一个文件以便以同步模式追加。  如果该文件不存在，则将创建该文件 -    <code>as+</code> - 打开一个文件以便以同步模式读取和追加。  如果该文件不存在，则将创建该文件 -    <code>r</code> - 打开文件进行阅读。  如果文件不存在，则会发生异常 -    <code>r+</code> - 打开一个文件进行读写。  如果文件不存在，则会发生异常 -    <code>rs+</code> - 打开一个文件，以同步模式读写。  指示操作系统绕过本地文件系统缓存 -    <code>w</code> - 打开文件进行写作。  如果该文件不存在，则将创建该文件。  如果文件存在，则将替换它 -    <code>wx</code> - 与<code>w</code>相同但如果文件已存在则失败 -    <code>w+</code> - 打开一个文件进行读写。  如果该文件不存在，则将创建该文件。  如果文件存在，则将替换它 -    <code>wx+</code> - 与<code>w+</code>相同但如果文件已存在则失败 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_google_perftools_module-nginx中文手册]]></title>
      <url>/ngx/ngx_google_perftools_module.html</url>
      <content type="html"><![CDATA[<p>ngx_google_perftools_module<br><a id="more"></a></p>
<h2 id="Module-ngx-google-perftools-module"><a href="#Module-ngx-google-perftools-module" class="headerlink" title="Module ngx_google_perftools_module"></a>Module ngx_google_perftools_module</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#google_perftools_profiles">google_perftools_profiles</a> <br></td>

<p>   <code>ngx_google_perftoos_module</code>模块（0.6.29）支持使用<a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">Google Performance Tools</a>分析nginx工作进程。  该模块适用于nginx开发人员。 </p>
<p>  默认情况下不会构建此模块，应使用<code>--with-google_perftools_module</code>配置参数启用它。 </p>
<blockquote>
<p>  该模块需要<a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">gperftools</a>库。 </p>
</blockquote>
<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">google_perftools_profiles /path/to/profile;
</pre>

<p>  配置文件将存储为<code>/path/to/profile.&amp;lt;worker_pid&amp;gt;</code> 。 </p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**google_perftools_profiles*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  设置一个文件名，用于保存nginx工作进程的分析信息。  工作进程的ID始终是文件名的一部分，并在点后面附加到文件名的末尾。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_core_module-nginx中文手册]]></title>
      <url>/ngx/ngx_core_module.html</url>
      <content type="html"><![CDATA[<p>ngx_core_module<br><a id="more"></a></p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><td align="left" class="notranslate"> <a href="#example">Example Configuration</a> <br> <a href="#directives">Directives</a> <br>     <a href="#accept_mutex">accept_mutex</a> <br>     <a href="#accept_mutex_delay">accept_mutex_delay</a> <br>     <a href="#daemon">daemon</a> <br>     <a href="#debug_connection">debug_connection</a> <br>     <a href="#debug_points">debug_points</a> <br>     <a href="#env">env</a> <br>     <a href="#error_log">error_log</a> <br>     <a href="#events">events</a> <br>     <a href="#include">include</a> <br>     <a href="#load_module">load_module</a> <br>     <a href="#lock_file">lock_file</a> <br>     <a href="#master_process">master_process</a> <br>     <a href="#multi_accept">multi_accept</a> <br>     <a href="#pcre_jit">pcre_jit</a> <br>     <a href="#pid">pid</a> <br>     <a href="#ssl_engine">ssl_engine</a> <br>     <a href="#thread_pool">thread_pool</a> <br>     <a href="#timer_resolution">timer_resolution</a> <br>     <a href="#use">use</a> <br>     <a href="#user">user</a> <br>     <a href="#worker_aio_requests">worker_aio_requests</a> <br>     <a href="#worker_connections">worker_connections</a> <br>     <a href="#worker_cpu_affinity">worker_cpu_affinity</a> <br>     <a href="#worker_priority">worker_priority</a> <br>     <a href="#worker_processes">worker_processes</a> <br>     <a href="#worker_rlimit_core">worker_rlimit_core</a> <br>     <a href="#worker_rlimit_nofile">worker_rlimit_nofile</a> <br>     <a href="#worker_shutdown_timeout">worker_shutdown_timeout</a> <br>     <a href="#working_directory">working_directory</a> <br></td>

<h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="notranslate">user www www;
worker_processes 2;

error_log /var/log/nginx-error.log info;

events {
    use kqueue;
    worker_connections 2048;
}

...
</pre>



<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**accept_mutexon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">accept_mutex off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果启用了<code>accept_mutex</code> ，则工作进程将依次接受新连接。  否则，将通知所有工作进程有关新连接的信息，如果新连接的数量很少，则某些工作进程可能只是浪费系统资源。 </p>
<blockquote>
<p>  无需在支持<a href="events.html#epoll">EPOLLEXCLUSIVE</a>标志（1.11.3）的系统上或使用<a href="http/ngx_http_core_module.html#reuseport">reuseport</a>时<a href="http/ngx_http_core_module.html#reuseport">启用accept_mutex</a> 。 </p>
<p>  在1.11.3版之前，默认值为<code>on</code> 。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**accept_mutex_delay*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">accept_mutex_delay 500ms;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果启用了<a href="#accept_mutex">accept_mutex</a> ，则指定当另一个工作进程当前正在接受新连接时，工作进程将尝试重新启动接受新连接的最长时间。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**daemonon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">daemon on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  确定nginx是否应该成为守护进程。  主要用于开发过程中。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**debug_connection**  *address*</code> |    <code>*CIDR*</code> |    <code>unix:</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  为选定的客户端连接启用调试日志。  其他连接将使用<a href="#error_log">error_log</a>指令设置的日志记录级别。  调试连接由IPv4或IPv6（1.3.0,1.2.1）地址或网络指定。  也可以使用主机名指定连接。  对于使用UNIX域套接字（1.3.0,1.2.1）的连接，调试日志由“ <code>unix:</code> ”参数启用。 </p>
<pre class="notranslate">events {
    debug_connection 127.0.0.1;
    debug_connection localhost;
    debug_connection 192.0.2.0/24;
    debug_connection ::1;
    debug_connection 2001:0db8::/32;
    debug_connection unix:;
    ...
}
</pre>



<blockquote>
<p>  要使此指令起作用，需要使用<code>--with-debug</code>构建nginx，请参阅“ <a href="debugging_log.html">调试日志</a> ”。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**debug_pointsabort</code> | <code>stop</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令用于调试。 </p>
<p>  当检测到内部错误时，例如在重新启动工作进程时套接字泄漏，启用<code>debug_points</code>会导致核心文件创建（ <code>abort</code> ）或停止进程（ <code>stop</code> ）以使用系统调试器进行进一步分析。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**env*variable*</code> [= <code>*value*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">env TZ;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  默认情况下，nginx会删除从其父进程继承的所有环境变量，但TZ变量除外。  该指令允许保留一些继承的变量，更改其值或创建新的环境变量。  那么这些变量是： </p>
<ul>
<li>在可执行文件的<a href="control.html#upgrade">实时升级</a>期间继承; -   由<a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a>模块使用; -   由工作进程使用。  应该记住，以这种方式控制系统库并不总是可行的，因为库只在初始化期间检查变量是常见的，远在它们可以使用该指令设置之前。  一个例外是上面提到的可执行文件的<a href="control.html#upgrade">实时升级</a> 。 </li>
</ul>
<p>  除非明确配置，否则TZ变量始终继承并可供<a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a>模块使用。 </p>
<p>  用法示例： </p>
<pre class="notranslate">env MALLOC_OPTIONS;
env PERL5LIB=/data/site/modules;
env OPENSSL_ALLOW_PROXY_CERTS=1;
</pre>





<blockquote>
<p>   NGINX环境变量由nginx在内部使用，不应由用户直接设置。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**error_log*file*</code> [ <code>*level*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">error_log logs/error.log error;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> , <code>http</code> , <code>mail</code> , <code>stream</code> , <code>server</code> , <code>location</code> <br>                </td></p>
<p>  配置日志记录。  可以在同一级别指定多个日志（1.5.2）。  如果在<code>main</code>配置级别上未明确定义将日志写入文件，则将使用默认文件。 </p>
<p>  第一个参数定义将存储日志的<code>*file*</code> 。  特殊值<code>stderr</code>选择标准错误文件。  可以通过指定“ <code>syslog:</code> ”前缀来配置记录到<a href="syslog.html">syslog</a> 。  可以通过指定“ <code>memory:</code> ”前缀和缓冲区<code>*size*</code>来配置记录到<a href="debugging_log.html#memory">循环内存缓冲区</a> ，通常用于调试（1.7.11）。 </p>
<p>  第二个参数确定日志记录<code>*level*</code> ，可以是以下之一： <code>debug</code> ， <code>info</code> ， <code>notice</code> ， <code>warn</code> ， <code>error</code> ， <code>crit</code> ， <code>alert</code>或<code>emerg</code> 。  上面的日志级别按严重性增加的顺序列出。  设置某个日志级别将导致记录指定和更严重日志级别的所有消息。  例如，默认级别<code>error</code>将导致记录<code>error</code> ， <code>crit</code> ， <code>alert</code>和<code>emerg</code>消息。  如果省略此参数，则使用<code>error</code> 。 </p>
<blockquote>
<p>  要使<code>debug</code>日志记录正常工作，需要使用<code>--with-debug</code>构建nginx，请参阅“ <a href="debugging_log.html">调试日志</a> ”。 </p>
<p>  该指令可以在从1.7.11版本开始的<code>stream</code>级别上指定，也可以在从1.9.0版本开始的<code>mail</code>级别上指定。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**events** { ... }</code> <br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  提供配置文件上下文，其中指定了影响连接处理的指令。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**include*file*</code> | <code>*mask*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>any</code> <br>                </td></p>
<p>  包含另一个<code>*file*</code>或与指定<code>*mask*</code>匹配的文件到配置中。  包含的文件应包含语法正确的指令和块。 </p>
<p>  用法示例： </p>
<pre class="notranslate">include mime.types;
include vhosts/*.conf;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**load_module*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.9.11版中。 </p>
<p>  加载动态模块。 </p>
<p>  例： </p>
<pre class="notranslate">load_module modules/ngx_mail_module.so;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**lock_file*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">lock_file logs/nginx.lock;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>   nginx使用锁定机制来实现<a href="#accept_mutex">accept_mutex</a>并序列化对共享内存的访问。  在大多数系统上，锁是使用原子操作实现的，并且忽略该指令。  在其他系统上，使用“锁定文件”机制。  该指令指定锁文件名称的前缀。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**master_processon</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">master_process on;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  确定是否已启动工作进程。  该指令适用于nginx开发人员。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**multi_accepton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">multi_accept off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  如果禁用<code>multi_accept</code>则工作进程将一次接受一个新连接。  否则，工作进程将一次接受所有新连接。 </p>
<blockquote>
<p>  如果使用<a href="events.html#kqueue">kqueue</a>连接处理方法，则忽略该指令，因为它报告了等待接受的新连接的数量。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pcre_jiton</code> | <code>off</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pcre_jit off;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.1.12版本中。 </p>
<p>  启用或禁用对配置解析时已知的正则表达式使用“即时编译”（PCRE JIT）。 </p>
<p>   PCRE JIT可以显着加快正则表达式的处理速度。 </p>
<blockquote>
<p>  从使用<code>--enable-jit</code>配置参数构建的8.20版开始，JIT在PCRE库中可用。  当使用nginx（– <code>--with-pcre=</code> ）构建PCRE库时，通过<code>--with-pcre-jit</code>配置参数启用JIT支持。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**pid*file*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">pid logs/nginx.pid;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义将存储主进程的进程ID的<code>*file*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**ssl_engine*device*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义硬件SSL加速器的名称。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**thread_pool**  *name*</code>    <code>threads</code> = <code>*number*</code>    [ <code>max_queue</code> = <code>*number*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">thread_pool default threads=32 max_queue=65536;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.7.11版本中。 </p>
<p>  定义用于多线程读取和发送文件<a href="http/ngx_http_core_module.html#aio">而不阻塞</a>工作进程的命名线程池。 </p>
<p>   <code>threads</code>参数定义池中的线程数。 </p>
<p>  如果池中的所有线程都忙，则新任务将在队列中等待。   <code>max_queue</code>参数限制允许在队列中等待的任务数。  默认情况下，队列中最多可以等待65536个任务。  当队列溢出时，任务完成并出现错误。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**timer_resolution*interval*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  减少工作进程中的计时器分辨率，从而减少<code>gettimeofday()</code>系统调用的次数。  默认情况下，每次收到内核事件时都会调用<code>gettimeofday()</code> 。  在降低分辨率的情况下， <code>gettimeofday()</code>仅在每个指定的<code>*interval*</code>调用一次。 </p>
<p>  例： </p>
<pre class="notranslate">timer_resolution 100ms;
</pre>



<p>  间隔的内部实现取决于使用的方法： </p>
<ul>
<li>如果使用<code>kqueue</code> ， <code>EVFILT_TIMER</code>过滤器; -    <code>timer_create()</code>如果使用了<code>eventport</code> ; -    <code>setitimer()</code>否则。 </li>
</ul>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**use*method*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  指定要使用的<a href="events.html">连接处理</a> <code>*method*</code> 。  通常不需要明确指定它，因为nginx默认使用最有效的方法。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**user*user*</code> [ <code>*group*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">user nobody nobody;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程使用的<code>*user*</code>和<code>*group*</code>凭据。  如果省略group，则使用名称等于<code>*user*</code>的组。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_aio_requests*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_aio_requests 32;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  该指令出现在1.1.4和1.0.7版本中。 </p>
<p>  将<a href="http/ngx_http_core_module.html#aio">aio</a>与<a href="events.html#epoll">epoll</a>连接处理方法一起使用时，设置单个工作进程的未完成异步I / O操作的最大<code>*number*</code> 。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_connections*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_connections 512;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>events</code> <br>                </td></p>
<p>  设置工作进程可以打开的最大并发连接数。 </p>
<p>  应该记住，这个数字包括所有连接（例如与代理服务器的连接等），而不仅仅是与客户端的连接。  另一个考虑因素是实际的并发连接数不能超过最大打开文件数的当前限制，可以通过<a href="#worker_rlimit_nofile">worker_rlimit_nofile</a>更改。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_cpu_affinity*cpumask*</code> …; <br> <code>**worker_cpu_affinityauto</code> [ <code>*cpumask*</code> ];<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  将工作进程绑定到CPU组。  每个CPU集由允许的CPU的位掩码表示。  应该为每个工作进程定义一个单独的集合。  默认情况下，工作进程不绑定到任何特定的CPU。 </p>
<p>  例如， </p>
<pre class="notranslate">worker_processes    4;
worker_cpu_affinity 0001 0010 0100 1000;
</pre>

<p>  将每个工作进程绑定到一个单独的CPU，同时 </p>
<pre class="notranslate">worker_processes    2;
worker_cpu_affinity 0101 1010;
</pre>

<p>  将第一个工作进程绑定到CPU0 / CPU2，将第二个工作进程绑定到CPU1 / CPU3。  第二个例子适用于超线程。 </p>
<p>  特殊值<code>auto</code> （1.9.10）允许将工作进程自动绑定到可用的CPU： </p>
<pre class="notranslate">worker_processes auto;
worker_cpu_affinity auto;
</pre>

<p>  可选的mask参数可用于限制可用于自动绑定的CPU： </p>
<pre class="notranslate">worker_cpu_affinity auto 01010101;
</pre>





<blockquote>
<p>  该指令仅适用于FreeBSD和Linux。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_priority*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_priority 0;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的调度优先级，就像使用<code>nice</code>命令一样：负数表示更高的优先级。  允许范围通常在-20到20之间变化。 </p>
<p>  例： </p>
<pre class="notranslate">worker_priority -10;
</pre>


<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_processes*number*</code> | <code>auto</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">            <pre class="notranslate">worker_processes 1;</pre>                </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的数量。 </p>
<p>  最佳值取决于许多因素，包括（但不限于）CPU核心数，存储数据的硬盘驱动器数和负载模式。  如果有疑问，将其设置为可用CPU核心数将是一个良好的开端（值“ <code>auto</code> ”将尝试自动检测它）。 </p>
<blockquote>
<p>  从版本1.3.8和1.2.5开始支持<code>auto</code>参数。 </p>
</blockquote>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_rlimit_core*size*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  更改工作进程的核心文件（ <code>RLIMIT_CORE</code> ）的最大大小限制。  用于在不重新启动主进程的情况下增加限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_rlimit_nofile*number*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  更改工作进程的最大打开文件数（ <code>RLIMIT_NOFILE</code> ）限制。  用于在不重新启动主进程的情况下增加限制。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**worker_shutdown_timeout*time*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  该指令出现在1.11.11版中。 </p>
<p>  配置正常关闭工作进程的超时。  当<code>*time*</code>到期时，nginx将尝试关闭当前打开的所有连接以方便关闭。 </p>
<p><th class="notranslate">            Syntax:                </th><td class="notranslate">            <code>**working_directory*directory*</code> ;<br>                </td></p>
<p><th class="notranslate">            Default:                </th><td class="notranslate">                        —                        </td></p>
<p><th class="notranslate">            Context:                </th><td class="notranslate">            <code>main</code> <br>                </td></p>
<p>  定义工作进程的当前工作目录。  它主要在编写核心文件时使用，在这种情况下，工作进程应具有指定目录的写入权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx_dtrace_pid_provider-nginx中文手册]]></title>
      <url>/ngx/nginx_dtrace_pid_provider.html</url>
      <content type="html"><![CDATA[<p>nginx_dtrace_pid_provider<br><a id="more"></a></p>
<h2 id="使用DTrace-pid提供程序调试nginx"><a href="#使用DTrace-pid提供程序调试nginx" class="headerlink" title="使用DTrace pid提供程序调试nginx"></a>使用DTrace pid提供程序调试nginx</h2><p>  本文假设读者具有nginx内部和<a href="#see_also">DTrace</a>的一般知识。 </p>
<p>  尽管使用<a href="debugging_log.html">–with-debug</a>选项构建的nginx已经提供了大量有关请求处理的信息，但有时需要更彻底地跟踪代码路径的特定部分，同时省略其余的调试输出。   DTrace pid提供程序（在Solaris，macOS上提供）是一个用于探索userland程序内部的有用工具，因为它不需要任何代码更改，它可以帮助完成任务。  用于跟踪和打印nginx函数调用的简单DTrace脚本可能如下所示： </p>
<pre class="notranslate">#pragma D option flowindent

pid$target:nginx::entry {
}

pid$target:nginx::return {
}
</pre>



<p>  但是，函数调用跟踪的DTrace功能仅提供有限的有用信息。  函数参数的实时检查通常更有趣，但也更复杂一些。  以下示例旨在帮助读者更熟悉DTrace以及使用DTrace分析nginx行为的过程。 </p>
<p>  将DTrace与nginx一起使用的常见方案之一如下：附加到nginx工作进程以记录请求行和请求开始时间。  要附加的相应函数是<code>ngx_http_process_request()</code> ，所讨论的参数是指向<code>ngx_http_request_t</code>结构的指针。  用于此类请求记录的DTrace脚本可以如下所示： </p>
<pre class="notranslate">pid$target::*ngx_http_process_request:entry
{
    this-&gt;request = (ngx_http_request_t *)copyin(arg0, sizeof(ngx_http_request_t));
    this-&gt;request_line = stringof(copyin((uintptr_t)this-&gt;request-&gt;request_line.data,
                                         this-&gt;request-&gt;request_line.len));
    printf("request line = %s\n", this-&gt;request_line);
    printf("request start sec = %d\n", this-&gt;request-&gt;start_sec);
}
</pre>



<p>  应该注意的是，在上面的示例中，DTrace需要一些关于<code>ngx_http_process_request</code>结构的知识。  不幸的是，虽然可以在DTrace脚本中使用特定的<code>#include</code>指令，然后将其传递给C预处理器（带有<code>-C</code>标志），但这并不能真正起作用。  由于存在大量的交叉依赖性，因此几乎所有的nginx头文件都必须包含在内。  反过来，基于<code>configure</code>脚本设置，nginx标头将包括PCRE，OpenSSL和各种系统头文件。  虽然理论上所有与特定nginx构建相关的头文件都可能包含在DTrace脚本预处理和编译中，但实际上DTrace脚本很可能由于某些头文件中的语法未知而无法编译。 </p>
<p>  上述问题可以通过在DTrace脚本中仅包含相关且必要的结构和类型定义来解决。   DTrace必须知道结构，类型和字段偏移的大小。  因此，可以通过手动优化用于DTrace的结构定义来进一步减少依赖性。 </p>
<p>  让我们使用上面的DTrace脚本示例，看看它需要什么样的结构定义才能正常工作。 </p>
<p>  首先应该包括configure生成的<code>objs/ngx_auto_config.h</code>文件，因为它定义了一些影响各种<code>#ifdef</code>的常量。  之后， <code>ngx_table_elt_t</code>一些基本类型和定义（如<code>ngx_str_t</code> ， <code>ngx_table_elt_t</code> ， <code>ngx_uint_t</code>等）放在DTrace脚本的开头。  这些定义是紧凑的，常用且不太可能经常改变。 </p>
<p>  然后是<code>ngx_http_process_request_t</code>结构，其中包含许多指向其他结构的指针。  因为这些指针实际上与此脚本无关，并且因为它们具有相同的大小，所以可以用void指针替换它们。  不是更改定义，最好添加适当的typedef，但是： </p>
<pre class="notranslate">typedef ngx_http_upstream_t     void;
typedef ngx_http_request_body_t void;
</pre>

<p>  最后但并非最不重要的是，有必要添加两个成员结构的定义（ <code>ngx_http_headers_in_t</code> ， <code>ngx_http_headers_out_t</code> ），回调函数的声明和常量的定义。 </p>
<p>  最终的DTrace脚本可以从<a href="http://nginx.org/download/trace_process_request.d" target="_blank" rel="noopener">这里</a>下载。 </p>
<p>  以下示例显示了运行此脚本的输出： </p>
<pre class="notranslate"># dtrace -C -I ./objs -s trace_process_request.d -p 4848
dtrace: script 'trace_process_request.d' matched 1 probe
CPU     ID                    FUNCTION:NAME
  1      4 .XAbmO.ngx_http_process_request:entry request line = GET / HTTP/1.1
request start sec = 1349162898

  0      4 .XAbmO.ngx_http_process_request:entry request line = GET /en/docs/nginx_dtrace_pid_provider.html HTTP/1.1
request start sec = 1349162899
</pre>



<p>  使用类似的技术，读者应该能够跟踪其他nginx函数调用。 </p>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><ul>
<li><a href="http://docs.oracle.com/cd/E19253-01/817-6223/index.html" target="_blank" rel="noopener">Solaris动态跟踪指南</a> -    <a href="http://dtrace.org/blogs/brendan/2011/02/09/dtrace-pid-provider/" target="_blank" rel="noopener">有关DTrace pid提供程序的简介文章</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux_packages-nginx中文手册]]></title>
      <url>/ngx/linux_packages.html</url>
      <content type="html"><![CDATA[<p>linux_packages<br><a id="more"></a></p>
<h2 id="nginx：Linux包"><a href="#nginx：Linux包" class="headerlink" title="nginx：Linux包"></a>nginx：Linux包</h2><p>  目前，nginx软件包可用于以下发行版和版本： </p>
<p>   RHEL / CentOS的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">6.x</td><td class="notranslate">x86_64, i386</td><br><td width="20%" class="notranslate">7.4+</td><td class="notranslate">x86_64, ppc64le</td><br></tbody></table>



</blockquote>
<p>   Debian的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td width="20%" class="notranslate">Codename</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">8.x</td><td width="20%" class="notranslate">jessie</td><td class="notranslate">x86_64, i386</td><br><td width="20%" class="notranslate">9.x</td><td width="20%" class="notranslate">stretch</td><td class="notranslate">x86_64, i386</td><br></tbody></table>



</blockquote>
<p>   Ubuntu的： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td width="20%" class="notranslate">Codename</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">14.04</td><td width="20%" class="notranslate">trusty</td><td class="notranslate">x86_64, i386, aarch64/arm64</td><br><td width="20%" class="notranslate">16.04</td><td width="20%" class="notranslate">xenial</td><td class="notranslate">x86_64, i386, ppc64el, aarch64/arm64</td><br><td width="20%" class="notranslate">18.04</td><td width="20%" class="notranslate">bionic</td><td class="notranslate">x86_64, aarch64/arm64</td><br><td width="20%" class="notranslate">18.10</td><td width="20%" class="notranslate">cosmic</td><td class="notranslate">x86_64</td><br></tbody></table>



</blockquote>
<p>   SLES： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">Version</td><td class="notranslate">Supported Platforms</td><br><td width="20%" class="notranslate">12</td><td class="notranslate">x86_64</td><br><td width="20%" class="notranslate">15</td><td class="notranslate">x86_64</td><br></tbody></table>



</blockquote>
<p>  要启用Linux软件包的自动更新，请为RHEL / CentOS发行版设置yum存储库，为Debian / Ubuntu发行版设置apt存储库，或为SLES设置zypper存储库。 </p>
<h4 id="用于稳定版本的预制包"><a href="#用于稳定版本的预制包" class="headerlink" title="用于稳定版本的预制包"></a>用于稳定版本的预制包</h4><p>  要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为<code>/etc/yum.repos.d/nginx.repo</code>的文件： </p>
<pre class="notranslate">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/
gpgcheck=0
enabled=1
</pre>

<p>  对于6.x或7.x版本，将“ <code>OS</code> ”替换为“ <code>rhel</code> ”或“ <code>centos</code> ”，取决于所使用的分布，将“ <code>OSRELEASE</code> ”替换为“ <code>6</code> ”或“ <code>7</code> ”。 </p>
<p>  对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到<code>apt</code>程序密钥环。  请从我们的网站下载<a href="/keys/nginx_signing.key">此密钥</a> ，并使用以下命令将其添加到<code>apt</code>程序密钥环： </p>
<pre class="notranslate">sudo apt-key add nginx_signing.key
</pre>



<p>  对于Debian，用Debian分发<a href="#distributions">代号</a>取代<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/debian/ *codename* nginx
deb-src http://nginx.org/packages/debian/ *codename* nginx
</pre>



<p>  对于Ubuntu，使用Ubuntu分发<a href="#distributions">代号来</a>替换<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/ubuntu/ *codename* nginx
deb-src http://nginx.org/packages/ubuntu/ *codename* nginx
</pre>



<p>  对于Debian / Ubuntu，然后运行以下命令： </p>
<pre class="notranslate">apt-get update
apt-get install nginx
</pre>



<p>  对于SLES 12，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/sles/12' nginx
</pre>



<p>  对于SLES 15，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/sles/15' nginx
</pre>



<h4 id="Mainline版本的预构建包"><a href="#Mainline版本的预构建包" class="headerlink" title="Mainline版本的预构建包"></a>Mainline版本的预构建包</h4><p>  要为RHEL / CentOS设置yum存储库，请使用以下内容创建名为<code>/etc/yum.repos.d/nginx.repo</code>的文件： </p>
<pre class="notranslate">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/mainline/OS/OSRELEASE/$basearch/
gpgcheck=0
enabled=1
</pre>

<p>  对于6.x或7.x版本，将“ <code>OS</code> ”替换为“ <code>rhel</code> ”或“ <code>centos</code> ”，取决于所使用的分布，将“ <code>OSRELEASE</code> ”替换为“ <code>6</code> ”或“ <code>7</code> ”。 </p>
<p>  对于Debian / Ubuntu，为了验证nginx存储库签名并在安装nginx包期间消除有关丢失PGP密钥的警告，有必要将用于签署nginx包和存储库的密钥添加到<code>apt</code>程序密钥环。  请从我们的网站下载<a href="/keys/nginx_signing.key">此密钥</a> ，并使用以下命令将其添加到<code>apt</code>程序密钥环： </p>
<pre class="notranslate">sudo apt-key add nginx_signing.key
</pre>



<p>  对于Debian，用Debian分发<a href="#distributions">代号</a>取代<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/mainline/debian/ *codename* nginx
deb-src http://nginx.org/packages/mainline/debian/ *codename* nginx
</pre>



<p>  对于Ubuntu，使用Ubuntu分发<a href="#distributions">代号来</a>替换<em>代号</em> ，并将以下内容附加到<code>/etc/apt/sources.list</code>文件的末尾： </p>
<pre class="notranslate">deb http://nginx.org/packages/mainline/ubuntu/ *codename* nginx
deb-src http://nginx.org/packages/mainline/ubuntu/ *codename* nginx
</pre>



<p>  对于Debian / Ubuntu，然后运行以下命令： </p>
<pre class="notranslate">apt-get update
apt-get install nginx
</pre>



<p>  对于SLES 12，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/mainline/sles/12' nginx
</pre>



<p>  对于SLES 15，运行以下命令： </p>
<pre class="notranslate">zypper addrepo -G -t yum -c 'http://nginx.org/packages/mainline/sles/15' nginx
</pre>



<h4 id="源包"><a href="#源包" class="headerlink" title="源包"></a>源包</h4><p>  包装源可以在<a href="http://hg.nginx.org/pkg-oss" target="_blank" rel="noopener">包装源库中找到</a> 。 </p>
<p>   <code>default</code>分支包含当前主线版本的打包源，而<code>stable-*</code>分支包含稳定版本的最新源。  要构建二进制包，请在Debian / Ubuntu上的<code>debian/</code>目录中运行<code>make</code> ，或在RHEL / CentOS / SLES上的<code>rpm/SPECS/</code>运行<code>make</code> 。 </p>
<p>  打包源在nginx使用的相同的<a href="LICENSE">2条款BSD类许可证</a>下分发。 </p>
<h4 id="动态模块"><a href="#动态模块" class="headerlink" title="动态模块"></a>动态模块</h4><p>  主nginx包是使用所有模块构建的，这些模块不需要额外的库来避免额外的依赖性。  从版本1.9.11开始，nginx支持<a href="ngx_core_module.html#load_module">动态模块</a> ，以下模块构建为动态模块并作为单独的软件包提供： </p>
<pre class="notranslate">nginx-module-geoip
nginx-module-image-filter
nginx-module-njs
nginx-module-perl
nginx-module-xslt
</pre>



<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>   RPM软件包和Debian / Ubuntu存储库都使用数字签名来验证下载软件包的完整性和来源。  为了检查签名，有必要下载<a href="/keys/nginx_signing.key">nginx签名密钥</a>并将其导入<code>rpm</code>或<code>apt</code>程序的密钥环： </p>
<ul>
<li>在Debian / Ubuntu上： <blockquote class="example"><pre class="notranslate">sudo apt-key add nginx_signing.key</pre></blockquote>-   在RHEL / CentOS上： <blockquote class="example"><pre class="notranslate">sudo rpm –import nginx_signing.key</pre></blockquote>-   在SLES上： <blockquote class="example"><pre class="notranslate">sudo rpm –import nginx_signing.key</pre></blockquote><pre class="notranslate">sudo rpm --import nginx_signing.key</pre>



</li>
</ul>
<p>  在Debian / Ubuntu / SLES上，默认情况下会检查签名，但在RHEL / CentOS上需要设置 </p>
<pre class="notranslate">gpgcheck=1</pre>

<p>  在<code>/etc/yum.repos.d/nginx.repo</code>文件中。 </p>
<p>  由于我们的<a href="en/pgp_keys.html">PGP密钥</a>和软件包位于同一台服务器上，因此它们同样受信任。  强烈建议另外验证下载的PGP密钥的真实性。   PGP具有“信任网”概念，当一个密钥由其他人的密钥签名时，该密钥又由另一个密钥签名，依此类推。  通常可以构建从任意密钥到您知道并亲自信任的某个人密钥的链，从而验证链中第一个密钥的真实性。   <a href="http://www.dewinter.com/gnupg_howto/english/GPGMiniHowto-1.html" target="_blank" rel="noopener">GPG Mini Howto</a>详细描述了这一概念。  我们的密钥有足够的签名，其真实性相对容易检查。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[install-nginx中文手册]]></title>
      <url>/ngx/install.html</url>
      <content type="html"><![CDATA[<p>install<br><a id="more"></a></p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>   nginx的安装方式可能不同，具体取决于操作系统。 </p>
<h4 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h4><p>  对于Linux，可以使用nginx.org中的nginx <a href="linux_packages.html">包</a> 。 </p>
<h4 id="在FreeBSD上安装"><a href="#在FreeBSD上安装" class="headerlink" title="在FreeBSD上安装"></a>在FreeBSD上安装</h4><p>  在FreeBSD上，可以从<a href="http://www.freebsd.org/doc/handbook/pkgng-intro.html" target="_blank" rel="noopener">软件包</a>或通过<a href="http://www.freebsd.org/doc/handbook/ports-using.html" target="_blank" rel="noopener">ports</a>系统安装nginx。   ports系统提供了更大的灵活性，允许在众多选项中进行选择。  该端口将使用指定的选项编译nginx并安装它。 </p>
<h4 id="从源头构建"><a href="#从源头构建" class="headerlink" title="从源头构建"></a>从源头构建</h4><p>  如果需要一些特殊功能，包和端口不可用，也可以从源文件编译nginx。  虽然更灵活，但这种方法对初学者来说可能很复杂。  有关更多信息，请参阅<a href="configure.html">从源构建nginx</a> 。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[index-nginx中文手册]]></title>
      <url>/ngx/index.html</url>
      <content type="html"><![CDATA[<p>index<br><a id="more"></a></p>
<h2 id="nginx文档"><a href="#nginx文档" class="headerlink" title="nginx文档"></a>nginx文档</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li><p><a href="install.html">安装nginx</a> -    <a href="configure.html">从Sources构建nginx</a> -    <a href="beginners_guide.html">初学者指南</a> -    <a href="https://www.nginx.com/resources/admin-guide/" target="_blank" rel="noopener">管理员指南</a> -    <a href="control.html">控制nginx</a> -    <a href="events.html">连接处理方法</a> -    <a href="hash.html">设置哈希值</a> -    <a href="debugging_log.html">调试日志</a> -    <a href="syslog.html">记录到syslog</a> -    <a href="syntax.html">配置文件测量单位</a> -    <a href="switches.html">命令行参数</a> -    <a href="windows.html">适用于Windows的nginx</a> </p>
</li>
<li><p><a href="http/request_processing.html">nginx如何处理请求</a> -    <a href="http/server_names.html">服务器名称</a> -    <a href="http/load_balancing.html">使用nginx作为HTTP负载均衡器</a> -    <a href="http/configuring_https_servers.html">配置HTTPS服务器</a> </p>
</li>
<li><p><a href="stream/stream_processing.html">nginx如何处理TCP / UDP会话</a> </p>
</li>
<li><p><a href="njs/index.html">用njs编写脚本</a> </p>
</li>
<li><p><a href="http://www.aosabook.org/en/nginx.html" target="_blank" rel="noopener">“开源应用程序架构”中的“nginx”一章</a> </p>
</li>
</ul>
<h4 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h4><ul>
<li><p><a href="howto_build_on_win32.html">使用Visual C在Win32平台上构建nginx</a> -    <a href="https://www.nginx.com/resources/admin-guide/setting-nginx-plus-environment-amazon-ec2/" target="_blank" rel="noopener">在Amazon EC2上设置NGINX Plus环境</a> -    <a href="nginx_dtrace_pid_provider.html">使用DTrace pid提供程序调试nginx</a> </p>
</li>
<li><p><a href="http/converting_rewrite_rules.html">转换重写规则</a> -    <a href="http/websocket.html">WebSocket代理</a> </p>
</li>
</ul>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><ul>
<li><a href="contributing_changes.html">贡献变化</a> -    <a href="dev/development_guide.html">开发指南</a> </li>
</ul>
<h4 id="模块参考"><a href="#模块参考" class="headerlink" title="模块参考"></a>模块参考</h4><ul>
<li><a href="dirindex.html">按字母顺序排列的指令索引</a> -    <a href="varindex.html">按字母顺序排列的变量索引</a> </li>
</ul>
<ul>
<li><a href="ngx_core_module.html">核心功能</a> </li>
</ul>
<ul>
<li><a href="http/ngx_http_core_module.html">ngx_http_core_module</a> -    <a href="http/ngx_http_access_module.html">ngx_http_access_module</a> -    <a href="http/ngx_http_addition_module.html">ngx_http_addition_module</a> -    <a href="http/ngx_http_api_module.html">ngx_http_api_module</a> -    <a href="http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a> -    <a href="http/ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a> -    <a href="http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a> -    <a href="http/ngx_http_autoindex_module.html">ngx_http_autoindex_module</a> -    <a href="http/ngx_http_browser_module.html">ngx_http_browser_module</a> -    <a href="http/ngx_http_charset_module.html">ngx_http_charset_module</a> -    <a href="http/ngx_http_dav_module.html">ngx_http_dav_module</a> -    <a href="http/ngx_http_empty_gif_module.html">ngx_http_empty_gif_module</a> -    <a href="http/ngx_http_f4f_module.html">ngx_http_f4f_module</a> -    <a href="http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a> -    <a href="http/ngx_http_flv_module.html">ngx_http_flv_module</a> -    <a href="http/ngx_http_geo_module.html">ngx_http_geo_module</a> -    <a href="http/ngx_http_geoip_module.html">ngx_http_geoip_module</a> -    <a href="http/ngx_http_grpc_module.html">ngx_http_grpc_module</a> -    <a href="http/ngx_http_gunzip_module.html">ngx_http_gunzip_module</a> -    <a href="http/ngx_http_gzip_module.html">ngx_http_gzip_module</a> -    <a href="http/ngx_http_gzip_static_module.html">ngx_http_gzip_static_module</a> -    <a href="http/ngx_http_headers_module.html">ngx_http_headers_module</a> -    <a href="http/ngx_http_hls_module.html">ngx_http_hls_module</a> -    <a href="http/ngx_http_image_filter_module.html">ngx_http_image_filter_module</a> -    <a href="http/ngx_http_index_module.html">ngx_http_index_module</a> -    <a href="http/ngx_http_js_module.html">ngx_http_js_module</a> -    <a href="http/ngx_http_keyval_module.html">ngx_http_keyval_module</a> -    <a href="http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a> -    <a href="http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a> -    <a href="http/ngx_http_log_module.html">ngx_http_log_module</a> -    <a href="http/ngx_http_map_module.html">ngx_http_map_module</a> -    <a href="http/ngx_http_memcached_module.html">ngx_http_memcached_module</a> -    <a href="http/ngx_http_mirror_module.html">ngx_http_mirror_module</a> -    <a href="http/ngx_http_mp4_module.html">ngx_http_mp4_module</a> -    <a href="http/ngx_http_perl_module.html">ngx_http_perl_module</a> -    <a href="http/ngx_http_proxy_module.html">ngx_http_proxy_module</a> -    <a href="http/ngx_http_random_index_module.html">ngx_http_random_index_module</a> -    <a href="http/ngx_http_realip_module.html">ngx_http_realip_module</a> -    <a href="http/ngx_http_referer_module.html">ngx_http_referer_module</a> -    <a href="http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a> -    <a href="http/ngx_http_scgi_module.html">ngx_http_scgi_module</a> -    <a href="http/ngx_http_secure_link_module.html">ngx_http_secure_link_module</a> -    <a href="http/ngx_http_session_log_module.html">ngx_http_session_log_module</a> -    <a href="http/ngx_http_slice_module.html">ngx_http_slice_module</a> -    <a href="http/ngx_http_spdy_module.html">ngx_http_spdy_module</a> -    <a href="http/ngx_http_split_clients_module.html">ngx_http_split_clients_module</a> -    <a href="http/ngx_http_ssi_module.html">ngx_http_ssi_module</a> -    <a href="http/ngx_http_ssl_module.html">ngx_http_ssl_module</a> -    <a href="http/ngx_http_status_module.html">ngx_http_status_module</a> -    <a href="http/ngx_http_stub_status_module.html">ngx_http_stub_status_module</a> -    <a href="http/ngx_http_sub_module.html">ngx_http_sub_module</a> -    <a href="http/ngx_http_upstream_module.html">ngx_http_upstream_module</a> -    <a href="http/ngx_http_upstream_conf_module.html">ngx_http_upstream_conf_module</a> -    <a href="http/ngx_http_upstream_hc_module.html">ngx_http_upstream_hc_module</a> -    <a href="http/ngx_http_userid_module.html">ngx_http_userid_module</a> -    <a href="http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module</a> -    <a href="http/ngx_http_v2_module.html">ngx_http_v2_module</a> -    <a href="http/ngx_http_xslt_module.html">ngx_http_xslt_module</a> </li>
</ul>
<ul>
<li><a href="mail/ngx_mail_core_module.html">ngx_mail_core_module</a> -    <a href="mail/ngx_mail_auth_http_module.html">ngx_mail_auth_http_module</a> -    <a href="mail/ngx_mail_proxy_module.html">ngx_mail_proxy_module</a> -    <a href="mail/ngx_mail_ssl_module.html">ngx_mail_ssl_module</a> -    <a href="mail/ngx_mail_imap_module.html">ngx_mail_imap_module</a> -    <a href="mail/ngx_mail_pop3_module.html">ngx_mail_pop3_module</a> -    <a href="mail/ngx_mail_smtp_module.html">ngx_mail_smtp_module</a> </li>
</ul>
<ul>
<li><a href="stream/ngx_stream_core_module.html">ngx_stream_core_module</a> -    <a href="stream/ngx_stream_access_module.html">ngx_stream_access_module</a> -    <a href="stream/ngx_stream_geo_module.html">ngx_stream_geo_module</a> -    <a href="stream/ngx_stream_geoip_module.html">ngx_stream_geoip_module</a> -    <a href="stream/ngx_stream_js_module.html">ngx_stream_js_module</a> -    <a href="stream/ngx_stream_keyval_module.html">ngx_stream_keyval_module</a> -    <a href="stream/ngx_stream_limit_conn_module.html">ngx_stream_limit_conn_module</a> -    <a href="stream/ngx_stream_log_module.html">ngx_stream_log_module</a> -    <a href="stream/ngx_stream_map_module.html">ngx_stream_map_module</a> -    <a href="stream/ngx_stream_proxy_module.html">ngx_stream_proxy_module</a> -    <a href="stream/ngx_stream_realip_module.html">ngx_stream_realip_module</a> -    <a href="stream/ngx_stream_return_module.html">ngx_stream_return_module</a> -    <a href="stream/ngx_stream_split_clients_module.html">ngx_stream_split_clients_module</a> -    <a href="stream/ngx_stream_ssl_module.html">ngx_stream_ssl_module</a> -    <a href="stream/ngx_stream_ssl_preread_module.html">ngx_stream_ssl_preread_module</a> -    <a href="stream/ngx_stream_upstream_module.html">ngx_stream_upstream_module</a> -    <a href="stream/ngx_stream_upstream_hc_module.html">ngx_stream_upstream_hc_module</a> -    <a href="stream/ngx_stream_zone_sync_module.html">ngx_stream_zone_sync_module</a> </li>
</ul>
<ul>
<li><a href="ngx_google_perftools_module.html">ngx_google_perftools_module</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[howto_build_on_win32-nginx中文手册]]></title>
      <url>/ngx/howto_build_on_win32.html</url>
      <content type="html"><![CDATA[<p>howto_build_on_win32<br><a id="more"></a></p>
<h2 id="使用Visual-C在Win32平台上构建nginx"><a href="#使用Visual-C在Win32平台上构建nginx" class="headerlink" title="使用Visual C在Win32平台上构建nginx"></a>使用Visual C在Win32平台上构建nginx</h2><td align="left" class="notranslate"> <a href="#build_steps">Build steps</a> <br> <a href="#see_also">See also</a> <br></td>

<h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>  要在MicrosoftWin32®平台上构建nginx，您需要： </p>
<ul>
<li>Microsoft Visual C编译器。  已知Microsoft VisualStudio®8和10可以使用。 -    <a href="http://www.mingw.org/wiki/MSYS" target="_blank" rel="noopener">MSYS</a> 。 -    Perl，如果你想用SSL支持构建OpenSSL®和nginx。  例如<a href="http://www.activestate.com/activeperl" target="_blank" rel="noopener">ActivePerl</a>或<a href="http://strawberryperl.com" target="_blank" rel="noopener">Strawberry Perl</a> 。 -    <a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>客户。 -    <a href="http://www.pcre.org" target="_blank" rel="noopener">PCRE</a> ， <a href="http://zlib.net" target="_blank" rel="noopener">zlib</a>和<a href="http://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>库源。 </li>
</ul>
<h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><p>  确保在开始构建之前将Perl，Mercurial和MSYS bin目录的路径添加到PATH环境变量中。  要设置Visual C环境，请从Visual C目录运行vcvarsall.bat脚本。 </p>
<p>  要构建nginx： </p>
<ul>
<li>启动MSYS bash。 </li><li>  查看hg.nginx.org存储库中的nginx源代码。  例如： <blockquote class="example"><pre class="notranslate">hg clone <a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">http://hg.nginx.org/nginx</a><br></pre></blockquote></li><li>  创建一个build和lib目录，并将zlib，PCRE和OpenSSL库源解压缩到lib目录中： <blockquote class="example"><pre class="notranslate">mkdir objs<br>mkdir objs/lib<br>cd objs/lib<br>tar -xzf ../../pcre-8.42.tar.gz<br>tar -xzf ../../zlib-1.2.11.tar.gz<br>tar -xzf ../../openssl-1.0.2q.tar.gz<br></pre></blockquote></li><li>  运行configure脚本： <blockquote class="example"><pre class="notranslate">auto/configure \<br>–with-cc=cl \<br>–with-debug \<br>–prefix= \<br>–conf-path=conf/nginx.conf \<br>–pid-path=logs/nginx.pid \<br>–http-log-path=logs/access.log \<br>–error-log-path=logs/error.log \<br>–sbin-path=nginx.exe \<br>–http-client-body-temp-path=temp/client_body_temp \<br>–http-proxy-temp-path=temp/proxy_temp \<br>–http-fastcgi-temp-path=temp/fastcgi_temp \<br>–http-scgi-temp-path=temp/scgi_temp \<br>–http-uwsgi-temp-path=temp/uwsgi_temp \<br>–with-cc-opt=-DFD_SETSIZE=1024 \<br>–with-pcre=objs/lib/pcre-8.42 \<br>–with-zlib=objs/lib/zlib-1.2.11 \<br>–with-openssl=objs/lib/openssl-1.0.2q \<br>–with-openssl-opt=no-asm \<br>–with-select_module \<br>–with-http_ssl_module<br></pre></blockquote></li><li>  运行make： <blockquote class="example"><pre class="notranslate">nmake<br></pre></blockquote></li><pre class="notranslate">mkdir objs
mkdir objs/lib
cd objs/lib
tar -xzf ../../pcre-8.42.tar.gz
tar -xzf ../../zlib-1.2.11.tar.gz
tar -xzf ../../openssl-1.0.2q.tar.gz
</pre>


</ul>
<pre class="notranslate">nmake
</pre>



<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><ul>
<li><a href="windows.html">适用于Windows的nginx</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hash-nginx中文手册]]></title>
      <url>/ngx/hash.html</url>
      <content type="html"><![CDATA[<p>hash<br><a id="more"></a></p>
<h2 id="设置哈希值"><a href="#设置哈希值" class="headerlink" title="设置哈希值"></a>设置哈希值</h2><p>  为了快速处理静态数据集，例如服务器名称， <a href="http/ngx_http_map_module.html#map">映射</a>指令的值，MIME类型，请求头字符串的名称，nginx使用哈希表。  在启动期间和每次重新配置时，nginx选择最小可能大小的散列表，使得存储具有相同散列值的密钥的桶大小不超过配置的参数（散列桶大小）。  表的大小以桶表示。  继续调整，直到表大小超过散列最大大小参数。  大多数哈希都有相应的指令允许更改这些参数，例如，对于服务器名称哈希，它们是<a href="http/ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a>和<a href="http/ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> 。 </p>
<p>  散列桶大小参数与处理器的高速缓存行大小的倍数对齐。  这通过减少内存访问的数量来加速现代处理器上的散列中的密钥搜索。  如果散列桶大小等于一个处理器的高速缓存行大小，那么在最坏的情况下，密钥搜索期间的内存访问次数将是两次 - 首先计算存储区地址，第二次是在存储桶内的密钥搜索期间。  因此，如果nginx发出请求增加散列最大大小或散列桶大小的消息，则应首先增加第一个参数。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[examples-nginx中文手册]]></title>
      <url>/ngx/examples.html</url>
      <content type="html"><![CDATA[<p>examples<br><a id="more"></a></p>
<h2 id="示例nginx配置"><a href="#示例nginx配置" class="headerlink" title="示例nginx配置"></a>示例nginx配置</h2><p>  示例站点配置，将所有请求传递给后端，但以“/ download /”开头的图像和请求除外。 </p>
<pre class="notranslate">user  www www;

worker_processes  2;

pid /var/run/nginx.pid;

#                          [ debug | info | notice | warn | error | crit ]

error_log  /var/log/nginx.error_log  info;

events {
    worker_connections   2000;

    # use [ kqueue | epoll | /dev/poll | select | poll ];
    use kqueue;
}

http {

    include       conf/mime.types;
    default_type  application/octet-stream;


    log_format main      '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         '"$gzip_ratio"';

    log_format download  '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         '"$http_range" "$sent_http_content_range"';

    client_header_timeout  3m;
    client_body_timeout    3m;
    send_timeout           3m;

    client_header_buffer_size    1k;
    large_client_header_buffers  4 4k;

    gzip on;
    gzip_min_length  1100;
    gzip_buffers     4 8k;
    gzip_types       text/plain;

    output_buffers   1 32k;
    postpone_output  1460;

    sendfile         on;
    tcp_nopush       on;
    tcp_nodelay      on;
    send_lowat       12000;

    keepalive_timeout  75 20;

    #lingering_time     30;
    #lingering_timeout  10;
    #reset_timedout_connection  on;


    server {
        listen        one.example.com;
        server_name   one.example.com  www.one.example.com;

        access_log   /var/log/nginx.access_log  main;

        location / {
            proxy_pass         http://127.0.0.1/;
            proxy_redirect     off;

            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            #proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;

            client_max_body_size       10m;
            client_body_buffer_size    128k;

            client_body_temp_path      /var/nginx/client_body_temp;

            proxy_connect_timeout      70;
            proxy_send_timeout         90;
            proxy_read_timeout         90;
            proxy_send_lowat           12000;

            proxy_buffer_size          4k;
            proxy_buffers              4 32k;
            proxy_busy_buffers_size    64k;
            proxy_temp_file_write_size 64k;

            proxy_temp_path            /var/nginx/proxy_temp;

            charset  koi8-r;
        }

        error_page  404  /404.html;

        location = /404.html {
            root  /spool/www;
        }

        location /old_stuff/ {
            rewrite   ^/old_stuff/(.*)$  /new_stuff/$1  permanent;
        }

        location /download/ {

            valid_referers  none  blocked  server_names  *.example.com;

            if ($invalid_referer) {
                #rewrite   ^/   http://www.example.com/;
                return   403;
            }

            #rewrite_log  on;

            # rewrite /download/*/mp3/*.any_ext to /download/*/mp3/*.mp3
            rewrite ^/(download/.*)/mp3/(.*)\..*$
                    /$1/mp3/$2.mp3                   break;

            root         /spool/www;
            #autoindex    on;
            access_log   /var/log/nginx-download.access_log  download;
        }

        location ~* \.(jpg|jpeg|gif)$ {
            root         /spool/www;
            access_log   off;
            expires      30d;
        }
    }
}
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[events-nginx中文手册]]></title>
      <url>/ngx/events.html</url>
      <content type="html"><![CDATA[<p>events<br><a id="more"></a></p>
<h2 id="连接处理方法"><a href="#连接处理方法" class="headerlink" title="连接处理方法"></a>连接处理方法</h2><p>   nginx支持各种连接处理方法。  特定方法的可用性取决于所使用的平台。  在支持多种方法的平台上，nginx通常会自动选择最有效的方法。  但是，如果需要，可以<a href="ngx_core_module.html#use">使用use</a>指令显式选择连接处理方法。 </p>
<p>  支持以下连接处理方法： </p>
<ul>
<li><code>select</code> - 标准方法。  支持模块自动构建在缺乏更有效方法的平台上。   <code>--with-select_module</code>和<code>--without-select_module</code>配置参数可用于强制启用或禁用此模块的构建。 -    <code>poll</code> - 标准方法。  支持模块自动构建在缺乏更有效方法的平台上。   <code>--with-poll_module</code>和<code>--without-poll_module</code>配置参数可用于强制启用或禁用此模块的构建。 -    <code>kqueue</code> - 在FreeBSD 4.1 +，OpenBSD 2.9 +，NetBSD 2.0和macOS上使用的有效方法。 -    Linux 2.6+上使用的<code>epoll</code> -efficient方法。 <blockquote class="note">  自1.11.3起，支持<code>EPOLLRDHUP</code> （Linux 2.6.17，glibc 2.8）和<code>EPOLLEXCLUSIVE</code> （Linux 4.5，glibc 2.24）标志。 </blockquote><blockquote class="note">  一些较旧的发行版（如SuSE 8.2）提供了为2.4内核添加epoll支持的补丁。 </blockquote>-    <code>/dev/poll</code> -  Solaris 7 11/99 +，HP / UX 11.22+（eventport），IRIX 6.5.15+和Tru64 UNIX 5.1A +上使用的有效方法。 -    <code>eventport</code> - 事件端口，Solaris 10+上使用的方法（由于已知问题，建议使用<code>/dev/poll</code>方法）。 <blockquote>
<p>  一些较旧的发行版（如SuSE 8.2）提供了为2.4内核添加epoll支持的补丁。 </p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dirindex-nginx中文手册]]></title>
      <url>/ngx/dirindex.html</url>
      <content type="html"><![CDATA[<p>dirindex<br><a id="more"></a></p>
<h2 id="按字母顺序排列的指令索引"><a href="#按字母顺序排列的指令索引" class="headerlink" title="按字母顺序排列的指令索引"></a>按字母顺序排列的指令索引</h2><p>   <a href="http/ngx_http_core_module.html#absolute_redirect">absolute_redirect</a> <br>   <a href="ngx_core_module.html#accept_mutex">accept_mutex</a> <br>   <a href="ngx_core_module.html#accept_mutex_delay">accept_mutex_delay</a> <br>   <a href="http/ngx_http_log_module.html#access_log">access_log</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#access_log">access_log</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_addition_module.html#add_after_body">add_after_body</a> <br>   <a href="http/ngx_http_addition_module.html#add_before_body">add_before_body</a> <br>   <a href="http/ngx_http_headers_module.html#add_header">add_header</a> <br>   <a href="http/ngx_http_headers_module.html#add_trailer">add_trailer</a> <br>   <a href="http/ngx_http_addition_module.html#addition_types">addition_types</a> <br>   <a href="http/ngx_http_core_module.html#aio">AIO</a> <br>   <a href="http/ngx_http_core_module.html#aio_write">aio_write</a> <br>   <a href="http/ngx_http_core_module.html#alias">别号</a> <br>   <a href="http/ngx_http_access_module.html#allow">允许</a> （ngx_http_access_module） <br>   <a href="stream/ngx_stream_access_module.html#allow">允许</a> （ngx_stream_access_module） <br>   <a href="http/ngx_http_browser_module.html#ancient_browser">ancient_browser</a> <br>   <a href="http/ngx_http_browser_module.html#ancient_browser_value">ancient_browser_value</a> <br>   <a href="http/ngx_http_api_module.html#api">API</a> <br>   <a href="http/ngx_http_auth_basic_module.html#auth_basic">auth_basic</a> <br>   <a href="http/ngx_http_auth_basic_module.html#auth_basic_user_file">auth_basic_user_file</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http">auth_http</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_header">auth_http_header</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_pass_client_cert">auth_http_pass_client_cert</a> <br>   <a href="mail/ngx_mail_auth_http_module.html#auth_http_timeout">auth_http_timeout</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt">auth_jwt</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_claim_set">auth_jwt_claim_set</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_header_set">auth_jwt_header_set</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_key_file">auth_jwt_key_file</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_key_request">auth_jwt_key_request</a> <br>   <a href="http/ngx_http_auth_jwt_module.html#auth_jwt_leeway">auth_jwt_leeway</a> <br>   <a href="http/ngx_http_auth_request_module.html#auth_request">auth_request</a> <br>   <a href="http/ngx_http_auth_request_module.html#auth_request_set">auth_request_set</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex">自动索引</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_exact_size">autoindex_exact_size</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_format">autoindex_format</a> <br>   <a href="http/ngx_http_autoindex_module.html#autoindex_localtime">autoindex_localtime</a> <br>   <a href="http/ngx_http_rewrite_module.html#break">打破</a> <br>   <a href="http/ngx_http_charset_module.html#charset">字符集</a> <br>   <a href="http/ngx_http_charset_module.html#charset_map">charset_map</a> <br>   <a href="http/ngx_http_charset_module.html#charset_types">charset_types</a> <br>   <a href="http/ngx_http_core_module.html#chunked_transfer_encoding">chunked_transfer_encoding</a> <br>   <a href="http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#client_body_in_file_only">client_body_in_file_only</a> <br>   <a href="http/ngx_http_core_module.html#client_body_in_single_buffer">client_body_in_single_buffer</a> <br>   <a href="http/ngx_http_core_module.html#client_body_temp_path">client_body_temp_path</a> <br>   <a href="http/ngx_http_core_module.html#client_body_timeout">client_body_timeout</a> <br>   <a href="http/ngx_http_core_module.html#client_header_buffer_size">client_header_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#client_header_timeout">client_header_timeout</a> <br>   <a href="http/ngx_http_core_module.html#client_max_body_size">client_max_body_size</a> <br>   <a href="http/ngx_http_core_module.html#connection_pool_size">connection_pool_size</a> <br>   <a href="http/ngx_http_dav_module.html#create_full_put_path">create_full_put_path</a> <br>   <a href="ngx_core_module.html#daemon">守护进程</a> <br>   <a href="http/ngx_http_dav_module.html#dav_access">dav_access</a> <br>   <a href="http/ngx_http_dav_module.html#dav_methods">dav_methods</a> <br>   <a href="ngx_core_module.html#debug_connection">debug_connection</a> <br>   <a href="ngx_core_module.html#debug_points">debug_points</a> <br>   <a href="http/ngx_http_core_module.html#default_type">default_type文件</a> <br>   <a href="http/ngx_http_access_module.html#deny">拒绝</a> （ngx_http_access_module） <br>   <a href="stream/ngx_stream_access_module.html#deny">拒绝</a> （ngx_stream_access_module） <br>   <a href="http/ngx_http_core_module.html#directio">的directio</a> <br>   <a href="http/ngx_http_core_module.html#directio_alignment">directio_alignment</a> <br>   <a href="http/ngx_http_core_module.html#disable_symlinks">disable_symlinks</a> <br>   <a href="http/ngx_http_empty_gif_module.html#empty_gif">empty_gif</a> <br>   <a href="ngx_core_module.html#env">ENV</a> <br>   <a href="ngx_core_module.html#error_log">error_log中</a> <br>   <a href="http/ngx_http_core_module.html#error_page">error_page</a> <br>   <a href="http/ngx_http_core_module.html#etag">ETAG</a> <br>   <a href="ngx_core_module.html#events">事件</a> <br>   <a href="http/ngx_http_headers_module.html#expires">到期</a> <br>   <a href="http/ngx_http_f4f_module.html#f4f">F4F</a> <br>   <a href="http/ngx_http_f4f_module.html#f4f_buffer_size">f4f_buffer_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_bind">fastcgi_bind</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffer_size">fastcgi_buffer_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffering">fastcgi_buffering</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_buffers">fastcgi_buffers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_busy_buffers_size">fastcgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache">fastcgi_cache</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_background_update">fastcgi_cache_background_update</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_bypass">fastcgi_cache_bypass</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_key">fastcgi_cache_key</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock">fastcgi_cache_lock</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock_age">fastcgi_cache_lock_age</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_lock_timeout">fastcgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_max_range_offset">fastcgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_methods">fastcgi_cache_methods</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_min_uses">fastcgi_cache_min_uses</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_path">fastcgi_cache_path</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_purge">fastcgi_cache_purge</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_revalidate">fastcgi_cache_revalidate</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_use_stale">fastcgi_cache_use_stale</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_cache_valid">fastcgi_cache_valid</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_catch_stderr">fastcgi_catch_stderr</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_connect_timeout">fastcgi_connect_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_force_ranges">fastcgi_force_ranges</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_hide_header">fastcgi_hide_header</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_ignore_client_abort">fastcgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_index">fastcgi_index</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_intercept_errors">fastcgi_intercept_errors</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_limit_rate">fastcgi_limit_rate</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_max_temp_file_size">fastcgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream">fastcgi_next_upstream</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream_timeout">fastcgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_next_upstream_tries">fastcgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_no_cache">fastcgi_no_cache</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_header">fastcgi_pass_header</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_request_body">fastcgi_pass_request_body</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_pass_request_headers">fastcgi_pass_request_headers</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_read_timeout">fastcgi_read_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_request_buffering">fastcgi_request_buffering</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_send_lowat">fastcgi_send_lowat</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_send_timeout">fastcgi_send_timeout</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_socket_keepalive">fastcgi_socket_keepalive</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_split_path_info">fastcgi_split_path_info</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_store">fastcgi_store</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_store_access">fastcgi_store_access</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_temp_file_write_size">fastcgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_fastcgi_module.html#fastcgi_temp_path">fastcgi_temp_path</a> <br>   <a href="http/ngx_http_flv_module.html#flv">FLV</a> <br>   <a href="http/ngx_http_geo_module.html#geo">geo</a> （ngx_http_geo_module） <br>   <a href="stream/ngx_stream_geo_module.html#geo">geo</a> （ngx_stream_geo_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_city">geoip_city</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_city">geoip_city</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_country">geoip_country</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_country">geoip_country</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_org">geoip_org</a> （ngx_http_geoip_module） <br>   <a href="stream/ngx_stream_geoip_module.html#geoip_org">geoip_org</a> （ngx_stream_geoip_module） <br>   <a href="http/ngx_http_geoip_module.html#geoip_proxy">geoip_proxy</a> <br>   <a href="http/ngx_http_geoip_module.html#geoip_proxy_recursive">geoip_proxy_recursive</a> <br>   <a href="ngx_google_perftools_module.html#google_perftools_profiles">google_perftools_profiles</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_bind">grpc_bind</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_buffer_size">grpc_buffer_size</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_connect_timeout">grpc_connect_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_hide_header">grpc_hide_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ignore_headers">grpc_ignore_headers</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_intercept_errors">grpc_intercept_errors</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream">grpc_next_upstream</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream_timeout">grpc_next_upstream_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_next_upstream_tries">grpc_next_upstream_tries</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_pass">grpc_pass</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_pass_header">grpc_pass_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_read_timeout">grpc_read_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_send_timeout">grpc_send_timeout</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_set_header">grpc_set_header</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_socket_keepalive">grpc_socket_keepalive</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_certificate">grpc_ssl_certificate</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_certificate_key">grpc_ssl_certificate_key</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_ciphers">grpc_ssl_ciphers</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_crl">grpc_ssl_crl</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_name">grpc_ssl_name</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_password_file">grpc_ssl_password_file</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_protocols">grpc_ssl_protocols</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_server_name">grpc_ssl_server_name</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_session_reuse">grpc_ssl_session_reuse</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_trusted_certificate">grpc_ssl_trusted_certificate</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_verify">grpc_ssl_verify</a> <br>   <a href="http/ngx_http_grpc_module.html#grpc_ssl_verify_depth">grpc_ssl_verify_depth</a> <br>   <a href="http/ngx_http_gunzip_module.html#gunzip">gunzip解</a> <br>   <a href="http/ngx_http_gunzip_module.html#gunzip_buffers">gunzip_buffers</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip">gzip的</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_buffers">gzip_buffers</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_comp_level">gzip_comp_level</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_disable">gzip_disable</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_http_version">gzip_http_version</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_min_length">gzip_min_length</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_proxied">gzip_proxied</a> <br>   <a href="http/ngx_http_gzip_static_module.html#gzip_static">gzip_static</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_types">gzip_types</a> <br>   <a href="http/ngx_http_gzip_module.html#gzip_vary">gzip_vary</a> <br>   <a href="http/ngx_http_upstream_module.html#hash">hash</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#hash">hash</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_hc_module.html#health_check">health_check</a> （ngx_http_upstream_hc_module） <br>   health_check（ngx_stream_upstream_hc_module） <br>   <a href="stream/ngx_stream_upstream_hc_module.html#health_check_timeout">health_check_timeout</a> <br>   <a href="http/ngx_http_hls_module.html#hls">HLS</a> <br>   <a href="http/ngx_http_hls_module.html#hls_buffers">hls_buffers</a> <br>   <a href="http/ngx_http_hls_module.html#hls_forward_args">hls_forward_args</a> <br>   <a href="http/ngx_http_hls_module.html#hls_fragment">hls_fragment</a> <br>   <a href="http/ngx_http_hls_module.html#hls_mp4_buffer_size">hls_mp4_buffer_size</a> <br>   <a href="http/ngx_http_hls_module.html#hls_mp4_max_buffer_size">hls_mp4_max_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#http">HTTP</a> <br>   <a href="http/ngx_http_v2_module.html#http2_body_preread_size">http2_body_preread_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_chunk_size">http2_chunk_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_idle_timeout">http2_idle_timeout</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_concurrent_pushes">http2_max_concurrent_pushes</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_concurrent_streams">http2_max_concurrent_streams</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_field_size">http2_max_field_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_header_size">http2_max_header_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_max_requests">http2_max_requests</a> <br>   <a href="http/ngx_http_v2_module.html#http2_push">http2_push</a> <br>   <a href="http/ngx_http_v2_module.html#http2_push_preload">http2_push_preload</a> <br>   <a href="http/ngx_http_v2_module.html#http2_recv_buffer_size">http2_recv_buffer_size</a> <br>   <a href="http/ngx_http_v2_module.html#http2_recv_timeout">http2_recv_timeout</a> <br>   <a href="http/ngx_http_rewrite_module.html#if">如果</a> <br>   <a href="http/ngx_http_core_module.html#if_modified_since">if_modified_since</a> <br>   <a href="http/ngx_http_core_module.html#ignore_invalid_headers">ignore_invalid_headers</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter">image_filter</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_buffer">image_filter_buffer</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_interlace">image_filter_interlace</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_jpeg_quality">image_filter_jpeg_quality</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_sharpen">image_filter_sharpen</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_transparency">image_filter_transparency</a> <br>   <a href="http/ngx_http_image_filter_module.html#image_filter_webp_quality">image_filter_webp_quality</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_auth">imap_auth</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_capabilities">imap_capabilities</a> <br>   <a href="mail/ngx_mail_imap_module.html#imap_client_buffer">imap_client_buffer</a> <br>   <a href="ngx_core_module.html#include">包括</a> <br>   <a href="http/ngx_http_index_module.html#index">指数</a> <br>   <a href="http/ngx_http_core_module.html#internal">内部</a> <br>   <a href="http/ngx_http_upstream_module.html#ip_hash">ip_hash</a> <br>   <a href="stream/ngx_stream_js_module.html#js_access">js_access</a> <br>   <a href="http/ngx_http_js_module.html#js_content">js_content</a> <br>   <a href="stream/ngx_stream_js_module.html#js_filter">js_filter</a> <br>   <a href="http/ngx_http_js_module.html#js_include">js_include</a> （ngx_http_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_include">js_include</a> （ngx_stream_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_preread">js_preread</a> <br>   <a href="http/ngx_http_js_module.html#js_set">js_set</a> （ngx_http_js_module） <br>   <a href="stream/ngx_stream_js_module.html#js_set">js_set</a> （ngx_stream_js_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive">活着</a> <br>   <a href="http/ngx_http_core_module.html#keepalive_disable">keepalive_disable</a> <br>   <a href="http/ngx_http_core_module.html#keepalive_requests">keepalive_requests</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive_requests">keepalive_requests</a> （ngx_http_upstream_module） <br>   <a href="http/ngx_http_core_module.html#keepalive_timeout">keepalive_timeout</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#keepalive_timeout">keepalive_timeout</a> （ngx_http_upstream_module） <br>   <a href="http/ngx_http_keyval_module.html#keyval">keyval</a> （ngx_http_keyval_module） <br>   <a href="stream/ngx_stream_keyval_module.html#keyval">keyval</a> （ngx_stream_keyval_module） <br>   <a href="http/ngx_http_keyval_module.html#keyval_zone">keyval_zone</a> （ngx_http_keyval_module） <br>   <a href="stream/ngx_stream_keyval_module.html#keyval_zone">keyval_zone</a> （ngx_stream_keyval_module） <br>   <a href="http/ngx_http_core_module.html#large_client_header_buffers">large_client_header_buffers</a> <br>   <a href="http/ngx_http_upstream_module.html#least_conn">least_conn</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#least_conn">least_conn</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_module.html#least_time">least_time</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#least_time">least_time</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn">limit_conn</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn">limit_conn</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_log_level">limit_conn_log_level</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn_log_level">limit_conn_log_level</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_status">limit_conn_status</a> <br>   <a href="http/ngx_http_limit_conn_module.html#limit_conn_zone">limit_conn_zone</a> （ngx_http_limit_conn_module） <br>   <a href="stream/ngx_stream_limit_conn_module.html#limit_conn_zone">limit_conn_zone</a> （ngx_stream_limit_conn_module） <br>   <a href="http/ngx_http_core_module.html#limit_except">limit_except</a> <br>   <a href="http/ngx_http_core_module.html#limit_rate">limit_rate</a> <br>   <a href="http/ngx_http_core_module.html#limit_rate_after">limit_rate_after</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req">limit_req</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_log_level">limit_req_log_level</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_status">limit_req_status</a> <br>   <a href="http/ngx_http_limit_req_module.html#limit_req_zone">limit_req_zone</a> <br>   <a href="http/ngx_http_limit_conn_module.html#limit_zone">limit_zone</a> <br>   <a href="http/ngx_http_core_module.html#lingering_close">lingering_close</a> <br>   <a href="http/ngx_http_core_module.html#lingering_time">lingering_time</a> <br>   <a href="http/ngx_http_core_module.html#lingering_timeout">lingering_timeout</a> <br>   <a href="http/ngx_http_core_module.html#listen">听</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#listen">听</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#listen">听</a> （ngx_stream_core_module） <br>   <a href="ngx_core_module.html#load_module">load_module</a> <br>   <a href="http/ngx_http_core_module.html#location">地点</a> <br>   <a href="ngx_core_module.html#lock_file">LOCK_FILE</a> <br>   <a href="http/ngx_http_log_module.html#log_format">log_format</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#log_format">log_format</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_core_module.html#log_not_found">log_not_found</a> <br>   <a href="http/ngx_http_core_module.html#log_subrequest">log_subrequest</a> <br>   <a href="mail/ngx_mail_core_module.html#mail">邮件</a> <br>   <a href="http/ngx_http_map_module.html#map">地图</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map">地图</a> （ngx_stream_map_module） <br>   <a href="http/ngx_http_map_module.html#map_hash_bucket_size">map_hash_bucket_size</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map_hash_bucket_size">map_hash_bucket_size</a> （ngx_stream_map_module） <br>   <a href="http/ngx_http_map_module.html#map_hash_max_size">map_hash_max_size</a> （ngx_http_map_module） <br>   <a href="stream/ngx_stream_map_module.html#map_hash_max_size">map_hash_max_size</a> （ngx_stream_map_module） <br>   <a href="ngx_core_module.html#master_process">master_process</a> <br>   <a href="http/ngx_http_upstream_hc_module.html#match">匹配</a> （ngx_http_upstream_hc_module） <br>   <a href="stream/ngx_stream_upstream_hc_module.html#match">匹配</a> （ngx_stream_upstream_hc_module） <br>   <a href="http/ngx_http_core_module.html#max_ranges">max_ranges</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_bind">memcached_bind</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_buffer_size">memcached_buffer_size</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_connect_timeout">memcached_connect_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_force_ranges">memcached_force_ranges</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_gzip_flag">memcached_gzip_flag</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream">memcached_next_upstream</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream_timeout">memcached_next_upstream_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_next_upstream_tries">memcached_next_upstream_tries</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_pass">memcached_pa​​ss</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_read_timeout">memcached_read_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_send_timeout">memcached_send_timeout</a> <br>   <a href="http/ngx_http_memcached_module.html#memcached_socket_keepalive">memcached_socket_keepalive</a> <br>   <a href="http/ngx_http_core_module.html#merge_slashes">merge_slashes</a> <br>   <a href="http/ngx_http_dav_module.html#min_delete_depth">min_delete_depth</a> <br>   <a href="http/ngx_http_mirror_module.html#mirror">镜子</a> <br>   <a href="http/ngx_http_mirror_module.html#mirror_request_body">mirror_request_body</a> <br>   <a href="http/ngx_http_browser_module.html#modern_browser">modern_browser</a> <br>   <a href="http/ngx_http_browser_module.html#modern_browser_value">modern_browser_value</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4">MP4</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_buffer_size">mp4_buffer_size</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_limit_rate">mp4_limit_rate</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_limit_rate_after">mp4_limit_rate_after</a> <br>   <a href="http/ngx_http_mp4_module.html#mp4_max_buffer_size">mp4_max_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#msie_padding">msie_padding</a> <br>   <a href="http/ngx_http_core_module.html#msie_refresh">msie_refresh</a> <br>   <a href="ngx_core_module.html#multi_accept">multi_accept</a> <br>   <a href="http/ngx_http_upstream_module.html#ntlm">NTLM</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache">open_file_cache</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_errors">open_file_cache_errors</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_min_uses">open_file_cache_min_uses</a> <br>   <a href="http/ngx_http_core_module.html#open_file_cache_valid">open_file_cache_valid</a> <br>   <a href="http/ngx_http_log_module.html#open_log_file_cache">open_log_file_cache</a> （ngx_http_log_module） <br>   <a href="stream/ngx_stream_log_module.html#open_log_file_cache">open_log_file_cache</a> （ngx_stream_log_module） <br>   <a href="http/ngx_http_core_module.html#output_buffers">output_buffers</a> <br>   <a href="http/ngx_http_charset_module.html#override_charset">override_charset</a> <br>   <a href="ngx_core_module.html#pcre_jit">pcre_jit</a> <br>   <a href="http/ngx_http_perl_module.html#perl">perl的</a> <br>   <a href="http/ngx_http_perl_module.html#perl_modules">perl_modules</a> <br>   <a href="http/ngx_http_perl_module.html#perl_require">perl_require</a> <br>   <a href="http/ngx_http_perl_module.html#perl_set">perl_set</a> <br>   <a href="ngx_core_module.html#pid">PID</a> <br>   <a href="mail/ngx_mail_pop3_module.html#pop3_auth">pop3_auth</a> <br>   <a href="mail/ngx_mail_pop3_module.html#pop3_capabilities">pop3_capabilities</a> <br>   <a href="http/ngx_http_core_module.html#port_in_redirect">port_in_redirect</a> <br>   <a href="http/ngx_http_core_module.html#postpone_output">postpone_output</a> <br>   <a href="stream/ngx_stream_core_module.html#preread_buffer_size">preread_buffer_size</a> <br>   <a href="stream/ngx_stream_core_module.html#preread_timeout">preread_timeout</a> <br>   <a href="mail/ngx_mail_core_module.html#protocol">协议</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_bind">proxy_bind</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_bind">proxy_bind</a> （ngx_stream_proxy_module） <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_buffer">proxy_buffer</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_buffer_size">proxy_buffer_size</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffering">proxy_buffering</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_buffers">proxy_buffers</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_busy_buffers_size">proxy_busy_buffers_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache">proxy_cache</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_background_update">proxy_cache_background_update</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_bypass">proxy_cache_bypass</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_convert_head">proxy_cache_convert_head</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_key">proxy_cache_key</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock">proxy_cache_lock</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock_age">proxy_cache_lock_age</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_max_range_offset">proxy_cache_max_range_offset</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_methods">proxy_cache_methods</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_min_uses">proxy_cache_min_uses</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_path">proxy_cache_path</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_purge">proxy_cache_purge</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_revalidate">proxy_cache_revalidate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_use_stale">proxy_cache_use_stale</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cache_valid">proxy_cache_valid</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_connect_timeout">proxy_connect_timeout</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_cookie_domain">proxy_cookie_domain</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_cookie_path">proxy_cookie_path</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_download_rate">proxy_download_rate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_force_ranges">proxy_force_ranges</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_headers_hash_bucket_size">proxy_headers_hash_bucket_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_headers_hash_max_size">proxy_headers_hash_max_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_hide_header">proxy_hide_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ignore_client_abort">proxy_ignore_client_abort</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_intercept_errors">proxy_intercept_errors</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_limit_rate">proxy_limit_rate</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_max_temp_file_size">proxy_max_temp_file_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_method">proxy_method</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream_timeout">proxy_next_upstream_timeout</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_next_upstream_tries">proxy_next_upstream_tries</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_next_upstream_tries">proxy_next_upstream_tries</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_no_cache">proxy_no_cache</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_pass">proxy_pass</a> （ngx_stream_proxy_module） <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_pass_error_message">proxy_pass_error_message</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_header">proxy_pass_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_request_body">proxy_pass_request_body</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_pass_request_headers">proxy_pass_request_headers</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_protocol">proxy_protocol</a> <br>   <a href="stream/ngx_stream_core_module.html#proxy_protocol_timeout">proxy_protocol_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_read_timeout">proxy_read_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_redirect">proxy_redirect</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_request_buffering">proxy_request_buffering</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_requests">proxy_requests</a> <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_responses">proxy_responses</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_send_lowat">proxy_send_lowat</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_send_timeout">proxy_send_timeout</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_set_body">proxy_set_body</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_set_header">proxy_set_header</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_socket_keepalive">proxy_socket_keepalive</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_socket_keepalive">proxy_socket_keepalive</a> （ngx_stream_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl">proxy_ssl</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_certificate">proxy_ssl_certificate</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_certificate">proxy_ssl_certificate</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_certificate_key">proxy_ssl_certificate_key</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_ciphers">proxy_ssl_ciphers</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_ciphers">proxy_ssl_ciphers</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_crl">proxy_ssl_crl</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_crl">proxy_ssl_crl</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_name">proxy_ssl_name</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_name">proxy_ssl_name</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_password_file">proxy_ssl_password_file</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_password_file">proxy_ssl_password_file</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_protocols">proxy_ssl_protocols</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_protocols">proxy_ssl_protocols</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_server_name">proxy_ssl_server_name</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_server_name">proxy_ssl_server_name</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_trusted_certificate">proxy_ssl_trusted_certificate</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_verify">proxy_ssl_verify</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_verify">proxy_ssl_verify</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> （ngx_http_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_ssl_verify_depth">proxy_ssl_verify_depth</a> （ngx_stream_proxy_module） <br>   <a href="http/ngx_http_proxy_module.html#proxy_store">proxy_store</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_store_access">proxy_store_access</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_temp_file_write_size">proxy_temp_file_write_size</a> <br>   <a href="http/ngx_http_proxy_module.html#proxy_temp_path">proxy_temp_path</a> <br>   <a href="mail/ngx_mail_proxy_module.html#proxy_timeout">proxy_timeout</a> （ngx_mail_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_timeout">proxy_timeout</a> （ngx_stream_proxy_module） <br>   <a href="stream/ngx_stream_proxy_module.html#proxy_upload_rate">proxy_upload_rate</a> <br>   <a href="http/ngx_http_upstream_module.html#queue">队列</a> <br>   <a href="http/ngx_http_upstream_module.html#random">随机的</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#random">随机的</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_random_index_module.html#random_index">random_index</a> <br>   <a href="http/ngx_http_core_module.html#read_ahead">read_ahead</a> <br>   <a href="http/ngx_http_realip_module.html#real_ip_header">real_ip_header</a> <br>   <a href="http/ngx_http_realip_module.html#real_ip_recursive">real_ip_recursive</a> <br>   <a href="http/ngx_http_core_module.html#recursive_error_pages">recursive_error_pages</a> <br>   <a href="http/ngx_http_referer_module.html#referer_hash_bucket_size">referer_hash_bucket_size</a> <br>   <a href="http/ngx_http_referer_module.html#referer_hash_max_size">referer_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#request_pool_size">request_pool_size</a> <br>   <a href="http/ngx_http_core_module.html#reset_timedout_connection">reset_timedout_connection</a> <br>   <a href="http/ngx_http_core_module.html#resolver">解析器</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#resolver">解析器</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#resolver">解析器</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#resolver_timeout">resolver_timeout</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_rewrite_module.html#return">return</a> （ngx_http_rewrite_module） <br>   <a href="stream/ngx_stream_return_module.html#return">return</a> （ngx_stream_return_module） <br>   <a href="http/ngx_http_rewrite_module.html#rewrite">改写</a> <br>   <a href="http/ngx_http_rewrite_module.html#rewrite_log">rewrite_log</a> <br>   <a href="http/ngx_http_core_module.html#root">根</a> <br>   <a href="http/ngx_http_core_module.html#satisfy">满足</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_bind">scgi_bind</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffer_size">scgi_buffer_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffering">scgi_buffering</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_buffers">scgi_buffers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_busy_buffers_size">scgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache">scgi_cache</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_background_update">scgi_cache_background_update</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_bypass">scgi_cache_bypass</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_key">scgi_cache_key</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock">scgi_cache_lock</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock_age">scgi_cache_lock_age</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_lock_timeout">scgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_max_range_offset">scgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_methods">scgi_cache_methods</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_min_uses">scgi_cache_min_uses</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_path">scgi_cache_path</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_purge">scgi_cache_purge</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_revalidate">scgi_cache_revalidate</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_use_stale">scgi_cache_use_stale</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_cache_valid">scgi_cache_valid</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_connect_timeout">scgi_connect_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_force_ranges">scgi_force_ranges</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_hide_header">scgi_hide_header</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_ignore_client_abort">scgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_intercept_errors">scgi_intercept_errors</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_limit_rate">scgi_limit_rate</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_max_temp_file_size">scgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream">scgi_next_upstream</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream_timeout">scgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_next_upstream_tries">scgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_no_cache">scgi_no_cache</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_param">scgi_param</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass">scgi_pass</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_header">scgi_pass_header</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_request_body">scgi_pass_request_body</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_pass_request_headers">scgi_pass_request_headers</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_read_timeout">scgi_read_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_request_buffering">scgi_request_buffering</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_send_timeout">scgi_send_timeout</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_socket_keepalive">scgi_socket_keepalive</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_store">scgi_store</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_store_access">scgi_store_access</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_temp_file_write_size">scgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_scgi_module.html#scgi_temp_path">scgi_temp_path</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link">secure_link</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link_md5">secure_link_md5</a> <br>   <a href="http/ngx_http_secure_link_module.html#secure_link_secret">secure_link_secret</a> <br>   <a href="http/ngx_http_core_module.html#send_lowat">send_lowat</a> <br>   <a href="http/ngx_http_core_module.html#send_timeout">send_timeout</a> <br>   <a href="http/ngx_http_core_module.html#sendfile">发送文件</a> <br>   <a href="http/ngx_http_core_module.html#sendfile_max_chunk">sendfile_max_chunk</a> <br>   <a href="http/ngx_http_core_module.html#server">服务器</a> （ngx_http_core_module） <br>   <a href="http/ngx_http_upstream_module.html#server">服务器</a> （ngx_http_upstream_module） <br>   <a href="mail/ngx_mail_core_module.html#server">服务器</a> （ngx_mail_core_module） <br>   <a href="stream/ngx_stream_core_module.html#server">服务器</a> （ngx_stream_core_module） <br>   <a href="stream/ngx_stream_upstream_module.html#server">服务器</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_core_module.html#server_name">server_name</a> （ngx_http_core_module） <br>   <a href="mail/ngx_mail_core_module.html#server_name">server_name</a> （ngx_mail_core_module） <br>   <a href="http/ngx_http_core_module.html#server_name_in_redirect">server_name_in_redirect</a> <br>   <a href="http/ngx_http_core_module.html#server_names_hash_bucket_size">server_names_hash_bucket_size</a> <br>   <a href="http/ngx_http_core_module.html#server_names_hash_max_size">server_names_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#server_tokens">server_tokens</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log">session_log</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log_format">session_log_format</a> <br>   <a href="http/ngx_http_session_log_module.html#session_log_zone">session_log_zone</a> <br>   <a href="http/ngx_http_rewrite_module.html#set">组</a> <br>   <a href="http/ngx_http_realip_module.html#set_real_ip_from">set_real_ip_from</a> （ngx_http_realip_module） <br>   <a href="stream/ngx_stream_realip_module.html#set_real_ip_from">set_real_ip_from</a> （ngx_stream_realip_module） <br>   <a href="http/ngx_http_slice_module.html#slice">切片</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_auth">SMTP_AUTH</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_capabilities">smtp_capabilities</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_client_buffer">smtp_client_buffer</a> <br>   <a href="mail/ngx_mail_smtp_module.html#smtp_greeting_delay">smtp_greeting_delay</a> <br>   <a href="http/ngx_http_charset_module.html#source_charset">source_charset</a> <br>   <a href="http/ngx_http_spdy_module.html#spdy_chunk_size">spdy_chunk_size</a> <br>   <a href="http/ngx_http_spdy_module.html#spdy_headers_comp">spdy_headers_comp</a> <br>   <a href="http/ngx_http_split_clients_module.html#split_clients">split_clients</a> （ngx_http_split_clients_module） <br>   <a href="stream/ngx_stream_split_clients_module.html#split_clients">split_clients</a> （ngx_stream_split_clients_module） <br>   <a href="http/ngx_http_ssi_module.html#ssi">SSI</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_last_modified">ssi_last_modified</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_min_file_chunk">ssi_min_file_chunk</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_silent_errors">ssi_silent_errors</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_types">ssi_types</a> <br>   <a href="http/ngx_http_ssi_module.html#ssi_value_length">ssi_value_length</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl">ssl</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl">ssl</a> （ngx_mail_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_buffer_size">ssl_buffer_size</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_certificate">ssl_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_ciphers">ssl_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_client_certificate">ssl_client_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_crl">ssl_crl</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_dhparam">ssl_dhparam</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_early_data">ssl_early_data</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_ecdh_curve">ssl_ecdh_curve</a> （ngx_stream_ssl_module） <br>   <a href="ngx_core_module.html#ssl_engine">ssl_engine</a> <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_handshake_timeout">ssl_handshake_timeout</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_password_file">ssl_password_file</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_prefer_server_ciphers">ssl_prefer_server_ciphers</a> （ngx_stream_ssl_module） <br>   <a href="stream/ngx_stream_ssl_preread_module.html#ssl_preread">ssl_preread</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_protocols">ssl_protocols</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_cache">ssl_session_cache</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_ticket_key">ssl_session_ticket_key</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_tickets">ssl_session_tickets</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling">ssl_stapling</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_file">ssl_stapling_file</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_responder">ssl_stapling_responder</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_stapling_verify">ssl_stapling_verify</a> <br>   <a href="http/ngx_http_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_trusted_certificate">ssl_trusted_certificate</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_verify_client">ssl_verify_client</a> （ngx_stream_ssl_module） <br>   <a href="http/ngx_http_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_http_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_mail_ssl_module） <br>   <a href="stream/ngx_stream_ssl_module.html#ssl_verify_depth">ssl_verify_depth</a> （ngx_stream_ssl_module） <br>   <a href="mail/ngx_mail_ssl_module.html#starttls">STARTTLS</a> <br>   <a href="http/ngx_http_upstream_module.html#state">state</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#state">state</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_status_module.html#status">状态</a> <br>   <a href="http/ngx_http_status_module.html#status_format">status_format的</a> <br>   <a href="http/ngx_http_api_module.html#status_zone">status_zone</a> （ngx_http_api_module） <br>   <a href="http/ngx_http_status_module.html#status_zone">status_zone</a> （ngx_http_status_module） <br>   <a href="http/ngx_http_upstream_module.html#sticky">黏</a> <br>   <a href="http/ngx_http_upstream_module.html#sticky_cookie_insert">sticky_cookie_insert</a> <br>   <a href="stream/ngx_stream_core_module.html#stream">流</a> <br>   <a href="http/ngx_http_stub_status_module.html#stub_status">stub_status</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter">sub_filter</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_last_modified">sub_filter_last_modified</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_once">sub_filter_once</a> <br>   <a href="http/ngx_http_sub_module.html#sub_filter_types">sub_filter_types</a> <br>   <a href="http/ngx_http_core_module.html#subrequest_output_buffer_size">subrequest_output_buffer_size</a> <br>   <a href="http/ngx_http_core_module.html#tcp_nodelay">tcp_nodelay</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#tcp_nodelay">tcp_nodelay</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#tcp_nopush">tcp_nopush</a> <br>   <a href="ngx_core_module.html#thread_pool">thread_pool</a> <br>   <a href="mail/ngx_mail_core_module.html#timeout">超时</a> <br>   <a href="ngx_core_module.html#timer_resolution">timer_resolution</a> <br>   <a href="http/ngx_http_core_module.html#try_files">try_files</a> <br>   <a href="http/ngx_http_core_module.html#types">类型</a> <br>   <a href="http/ngx_http_core_module.html#types_hash_bucket_size">types_hash_bucket_size</a> <br>   <a href="http/ngx_http_core_module.html#types_hash_max_size">types_hash_max_size</a> <br>   <a href="http/ngx_http_core_module.html#underscores_in_headers">underscores_in_headers</a> <br>   <a href="http/ngx_http_rewrite_module.html#uninitialized_variable_warn">uninitialized_variable_warn</a> <br>   <a href="http/ngx_http_upstream_module.html#upstream">上游</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#upstream">上游</a> （ngx_stream_upstream_module） <br>   <a href="http/ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a> <br>   <a href="ngx_core_module.html#use">使用</a> <br>   <a href="ngx_core_module.html#user">用户</a> <br>   <a href="http/ngx_http_userid_module.html#userid">用户身份</a> <br>   <a href="http/ngx_http_userid_module.html#userid_domain">userid_domain</a> <br>   <a href="http/ngx_http_userid_module.html#userid_expires">userid_expires</a> <br>   <a href="http/ngx_http_userid_module.html#userid_mark">userid_mark</a> <br>   <a href="http/ngx_http_userid_module.html#userid_name">userid_name</a> <br>   <a href="http/ngx_http_userid_module.html#userid_p3p">userid_p3p</a> <br>   <a href="http/ngx_http_userid_module.html#userid_path">userid_path</a> <br>   <a href="http/ngx_http_userid_module.html#userid_service">userid_service</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_bind">uwsgi_bind</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffer_size">uwsgi_buffer_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffering">uwsgi_buffering</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_buffers">uwsgi_buffers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_busy_buffers_size">uwsgi_busy_buffers_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache">uwsgi_cache</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_background_update">uwsgi_cache_background_update</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_bypass">uwsgi_cache_bypass</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_key">uwsgi_cache_key</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock">uwsgi_cache_lock</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock_age">uwsgi_cache_lock_age</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_lock_timeout">uwsgi_cache_lock_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_max_range_offset">uwsgi_cache_max_range_offset</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_methods">uwsgi_cache_methods</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_min_uses">uwsgi_cache_min_uses</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_path">uwsgi_cache_path</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_purge">uwsgi_cache_purge</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_revalidate">uwsgi_cache_revalidate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_use_stale">uwsgi_cache_use_stale</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_cache_valid">uwsgi_cache_valid</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_connect_timeout">uwsgi_connect_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_force_ranges">uwsgi_force_ranges</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_hide_header">uwsgi_hide_header</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ignore_client_abort">uwsgi_ignore_client_abort</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_intercept_errors">uwsgi_intercept_errors</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_limit_rate">uwsgi_limit_rate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_max_temp_file_size">uwsgi_max_temp_file_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_modifier1">uwsgi_modifier1</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_modifier2">uwsgi_modifier2</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream">uwsgi_next_upstream</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream_timeout">uwsgi_next_upstream_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_next_upstream_tries">uwsgi_next_upstream_tries</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_no_cache">uwsgi_no_cache</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_param">uwsgi_param</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_header">uwsgi_pass_header</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_request_body">uwsgi_pass_request_body</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_pass_request_headers">uwsgi_pass_request_headers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_read_timeout">uwsgi_read_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_request_buffering">uwsgi_request_buffering</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_send_timeout">uwsgi_send_timeout</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_socket_keepalive">uwsgi_socket_keepalive</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_certificate">uwsgi_ssl_certificate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_certificate_key">uwsgi_ssl_certificate_key</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_ciphers">uwsgi_ssl_ciphers</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_crl">uwsgi_ssl_crl</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_name">uwsgi_ssl_name</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_password_file">uwsgi_ssl_password_file</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_protocols">uwsgi_ssl_protocols</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_server_name">uwsgi_ssl_server_name</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_session_reuse">uwsgi_ssl_session_reuse</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_trusted_certificate">uwsgi_ssl_trusted_certificate</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_verify">uwsgi_ssl_verify</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_ssl_verify_depth">uwsgi_ssl_verify_depth</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_store">uwsgi_store</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_store_access">uwsgi_store_access</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_temp_file_write_size">uwsgi_temp_file_write_size</a> <br>   <a href="http/ngx_http_uwsgi_module.html#uwsgi_temp_path">uwsgi_temp_path</a> <br>   <a href="http/ngx_http_referer_module.html#valid_referers">valid_referers</a> <br>   <a href="http/ngx_http_core_module.html#variables_hash_bucket_size">variables_hash_bucket_size</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#variables_hash_bucket_size">variables_hash_bucket_size</a> （ngx_stream_core_module） <br>   <a href="http/ngx_http_core_module.html#variables_hash_max_size">variables_hash_max_size</a> （ngx_http_core_module） <br>   <a href="stream/ngx_stream_core_module.html#variables_hash_max_size">variables_hash_max_size</a> （ngx_stream_core_module） <br>   <a href="ngx_core_module.html#worker_aio_requests">worker_aio_requests</a> <br>   <a href="ngx_core_module.html#worker_connections">worker_connections</a> <br>   <a href="ngx_core_module.html#worker_cpu_affinity">worker_cpu_affinity</a> <br>   <a href="ngx_core_module.html#worker_priority">worker_priority</a> <br>   <a href="ngx_core_module.html#worker_processes">worker_processes</a> <br>   <a href="ngx_core_module.html#worker_rlimit_core">worker_rlimit_core</a> <br>   <a href="ngx_core_module.html#worker_rlimit_nofile">worker_rlimit_nofile</a> <br>   <a href="ngx_core_module.html#worker_shutdown_timeout">worker_shutdown_timeout</a> <br>   <a href="ngx_core_module.html#working_directory">working_directory的</a> <br>   <a href="mail/ngx_mail_proxy_module.html#xclient">X客户端</a> <br>   <a href="http/ngx_http_xslt_module.html#xml_entities">xml_entities</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_last_modified">xslt_last_modified</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_param">xslt_param</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_string_param">xslt_string_param</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_stylesheet">xslt_stylesheet</a> <br>   <a href="http/ngx_http_xslt_module.html#xslt_types">xslt_types</a> <br>   <a href="http/ngx_http_upstream_module.html#zone">zone</a> （ngx_http_upstream_module） <br>   <a href="stream/ngx_stream_upstream_module.html#zone">zone</a> （ngx_stream_upstream_module） <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync">zone_sync</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_buffers">zone_sync_buffers</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_connect_retry_interval">zone_sync_connect_retry_interval</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_connect_timeout">zone_sync_connect_timeout</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_interval">zone_sync_interval</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_recv_buffer_size">zone_sync_recv_buffer_size</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_server">zone_sync_server</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl">zone_sync_ssl</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_certificate">zone_sync_ssl_certificate</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_certificate_key">zone_sync_ssl_certificate_key</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_ciphers">zone_sync_ssl_ciphers</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_crl">zone_sync_ssl_crl</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_name">zone_sync_ssl_name</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_password_file">zone_sync_ssl_password_file</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_protocols">zone_sync_ssl_protocols</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_server_name">zone_sync_ssl_server_name</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_trusted_certificate">zone_sync_ssl_trusted_certificate</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_verify">zone_sync_ssl_verify</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_ssl_verify_depth">zone_sync_ssl_verify_depth</a> <br>   <a href="stream/ngx_stream_zone_sync_module.html#zone_sync_timeout">zone_sync_timeout</a> <br></p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[debugging_log-nginx中文手册]]></title>
      <url>/ngx/debugging_log.html</url>
      <content type="html"><![CDATA[<p>debugging_log<br><a id="more"></a></p>
<h2 id="调试日志"><a href="#调试日志" class="headerlink" title="调试日志"></a>调试日志</h2><td align="left" class="notranslate"> <a href="#clients">Debugging log for selected clients</a> <br> <a href="#memory">Logging to a cyclic memory buffer</a> <br></td>

<p>  要启用调试日志，需要配置nginx以在构建期间支持调试： </p>
<pre class="notranslate">./configure --with-debug ...
</pre>

<p>  然后应使用<a href="ngx_core_module.html#error_log">error_log</a>指令设置<code>debug</code>级别： </p>
<pre class="notranslate">error_log /path/to/log debug;
</pre>

<p>  要验证nginx是否配置为支持调试，请运行<code>nginx -V</code>命令： </p>
<pre class="notranslate">configure arguments: --with-debug ...
</pre>

<p>  预构建的<a href="linux_packages.html">Linux</a>软件包为使用<code>nginx-debug</code>二进制文件（1.9.8）调试日志提供了开箱即用的支持，可以使用命令运行 </p>
<pre class="notranslate">service nginx stop
service nginx-debug start
</pre>

<p>  然后设置<code>debug</code>级别。  用于Windows的nginx二进制版本始终使用调试日志支持构建，因此仅设置<code>debug</code>级别就足够了。 </p>
<p>  请注意，重新定义日志而不指定<code>debug</code>级别将禁用调试日志。  在下面的示例中，重新定义<a href="http/ngx_http_core_module.html#server">服务器</a>级别上的日志会禁用此服务器的调试日志： </p>
<pre class="notranslate">error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log;
        ...
</pre>

<p>  为避免这种情况，应重新定义重新定义日志的行，或者还应添加<code>debug</code>级别规范： </p>
<pre class="notranslate">error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log debug;
        ...
</pre>



<h4 id="调试所选客户端的日志"><a href="#调试所选客户端的日志" class="headerlink" title="调试所选客户端的日志"></a>调试所选客户端的日志</h4><p>  也可以仅为<a href="ngx_core_module.html#debug_connection">选定的客户端地址</a>启用调试日志： </p>
<pre class="notranslate">error_log /path/to/log;

events {
    debug_connection 192.168.1.1;
    debug_connection 192.168.10.0/24;
}
</pre>



<h4 id="记录到循环内存缓冲区"><a href="#记录到循环内存缓冲区" class="headerlink" title="记录到循环内存缓冲区"></a>记录到循环内存缓冲区</h4><p>  调试日志可以写入循环内存缓冲区： </p>
<pre class="notranslate">error_log memory:32m debug;
</pre>

<p>  即使在高负载下，在<code>debug</code>级别上记录到内存缓冲区也不会对性能产生重大影响。  在这种情况下，可以使用<code>gdb</code>脚本提取日志，如下所示： </p>
<pre class="notranslate">set $log = ngx_cycle-&gt;log

while $log-&gt;writer != ngx_log_memory_writer
    set $log = $log-&gt;next
end

set $buf = (ngx_log_memory_buf_t *) $log-&gt;wdata
dump binary memory debug_log.txt $buf-&gt;start $buf-&gt;end
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[control-nginx中文手册]]></title>
      <url>/ngx/control.html</url>
      <content type="html"><![CDATA[<p>control<br><a id="more"></a></p>
<h2 id="控制nginx"><a href="#控制nginx" class="headerlink" title="控制nginx"></a>控制nginx</h2><td align="left" class="notranslate"> <a href="#reconfiguration">Changing Configuration</a> <br> <a href="#logs">Rotating Log-files</a> <br> <a href="#upgrade">Upgrading Executable on the Fly</a> <br></td>

<p>   nginx可以用信号控制。  默认情况下，主进程的进程ID将写入文件<code>/usr/local/nginx/logs/nginx.pid</code> 。  此名称可以在配置时更改，也可以使用<a href="ngx_core_module.html#pid">pid</a>指令在<code>nginx.conf</code>更改。  主进程支持以下信号： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">TERM, INT</td><td class="notranslate">fast shutdown</td><br><td width="20%" class="notranslate">QUIT</td><td class="notranslate">graceful shutdown</td><br><tr><td width="20%" class="notranslate">HUP</td><td class="notranslate">changing configuration,<br>keeping up with a changed time zone (only for FreeBSD and Linux),<br>starting new worker processes with a new configuration,<br>graceful shutdown of old worker processes</td></tr><td width="20%" class="notranslate">USR1</td><td class="notranslate">re-opening log files</td><br><td width="20%" class="notranslate">USR2</td><td class="notranslate">upgrading an executable file</td><br><td width="20%" class="notranslate">WINCH</td><td class="notranslate">graceful shutdown of worker processes</td><br></tbody></table>



</blockquote>
<p>  虽然不是必需的，但也可以通过信号控制单个工作进程。  支持的信号是： </p>
<blockquote>
<table width="100%"><tbody><td width="20%" class="notranslate">TERM, INT</td><td class="notranslate">fast shutdown</td><br><td width="20%" class="notranslate">QUIT</td><td class="notranslate">graceful shutdown</td><br><td width="20%" class="notranslate">USR1</td><td class="notranslate">re-opening log files</td><br><tr><td width="20%" class="notranslate">WINCH</td><td class="notranslate">abnormal termination for debugging<br>(requires <a href="ngx_core_module.html#debug_points">debug_points</a> to be enabled)<br></td></tr></tbody></table>



</blockquote>
<h4 id="改变配置"><a href="#改变配置" class="headerlink" title="改变配置"></a>改变配置</h4><p>  为了让nginx重新读取配置文件，应该将HUP信号发送到主进程。  主进程首先检查语法有效性，然后尝试应用新配置，即打开日志文件和新的侦听套接字。  如果此操作失败，则会回滚更改并继续使用旧配置。  如果成功，它将启动新的工作进程，并向旧工作进程发送消息，请求它们正常关闭。  旧工作进程关闭侦听套接字并继续为旧客户端提供服务。  在为所有客户端提供服务后，将关闭旧工作进程。 </p>
<p>  让我们通过例子来说明这一点。  想象一下，nginx是在FreeBSD和命令上运行的 </p>
<pre class="notranslate">ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep '(nginx|PID)'
</pre>

<p>  产生以下输出： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  如果将HUP发送到主进程，则输出变为： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</pre>



<p>   PID 33129的旧工作进程之一仍然继续工作。  退出一段时间后： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
</pre>



<h4 id="旋转日志文件"><a href="#旋转日志文件" class="headerlink" title="旋转日志文件"></a>旋转日志文件</h4><p>  为了旋转日志文件，需要先重命名它们。  之后，应将USR1信号发送到主进程。  然后，主进程将重新打开所有当前打开的日志文件，并为作为所有者的工作进程正在运行的非特权用户分配。  成功重新打开后，主进程将关闭所有打开的文件，并将消息发送到工作进程，要求他们重新打开文件。  工作进程还会立即打开新文件并关闭旧文件。  因此，旧文件几乎可立即用于后期处理，例如压缩。 </p>
<h4 id="即时升级可执行文件"><a href="#即时升级可执行文件" class="headerlink" title="即时升级可执行文件"></a>即时升级可执行文件</h4><p>  为了升级服务器可执行文件，应首先使用新的可执行文件代替旧文件。  之后，应将USR2信号发送到主进程。  主进程首先使用进程ID将其文件重命名为带有<code>.oldbin</code>后缀的新文件，例如<code>/usr/local/nginx/logs/nginx.pid.oldbin</code> ，然后启动一个新的可执行文件，该文件又启动新的工作进程： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  之后，所有工作进程（新旧进程）继续接受请求。  如果将WINCH信号发送到第一个主进程，它将向其工作进程发送消息，请求它们正常关闭，然后它们将开始退出： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33135 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  一段时间后，只有新的工作进程才会处理请求： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>



<p>  应该注意的是，旧的主进程不会关闭其侦听套接字，并且可以管理它以在需要时再次启动其工作进程。  如果由于某种原因新的可执行文件无法接受，可以执行以下操作之一： </p>
<ul>
<li>将HUP信号发送到旧的主进程。  旧的主进程将启动新的工作进程，而无需重新读取配置。  之后，通过将QUIT信号发送到新的主进程，可以正常关闭所有新进程。 -   将TERM信号发送到新的主进程。  然后它会向其工作进程发送一条消息，要求它们立即退出，并且它们几乎都会立即退出。   （如果新进程由于某种原因没有退出，则应将KILL信号发送给它们以强制它们退出。）当新的主进程退出时，旧的主进程将自动启动新的进程进程。 </li>
</ul>
<p>  如果新的主进程退出，则旧的主进程将使用进程ID从文件名中丢弃<code>.oldbin</code>后缀。 </p>
<p>  如果升级成功，则应将QUIT信号发送到旧的主进程，并且只保留新进程： </p>
<pre class="notranslate">  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
36264     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
</pre>





]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[contributing_changes-nginx中文手册]]></title>
      <url>/ngx/contributing_changes.html</url>
      <content type="html"><![CDATA[<p>contributing_changes<br><a id="more"></a></p>
<h2 id="贡献变化"><a href="#贡献变化" class="headerlink" title="贡献变化"></a>贡献变化</h2><td align="left" class="notranslate"> <a href="#getting_sources">Getting Sources</a> <br> <a href="#formatting_changes">Formatting Changes</a> <br> <a href="#before_submitting">Before Submitting</a> <br> <a href="#submitting_changes">Submitting Changes</a> <br> <a href="#license">License</a> <br></td>

<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>   <a href="https://www.mercurial-scm.org" target="_blank" rel="noopener">Mercurial</a>用于存储源代码。  可以使用以下命令克隆<a href="http://hg.nginx.org/nginx" target="_blank" rel="noopener">存储库</a> ： </p>
<pre class="notranslate">hg clone http://hg.nginx.org/nginx
</pre>



<h4 id="格式化更改"><a href="#格式化更改" class="headerlink" title="格式化更改"></a>格式化更改</h4><p>  应根据nginx使用的<a href="dev/development_guide.html#code_style">代码样式</a>格式化更改。  有时，没有明确的规则;  在这种情况下，检查现有nginx源的格式并模仿这种风格。  如果样式与周围的代码相对应，则更有可能接受更改。 </p>
<p>  提交更改以创建Mercurial <a href="https://www.mercurial-scm.org/wiki/ChangeSet" target="_blank" rel="noopener">变更集</a> 。  请确保更改作者的指定<a href="https://www.mercurial-scm.org/wiki/QuickStart#Setting_a_username" target="_blank" rel="noopener">电子邮件</a>地址和真实姓名正确无误。 </p>
<p>  提交消息应该有一个单行的概要，后面跟一个空行后的详细描述。  希望第一行不超过67个符号。  可以使用<code>hg export</code>命令获取作为补丁的结果变更集： </p>
<pre class="notranslate"># HG changeset patch
# User Filipe Da Silva &lt;username@example.com&gt;
# Date 1368089668 -7200
#      Thu May 09 10:54:28 2013 +0200
# Node ID 2220de0521ca2c0b664a8ea1e201ce1cb90fd7a2
# Parent  822b82191940ef309cd1e6502f94d50d811252a1
Mail: removed surplus ngx_close_connection() call.

It is already called for a peer connection a few lines above.

diff -r 822b82191940 -r 2220de0521ca src/mail/ngx_mail_auth_http_module.c
--- a/src/mail/ngx_mail_auth_http_module.c      Wed May 15 15:04:49 2013 +0400
+++ b/src/mail/ngx_mail_auth_http_module.c      Thu May 09 10:54:28 2013 +0200
@@ -699,7 +699,6 @@ ngx_mail_auth_http_process_headers(ngx_m

                     p = ngx_pnalloc(s-&gt;connection-&gt;pool, ctx-&gt;err.len);
                     if (p == NULL) {
-                        ngx_close_connection(ctx-&gt;peer.connection);
                         ngx_destroy_pool(ctx-&gt;pool);
                         ngx_mail_session_internal_server_error(s);
                         return;
</pre>



<h4 id="在提交之前"><a href="#在提交之前" class="headerlink" title="在提交之前"></a>在提交之前</h4><p>  在提交更改之前，有几点值得考虑： </p>
<ul>
<li>建议的更改应适用于广泛的<a href="index.html#tested_os_and_platforms">受支持平台</a> 。 -   尽量明确为什么需要建议的更改，并尽可能提供用例。 </li><li>  通过测试套件传递更改是确保它们不会导致回归的好方法。  可以使用以下命令克隆包含测试的<a href="http://hg.nginx.org/nginx-tests" target="_blank" rel="noopener">存储库</a> ： <blockquote class="example"><pre class="notranslate">hg clone <a href="http://hg.nginx.org/nginx-tests" target="_blank" rel="noopener">http://hg.nginx.org/nginx-tests</a><br></pre></blockquote></li>
</ul>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>  建议的更改应发送到<a href="support.html#nginx_devel">nginx开发</a>邮件列表。  提交变更集的首选方便方法是使用<a href="https://www.mercurial-scm.org/wiki/PatchbombExtension" target="_blank" rel="noopener">patchbomb</a>扩展。 </p>
<h4 id="执照"><a href="#执照" class="headerlink" title="执照"></a>执照</h4><p>  提交更改意味着授予项目在相应<a href="LICENSE">许可</a>下使用它的权限。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[configure-nginx中文手册]]></title>
      <url>/ngx/configure.html</url>
      <content type="html"><![CDATA[<p>configure<br><a id="more"></a></p>
<h2 id="从Sources构建nginx"><a href="#从Sources构建nginx" class="headerlink" title="从Sources构建nginx"></a>从Sources构建nginx</h2><p>  使用<code>configure</code>命令配置构建。  它定义了系统的各个方面，包括允许nginx用于连接处理的方法。  最后它创建了一个<code>Makefile</code> 。 </p>
<p>   <code>configure</code>命令支持以下参数： </p>
<p>  参数用法示例（所有这些都需要在一行中输入）： </p>
<pre class="notranslate">./configure
    --sbin-path=/usr/local/nginx/nginx
    --conf-path=/usr/local/nginx/nginx.conf
    --pid-path=/usr/local/nginx/nginx.pid
    --with-http_ssl_module
    --with-pcre=../pcre-8.42
    --with-zlib=../zlib-1.2.11
</pre>



<p>  配置完成后，使用<code>make</code>编译和安装nginx。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compatibility-nginx中文手册]]></title>
      <url>/ngx/compatibility.html</url>
      <content type="html"><![CDATA[<p>compatibility<br><a id="more"></a></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><td align="left" class="notranslate"> <a href="#supported">What is currently supported</a> <br> <a href="#not_supported">What is not supported yet</a> <br></td>

<p>   njs是根据<a href="http://www.ecma-international.org/ecma-262/5.1/" target="_blank" rel="noopener">ECMAScript 5.1</a> （严格模式）创建的，带有一些<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript 6</a>及更高版本的扩展。  合规性仍在不断发展。 </p>
<h4 id="目前支持什么"><a href="#目前支持什么" class="headerlink" title="目前支持什么"></a>目前支持什么</h4><ul>
<li>布尔值，数字，字符串，对象，数组，函数和正则表达式 -    ES5.1运算符，ES7指数运算符 -    ES5.1语句： <code>var</code> ， <code>if</code> ， <code>else</code> ， <code>switch</code> ， <code>for</code> ， <code>for in</code> ， <code>while</code> ， <code>do while</code> ， <code>break</code> ， <code>continue</code> ， <code>return</code> ， <code>try</code> ， <code>catch</code> ， <code>throw</code> ， <code>finally</code> -    ES6 <code>Number</code>和<code>Math</code>属性和方法 -    <code>String</code>方法： <ul class="compact"><li>   ES5.1： <a href="reference.html#string_fromcharcode"><code>fromCharCode</code></a> ， <a href="reference.html#string_concat"><code>concat</code></a> ， <a href="reference.html#string_slice"><code>slice</code></a> ， <a href="reference.html#string_substring"><code>substring</code></a> ， <a href="reference.html#string_substr"><code>substr</code></a> ， <a href="reference.html#string_charat"><code>charAt</code></a> ， <a href="reference.html#string_indexof"><code>indexOf</code></a> ， <a href="reference.html#string_lastindexof"><code>lastIndexOf</code></a> ， <a href="reference.html#string_tolowercase"><code>toLowerCase</code></a> ， <a href="reference.html#string_touppercase"><code>toUpperCase</code></a> ， <a href="reference.html#string_trim"><code>trim</code></a> ， <a href="reference.html#string_search"><code>search</code></a> ， <a href="reference.html#string_match"><code>match</code></a> ， <a href="reference.html#string_split"><code>split</code></a> ， <a href="reference.html#string_replace"><code>replace</code></a> -    ES6： <a href="reference.html#string_fromcodepoint"><code>fromCodePoint</code></a> ， <a href="reference.html#string_codepointat"><code>codePointAt</code></a> ， <a href="reference.html#string_includes"><code>includes</code></a> ， <a href="reference.html#string_startswith"><code>startsWith</code></a> ， <a href="reference.html#string_endswith"><code>endsWith</code></a> ， <a href="reference.html#string_repeat"><code>repeat</code></a> -    ES8： <a href="reference.html#string_padstart"><code>padStart</code></a> ， <a href="reference.html#string_padend"><code>padEnd</code></a> -   非标准： <a href="reference.html#string_bytesfrom"><code>bytesFrom</code></a> （ <a href="reference.html#string_bytesfrom"><code>bytesFrom</code></a> ） <a href="reference.html#string_fromutf8"><code>fromUTF8</code></a> ， <a href="reference.html#string_toutf8"><code>toUTF8</code></a> ， <a href="reference.html#string_frombytes"><code>fromBytes</code></a> ， <a href="reference.html#string_tobytes"><code>toBytes</code></a> -    ES5.1： <code>create</code> （不带属性列表的支持）， <code>keys</code> ， <code>defineProperty</code> ， <code>defineProperties</code> ， <code>getOwnPropertyDescriptor</code> ， <code>getPrototypeOf</code> ， <code>hasOwnProperty</code> ， <code>isPrototypeOf</code> ， <code>preventExtensions</code> ， <code>isExtensible</code> ， <code>freeze</code> ， <code>isFrozen</code> ， <code>seal</code> ， <code>isSealed</code> -    ES5.1： <code>isArray</code> ， <code>slice</code> ， <code>splice</code> ， <code>push</code> ， <code>pop</code> ， <code>unshift</code> ， <code>shift</code> ， <code>reverse</code> ， <code>sort</code> ， <code>join</code> ， <code>concat</code> ， <code>indexOf</code> ， <code>lastIndexOf</code> ， <code>forEach</code> ， <code>some</code> ， <code>every</code> ， <code>filter</code> ， <code>map</code> ， <code>reduce</code> ， <code>reduceRight</code> -    ES6： <code>of</code> ， <code>fill</code> ， <code>find</code> ， <code>findIndex</code> -    ES7： <code>includes</code> </li>
</ul>
<h4 id="什么是不支持的"><a href="#什么是不支持的" class="headerlink" title="什么是不支持的"></a>什么是不支持的</h4><ul>
<li>ES6 <code>let</code>和<code>const</code>声明 -   标签 -    <code>eval</code>功能 -    <code>new Function()</code>构造函数 -    <code>setInterval</code> ， <code>setImmediate</code>函数 </li>
</ul>
</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[changes-nginx中文手册]]></title>
      <url>/ngx/changes.html</url>
      <content type="html"><![CDATA[<p>changes<br><a id="more"></a></p>
<h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><h4 id="变化为0-2-6"><a href="#变化为0-2-6" class="headerlink" title="变化为0.2.6"></a>变化为0.2.6</h4><p>  发布日期：2018年11月27日 </p>
<p>  核心： </p>
<ul>
<li>特点：使内置原型可变。 -   特征：使全局对象变得可变。 -   功能： <code>console.time()</code>和<code>console.timeEnd()</code>方法。 -   功能：允许重新声明变量和函数。 -   功能：扩展<code>Object.defineProperty()</code>规范一致性。 -   功能：为CLI引入安静模式以处理来自stdin的简单表达式。 -   特点：引入紧凑形式的回溯来处理堆栈溢出。 -   改进：改进各种例外的措辞。 -   修正：修复闭包值处理。 -   修正：各种值类型的固定相等运算符。 -   修正：修复了各种范围内“this”关键字的处理。 -   修正：修复了<code>Object.keys()</code>处理非对象值的问题。 -   修正：在<code>if</code>语句中修复了throw语句的解析。 -   修正：修复throw语句后的换行符。 -   修正：修复if语句中没有换行符的语句解析。 -   修正： <code>njs_array_expand()</code>固定大小<code>uint32_t</code>溢出。 -   修正： <code>object_value</code>类型的固定<code>typeof</code>运算符。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-5"><a href="#变化为0-2-5" class="headerlink" title="变化为0.2.5"></a>变化为0.2.5</h4><p>  发布日期：2018年10月30日 </p>
<p>   nginx模块： </p>
<ul>
<li>修正：在流模块中修复计数待处理事件。 -   修正：修复了流模块中的<code>s.off()</code> 。 -   修正：修复了流模块中<code>js_filter</code>中数据块的处理。 -   修正：在http模块中修复了http <code>status</code>和<code>contentType</code> getter。 -   修正：在http模块中修复了http响应和父getter。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：参数对象支持。 -   特征：非整数分数支持。 -   改进：处理<code>Array.prototype.slice()</code>非数组值。 -   修正：修复了<code>Array.prototype.length</code> setter -   修正：固定<code>njs_array_alloc()</code> ，长度&gt; 2 ** 31。 -   修正：处理32位<code>njs_array_alloc()</code>上的<code>njs_array_alloc()</code> int溢出。 -   修正：修复代码大小不匹配错误消息。 -   修正：修复循环中的删除操作符。 -   修正：修复了复杂对象的<code>Object.getOwnPropertyDescriptor()</code> （继承自<code>Array</code>和<code>string</code>值）。 -   修正：修复了非对象属性的<code>Object.prototype.hasOwnProperty()</code> -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-4"><a href="#变化为0-2-4" class="headerlink" title="变化为0.2.4"></a>变化为0.2.4</h4><p>  发布日期：2018年9月18日 </p>
<p>   nginx模块： </p>
<ul>
<li>更改：重构的流模块处理程序。   新方法和属性： <a href="reference.html#s_on">s.on（）</a> ， <a href="reference.html#s_off">s.off（）</a> ， <a href="reference.html#s_allow">s.allow（）</a> ， <a href="reference.html#s_done">s.done（）</a> ， <a href="reference.html#s_decline">s.decline（）</a> ， <a href="reference.html#s_deny">s.deny（）</a> 。   删除了<a href="reference.html#stream">Stream</a>对象的属性： <code>s.OK</code> ， <code>s.ABORT</code> ， <code>s.AGAIN</code> ， <code>s.DECLINED</code> ， <code>s.ERROR</code> （替换为<a href="reference.html#s_allow">s.allow（）</a> ， <a href="reference.html#s_done">s.done（）</a> ， <a href="reference.html#s_deny">s.deny（）</a> ）。    <code>s.buffer</code> （用于读取替换为相应回调的数据参数，用于写入使用<a href="reference.html#s_send">s.send（）</a> ）。    <code>s.fromUpstream</code> （替换为相应事件的回调）。    <code>s.eof</code> （替换为 ``   <a href="reference.html#s_on_callback_last">flags.last</a> ）。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：添加了<code>Function.prototype.length</code> 。 -   功能：介绍沙盒模式。 -   改进：适当时添加异常字符串。 -   改进：改进了原始类型转换异常的措辞。 -   修正：为尝试更改冻结属性而抛出<code>TypeError</code> 。 -   修正：修复现有属性的<code>Object.defineProperty()</code> 。 -   修正：在for for迭代时尊重可枚举属性。 -   修正：尊重属性处理程序的可写属性。 -   修正：修复了函数参数中的异常处理。 -   修正：修复了不同值类型的<code>Object.prototype.toString</code> 。 -   修正：修复了对象类型参数的<code>Object()</code>构造函数。 -   修正：固定对象和字符串的比较。 -   修正：修复了未定义参数的<code>String.slice()</code> 。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-3"><a href="#变化为0-2-3" class="headerlink" title="变化为0.2.3"></a>变化为0.2.3</h4><p>  发布日期：2018年7月31日 </p>
<p>   nginx模块： </p>
<ul>
<li>修正：从<code>Reply</code>对象进行子请求导致分段错误。 -   修正：获取主<a href="reference.html#http">HTTP Request</a>对象的parent属性导致了分段错误。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：为值添加了漂亮的字符串表示。 -   功能：正确打印浮点数。 -   功能：正确解析浮点数。 -   功能： <a href="reference.html#string_bytesfrom">String.bytesFrom（）</a>方法（将<code>hex</code> ， <code>base64</code> ， <code>base64url</code>解码为字节字符串）。 -   功能： <a href="reference.html#string_padstart">String.padStart（）</a>和<a href="reference.html#string_padend">String.padEnd（）</a>方法。 -   功能：增加了对二进制文字的支持。 -   改进：在数字解析中添加有关非法令牌的信息。 -   改进：允许在八进制文字值中使用大写字母<code>O</code> -   改进：在<code>console.log()</code>添加了对多个参数的支持。 -   修正：修复了将<code>call()</code>应用于外部值的方法。 -   修正：应用于对象的固定加法运算符。 -   修正：在<code>njs_vm_value_to_ext_string()</code>修复异常处理。 -   修正：使用布尔，null和未定义的参数修复<code>Number()</code> 。 -   修正：修复了设置非数字<code>Array.length</code>错误处理。 -   修正：修复全局对象的自动完成。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-2"><a href="#变化为0-2-2" class="headerlink" title="变化为0.2.2"></a>变化为0.2.2</h4><p>  发布日期：2018年6月19日 </p>
<p>   nginx模块： </p>
<ul>
<li>更改：合并HTTP <code>Response</code>和<code>Reply</code>到<a href="reference.html#http">HTTP请求</a> 。  新成员<code>Request</code> ： <ul class="compact"><li>   <code>req.status</code> （ <code>res.status</code> ） -    <code>req.parent</code> （ <code>reply.parent</code> ） -    <code>req.requestBody</code> （ <code>req.body</code> ） -    <code>req.responseBody</code> （ <code>reply.body</code> ） -    <code>req.headersIn</code> （ <code>req.headers</code> ） -    <code>req.headersOut</code> （ <code>res.headers</code> ） -    <code>req.sendHeader()</code> （ <code>res.sendHeader()</code> ） -    <code>req.send()</code> （ <code>res.send()</code> ） -    <code>req.finish()</code> （ <code>res.finish()</code> ） -    <code>req.return()</code> （ <code>res.return()</code> ）<br>弃用的<code>Request</code>成员： </li>
<li><p><code>req.body</code> （使用<code>req.requestBody</code>或<code>req.responseBody</code> ） -    <code>req.headers</code> （使用<code>req.headersIn</code>或<code>req.headersOut</code> ） -  <code>req.response</code><br>已弃用的属性将在下一版本中删除。 </p>
<p>功能：HTTP <a href="reference.html#r_internal_redirect">internalRedirect（）</a>方法。 </p>
</li>
</ul>
<p>  核心： </p>
<ul>
<li>修正：在<code>crypto.createHmac()</code>修复了heap-buffer-overflow。 </li>
</ul>
<h4 id="变化为0-2-1"><a href="#变化为0-2-1" class="headerlink" title="变化为0.2.1"></a>变化为0.2.1</h4><p>  发布日期：2018年5月31日 </p>
<p>   nginx模块： </p>
<ul>
<li>功能：HTTP请求正文getter。 -   改进：将njs vm移动到<code>main</code>配置。 -   改进：改进了<a href="http/ngx_http_js_module.html#js_set">js_set</a>和<a href="http/ngx_http_js_module.html#js_content">js_content</a>指令的日志记录。 -   改进：在<a href="http/ngx_http_js_module.html#js_content">js_content</a>处理程序中默认将状态代码设置为500 -   改进：在<a href="http/ngx_http_js_module.html#js_content">js_content</a>处理程序中添加了返回状态代码的调试 -   修正：修复了<a href="http/ngx_http_js_module.html#js_include">js_include中的</a>错误记录。 </li>
</ul>
<p>  核心： </p>
<ul>
<li>功能：添加了数组长度设置器。 -   改进：公共标头<code>cleanup. njscript.h</code>   <code>cleanup. njscript.h</code>重命名为<code>njs.h</code> -   修正：调用<code>digest()</code>后修复了crypto <code>update()</code>方法。 -   修正：修复了大小&lt;= alg size&gt; 64的密钥的<code>crypto.createHmac()</code> 。 -   修正：修复了带空单元格的数组的<code>JSON.stringify()</code> 。 -   修正：修复了<code>JSON.stringify()</code>不支持的类型的异常类型。 -   修正：修复了函数未定义参数的处理。 -   修正：修复了对<code>Object.getOwnPropertyDescriptor()</code>缺失<code>arg</code>的处理。 -   修正：修复了<code>Object.getOwnPropertyDescriptor()</code>中属性的处理。 -   修正：修复了<code>Array.length</code>属性的可写标志。 -   修正： <code>clearTimeout()</code>固定返回值类型。 -   修正：修复了<code>njs_vm_external_bind()</code> 。 -   修正：修复了各种其他错误。 </li>
</ul>
<h4 id="变化为0-2-0"><a href="#变化为0-2-0" class="headerlink" title="变化为0.2.0"></a>变化为0.2.0</h4><p>  发布日期：2018年4月3日 </p>
<ul>
<li>功能：通过CLI报告njs版本。 -   功能：转换异常的类型的文本描述。 -   功能： <code>setTimeout()</code>和<code>clearTimeout()</code>方法。 -   功能：字节字符串为<code>hex</code> ， <code>base64</code> ， <code>base64url</code>编码。 -   功能： <a href="https://nodejs.org/api/crypto.html#crypto_class_hash" target="_blank" rel="noopener">Node.js样式</a> <code>Crypto</code>方法。 -   功能：HTTP和流<code>warn()</code>和<code>error()</code>方法。 -   功能：HTTP <code>subrequest()</code>方法。 -   功能：HTTP <code>return()</code>方法。 -   修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-15"><a href="#变化0-1-15" class="headerlink" title="变化0.1.15"></a>变化0.1.15</h4><p>  发布日期：2017年11月20日 </p>
<ul>
<li>功能： <code>Error</code> ， <code>EvalError</code> ， <code>InternalError</code> ， <code>RangeError</code> ， <code>ReferenceError</code> ， <code>SyntaxError</code> ， <code>TypeError</code> ， <code>URIError</code>对象。 -   功能：八进制文字支持。 -   功能： <a href="https://nodejs.org/api/fs.html#fs_file_system" target="_blank" rel="noopener">Node.js样式</a> <code>File system</code>访问方法： <code>fs.readFile()</code> ， <code>fs.readFileSync()</code> ， <code>fs.appendFile()</code> ， <code>fs.appendFileSync()</code> ， <code>fs.writeFile()</code> ， <code>fs.writeFileSync()</code> 。 -   功能：nginx模块在异常时打印回溯。 -   修正：杂项错误已得到修复。 </li>
</ul>
<h4 id="变化0-1-14"><a href="#变化0-1-14" class="headerlink" title="变化0.1.14"></a>变化0.1.14</h4><p>  发布日期：2017年10月9日 </p>
<ul>
<li>功能：JSON对象。 -   功能：交互式shell中的对象级完成。 -   功能：各种配置改进。 -   修正：核心和交互式shell中修复了各种错误。 </li>
</ul>
<h4 id="变化0-1-13"><a href="#变化0-1-13" class="headerlink" title="变化0.1.13"></a>变化0.1.13</h4><p>  发布日期：2017年8月31日 </p>
<ul>
<li>功能：交互式shell中的<code>console.log()</code>和<code>console.help()</code>方法。 -   功能：交互式shell在异常时打印回溯。 -   功能：如果<code>libedit</code>可用，默认情况下为交互式shell。 -   修正：在命令行模式下从<code>stdin</code>处理大文件。 -   修正：改进了<code>editline</code>检测。 </li>
</ul>
<h4 id="变化0-1-12"><a href="#变化0-1-12" class="headerlink" title="变化0.1.12"></a>变化0.1.12</h4><p>  发布日期：2017年8月8日 </p>
<ul>
<li>功能：交互式shell。 -   修正：在<code>Object.isSealed()</code> 。 </li>
</ul>
<h4 id="0-1-11的变化"><a href="#0-1-11的变化" class="headerlink" title="0.1.11的变化"></a>0.1.11的变化</h4><p>  发行日期：2017年6月27日 </p>
<ul>
<li>功能： <code>Object.keys()</code> ， <code>Object.prototype.hasOwnProperty()</code>方法。 -   功能： <code>Object.defineProperty()</code> ， <code>Object.defineProperties()</code> ， <code>Object.getOwnPropertyDescriptor()</code>方法。 -   功能： <code>Object.getPrototypeOf()</code> ， <code>Object.prototype.isPrototypeOf()</code>方法。 -   功能： <code>Object.preventExtensions()</code> ， <code>Object.isExtensible()</code> ， <code>Object.freeze()</code> ， <code>Object.isFrozen()</code> ， <code>Object.seal()</code> ， <code>Object.isSealed()</code>方法。 -   特征：科学记数法（ <code>3.35e10</code> ）文字支持。 -   功能：十六进制（ <code>0x1123</code> ）文字支持。 -   修正：处理大型数组索引。 -   修正：在<code>parseInt()</code>和<code>Date.parse()</code> 。 </li>
</ul>
<h4 id="变化0-1-10"><a href="#变化0-1-10" class="headerlink" title="变化0.1.10"></a>变化0.1.10</h4><p>  发行日期：2017年4月4日 </p>
<ul>
<li>功能：嵌套函数和函数闭包。 -   功能： <code>Array.of()</code> ， <code>Array.prototype.fill()</code> ， <code>Array.prototype.find()</code> ， <code>Array.prototype.findIndex()</code>方法。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-9"><a href="#变化0-1-9" class="headerlink" title="变化0.1.9"></a>变化0.1.9</h4><p>  发布日期：2017年2月1日 </p>
<ul>
<li>修正：在nginx中使用njs时，未初始化全局变量。 </li>
</ul>
<h4 id="变化0-1-8"><a href="#变化0-1-8" class="headerlink" title="变化0.1.8"></a>变化0.1.8</h4><p>  发布日期：2017年1月24日 </p>
<ul>
<li>更改：强制执行<code>strict</code>模式，必须显式声明变量。 -   功能： <code>for</code>和<code>for-in</code>循环支持变量声明。 -   修正：全局和功能范围已得到修复。 -   修正：现在<code>for-in</code>循环不会丢弃属性变量的最后一个值。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-7"><a href="#变化0-1-7" class="headerlink" title="变化0.1.7"></a>变化0.1.7</h4><p>  发布日期：2016年12月27日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用<a href="http/ngx_http_js_module.html#js_include">js_include</a>指令。 -   特征：取幂运算符。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
<h4 id="变化0-1-6"><a href="#变化0-1-6" class="headerlink" title="变化0.1.6"></a>变化0.1.6</h4><p>  发布日期：2016年12月13日 </p>
<ul>
<li>更改：已在服务器和位置级别禁用<a href="http/ngx_http_js_module.html#js_set">js_set</a>指令。 -   特征：ES6 <code>Math</code>方法。 -   修正：修复了各种错误和分段错误。 </li>
</ul>
</li></ul>]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[beginners_guide-nginx中文手册]]></title>
      <url>/ngx/beginners_guide.html</url>
      <content type="html"><![CDATA[<p>beginners_guide<br><a id="more"></a></p>
<h2 id="初学者指南"><a href="#初学者指南" class="headerlink" title="初学者指南"></a>初学者指南</h2><td align="left" class="notranslate"> <a href="#control">Starting, Stopping, and Reloading Configuration</a> <br> <a href="#conf_structure">Configuration File’s Structure</a> <br> <a href="#static">Serving Static Content</a> <br> <a href="#proxy">Setting Up a Simple Proxy Server</a> <br> <a href="#fastcgi">Setting Up FastCGI Proxying</a> <br></td>

<p>  本指南提供了对nginx的基本介绍，并介绍了可以使用它完成的一些简单任务。  据推测，nginx已安装在阅读器的机器上。  如果不是，请参阅<a href="install.html">安装nginx</a>页面。  本指南介绍如何启动和停止nginx，重新加载其配置，解释配置文件的结构，并介绍如何设置nginx以提供静态内容，如何将nginx配置为代理服务器，以及如何将其与一个FastCGI应用程序。 </p>
<p>   nginx有一个主进程和几个工作进程。  主进程的主要目的是读取和评估配置，并维护工作进程。  工作进程会对请求进行实际处理。   nginx使用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分发请求。  工作进程数在配置文件中定义，可以针对给定配置进行修复，也可以自动调整为可用CPU内核数（请参阅<a href="ngx_core_module.html#worker_processes">worker_processes</a> ）。 </p>
<p>   nginx及其模块的工作方式在配置文件中确定。  默认情况下，配置文件名为<code>nginx.conf</code>并放在目录<code>/usr/local/nginx/conf</code> ， <code>/etc/nginx</code>或<code>/usr/local/etc/nginx</code> 。 </p>
<h4 id="启动，停止和重新加载配置"><a href="#启动，停止和重新加载配置" class="headerlink" title="启动，停止和重新加载配置"></a>启动，停止和重新加载配置</h4><p>  要启动nginx，请运行可执行文件。  启动nginx后，可以通过使用<code>-s</code>参数调用可执行文件来控制它。  使用以下语法： </p>
<pre class="notranslate">nginx -s *signal*
</pre>

<p>   <em>信号</em>可能是以下之一： </p>
<ul>
<li><code>stop</code> - 快速关机 -    <code>quit</code> - 正常关机 -    <code>reload</code> - 重新加载配置文件 -    <code>reopen</code> - 重新打开日志文件<br>例如，要在等待工作进程完成当前请求的服务时停止nginx进程，可以执行以下命令： </li>
</ul>
<pre class="notranslate">nginx -s quit
</pre>



<blockquote>
<p>  此命令应在启动nginx的同一用户下执行。 </p>
</blockquote>
<p>  在将重新加载配置的命令发送到nginx或重新启动之前，将不会应用配置文件中所做的更改。  要重新加载配置，请执行： </p>
<pre class="notranslate">nginx -s reload
</pre>



<p>  一旦主进程收到重新加载配置的信号，它将检查新配置文件的语法有效性并尝试应用其中提供的配置。  如果成功，主进程将启动新的工作进程并向旧工作进程发送消息，请求它们关闭。  否则，主进程将回滚更改并继续使用旧配置。  旧工作进程，接收命令关闭，停止接受新连接并继续为当前请求提供服务，直到所有此类请求都得到服务。  之后，旧工作进程退出。 </p>
<p>  也可以借助Unix工具（如<code>kill</code>实用程序）将信号发送到nginx进程。  在这种情况下，信号直接发送到具有给定进程ID的进程。  默认情况下，nginx主进程的进程ID写入目录<code>/usr/local/nginx/logs</code>或<code>/var/run</code>的<code>nginx.pid</code> 。  例如，如果主进程ID是1628，要发送导致nginx正常关闭的QUIT信号，请执行： </p>
<pre class="notranslate">kill -s QUIT 1628
</pre>

<p>  要获取所有正在运行的nginx进程的列表，可以使用<code>ps</code>实用程序，例如，通过以下方式： </p>
<pre class="notranslate">ps -ax | grep nginx
</pre>

<p>  有关向nginx发送信号的更多信息，请参阅<a href="control.html">控制nginx</a> 。 </p>
<h4 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h4><p>   nginx由模块组成，这些模块由配置文件中指定的指令控制。  指令分为简单指令和块指令。  一个简单的指令包括由空格分隔的名称和参数，以分号（ <code>;</code> ）结尾。  块指令与简单指令具有相同的结构，但它不是以分号结尾，而是以大括号（ <code>{</code>和<code>}</code> ）包围的一组附加指令结束。  如果块指令可以在大括号内包含其他指令，则称为上下文（示例： <a href="ngx_core_module.html#events">events</a> ， <a href="http/ngx_http_core_module.html#http">http</a> ， <a href="http/ngx_http_core_module.html#server">server</a>和<a href="http/ngx_http_core_module.html#location">location</a> ）。 </p>
<p>  放置在任何上下文之外的配置文件中的指令被认为是在<a href="ngx_core_module.html">主</a>上下文中。   <code>events</code>和<code>http</code>指令驻留在<code>main</code>上下文中， <code>server</code>位于<code>http</code> ，位于<code>server</code> 。 </p>
<p>   <code>#</code>符号后面的其余部分被视为评论。 </p>
<h4 id="提供静态内容"><a href="#提供静态内容" class="headerlink" title="提供静态内容"></a>提供静态内容</h4><p>  一个重要的Web服务器任务是提供文件（例如图像或静态HTML页面）。  您将实现一个示例，根据请求，将从不同的本地目录提供文件： <code>/data/www</code> （可能包含HTML文件）和<code>/data/images</code> （包含图像）。  这将需要编辑配置文件并在<a href="http/ngx_http_core_module.html#http">http</a>块内设置具有两个<a href="http/ngx_http_core_module.html#location">位置</a>块的<a href="http/ngx_http_core_module.html#server">服务器</a>块。 </p>
<p>  首先，创建<code>/data/www</code>目录并将包含任何文本内容的<code>index.html</code>文件放入其中，然后创建<code>/data/images</code>目录并在其中放置一些图像。 </p>
<p>  接下来，打开配置文件。  默认配置文件已包含几个<code>server</code>块的示例，主要是注释掉的。  现在注释掉所有这些块并启动一个新的<code>server</code>块： </p>
<pre class="notranslate">http {
    server {
    }
}
</pre>

<p>  通常，配置文件可以包括由它们<a href="http/ngx_http_core_module.html#listen">监听</a>的端口和<a href="http/server_names.html">服务器名称</a> <a href="http/request_processing.html">区分</a>的多个<code>server</code>块。  一旦nginx决定哪个<code>server</code>处理请求，它就会根据<code>server</code>块内定义的<code>location</code>指令的参数测试请求头中指定的URI。 </p>
<p>  将以下<code>location</code>块添加到<code>server</code>块： </p>
<pre class="notranslate">location / {
    root /data/www;
}
</pre>

<p>  此<code>location</code>块指定与请求中的URI进行比较的“ <code>/</code> ”前缀。  对于匹配请求，URI将添加到<a href="http/ngx_http_core_module.html#root">根</a>指令中指定的路径，即<code>/data/www</code> ，以形成本地文件系统上所请求文件的路径。  如果存在多个匹配的<code>location</code>块，则nginx选择具有最长前缀的<code>location</code>块。  上面的<code>location</code>块提供长度为1的最短前缀，因此仅当所有其他<code>location</code>块无法提供匹配时，才会使用此块。 </p>
<p>  接下来，添加第二个<code>location</code>块： </p>
<pre class="notranslate">location /images/ {
    root /data;
}
</pre>

<p>  它将匹配以<code>/images/</code>开头的请求（ <code>location /</code>也匹配此类请求，但前缀较短）。 </p>
<p>  生成的<code>server</code>块配置应如下所示： </p>
<pre class="notranslate">server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
</pre>

<p>  这已经是服务器的工作配置，它可以侦听标准端口80，并且可以在本地计算机上访问<code>http://localhost/</code> 。  响应具有以<code>/images/</code>开头的URI的请求，服务器将从<code>/data/images</code>目录发送文件。  例如，响应<code>http://localhost/images/example.png</code>请求，nginx将发送<code>/data/images/example.png</code>文件。  如果此类文件不存在，nginx将发送指示404错误的响应。   URI不以<code>/images/</code>开头的请求将映射到<code>/data/www</code>目录。  例如，响应<code>http://localhost/some/example.html</code>请求，nginx将发送<code>/data/www/some/example.html</code>文件。 </p>
<p>  要应用新配置，请启动nginx（如果尚未启动）或通过执行以下命令将<code>reload</code>信号发送到nginx的主进程： </p>
<pre class="notranslate">nginx -s reload
</pre>





<blockquote>
<p>  如果某些内容无法按预期工作，您可以尝试在目录<code>/usr/local/nginx/logs</code>或<code>/var/log/nginx</code>中的<code>access.log</code>和<code>error.log</code>文件中找出原因。 </p>
</blockquote>
<h4 id="设置简单的代理服务器"><a href="#设置简单的代理服务器" class="headerlink" title="设置简单的代理服务器"></a>设置简单的代理服务器</h4><p>   nginx的一个常见用途是将其设置为代理服务器，这意味着服务器接收请求，将它们传递给代理服务器，从中检索响应，然后将它们发送给客户端。 </p>
<p>  我们将配置一个基本代理服务器，它使用来自本地目录的文件处理图像请求，并将所有其他请求发送到代理服务器。  在此示例中，将在单个nginx实例上定义两个服务器。 </p>
<p>  首先，通过向nginx的配置文件添加一个以上的<code>server</code>块来定义代理服务器，其中包含以下内容： </p>
<pre class="notranslate">server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
</pre>

<p>  这将是一个侦听端口8080的简单服务器（之前，自使用标准端口80以来尚未指定<code>listen</code>指令）并将所有请求映射到本地文件系统上的<code>/data/up1</code>目录。  创建此目录并将<code>index.html</code>文件放入其中。  请注意， <code>root</code>指令放在<code>server</code>上下文中。  当选择用于提供请求的<code>location</code>块不包括自己的<code>root</code>指令时，使用这样的<code>root</code>指令。 </p>
<p>  接下来，使用上一节中的服务器配置并对其进行修改以使其成为代理服务器配置。  在第一个<code>location</code>块中，将<a href="http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>指令与参数中指定的代理服务器的协议，名称和端口放在一起（在我们的示例中，它是<code>http://localhost:8080</code> ）： </p>
<pre class="notranslate">server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
</pre>



<p>  我们将修改第二个<code>location</code>块，该块当前将带有<code>/images/</code>前缀的请求映射到<code>/data/images</code>目录下的文件，以使其与具有典型文件扩展名的图像请求相匹配。  修改后的<code>location</code>块如下所示： </p>
<pre class="notranslate">location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
</pre>

<p>  该参数是一个正则表达式，匹配以<code>.gif</code> ， <code>.jpg</code>或<code>.png</code>结尾的所有URI。  正则表达式应该以<code>~</code> 。  相应的请求将映射到<code>/data/images</code>目录。 </p>
<p>  当nginx选择一个<code>location</code>块来提供请求时，它首先检查指定前缀的<a href="http/ngx_http_core_module.html#location">位置</a>指令，记住具有最长前缀的<code>location</code> ，然后检查正则表达式。  如果与正则表达式匹配，则nginx选择此<code>location</code> ，否则，它会选择之前记住的那个。 </p>
<p>  生成的代理服务器配置如下所示： </p>
<pre class="notranslate">server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre>

<p>  此服务器将过滤以<code>.gif</code> ， <code>.jpg</code>或<code>.png</code>结尾的请求，并将它们映射到<code>/data/images</code>目录（通过将URI添加到<code>root</code>指令的参数），并将所有其他请求传递给上面配置的代理服务器。 </p>
<p>  要应用新配置，请将<code>reload</code>信号发送到nginx，如前面部分所述。 </p>
<p>  可以使用<a href="http/ngx_http_proxy_module.html">更多</a>指令来进一步配置代理连接。 </p>
<h4 id="设置FastCGI代理"><a href="#设置FastCGI代理" class="headerlink" title="设置FastCGI代理"></a>设置FastCGI代理</h4><p>   nginx可用于将请求路由到FastCGI服务器，这些服务器运行使用各种框架和编程语言（如PHP）构建的应用程序。 </p>
<p>  使用FastCGI服务器的最基本的nginx配置包括使用<a href="http/ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>指令而不是<code>proxy_pass</code>指令，以及<a href="http/ngx_http_fastcgi_module.html#fastcgi_param">fastcgi_param</a>指令来设置传递给FastCGI服务器的参数。  假设可以在<code>localhost:9000</code>上访问FastCGI服务器。  以上一节中的代理配置为基础，将<code>proxy_pass</code>指令替换为<code>fastcgi_pass</code>指令，并将参数更改为<code>localhost:9000</code> 。  在PHP中， <code>SCRIPT_FILENAME</code>参数用于确定脚本名称， <code>QUERY_STRING</code>参数用于传递请求参数。  结果配置为： </p>
<pre class="notranslate">server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
</pre>

<p>  这将设置一个服务器，该服务器将除静态图像请求之外的所有请求路由到通过FastCGI协议在<code>localhost:9000</code>上运行的代理服务器。 </p>
]]></content>
      
        <categories>
            
            <category> nginx中文手册 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm学习]]></title>
      <url>/java/JVM%E5%AD%A6%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<p>JVM Java Virtual Machine (java虚拟机)</p>
<a id="more"></a>
<h1 id="JDK8-以后-Hotspot-JRockit-优秀特性"><a href="#JDK8-以后-Hotspot-JRockit-优秀特性" class="headerlink" title="JDK8 以后 Hotspot+JRockit 优秀特性"></a>JDK8 以后 Hotspot+JRockit 优秀特性</h1>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[guava教程]]></title>
      <url>/java/guava%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>guava教程</p>
<blockquote>
<p>guava谷歌出品,高效工具类<br>目标：节约时间，资源，提高生产力  Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<br>集合 [collections]<br>缓存 [caching]<br>原生类型支持 [primitives support]<br>并发库 [concurrency libraries]<br>通用注解 [common annotations]<br>字符串处理 [string processing]<br>I/O 等等<br><a id="more"></a></p>
</blockquote>
<h1 id="集合的创建-可变，不可变"><a href="#集合的创建-可变，不可变" class="headerlink" title="集合的创建, 可变，不可变"></a>集合的创建, 可变，不可变</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 普通Collection的创建</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">// 不变Collection的创建</span><br><span class="line">ImmutableList&lt;String&gt; iList = ImmutableList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(&quot;e1&quot;, &quot;e2&quot;);</span><br><span class="line">ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;);</span><br><span class="line"></span><br><span class="line">immutable(不可变)对象</span><br><span class="line">1.在多线程操作下，是线程安全的。</span><br><span class="line">2.所有不可变集合会比可变集合更有效的利用资源。</span><br><span class="line">3.中途不可改变</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList(&quot;Richard&quot;, &quot;Amy&quot;, &quot;Lily&quot;, &quot;Sarah&quot;);</span><br><span class="line">List&lt;Integer&gt; numbers = Lists.newArrayList(11, 78, 89, 45, 30);</span><br><span class="line">//创建加初始化</span><br></pre></td></tr></table></figure>
<h2 id="特殊的数据类型"><a href="#特殊的数据类型" class="headerlink" title="特殊的数据类型"></a>特殊的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单</span><br><span class="line">创建方式:  Multiset&lt;String&gt; set = HashMultiset.create();</span><br><span class="line">Multimap: key-value  key可以重复  </span><br><span class="line">创建方式: Multimap&lt;String, String&gt; teachers = ArrayListMultimap.create();</span><br><span class="line">BiMap: 双向Map(Bidirectional Map) 键与值都不能重复</span><br><span class="line">创建方式:  BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">Table: 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  //和sql中的联合主键有点像</span><br><span class="line">创建方式: Table&lt;String, String, Integer&gt; tables = HashBasedTable.create();</span><br></pre></td></tr></table></figure>
<h1 id="集合转字符串"><a href="#集合转字符串" class="headerlink" title="集合转字符串"></a>集合转字符串</h1><h2 id="list-转字符串"><a href="#list-转字符串" class="headerlink" title="list 转字符串"></a>list 转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for(int i=0; i&lt;list.size(); i++)&#123;</span><br><span class="line">	str = str + &quot;-&quot; +list.get(i);</span><br><span class="line">&#125;</span><br><span class="line">//str 为-aa-bb-cc</span><br><span class="line">//use guava</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String result = Joiner.on(&quot;-&quot;).join(list);</span><br><span class="line">//result为  aa-bb-cc</span><br></pre></td></tr></table></figure>
<h2 id="map转字符串"><a href="#map转字符串" class="headerlink" title="map转字符串"></a>map转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(&quot;xiaoming&quot;, 12);</span><br><span class="line">map.put(&quot;xiaohong&quot;,13);</span><br><span class="line">String result = Joiner.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).join(map);</span><br><span class="line">// result为 xiaoming=12,xiaohong=13</span><br></pre></td></tr></table></figure>
<h1 id="字符串转集合"><a href="#字符串转集合" class="headerlink" title="字符串转集合"></a>字符串转集合</h1><h2 id="字符串转list"><a href="#字符串转list" class="headerlink" title="字符串转list"></a>字符串转list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">String a = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">String[] strs = a.split(&quot;-&quot;);</span><br><span class="line">for(int i=0; i&lt;strs.length; i++)&#123;</span><br><span class="line">	list.add(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//use guava</span><br><span class="line">String str = &quot;1-2-3-4-5-6&quot;;</span><br><span class="line">List&lt;String&gt; list = Splitter.on(&quot;-&quot;).splitToList(str);</span><br><span class="line">//list为  [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h2 id="字符串转map"><a href="#字符串转map" class="headerlink" title="字符串转map"></a>字符串转map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;xiaoming=11,xiaohong=23&quot;;</span><br><span class="line">Map&lt;String,String&gt; map = Splitter.on(&quot;,&quot;).withKeyValueSeparator(&quot;=&quot;).split(str);</span><br></pre></td></tr></table></figure>
<h1 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;aa.dd,,ff,,.&quot;;</span><br><span class="line">List&lt;String&gt; result = Splitter.onPattern(&quot;[.|,]&quot;).omitEmptyStrings().splitToList(input);</span><br></pre></td></tr></table></figure>
<h1 id="差集合集并集"><a href="#差集合集并集" class="headerlink" title="差集合集并集"></a>差集合集并集</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashSet setA = newHashSet(1, 2, 3, 4, 5);  </span><br><span class="line">HashSet setB = newHashSet(4, 5, 6, 7, 8);  </span><br><span class="line">   </span><br><span class="line">SetView union = Sets.union(setA, setB);  </span><br><span class="line">System.out.println(&quot;union:&quot;);  </span><br><span class="line">for (Integer integer : union)  </span><br><span class="line">    System.out.println(integer);           //union:12345867</span><br><span class="line">   </span><br><span class="line">SetView difference = Sets.difference(setA, setB);  </span><br><span class="line">System.out.println(&quot;difference:&quot;);  </span><br><span class="line">for (Integer integer : difference)  </span><br><span class="line">    System.out.println(integer);        //difference:123</span><br><span class="line">   </span><br><span class="line">SetView intersection = Sets.intersection(setA, setB);  </span><br><span class="line">System.out.println(&quot;intersection:&quot;);  </span><br><span class="line">for (Integer integer : intersection)  </span><br><span class="line">    System.out.println(integer);  //intersection:45</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapDifference differenceMap = Maps.difference(mapA, mapB);  </span><br><span class="line">differenceMap.areEqual();  </span><br><span class="line">Map entriesDiffering = differenceMap.entriesDiffering();  </span><br><span class="line">Map entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();  </span><br><span class="line">Map entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();  </span><br><span class="line">Map entriesInCommon = differenceMap.entriesInCommon();</span><br></pre></td></tr></table></figure>
<h1 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">       CharSource charSource = Resources.asByteSource(url).asCharSource(StandardCharsets.UTF_8);</span><br><span class="line">       charSource.readLines().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> guava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot常用的注解]]></title>
      <url>/spring-boot/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot 常用的注解<br><a id="more"></a></p>
<blockquote>
<p>@PropertySource(value = “classpath:test.properties”) 加载配置文件<br>@ConfigurationProperties(prefix=”spring”) 提取前缀<br>@ConditionOnProperty 根据配置文件加载class</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot @Import @ImportResource 注解]]></title>
      <url>/spring-boot/springboot%20@Import%20@ImportResource%20%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>springboot @Import @ImportResource 注解<br><a id="more"></a></p>
<h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><blockquote>
<p>@Import注解在4.2之前只支持导入配置类；在4.2以及之后，@Import注解支持导入普通java类，并将其声明成一个bean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DemoService &#123;  </span><br><span class="line">    public void doSomething()&#123;  </span><br><span class="line">        System.out.println(&quot;everything is all fine&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@Configuration  </span><br><span class="line">@Import(DemoService.class)  </span><br><span class="line">public class DemoConfig &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AnnotationConfigApplicationContext context =  </span><br><span class="line">                new AnnotationConfigApplicationContext(&quot;com.example&quot;);  </span><br><span class="line">        DemoService ds = context.getBean(DemoService.class);  </span><br><span class="line">        ds.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h1><h2 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Controller</span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;url&#125;&quot;)</span><br><span class="line">	private String url;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	public String hello() &#123;</span><br><span class="line">		System.err.println(url);</span><br><span class="line">		return &quot;hello&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cons-java"><a href="#cons-java" class="headerlink" title="cons.java"></a>cons.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(&quot;classpath:test.xml&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class cons &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="test-xml"><a href="#test-xml" class="headerlink" title="test.xml"></a>test.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:/test.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="test-properties"><a href="#test-properties" class="headerlink" title="test.properties"></a>test.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">password=root</span><br><span class="line">url=127.0.0.1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单服务器开发]]></title>
      <url>/c/%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<p> 简单服务器开发</p>
 <a id="more"></a>
<h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	 struct  sockaddr_in  server,client;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 int cfd;</span><br><span class="line">	 int sfd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">     server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 int ret=bind(sfd,(struct sockaddr *)&amp;server,sizeof(server));</span><br><span class="line">	 if(ret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;bind error\n&quot;);</span><br><span class="line">	 	return -1; </span><br><span class="line">	 &#125;</span><br><span class="line">	 int lret=listen(sfd,10);</span><br><span class="line">	 if(lret==-1)&#123;</span><br><span class="line">	 	printf(&quot;%s&quot;,&quot;listen error\n&quot;);</span><br><span class="line">	 	return -1;</span><br><span class="line">	 &#125;</span><br><span class="line">	 int len=sizeof(client);</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	cfd=accept(sfd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">	 	char str[]=&quot;hello world\n&quot;;</span><br><span class="line">	 	write(cfd,str,sizeof(str));</span><br><span class="line">	 	while(1)&#123;</span><br><span class="line">	 		read(cfd,buf,1000);</span><br><span class="line">		    printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	 		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	 	</span><br><span class="line">	 	</span><br><span class="line">	 &#125;</span><br><span class="line">	 close(cfd);</span><br><span class="line">	 close(sfd);</span><br><span class="line">	 printf(&quot;over\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main()&#123;</span><br><span class="line">	 struct sockaddr_in server;</span><br><span class="line">	 char buf[1000];</span><br><span class="line">	 char buff[1000];</span><br><span class="line">	 int fd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">	 server.sin_family=AF_INET;</span><br><span class="line">	 server.sin_port=htons(7006);</span><br><span class="line">	 server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">	 connect(fd,(struct sockaddr*)&amp;server,sizeof(server));</span><br><span class="line">	 read(fd,buf,1000);</span><br><span class="line">	 printf(&quot;%s\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 while(1)&#123;</span><br><span class="line">	 	 </span><br><span class="line">	     scanf(&quot;%s&quot;,buff);</span><br><span class="line">        </span><br><span class="line">	     write(fd,buff,sizeof(buff));</span><br><span class="line">	     </span><br><span class="line">	   	</span><br><span class="line">	 &#125; </span><br><span class="line">	</span><br><span class="line">	 close(fd);	  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_image_filter_module应用]]></title>
      <url>/nginx/ngx_http_image_filter_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p> ngx_http_image_filter_module 缩略图应用</p>
 <a id="more"></a>
<h1 id="安装yum-install-y-gd-devel"><a href="#安装yum-install-y-gd-devel" class="headerlink" title="安装yum install -y gd-devel"></a>安装yum install -y gd-devel</h1><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-hhtp_image_filter_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	image_filter off;</span><br><span class="line">image_filter test;</span><br><span class="line">image_filter size;</span><br><span class="line">image_filter rotate 90 | 180 | 270;</span><br><span class="line">image_filter resize width height;</span><br><span class="line">image_filter crop width height;</span><br><span class="line">Default:	</span><br><span class="line">image_filter off;</span><br><span class="line">Context:	location</span><br></pre></td></tr></table></figure>
<h1 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~* /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ &#123;            </span><br><span class="line">    set $h $2;</span><br><span class="line">    set $w $3;</span><br><span class="line">    if ($h = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($w = &quot;0&quot;) &#123;</span><br><span class="line">        rewrite /img/(.+)_(\d+)x(\d+)\.(jpg|gif|png)$ /img/$1.$4 last;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    #根据给定的长宽生成缩略图</span><br><span class="line">    image_filter resize $h $w;</span><br><span class="line">    #原图最大2M，要裁剪的图片超过2M返回415错误，需要调节参数image_filter_buffer </span><br><span class="line">    image_filter_buffer 2M;                          </span><br><span class="line">     </span><br><span class="line">    #error_page  415              /img/notfound.jpg;</span><br><span class="line">    try_files /img/$1.$4  /img/notfound.jpg;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问缩略图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003_90x90.jpg</span><br><span class="line"></span><br><span class="line">访问原图方式</span><br><span class="line"></span><br><span class="line">http://nginx.im/img/9GUMJR7200AJ0003.jpg</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_addition_module应用]]></title>
      <url>/nginx/ngx_http_addition_module%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>ngx_http_addition_module在响应之前或者之后追加文本内容，比如js,html</p>
<a id="more"></a>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx.tar.gz</span><br><span class="line">cd nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_addition_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><blockquote>
<p>Syntax:    add_before_body uri;<br>Default:    —<br>Context:    http, server, location</p>
<p>Syntax:    add_after_body uri;<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<h1 id="nginx-conf-配置"><a href="#nginx-conf-配置" class="headerlink" title="nginx.conf 配置"></a>nginx.conf 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_before_body /head.html;</span><br><span class="line">    add_after_body  /foot.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim head.html</span><br><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim foot.html</span><br><span class="line"></span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用后</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;head&lt;/div&gt;</span><br><span class="line">&lt;h1&gt;hello nginx &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;foot&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot统一异常处理]]></title>
      <url>/java/springboot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
      <content type="html"><![CDATA[<p>springboot 统一异常处理</p>
<a id="more"></a>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">@EnableAutoConfiguration  //1</span><br><span class="line">@ComponentScan         //2 </span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;/&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	String home() &#123;</span><br><span class="line">		System.err.println(1 / 0);</span><br><span class="line">		return &quot;Hello World!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(test.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p> 标注 1,2 可以换成@SpringBootApplication<br> @SpringBootApplication //等同于 @Configuration @EnableAutoConfiguration @ComponentScan</p>
</blockquote>
</blockquote>
<h1 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package nginx;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ex &#123;</span><br><span class="line">	@ExceptionHandler(RuntimeException.class)</span><br><span class="line">	@ResponseBody // 拦截返回是 json返回结果</span><br><span class="line">	public Map&lt;String, Object&gt; exceptionHandler() &#123;</span><br><span class="line">		Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		result.put(&quot;code&quot;, &quot;500&quot;);</span><br><span class="line">		result.put(&quot;msg&quot;, &quot;亲,系统错误,请稍后重试....&quot;);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"><a href="#ControllerAdvice-注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常" class="headerlink" title="@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常"></a>@ControllerAdvice 注解，用于拦截全局的Controller的异常，注意：ControllerAdvice注解只拦截Controller不会拦截Interceptor的异常</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.cmc.schedule.handler;</span><br><span class="line"></span><br><span class="line">import com.gionee.base.entity.JsonResult;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.ConversionNotSupportedException;</span><br><span class="line">import org.springframework.beans.TypeMismatchException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotWritableException;</span><br><span class="line">import org.springframework.web.HttpMediaTypeNotAcceptableException;</span><br><span class="line">import org.springframework.web.HttpRequestMethodNotSupportedException;</span><br><span class="line">import org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常拦截处理器</span><br><span class="line"> *</span><br><span class="line"> * @author chenmc</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice</span><br><span class="line">@ResponseBody</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String logExceptionFormat = &quot;Capture Exception By GlobalExceptionHandler: Code: %s Detail: %s&quot;;</span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    //运行时异常  </span><br><span class="line">    @ExceptionHandler(RuntimeException.class)</span><br><span class="line">    public String runtimeExceptionHandler(RuntimeException ex) &#123;</span><br><span class="line">        return resultFormat(1, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空指针异常  </span><br><span class="line">    @ExceptionHandler(NullPointerException.class)</span><br><span class="line">    public String nullPointerExceptionHandler(NullPointerException ex) &#123;</span><br><span class="line">        return resultFormat(2, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换异常  </span><br><span class="line">    @ExceptionHandler(ClassCastException.class)</span><br><span class="line">    public String classCastExceptionHandler(ClassCastException ex) &#123;</span><br><span class="line">        return resultFormat(3, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //IO异常  </span><br><span class="line">    @ExceptionHandler(IOException.class)</span><br><span class="line">    public String iOExceptionHandler(IOException ex) &#123;</span><br><span class="line">        return resultFormat(4, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //未知方法异常  </span><br><span class="line">    @ExceptionHandler(NoSuchMethodException.class)</span><br><span class="line">    public String noSuchMethodExceptionHandler(NoSuchMethodException ex) &#123;</span><br><span class="line">        return resultFormat(5, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组越界异常  </span><br><span class="line">    @ExceptionHandler(IndexOutOfBoundsException.class)</span><br><span class="line">    public String indexOutOfBoundsExceptionHandler(IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        return resultFormat(6, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMessageNotReadableException.class&#125;)</span><br><span class="line">    public String requestNotReadable(HttpMessageNotReadableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..requestNotReadable&quot;);</span><br><span class="line">        return resultFormat(7, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;TypeMismatchException.class&#125;)</span><br><span class="line">    public String requestTypeMismatch(TypeMismatchException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..TypeMismatchException&quot;);</span><br><span class="line">        return resultFormat(8, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //400错误  </span><br><span class="line">    @ExceptionHandler(&#123;MissingServletRequestParameterException.class&#125;)</span><br><span class="line">    public String requestMissingServletRequest(MissingServletRequestParameterException ex) &#123;</span><br><span class="line">        System.out.println(&quot;400..MissingServletRequest&quot;);</span><br><span class="line">        return resultFormat(9, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //405错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpRequestMethodNotSupportedException.class&#125;)</span><br><span class="line">    public String request405(HttpRequestMethodNotSupportedException ex) &#123;</span><br><span class="line">        return resultFormat(10, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //406错误  </span><br><span class="line">    @ExceptionHandler(&#123;HttpMediaTypeNotAcceptableException.class&#125;)</span><br><span class="line">    public String request406(HttpMediaTypeNotAcceptableException ex) &#123;</span><br><span class="line">        System.out.println(&quot;406...&quot;);</span><br><span class="line">        return resultFormat(11, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //500错误  </span><br><span class="line">    @ExceptionHandler(&#123;ConversionNotSupportedException.class, HttpMessageNotWritableException.class&#125;)</span><br><span class="line">    public String server500(RuntimeException ex) &#123;</span><br><span class="line">        System.out.println(&quot;500...&quot;);</span><br><span class="line">        return resultFormat(12, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈溢出</span><br><span class="line">    @ExceptionHandler(&#123;StackOverflowError.class&#125;)</span><br><span class="line">    public String requestStackOverflow(StackOverflowError ex) &#123;</span><br><span class="line">        return resultFormat(13, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //其他错误</span><br><span class="line">    @ExceptionHandler(&#123;Exception.class&#125;)</span><br><span class="line">    public String exception(Exception ex) &#123;</span><br><span class="line">        return resultFormat(14, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T extends Throwable&gt; String resultFormat(Integer code, T ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        log.error(String.format(logExceptionFormat, code, ex.getMessage()));</span><br><span class="line">        return JsonResult.failed(code, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java动态代理实现连接池]]></title>
      <url>/java/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</url>
      <content type="html"><![CDATA[<p> java动态代理实现连接池</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">import sun.font.CreatedFontTracker;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author michael</span><br><span class="line"> * Description: </span><br><span class="line"> *代理：如果对某个接口中的某个指定的方法的功能进行扩展，而不想实现接口里所有方法，可以使用（动态代理）代理模式</span><br><span class="line"> *java中代理模式:静态/动态/cglib（Spring）</span><br><span class="line"> *使用动态代理，可以检测接口中方法的执行</span><br><span class="line"> *</span><br><span class="line"> *Proxy</span><br><span class="line"> *static Object newProxyInstance(</span><br><span class="line"> *ClassLoader loader,  定义代理类的类加载器</span><br><span class="line"> *Class&lt;?&gt;[] interfaces,   代理类要实现的接口列表</span><br><span class="line"> *InvocationHandler h)  指派方法调用的调用处理程序 </span><br><span class="line"> * 2017年5月1日</span><br><span class="line"> */</span><br><span class="line">public class Pool &#123;</span><br><span class="line">	private int init_count = 3;</span><br><span class="line">	private int max_count = 6;</span><br><span class="line">	private int current_count = 0;</span><br><span class="line">	private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	//1.构造函数，初始化连接放入连接池</span><br><span class="line">	public Pool()&#123;</span><br><span class="line">		for (int i = 0; i &lt; init_count; i++) &#123;</span><br><span class="line">			current_count++;</span><br><span class="line">			Connection conn = createConnection();</span><br><span class="line">			pool.add(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//2.创建一个新的连接方法</span><br><span class="line">	private Connection createConnection()&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">			final Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">			//对con创建代理对象</span><br><span class="line">			Connection proxy = (Connection)Proxy.newProxyInstance(</span><br><span class="line">					con.getClass().getClassLoader(), </span><br><span class="line">					/*con.getClass().getInterfaces(),*/  //当目标对象是一个具体的类时</span><br><span class="line">					new Class[]&#123;Connection.class&#125;,   //目标对象实现的接口</span><br><span class="line">					new InvocationHandler() &#123;</span><br><span class="line">						</span><br><span class="line">						@Override</span><br><span class="line">						public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">								throws Throwable &#123;</span><br><span class="line">							//方法返回值</span><br><span class="line">							Object result = null;</span><br><span class="line">							//当前执行的方法名</span><br><span class="line">							String methodName = method.getName();</span><br><span class="line">							//判断是否执行了close方法的时候，把连接放到连接池</span><br><span class="line">							if(&quot;close&quot;.equals(methodName))&#123;</span><br><span class="line">								System.out.println(&quot;begin:当前执行了close方法&quot;);</span><br><span class="line">								//连接放入连接池</span><br><span class="line">								pool.addLast(con);</span><br><span class="line">								System.out.println(&quot;end:当前连接已经放入连接池&quot;);</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">							//调用目标对象方法</span><br><span class="line">							method.invoke(con, args);</span><br><span class="line">							&#125;</span><br><span class="line">							return result;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					);</span><br><span class="line">			return proxy;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			throw new RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//3.获取连接</span><br><span class="line">	public  Connection getConnection()&#123;</span><br><span class="line">		//3.1判断连接池中是否有链接，如果有连接，则直接用</span><br><span class="line">		if(pool.size()&gt;0)&#123;</span><br><span class="line">			return pool.removeFirst();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//3.2连接池中没有连接，判断，如果没有达到最大连接数，创建</span><br><span class="line">		if(current_count&lt;max_count)&#123;</span><br><span class="line">			//记录当前使用的连接数</span><br><span class="line">			current_count++;</span><br><span class="line">			return createConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		//3.3如果当前已经达到最大连接数，抛出异常</span><br><span class="line">		throw new RuntimeException(&quot;当前已经达到最大连接数！&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//4.释放连接</span><br><span class="line">	public void realeaseConnection(Connection con)&#123;</span><br><span class="line">		//4.1 判断：池的数目如果小于初始化练级，就放入池中</span><br><span class="line">		if(pool.size()&lt;init_count)&#123;</span><br><span class="line">			pool.addLast(con);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			//关闭</span><br><span class="line">			try &#123;</span><br><span class="line">				current_count-- ;</span><br><span class="line">				con.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">		Pool pool = new Pool();</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">		</span><br><span class="line">		//使用连接</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		pool.getConnection();</span><br><span class="line">	</span><br><span class="line">		Connection con1 = pool.getConnection();</span><br><span class="line">		con1.close();//如果没用动态代理，连接就关闭了</span><br><span class="line">		//希望：当关闭连接的时候，要把连接放入连接池。（当调用Connetion接口的close方法时候，希望触发pool.addLast(con)操作）</span><br><span class="line">		//解决1:实现Connection接口，重写close方法（方法太多，不太现实）</span><br><span class="line">		//解决2：</span><br><span class="line">		pool.getConnection();</span><br><span class="line">		System.out.println(&quot;连接池&quot;+pool.pool.size());</span><br><span class="line">		System.out.println(&quot;当前连接&quot;+pool.current_count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM中GC Minor-GC Major-GC Full-GC区别]]></title>
      <url>/java/JVM%E4%B8%ADGC%20Minor-GC%20Major-GC%20Full-GC%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p>JVM中GC Minor-GC Major-GC Full-GC区别</p>
<a id="more"></a>
<p>#JVM 内存分布</p>
<p>JVM堆包含 ，Eden,Survivor,Old 区</p>
<h1 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor-GC"></a>Minor-GC</h1><p>在Young space(Eden,survivor 区) 中的垃圾回收称为Minor-GC</p>
<blockquote>
<blockquote>
<p>不能为新对象分配空间的时候，Eden区满了，分配空间越快，Minor-GC越频繁<br>当内存池慢了后, 它的完整的内容会被复制出去，指针可以从0开始重新跟踪空闲内存。所以取代传统的标记-交换-压缩（Mark, Sweep , Compact）, Eden区和Survivor区使用标记-复制方式（Mark , Copy）. 因此在Eden区和Survivor区无内存碎片。写指针总是指向内存池的顶部。</p>
<p>在Minor GC时, 年老代（Tenured generation）可以被忽略. 年老代对年轻代的引用被认为是实际的GC根root。 在标记阶段年轻代对年老代的引用可以被简单的忽略。<br>出于常理, 所有的Minor GC都会触发stop-the-world暂停, 它意味着会暂停应用的所有线程. 对于大部分应用而言，暂停的延迟可以忽略不计。这是因为Eden中大部分的对象都可以垃圾回收掉，而不会被复制到Survivor/Old区。但如果相反，大部分的新对象不能被回收， Minor GC暂停会占用更多的时间。</p>
</blockquote>
</blockquote>
<h1 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major-GC"></a>Major-GC</h1><h2 id="Major-GC-清理年老区（old-space）"><a href="#Major-GC-清理年老区（old-space）" class="headerlink" title="Major GC 清理年老区（old space）"></a>Major GC 清理年老区（old space）</h2><h1 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full-GC"></a>Full-GC</h1><h2 id="清理年轻代，老年代"><a href="#清理年轻代，老年代" class="headerlink" title="清理年轻代，老年代"></a>清理年轻代，老年代</h2>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA自带的加密算法-MD5\SHA1\BASE64]]></title>
      <url>/java/BASE64.html</url>
      <content type="html"><![CDATA[<p>JAVA自带的加密算法-MD5\SHA1\BASE64<br>引入 commons-codec.jar<br><a id="more"></a></p>
<h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.md5Hex(str);</span><br></pre></td></tr></table></figure>
<h1 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">DigestUtils.shaHex(str);</span><br></pre></td></tr></table></figure>
<h1 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h1><blockquote>
<blockquote>
<p>加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str= &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">byte[] b = Base64.encodeBase64(str.getBytes(), true);</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
<p>解密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String  str = &quot;123&quot;;</span><br><span class="line">byte[] b = Base64.decodeBase64(str.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(new String(b));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中常见的坑]]></title>
      <url>/java/java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91.html</url>
      <content type="html"><![CDATA[<p>Java中常见的坑</p>
<h1 id="System-out-println-Object-toString"><a href="#System-out-println-Object-toString" class="headerlink" title="System.out.println( Object.toString )"></a>System.out.println( Object.toString )</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123; “Hello”, “World” &#125;;</span><br><span class="line">System.out.println(words);</span><br><span class="line"></span><br><span class="line">output: [Ljava.lang.String;@45ee12b7</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>改造</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(words));</span><br><span class="line"></span><br><span class="line">output: [Hello, World]</span><br></pre></td></tr></table></figure>
<h1 id="list-toArray-T-array"><a href="#list-toArray-T-array" class="headerlink" title="list.toArray(T[] array)"></a>list.toArray(T[] array)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);</span><br><span class="line">  list.add(&quot;222&quot;); </span><br><span class="line">  list.add(&quot;111&quot;); </span><br><span class="line">  String[] array = new String[list.size()];  #list.size()</span><br><span class="line">  array = list.toArray(array);</span><br></pre></td></tr></table></figure>
<h1 id="不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"><a href="#不要在foreach循环里进行元素的remove-add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。" class="headerlink" title="不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。"></a>不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator(); </span><br><span class="line">  while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">#加锁</span><br><span class="line"></span><br><span class="line">Map m = Collections.synchronizedMap(new HashMap());</span><br><span class="line">synchronized(m) &#123;</span><br><span class="line">     while(it.hasNext()) &#123; </span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件) &#123; </span><br><span class="line">        it.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> 创建线程安全集合</span><br><span class="line"> Collection c=Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"> List list=Collections.synchronizedList(new ArrayList());</span><br><span class="line"> Set s=Collections.synchronizedSet(new HashSet());</span><br><span class="line"> Map m=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Three.js展示全景图]]></title>
      <url>/%E5%9F%BA%E4%BA%8EThree.js%E5%B1%95%E7%A4%BA%E5%85%A8%E6%99%AF%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<p>基于Three.js展示全景图</p>
<a id="more"></a>
<h1 id="初始化插件-创建PhotoSphereViewer对象"><a href="#初始化插件-创建PhotoSphereViewer对象" class="headerlink" title="初始化插件,创建PhotoSphereViewer对象"></a>初始化插件,创建PhotoSphereViewer对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var PSV = new PhotoSphereViewer(&#123;</span><br><span class="line">        // 全景图的完整路径</span><br><span class="line">        panorama: img, </span><br><span class="line">        // 放全景图的元素</span><br><span class="line">        container: div,</span><br><span class="line">        // 可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。（设置为false禁用它）</span><br><span class="line">        time_anim: false,</span><br><span class="line">		tilt_up_max: 0,</span><br><span class="line">		tilt_down_max: 0,</span><br><span class="line"></span><br><span class="line">        // 可选值，默认为false。显示导航条。</span><br><span class="line">        navbar: true,</span><br><span class="line"></span><br><span class="line">        // 可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">        size: &#123;</span><br><span class="line">            width: &apos;100%&apos;,</span><br><span class="line">            height: canvasHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="配置参数备注"><a href="#配置参数备注" class="headerlink" title="配置参数备注"></a>配置参数备注</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">panorama：必填参数，全景图的路径。</span><br><span class="line">container：必填参数，放置全景图的div元素。</span><br><span class="line">autoload：可选，默认值为true，true为自动调用全景图，false为在后面加载全景图(通过.load()方法)。</span><br><span class="line">us empdata：可选，默认值为true，如果Photo Sphere Viewer必须读入XMP数据则为true。</span><br><span class="line">default_position：可选，默认值为&#123;&#125;，定义默认的位置，及用户看见的第一个点，例如：&#123;long: Math.PI, lat: Math.PI/2&#125;。</span><br><span class="line">min_fov：可选，默认值为30，观察的最小区域，单位degrees，在1-179之间。</span><br><span class="line">max_fov：可选，默认值为90，观察的最大区域，单位degrees，在1-179之间。</span><br><span class="line">allow_user_interactions：可选，默认值为true，设置为false则禁止用户和全景图交互(导航条不可用)。</span><br><span class="line">tilt_up_max：可选，默认值为Math.PI/2，向上倾斜的最大角度，单位radians。</span><br><span class="line">tilt_down_max：可选，默认值为Math.PI/2，向下倾斜的最大角度，单位radians。</span><br><span class="line">zoom_level：可选，默认值为0，默认的缩放级别，值在0-100之间。</span><br><span class="line">long_offset：可选，默认值为PI/360，mouse/touch移动时每像素经过的经度值。</span><br><span class="line">lat_offset：可选，默认值为PI/180，mouse/touch移动时每像素经过的纬度值。</span><br><span class="line">time_anim：可选，默认值为2000，全景图在time_anim毫秒后会自动进行动画。(设置为false禁用它)</span><br><span class="line">theta_offset：过时的选项，可选，默认值为1440，自动动画时水平方向的速度。</span><br><span class="line">anim_speed：可选，默认值为2rpm，动画的速度，每秒/分钟多少radians/degrees/revolutions。</span><br><span class="line">navbar：可选值，默认为false。显示导航条。</span><br><span class="line">navbar_style：可选值，默认为&#123;&#125;。导航条的自定义样式。下面是可用的样式列表：</span><br><span class="line">backgroundColor：导航条的背景颜色，默认值为rgba(61, 61, 61, 0.5)。</span><br><span class="line">buttonsColor：按钮的前景颜色，默认值为transparent。</span><br><span class="line">activeButtonsBackgroundColor：按钮激活状态的背景颜色，默认值为rgba(255, 255, 255, 0.1)。</span><br><span class="line">buttonsHeight：按钮的高度，单位像素，默认值为20。</span><br><span class="line">autorotateThickness：autorotate图标的厚度，单位像素，默认值为1。</span><br><span class="line">zoomRangeWidth：缩放的范围，单位显示，默认值50。</span><br><span class="line">zoomRangeThickness：缩放的范围的厚度，单位像素，默认值1。</span><br><span class="line">zoomRangeDisk：缩放范围的圆盘直径，单位像素，默认值为7。</span><br><span class="line">fullscreenRatio：全屏图标的比例，默认值为3/4。</span><br><span class="line">fullscreenThickness：全屏图标的厚度，单位像素，默认值为2。</span><br><span class="line">loading_msg：可选，默认值为Loading…，图片加载时的提示文字。</span><br><span class="line">loading_img：可选，默认值为null，在加载时显示的图片的路径。</span><br><span class="line">size：可选，默认值null，全景图容器的最终尺寸。例如：&#123;width: 500, height: 300&#125;。</span><br><span class="line">onready：可选值，默认值为null。当全景图准备就绪并且第一张图片显示时的回调函数。</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Three.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Three.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat启动流程]]></title>
      <url>/tomcat/tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>tomcat 启动启动过程分析<br><a id="more"></a></p>
<h1 id="org-apache-catalina-startup-Bootstrap-main"><a href="#org-apache-catalina-startup-Bootstrap-main" class="headerlink" title="org.apache.catalina.startup.Bootstrap.main"></a>org.apache.catalina.startup.Bootstrap.main</h1><blockquote>
<blockquote>
<p>org.apache.catalina.startup.Bootstrap.main 启动的入口方法</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">           if (command.equals(&quot;startd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;start&quot;;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stopd&quot;)) &#123;</span><br><span class="line">               args[args.length - 1] = &quot;stop&quot;;</span><br><span class="line">               daemon.stop();</span><br><span class="line">           &#125; else if (command.equals(&quot;start&quot;)) &#123;</span><br><span class="line">               daemon.setAwait(true);</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               daemon.start();</span><br><span class="line">           &#125; else if (command.equals(&quot;stop&quot;)) &#123;</span><br><span class="line">               daemon.stopServer(args);</span><br><span class="line">           &#125; else if (command.equals(&quot;configtest&quot;)) &#123;</span><br><span class="line">               daemon.load(args);</span><br><span class="line">               if (null==daemon.getServer()) &#123;</span><br><span class="line">                   System.exit(1);</span><br><span class="line">               &#125;</span><br><span class="line">               System.exit(0);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-gt-initClassLoaders"><a href="#main-gt-initClassLoaders" class="headerlink" title="main()-&gt;initClassLoaders()"></a>main()-&gt;initClassLoaders()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commonLoader = createClassLoader(&quot;common&quot;, null);</span><br><span class="line">#导入源码目录的 D:\apache-tomcat-xxxx-src\lib 的jar</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;); </span><br><span class="line">#导入 org.apache.catalina.startup.Catalina</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  daemon.setAwait(true);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  daemon 可以看成 org.apache.catalina.startup.Catalina类</span><br></pre></td></tr></table></figure>
<h1 id="org-apache-catalina-startup-Catalina"><a href="#org-apache-catalina-startup-Catalina" class="headerlink" title="org.apache.catalina.startup.Catalina"></a>org.apache.catalina.startup.Catalina</h1><blockquote>
<blockquote>
<p>start()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">		if (getServer() == null) &#123;</span><br><span class="line">			load(); //重点处理server.xml</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	.......</span><br><span class="line">		try &#123;</span><br><span class="line">			getServer().start();</span><br><span class="line">		&#125; catch (LifecycleException e) &#123;</span><br><span class="line">			log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;), e);</span><br><span class="line">			try &#123;</span><br><span class="line">				getServer().destroy();</span><br><span class="line">			&#125; catch (LifecycleException e1) &#123;</span><br><span class="line">				log.debug(&quot;destroy() failed for failed Server &quot;, e1);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>load()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void load() &#123;</span><br><span class="line">.....</span><br><span class="line">Digester digester = createStartDigester(); </span><br><span class="line">.....</span><br><span class="line">getServer().setCatalina(this);</span><br><span class="line">getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line">#设置 catalina.home、catalina.base</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>createStartDigester() 加载解析server.xml</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br><span class="line"></span><br><span class="line">		// When the &apos;engine&apos; is found, set the parentClassLoader.</span><br><span class="line">		digester.addRule(&quot;Server/Service/Engine&quot;, new SetParentClassLoaderRule(parentClassLoader));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Cluster/&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>Catalina.java 创建 server service engine 添加监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Add RuleSets for nested elements</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/GlobalNamingResources/&quot;));</span><br><span class="line">		digester.addRuleSet(new EngineRuleSet(&quot;Server/Service/&quot;));</span><br><span class="line">		digester.addRuleSet(new HostRuleSet(&quot;Server/Service/Engine/&quot;));</span><br><span class="line">		digester.addRuleSet(new ContextRuleSet(&quot;Server/Service/Engine/Host/&quot;));</span><br><span class="line">		addClusterRuleSet(digester, &quot;Server/Service/Engine/Host/Cluster/&quot;);</span><br><span class="line">		digester.addRuleSet(new NamingRuleSet(&quot;Server/Service/Engine/Host/Context/&quot;));</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Server的启动过程"><a href="#Server的启动过程" class="headerlink" title="Server的启动过程"></a>Server的启动过程</h1><blockquote>
<blockquote>
<p>Server 的默认实现是 org.apache.catalina.core.StandardServer，StandardServer 继承自 LifecycleMBeanBase，LifecycleMBeanBase又继承自 LifecycleBase。 init 和 start 方法就定义在 LifecycleBase 中，LifecycleBase 里的init和start方法又调用initInternal和startInternal方法，这两个方法都是模板方法有子类实现。所以 StandardServer 执行  initInternal 和 startInternal 方法。<br>同时 init 和 start 方法分别循环调用了每个Service的 init 和 start 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardServer</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line">		System.err.println(&quot;startInternal\n&quot;);</span><br><span class="line">		fireLifecycleEvent(CONFIGURE_START_EVENT, null);</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Services</span><br><span class="line">		synchronized (servicesLock) &#123;</span><br><span class="line">			for (int i = 0; i &lt; services.length; i++) &#123;</span><br><span class="line">				services[i].start(); //启动service</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Service-的启动过程"><a href="#Service-的启动过程" class="headerlink" title="Service 的启动过程"></a>Service 的启动过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardService</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	protected void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">		if (log.isInfoEnabled())</span><br><span class="line">			log.info(sm.getString(&quot;standardService.start.name&quot;, this.name));</span><br><span class="line">		setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">		// Start our defined Container first</span><br><span class="line">		if (engine != null) &#123;</span><br><span class="line">			synchronized (engine) &#123;</span><br><span class="line">				engine.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		synchronized (executors) &#123;</span><br><span class="line">			for (Executor executor : executors) &#123;</span><br><span class="line">				executor.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mapperListener.start();</span><br><span class="line"></span><br><span class="line">		// Start our defined Connectors second</span><br><span class="line">		synchronized (connectorsLock) &#123;</span><br><span class="line">			for (Connector connector : connectors) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					// If it has already failed, don&apos;t try and start it</span><br><span class="line">					if (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">						connector.start();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					log.error(sm.getString(&quot;standardService.connector.startFailed&quot;, connector), e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Engine-的启动"><a href="#Engine-的启动" class="headerlink" title="Engine 的启动"></a>Engine 的启动</h1><blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardEngine<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       // Log our server identification information</span><br><span class="line">       if(log.isInfoEnabled())</span><br><span class="line">           log.info( &quot;Starting Servlet Engine: &quot; + ServerInfo.getServerInfo());</span><br><span class="line"></span><br><span class="line">       // Standard container startup</span><br><span class="line">       super.startInternal(); #调用父类方法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> org.apache.catalina.core.ContainerBase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        // Start our subordinate components, if any</span><br><span class="line">        logger = null;</span><br><span class="line">        getLogger();</span><br><span class="line">        Cluster cluster = getClusterInternal();</span><br><span class="line">        if (cluster instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) cluster).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Realm realm = getRealmInternal();</span><br><span class="line">        if (realm instanceof Lifecycle) &#123;</span><br><span class="line">            ((Lifecycle) realm).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start our child containers, if any</span><br><span class="line">        Container children[] = findChildren();</span><br><span class="line">        List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">            results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean fail = false;</span><br><span class="line">        for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;containerBase.threadedStartFailed&quot;), e);</span><br><span class="line">                fail = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (fail) &#123;</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;containerBase.threadedStartFailed&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Start the Valves in our pipeline (including the basic), if any</span><br><span class="line">        if (pipeline instanceof Lifecycle)</span><br><span class="line">            ((Lifecycle) pipeline).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">        // Start our thread</span><br><span class="line">        threadStart(); #转Context 启动</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<h1 id="Context-启动"><a href="#Context-启动" class="headerlink" title="Context 启动"></a>Context 启动</h1><blockquote>
<blockquote>
<p>threadStart(); </p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  protected void threadStart() &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        thread = new Thread(new ContainerBackgroundProcessor(), threadName);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line">        thread.start(); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected class ContainerBackgroundProcessor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">                processChildren(ContainerBase.this);</span><br><span class="line">        ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.ContainerBackgroundProcessor.processChildren(Container)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void processChildren(Container container) &#123;</span><br><span class="line">         ...</span><br><span class="line">               container.backgroundProcess();</span><br><span class="line">        ...   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.StandardContext.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">	super.backgroundProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.core.ContainerBase.backgroundProcess()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void backgroundProcess() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	# 此时 listener 为org.apache.catalina.startup.HostConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.lifecycleEvent(LifecycleEvent)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">check();</span><br><span class="line"></span><br><span class="line">deployApps(); # 部署webapps 下的应用</span><br><span class="line"></span><br><span class="line">protected void deployApps() &#123;</span><br><span class="line"></span><br><span class="line">        File appBase = host.getAppBaseFile();</span><br><span class="line">        File configBase = host.getConfigBaseFile();</span><br><span class="line">        String[] filteredAppPaths = filterAppPaths(appBase.list());</span><br><span class="line">        // Deploy XML descriptors from configBase</span><br><span class="line">        deployDescriptors(configBase, configBase.list());</span><br><span class="line">        // Deploy WARs</span><br><span class="line">        deployWARs(appBase, filteredAppPaths);</span><br><span class="line">        // Deploy expanded folders</span><br><span class="line">        deployDirectories(appBase, filteredAppPaths);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.HostConfig.createDigester(String)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected static Digester createDigester(String contextClassName) &#123;</span><br><span class="line">#contextClassName= org.apache.catalina.core.StandardContext</span><br><span class="line">       Digester digester = new Digester();</span><br><span class="line">       digester.setValidating(false);</span><br><span class="line">       // Add object creation rule</span><br><span class="line">       digester.addObjectCreate(&quot;Context&quot;, contextClassName, &quot;className&quot;);</span><br><span class="line">       // Set the properties on that object (it doesn&apos;t matter if extra</span><br><span class="line">       // properties are set)</span><br><span class="line">       digester.addSetProperties(&quot;Context&quot;);</span><br><span class="line">       return (digester);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>org.apache.catalina.startup.ContextConfig监听StandardContext的事件</p>
<blockquote>
<p>调用 org.apache.catalina.core.StandardContext.startInternal()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected synchronized void startInternal() throws LifecycleException &#123; </span><br><span class="line">       ......</span><br><span class="line">       fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); // 解析web.xml的</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"> # 启动web.xml的 listener 例如 ：contextloaderlistener</span><br><span class="line">       if (ok) &#123;</span><br><span class="line">				if (!listenerStart()) &#123;</span><br><span class="line">log.error(sm.getString(&quot;standardContext.listenerFail&quot;));</span><br><span class="line">					ok = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<p> org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(String, Object)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">		LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">		for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">			listener.lifecycleEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	#此时的listener 为 org.apache.catalina.startup.ContextConfig</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>解析  web.xml org.apache.catalina.startup.ContextConfig.configureStart()</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void configureStart() &#123;</span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">		webConfig();  #  真正解析 web.xml</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> tomcat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot自义定错误返回页面和json格式]]></title>
      <url>/spring-boot%E8%87%AA%E4%B9%89%E5%AE%9A%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E5%92%8Cjson%E6%A0%BC%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<p>springboot发生错误时，在浏览器端访问和用测试接口的软件看到的返回页面是不一样的。</p>
<blockquote>
<p>浏览器端  返回 Whitelabel Error Page页面<br>测试接口的软件返回一个json 字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;timestamp&quot;: 1492063521109,</span><br><span class="line">&quot;status&quot;: 404,</span><br><span class="line">&quot;error&quot;: &quot;Not Found&quot;,</span><br><span class="line">&quot;message&quot;: &quot;No message available&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/test/auth&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h1 id="spring根据请求的-produces返回不同值"><a href="#spring根据请求的-produces返回不同值" class="headerlink" title="spring根据请求的 produces返回不同值"></a>spring根据请求的 produces返回不同值</h1><blockquote>
<p>BasicErrorController.java源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(produces = &quot;text/html&quot;) #浏览器访问</span><br><span class="line">public ModelAndView errorHtml(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping  #接口测试软件  application/json 默认没写</span><br><span class="line">@ResponseBody</span><br><span class="line">public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>@RequestMapping(value = “/produces”, produces = “application/json”)：表示将功能处理方法将生产json格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/json”时即可匹配;<br>@RequestMapping(value = “/produces”, produces = “application/xml”)：表示将功能处理方法将生产xml格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/xml”时即可匹配。</p>
</blockquote>
<h1 id="自定义浏览器端错误的返回页面"><a href="#自定义浏览器端错误的返回页面" class="headerlink" title="自定义浏览器端错误的返回页面"></a>自定义浏览器端错误的返回页面</h1><h2 id="重写BasicErrorController"><a href="#重写BasicErrorController" class="headerlink" title="重写BasicErrorController"></a>重写BasicErrorController</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		response.setStatus(getStatus(request).value());</span><br><span class="line">		Map&lt;String, Object&gt; model = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML));</span><br><span class="line">		return new ModelAndView(&quot;error/404.html&quot;, model);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-src-main-resources-public-error-404-html-页面"><a href="#创建-src-main-resources-public-error-404-html-页面" class="headerlink" title="创建 src/main/resources/public/error/404.html 页面"></a>创建 src/main/resources/public/error/404.html 页面</h2><h1 id="自定义测试软件返回json"><a href="#自定义测试软件返回json" class="headerlink" title="自定义测试软件返回json"></a>自定义测试软件返回json</h1><blockquote>
<p>重写BasicErrorController</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyErrorController extends BasicErrorController &#123;</span><br><span class="line"></span><br><span class="line">	public MyErrorController(ServerProperties serverProperties) &#123;</span><br><span class="line">		super(new DefaultErrorAttributes(), serverProperties.getError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		map.put(&quot;msg&quot;, body.get(&quot;message&quot;));</span><br><span class="line">		map.put(&quot;code&quot;, body.get(&quot;status&quot;));</span><br><span class="line">		map.put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot过滤器验证token]]></title>
      <url>/spring-boot/spring-token.html</url>
      <content type="html"><![CDATA[<p>springboot过滤器验证token<br><a id="more"></a></p>
<h1 id="token-java"><a href="#token-java" class="headerlink" title="token.java"></a>token.java</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TokenInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService adminService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        String token = request.getHeader(&quot;token&quot;);</span><br><span class="line">        String user = request.getHeader(&quot;userId&quot;);</span><br><span class="line">        if (token == null || user == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer userId = Integer.valueOf(user);</span><br><span class="line">        //获取Service实例</span><br><span class="line">        if (userService == null) &#123;</span><br><span class="line">            BeanFactory factory = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());</span><br><span class="line">            userService = (UserService) factory.getBean(&quot;userService&quot;);</span><br><span class="line">            adminService = (AdminService) factory.getBean(&quot;adminService&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //增加日活量</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            adminService.addAccessCount(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        String checkToken = userService.selectToken(userId);</span><br><span class="line">        //检查头部请求</span><br><span class="line">        if (!checkToken.equals(token)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> token </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> token </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot-Access-Control-Allow-Origin]]></title>
      <url>/spring-boot/spring-boot-Access-Control-Allow-Origin.html</url>
      <content type="html"><![CDATA[<p>springboot 跨域研究</p>
<a id="more"></a>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><blockquote>
<p>在前后端开发的模式中，前端通常使用ajax调用后端服务器的接口，常见错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:8080’ is therefore not allowed access.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="springboot-解决跨域的方案"><a href="#springboot-解决跨域的方案" class="headerlink" title="springboot 解决跨域的方案"></a>springboot 解决跨域的方案</h1><h2 id="通过UrlBasedCorsConfigurationSource解决"><a href="#通过UrlBasedCorsConfigurationSource解决" class="headerlink" title="通过UrlBasedCorsConfigurationSource解决"></a>通过UrlBasedCorsConfigurationSource解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    private CorsConfiguration buildConfig() &#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1 设置访问源地址</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2 设置访问源请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3 设置访问源请求方法</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4 对接口配置跨域设置</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过拦截器解决"><a href="#通过拦截器解决" class="headerlink" title="通过拦截器解决"></a>通过拦截器解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CORSConfiguration &#123;</span><br><span class="line">	@Bean</span><br><span class="line">	public WebMvcConfigurer corsConfigurer() &#123;</span><br><span class="line">		return new WebMvcConfigurerAdapter() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">				registry.addMapping(&quot;/**&quot;).allowedHeaders(&quot;*&quot;).allowedMethods(&quot;*&quot;).allowedOrigins(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过注解解决"><a href="#通过注解解决" class="headerlink" title="通过注解解决"></a>通过注解解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &quot;http://a.com&quot;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-feign伪rpc集成]]></title>
      <url>/spring-boot-feign%E4%BC%AArpc%E9%9B%86%E6%88%90.html</url>
      <content type="html"><![CDATA[<p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。可以认为是一种伪RPC。<br><a id="more"></a></p>
<h1 id="和springboot整合"><a href="#和springboot整合" class="headerlink" title="和springboot整合"></a>和springboot整合</h1><blockquote>
<p>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.3.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="配置application-properties-文件"><a href="#配置application-properties-文件" class="headerlink" title="配置application.properties 文件"></a>配置application.properties 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign.name=feignName</span><br><span class="line">feign.url=http://localhost:88</span><br><span class="line">feign.client.config.default.loggerLevel = full</span><br><span class="line">feign.connectTimeoutMillis=1000   #连接超时,单位毫秒</span><br><span class="line">feign.readTimeoutMillis=15000     #读超时,单位毫秒</span><br></pre></td></tr></table></figure>
<h1 id="编写feign的-interface"><a href="#编写feign的-interface" class="headerlink" title="编写feign的 interface"></a>编写feign的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(url = &quot;$&#123;feign.url&#125;&quot;, name = &quot;feign.name&quot;)</span><br><span class="line">public interface testfeign &#123;</span><br><span class="line">	@RequestMapping(value = &quot;/version&quot;, method = RequestMethod.GET)</span><br><span class="line">	public String version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在controller-注入上面的-interface"><a href="#在controller-注入上面的-interface" class="headerlink" title="在controller 注入上面的 interface"></a>在controller 注入上面的 interface</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private testfeign stestfeign;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;testfeign&quot;)</span><br><span class="line">	private String pub() &#123;</span><br><span class="line">		return stestfeign.version();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置项目启动文件"><a href="#配置项目启动文件" class="headerlink" title="配置项目启动文件"></a>配置项目启动文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">@EnableFeignClients(basePackages = &quot;im.nginx.test&quot;)</span><br><span class="line">#im.nginx.test 为feign interface 文件所在的包</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> feign </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> feign </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot-mybatis-druid整合]]></title>
      <url>/spring-boot-mybatis-druid%E6%95%B4%E5%90%88.html</url>
      <content type="html"><![CDATA[<p>springboot mybatis  druid简单整合</p>
<a id="more"></a>
<h1 id="在eclipse-中创建maven-工程-修改pom-xml-文件"><a href="#在eclipse-中创建maven-工程-修改pom-xml-文件" class="headerlink" title="在eclipse 中创建maven 工程, 修改pom.xml 文件"></a>在eclipse 中创建maven 工程, 修改pom.xml 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  </span><br><span class="line">   &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; </span><br><span class="line"> &lt;/parent&gt;  </span><br><span class="line"> &lt;dependencies&gt; </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.1.5&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;1.3.0&lt;/version&gt; </span><br><span class="line">   &lt;/dependency&gt;  </span><br><span class="line">   &lt;dependency&gt; </span><br><span class="line">     &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">     &lt;scope&gt;runtime&lt;/scope&gt; </span><br><span class="line">   &lt;/dependency&gt; </span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h1 id="在-src-main-resources下创建application-properties"><a href="#在-src-main-resources下创建application-properties" class="headerlink" title="在 src/main/resources下创建application.properties"></a>在 src/main/resources下创建application.properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">server.session.timeout=10</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/service_data?characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#mybatis</span><br><span class="line">mybatis.type-aliases-package=com.we.pojo</span><br><span class="line">mybatis.mapper-locations=classpath*:com/we/mapperxml/*.xml</span><br></pre></td></tr></table></figure>
<h1 id="编写Application-java-类"><a href="#编写Application-java-类" class="headerlink" title="编写Application.java 类"></a>编写Application.java 类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication()</span><br><span class="line">@ComponentScan(&quot;com.we&quot;) #很重要不配  404 </span><br><span class="line">@MapperScan(value = &quot;com.we.mapper&quot;) #很重要</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编写业务逻辑-启动spring-boot"><a href="#编写业务逻辑-启动spring-boot" class="headerlink" title="编写业务逻辑,启动spring boot"></a>编写业务逻辑,启动spring boot</h1><h1 id="druid-sql-监控功能"><a href="#druid-sql-监控功能" class="headerlink" title="druid sql 监控功能"></a>druid sql 监控功能</h1><blockquote>
<p>项目启动后访问 <a href="http://localhost:8088/druid/" target="_blank" rel="noopener">http://localhost:8088/druid/</a> 可以看见登录界面<br>修改默认访问账号密码<br>新建一个java文件  例如：druidConfig.java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class druidConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ServletRegistrationBean druidServlet() &#123;</span><br><span class="line">		ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean();</span><br><span class="line">		servletRegistrationBean.setServlet(new StatViewServlet());</span><br><span class="line">		servletRegistrationBean.addUrlMappings(&quot;/druid/*&quot;);</span><br><span class="line">		Map&lt;String, String&gt; initParameters = new HashMap&lt;String, String&gt;();</span><br><span class="line">		initParameters.put(&quot;loginUsername&quot;, &quot;admin&quot;); // ++监控页面登录用户名</span><br><span class="line">		initParameters.put(&quot;loginPassword&quot;, &quot;admin&quot;); // ++监控页面登录用户密码</span><br><span class="line">		servletRegistrationBean.setInitParameters(initParameters);</span><br><span class="line">		return servletRegistrationBean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这样就可以直接用 admin  admin 进入监控系统</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
            <tag> druid </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/nginx%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p>title: nginx常用基本变量及数据结构<br>tags: [nginx]<br>categories: nginx</p>
<a id="more"></a>
<h1 id="nginx-常用基本变量"><a href="#nginx-常用基本变量" class="headerlink" title="nginx 常用基本变量"></a>nginx 常用基本变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int  ngx_fd_t;</span><br><span class="line">typedef intptr_t        ngx_int_t;</span><br><span class="line">typedef uintptr_t       ngx_uint_t;</span><br><span class="line">typedef intptr_t        ngx_flag_t;</span><br><span class="line">typedef void *          ngx_buf_tag_t;</span><br></pre></td></tr></table></figure>
<h1 id="nginx常用数据结构"><a href="#nginx常用数据结构" class="headerlink" title="nginx常用数据结构"></a>nginx常用数据结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct &#123;</span><br><span class="line">     size_t      len;</span><br><span class="line">     u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br><span class="line"></span><br><span class="line">typedef struct stat  ngx_file_info_t;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ngx_http_conf_get_module_loc_conf 分析]]></title>
      <url>/ngx_http_conf_get_module_loc_conf.html</url>
      <content type="html"><![CDATA[<p>自定义参数处理函数中会用到ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);<br>获取配置块</p>
<a id="more"></a>
<h1 id="ngx-http-conf-get-module-loc-conf"><a href="#ngx-http-conf-get-module-loc-conf" class="headerlink" title="ngx_http_conf_get_module_loc_conf"></a>ngx_http_conf_get_module_loc_conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_http_conf_get_module_loc_conf(cf, module)                         \</span><br><span class="line">    ((ngx_http_conf_ctx_t *) cf-&gt;ctx)-&gt;loc_conf[module.ctx_index]</span><br></pre></td></tr></table></figure>
<h1 id="引出loc-conf初始化函数-ngx-http-block"><a href="#引出loc-conf初始化函数-ngx-http-block" class="headerlink" title="引出loc_conf初始化函数 ngx_http_block"></a>引出loc_conf初始化函数 ngx_http_block</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> *ngx_http_commands 命令集的回调函数 </span><br><span class="line"> *HTTP模块初始化的入口函数 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">static char *  </span><br><span class="line">ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)  </span><br><span class="line">&#123;  </span><br><span class="line">    char                        *rv;  </span><br><span class="line">    ngx_uint_t                   mi, m, s;  </span><br><span class="line">    ngx_conf_t                   pcf;  </span><br><span class="line">    ngx_http_module_t           *module;  </span><br><span class="line">    ngx_http_conf_ctx_t         *ctx;  </span><br><span class="line">    ngx_http_core_loc_conf_t    *clcf;  </span><br><span class="line">    ngx_http_core_srv_conf_t   **cscfp;  </span><br><span class="line">    ngx_http_core_main_conf_t   *cmcf;  </span><br><span class="line">  </span><br><span class="line">    if (*(ngx_http_conf_ctx_t **) conf) &#123;  </span><br><span class="line">        return &quot;is duplicate&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* the main http context */  </span><br><span class="line">  </span><br><span class="line">    /* 分配一块内存，存放http配置上下文 */  </span><br><span class="line">    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t));  </span><br><span class="line">    if (ctx == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    *(ngx_http_conf_ctx_t **) conf = ctx;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* count the number of the http modules and set up their indices */  </span><br><span class="line">  </span><br><span class="line">    /* 计算http模块个数 */  </span><br><span class="line">    ngx_http_max_module = ngx_count_modules(cf-&gt;cycle, NGX_HTTP_MODULE);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* the http main_conf context, it is the same in the all http contexts */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 最外层的HTTP配置 </span><br><span class="line">     * http </span><br><span class="line">      &#123; </span><br><span class="line">      include       mime.types; </span><br><span class="line">      default_type  application/octet-stream; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool,  </span><br><span class="line">                                 sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;main_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null srv_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">    /** </span><br><span class="line">     * server层的配置 </span><br><span class="line">     *   server </span><br><span class="line">  &#123; </span><br><span class="line">    listen       80; </span><br><span class="line">    #server_name  blog.s135.com; </span><br><span class="line">    index index.html index.htm index.php; </span><br><span class="line">    root   /home/wwwroot/; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;srv_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * the http null loc_conf context, it is used to merge </span><br><span class="line">     * the server&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * location 层的配置 </span><br><span class="line">    location ~ .*\.(php|php5)?$ </span><br><span class="line">    &#123; </span><br><span class="line">      #fastcgi_pass  unix:/tmp/php-cgi.sock; </span><br><span class="line">      fastcgi_pass  127.0.0.1:9000; </span><br><span class="line">      fastcgi_index index.php; </span><br><span class="line">      include fcgi.conf; </span><br><span class="line">    &#125; </span><br><span class="line">     */  </span><br><span class="line">    ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module);  </span><br><span class="line">    if (ctx-&gt;loc_conf == NULL) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * create the main_conf&apos;s, the null srv_conf&apos;s, and the null loc_conf&apos;s </span><br><span class="line">     * of the all http modules </span><br><span class="line">     */  </span><br><span class="line">     /** </span><br><span class="line">      * 调用：create_main_conf、create_srv_conf、create_loc_conf </span><br><span class="line">      * 创建配置 </span><br><span class="line">      */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_main_conf) &#123;  </span><br><span class="line">            ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf);  </span><br><span class="line">            if (ctx-&gt;main_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_srv_conf) &#123;  </span><br><span class="line">            ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf);  </span><br><span class="line">            if (ctx-&gt;srv_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;create_loc_conf) &#123;  </span><br><span class="line">            ctx-&gt;loc_conf[mi] = module-&gt;create_loc_conf(cf);  </span><br><span class="line">            if (ctx-&gt;loc_conf[mi] == NULL) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    pcf = *cf;  </span><br><span class="line">    cf-&gt;ctx = ctx;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * preconfiguration 预先初始化配置信息 </span><br><span class="line">     */  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;preconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;preconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* parse inside the http&#123;&#125; block */  </span><br><span class="line">  </span><br><span class="line">    cf-&gt;module_type = NGX_HTTP_MODULE;  </span><br><span class="line">    cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF;  </span><br><span class="line">    rv = ngx_conf_parse(cf, NULL);  </span><br><span class="line">  </span><br><span class="line">    if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">        goto failed;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * init http&#123;&#125; main_conf&apos;s, merge the server&#123;&#125;s&apos; srv_conf&apos;s </span><br><span class="line">     * and its location&#123;&#125;s&apos; loc_conf&apos;s </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 初始化main配置 </span><br><span class="line">     * 合并 server srv_conf </span><br><span class="line">     * 合并location loc_conf </span><br><span class="line">     */  </span><br><span class="line">    cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">    cscfp = cmcf-&gt;servers.elts;  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">        mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index;  </span><br><span class="line">  </span><br><span class="line">        /* init http&#123;&#125; main_conf&apos;s */  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;init_main_conf) &#123;  </span><br><span class="line">            rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]);  </span><br><span class="line">            if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">                goto failed;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        rv = ngx_http_merge_servers(cf, cmcf, module, mi);  </span><br><span class="line">        if (rv != NGX_CONF_OK) &#123;  </span><br><span class="line">            goto failed;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* create location trees */  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 创建 location模块的trees </span><br><span class="line">     */  </span><br><span class="line">    for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) &#123;  </span><br><span class="line">  </span><br><span class="line">        clcf = cscfp[s]-&gt;ctx-&gt;loc_conf[ngx_http_core_module.ctx_index];  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123;  </span><br><span class="line">            return NGX_CONF_ERROR;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123;  </span><br><span class="line">        if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx;  </span><br><span class="line">  </span><br><span class="line">        if (module-&gt;postconfiguration) &#123;  </span><br><span class="line">            if (module-&gt;postconfiguration(cf) != NGX_OK) &#123;  </span><br><span class="line">                return NGX_CONF_ERROR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_variables_init_vars(cf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * http&#123;&#125;&apos;s cf-&gt;ctx was needed while the configuration merging </span><br><span class="line">     * and in postconfiguration process </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /* optimize the lists of ports, addresses and server names */  </span><br><span class="line">  </span><br><span class="line">    /* ngx_http_optimize_servers 初始化listen 端口号 ip地址 服务器等监听信息*/  </span><br><span class="line">    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123;  </span><br><span class="line">        return NGX_CONF_ERROR;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return NGX_CONF_OK;  </span><br><span class="line">  </span><br><span class="line">failed:  </span><br><span class="line">  </span><br><span class="line">    *cf = pcf;  </span><br><span class="line">  </span><br><span class="line">    return rv;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ngx-http-conf-ctx-t"><a href="#ngx-http-conf-ctx-t" class="headerlink" title="ngx_http_conf_ctx_t"></a>ngx_http_conf_ctx_t</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">     void        **main_conf;</span><br><span class="line">     void        **srv_conf;</span><br><span class="line">     void        **loc_conf;</span><br><span class="line"> &#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-args-query-string-uri详解]]></title>
      <url>/nginx-args-query-string-uri%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>Nginx 中常见和url操作相关的变量</p>
<blockquote>
<p>$args<br>$query_string<br>$request_uri<br>$uri<br>$document_uri</p>
</blockquote>
<p>以上变量有什么联系和区别呢?</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url:  http://nginx.im/nginx/im/?page=1</span><br><span class="line">$args -&gt;    page=1</span><br><span class="line">$query_string -&gt; page=1</span><br><span class="line">$request_uri  -&gt; /nginx/im/?page=1</span><br><span class="line">$uri       -&gt;  /nginx/im</span><br><span class="line">$document_uri -&gt; /nginx/im</span><br><span class="line">**总结**</span><br><span class="line">$args &lt;=&gt; $query_string 获取？后面的参数</span><br><span class="line">$request_uri  获取除了host 之外所有的</span><br><span class="line">$uri &lt;=&gt; $cocuemnt_uri 获取请求路径</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> uri </tag>
            
            <tag> query_string </tag>
            
            <tag> request_uri </tag>
            
            <tag> document_uri </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-if指令与全局变量]]></title>
      <url>/nginx-if%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</url>
      <content type="html"><![CDATA[<p>if判断指令<br>语法为if(condition){…}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：</p>
<blockquote>
<p>当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false<br>直接比较变量和内容时，使用=或!=<br>~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配</p>
</blockquote>
<a id="more"></a>
<h1 id="if-常用判断"><a href="#if-常用判断" class="headerlink" title="if 常用判断"></a>if 常用判断</h1><p>-f和!-f用来判断是否存在文件<br>-d和!-d用来判断是否存在目录<br>-e和!-e用来判断是否存在文件或目录<br>-x和!-x用来判断文件是否可执行</p>
<h2 id="if应用"><a href="#if应用" class="headerlink" title="if应用"></a>if应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; //限速，$slow可以通过 set 指令设置</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; //防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nginx-常用全局变量"><a href="#nginx-常用全局变量" class="headerlink" title="nginx 常用全局变量"></a>nginx 常用全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$args ： #这个变量等于请求行中的参数，同$query_string</span><br><span class="line">$is_args : 如果请求带有参数, 值为 ? 否则为空字符串</span><br><span class="line">$content_length ： 请求头中的Content-length字段。</span><br><span class="line">$content_type ： 请求头中的Content-Type字段。</span><br><span class="line">$document_root ： 当前请求在root指令中指定的值。</span><br><span class="line">$host ： 请求主机头字段，否则为服务器名称。</span><br><span class="line">$http_user_agent ： 客户端agent信息</span><br><span class="line">$http_cookie ： 客户端cookie信息</span><br><span class="line">$limit_rate ： 这个变量可以限制连接速率。</span><br><span class="line">$request_method ： 客户端请求的动作，通常为GET或POST。</span><br><span class="line">$remote_addr ： 客户端的IP地址。</span><br><span class="line">$remote_port ： 客户端的端口。</span><br><span class="line">$remote_user ： 已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$scheme ： HTTP方法（如http，https）。</span><br><span class="line">$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</span><br><span class="line">$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</span><br><span class="line">$server_name ： 服务器名称。</span><br><span class="line">$server_port ： 请求到达服务器的端口号。</span><br><span class="line">$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</span><br><span class="line">$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</span><br><span class="line">$document_uri ： 与$uri相同。</span><br><span class="line">$nginx_version： 当前nginx版本</span><br><span class="line">$request: 原始请求 GET /one/2222 HTTP/1.1</span><br><span class="line">$status:  响应状态码</span><br><span class="line">$http_referer: url跳转来源</span><br><span class="line">$request_body : 客户端请求主体</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> if </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx-location正则表达式匹配规则及动静分离]]></title>
      <url>/nginx-location%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<p>nginx，location常用正则表达式，及nginx动静分离<br><a id="more"></a></p>
<h1 id="nginx匹配规则"><a href="#nginx匹配规则" class="headerlink" title="nginx匹配规则"></a>nginx匹配规则</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~      波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~     ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">=      进行普通字符精确匹配</span><br><span class="line">@      &quot;@&quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</span><br><span class="line">!~（!~*） 表示区分大小写不正则匹配和不区分大小写不正则匹配</span><br></pre></td></tr></table></figure>
<h1 id="nginx正则表达式"><a href="#nginx正则表达式" class="headerlink" title="nginx正则表达式"></a>nginx正则表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">. ： 匹配除换行符以外的任意字符</span><br><span class="line">? ： 重复0次或1次</span><br><span class="line">+ ： 重复1次或更多次</span><br><span class="line">* ： 重复0次或更多次</span><br><span class="line">\d ：匹配数字</span><br><span class="line">^ ： 匹配字符串的开始</span><br><span class="line">$ ： 匹配字符串的介绍</span><br><span class="line">&#123;n&#125; ： 重复n次</span><br><span class="line">&#123;n,&#125; ： 重复n次或更多次</span><br><span class="line">[c] ： 匹配单个字符c</span><br><span class="line">[a-z] ： 匹配a-z小写字母的任意一个</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 当正则表达式中含有 {} 是,必须将 正则表达式用 “” 引起来否则会报错<br>nginx: [emerg] pcre_compile() failed: missing ) in “/one/(\d” in /usr/local/nginx/conf/nginx.conf:56</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#rewrite ^/test/([\d]&#123;3&#125;)/$ /index.php?id=$1 break;  #报错</span><br><span class="line">#修改为</span><br><span class="line">rewrite &quot;^/test/([\d]&#123;3&#125;)/$&quot; /index.php?id=$1 break;</span><br><span class="line"></span><br><span class="line">#本条可以不用引号</span><br><span class="line">rewrite ^/(\d+)/$ /index.php?id=$1 break;</span><br></pre></td></tr></table></figure></p>
<h1 id="动静分离清单"><a href="#动静分离清单" class="headerlink" title="动静分离清单"></a>动静分离清单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /web/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /web/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:9000/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> location </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON字符串转换为Map]]></title>
      <url>/json/fastjson.html</url>
      <content type="html"><![CDATA[<p>JSON字符串转换为Map<br><a id="more"></a></p>
<h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zkn.newlearn.json;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class JsonToMapTest01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        String str = &quot;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;&quot;;</span><br><span class="line">        //第一种方式</span><br><span class="line">        Map maps = (Map)JSON.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : maps.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;     &quot; + ((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式</span><br><span class="line">        Map mapTypes = JSON.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类的parseObject来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapTypes.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapTypes.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第三种方式</span><br><span class="line">        Map mapType = JSON.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSON类,指定解析类型，来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object obj : mapType.keySet())&#123;</span><br><span class="line">            System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapType.get(obj));</span><br><span class="line">        &#125;</span><br><span class="line">        //第四种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map json = (Map) JSONObject.parse(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject类的parse方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第五种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map : json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第六种方式</span><br><span class="line">        /**</span><br><span class="line">         * JSONObject是Map接口的一个实现类</span><br><span class="line">         */</span><br><span class="line">        Map mapObj = JSONObject.parseObject(str,Map.class);</span><br><span class="line">        System.out.println(&quot;这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!&quot;);</span><br><span class="line">        for (Object map: json.entrySet())&#123;</span><br><span class="line">            System.out.println(((Map.Entry)map).getKey()+&quot;  &quot;+((Map.Entry)map).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        String strArr = &quot;&#123;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;,&quot; +</span><br><span class="line">                &quot;&#123;\&quot;00\&quot;:\&quot;zhangsan\&quot;,\&quot;11\&quot;:\&quot;lisi\&quot;,\&quot;22\&quot;:\&quot;wangwu\&quot;,\&quot;33\&quot;:\&quot;maliu\&quot;&#125;&#125;&quot;;</span><br><span class="line">       // JSONArray.parse()</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java排列组合随机字符串应用]]></title>
      <url>/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>已知固定长度的字符串字典</p>
<blockquote>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
</blockquote>
<p>按字典序输出固定随机字符串</p>
<a id="more"></a>
<h1 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static String randomChar(String dict, String pre, Integer len) &#123;</span><br><span class="line"></span><br><span class="line">		Integer dictLen = dict.length() - 1;</span><br><span class="line">		char[] preChar = pre.toCharArray();</span><br><span class="line">		char[] chArray = new char[len];</span><br><span class="line">		char achar = preChar[len - 1];</span><br><span class="line">		Integer preCharIndex = dict.indexOf(achar);</span><br><span class="line">		if ((preCharIndex + 1) &gt; dictLen) &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(0);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			chArray[len - 1] = dict.charAt(preCharIndex + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">			Integer preCharIndex1 = dict.indexOf(preChar[i + 1]); // 25</span><br><span class="line">			Integer preCharIndex2 = dict.indexOf(chArray[i + 1]); // 0</span><br><span class="line">			Integer preCharIndex3 = dict.indexOf(preChar[i]); //</span><br><span class="line">			if (Math.abs(preCharIndex1 - preCharIndex2) &gt; 1) &#123;</span><br><span class="line">				if (preCharIndex3 + 1 &gt; dictLen) &#123;</span><br><span class="line">					chArray[i] = dict.charAt(0);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				chArray[i] = dict.charAt(preCharIndex3 + 1);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				chArray[i] = preChar[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return new String(chArray);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 随机字符串 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-zip压缩单文件]]></title>
      <url>/java-zip%E5%8E%8B%E7%BC%A9%E5%8D%95%E6%96%87%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<p>java开发中经常用到压缩文件,在JDK中自带zip 压缩相关的类</p>
<blockquote>
<p>ZipOutputStream<br>ZipEntry</p>
<blockquote>
<p>在压缩文件中，每一个压缩的内容都可以用一个ZipEntry 表示，所以在进行压缩之前必须通过putNextEntry 设置一个ZipEntry 即可。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h1 id="单文件压缩"><a href="#单文件压缩" class="headerlink" title="单文件压缩"></a>单文件压缩</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># in为原始文件的绝对路径</span><br><span class="line">public static void zip(String in) throws Exception &#123;</span><br><span class="line">		File file = new File(in);</span><br><span class="line">		File zipFile = new File(in + &quot;.zip&quot;);</span><br><span class="line">		InputStream input = new FileInputStream(file);</span><br><span class="line">		ZipOutputStream zipOut = null;</span><br><span class="line">		zipOut = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">		zipOut.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">		zipOut.setComment(&quot;这是一个压缩文件&quot;);</span><br><span class="line">		int temp = 0;</span><br><span class="line">		while ((temp = input.read()) != -1) &#123;</span><br><span class="line">			zipOut.write(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">		zipOut.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> zip </tag>
            
            <tag> ZipInputStream </tag>
            
            <tag> ZipFile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java常用的一些代码片段]]></title>
      <url>/java%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<p>收集整理java开放中常用的一些代码片段（长期更新）</p>
<a id="more"></a>
<blockquote>
<p>字符串翻转</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String str)&#123;  </span><br><span class="line">        return new StringBuilder(str).reverse().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>spring 中读取 src/main/resource 下的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void testClassPathResource() throws IOException &#123;</span><br><span class="line">    Resource res = new      ClassPathResource(&quot;resource/ApplicationContext.xml&quot;);</span><br><span class="line">   InputStream input = res.getInputStream();</span><br><span class="line">   Assert.assertNotNull(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file = ResourceUtils.getFile(&quot;classpath:doc&quot;);</span><br><span class="line">str = FileUtils.readFileToString(file, &quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> java常用代码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson解析json字符串]]></title>
      <url>/fastjson%E8%A7%A3%E6%9E%90json%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      <content type="html"><![CDATA[<p>在微服务开发过程中,常要解析json 字符串, 用fastjson解析json 字符串</p>
<a id="more"></a>
<h1 id="获取单个value值"><a href="#获取单个value值" class="headerlink" title="获取单个value值"></a>获取单个value值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;&#123;\&quot;msg\&quot;:\&quot;111\&quot;,\&quot;code\&quot;:200,\&quot;data\&quot;:&#123;\&quot;total\&quot;:15,\&quot;pages\&quot;:8,\&quot;list\&quot;:[&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;,&#123;\&quot;actid\&quot;:1,\&quot;name\&quot;:\&quot;1\&quot;,\&quot;userid\&quot;:1,\&quot;acttype\&quot;:true,\&quot;actbegintime\&quot;:1,\&quot;actendtime\&quot;:1,\&quot;ext\&quot;:\&quot;1\&quot;,\&quot;isactive\&quot;:true,\&quot;remark\&quot;:\&quot;1\&quot;&#125;],\&quot;pageNum\&quot;:1&#125;&#125;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Object test(String str, String key) &#123;</span><br><span class="line">		Map mapTypes = JSON.parseObject(str);</span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		return ((JSONObject) mapTypes).getString(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果json字符串是一个json数组"><a href="#如果json字符串是一个json数组" class="headerlink" title="如果json字符串是一个json数组"></a>如果json字符串是一个json数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;Map&lt;String, Object&gt;&gt; GetJsonList(String str) &#123;</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; retmap = JSON.parseObject(str, new TypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">		return retmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> json </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[error-assignment-to-expression-with-array-type-error]]></title>
      <url>/error-assignment-to-expression-with-array-type-error.html</url>
      <content type="html"><![CDATA[<p>在结构体赋值操作中，编译器报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: assignment to expression with array type error</span><br></pre></td></tr></table></figure></p>
<p>如何才能避免这种错误呢？<br><a id="more"></a></p>
<h1 id="代码现场"><a href="#代码现场" class="headerlink" title="代码现场"></a>代码现场</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        char ss[10];</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        struct test t1;</span><br><span class="line">        t1.a=10;</span><br><span class="line">        t1.b=20;</span><br><span class="line">        t1.ss=&quot;1111111&quot;; # 编译器报错</span><br><span class="line">        printf(&quot;%d, %d, %s\n&quot;, t1.a, t1.b, t1.ss);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把一个字符串赋值给一个字符数组？"><a href="#把一个字符串赋值给一个字符数组？" class="headerlink" title="把一个字符串赋值给一个字符数组？"></a>把一个字符串赋值给一个字符数组？</h2><p>如果我们这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        char s[10]=&quot;ssssss&quot;;</span><br><span class="line">        printf(&quot;%s\n&quot;,s);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序能完美运行。为什么在结构体中是不行的？</p>
<blockquote>
<p>C语言只有在定义字符数组的时候才能用“=”来初始化变量，其它情况下是不能直接用“=”来为字符数组赋值的，<br>结构体中数组成员ss表示数组名，是一个指针，具有常量特性，表示数组存储空间的开始地址，而C语言中不能对常量赋值。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote>
<p>声明字符串时直接赋值<br>用scanf函数给字符串输入值<br>用strcpy函数给字符串赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(t1.ss,&quot;1111111&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7-rc-local不起作用修复]]></title>
      <url>/centos7-rc-local%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E4%BF%AE%E5%A4%8D.html</url>
      <content type="html"><![CDATA[<p>在centos7版本以下的系统中, 尝尝用rc.local 自动启动一些软件. 但是在centos7 中 默认rc.local 是不起作用的, centos7 中把 SysV 替换成  system 。centos7保留了rc.local ,只需要简单的设置就可以开启.</p>
<a id="more"></a>
<h1 id="设置rc-local-权限"><a href="#设置rc-local-权限" class="headerlink" title="设置rc.local 权限"></a>设置rc.local 权限</h1><p>我们在一下目录可以看见rc.local<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.local</span><br><span class="line">/etc/rc.d/rc.local</span><br><span class="line">#/etc/rc.local 是 /etc/rc.d/rc.local的软连接</span><br></pre></td></tr></table></figure></p>
<p>chmod +x /etc/rc.d/rc.local </p>
<h1 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable  rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="启动rc-local-service"><a href="#启动rc-local-service" class="headerlink" title="启动rc-local.service"></a>启动rc-local.service</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start   rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rc-local.service</span><br></pre></td></tr></table></figure>
<h1 id="在-etc-rc-local-编写启动软件指令"><a href="#在-etc-rc-local-编写启动软件指令" class="headerlink" title="在/etc/rc.local 编写启动软件指令"></a>在/etc/rc.local 编写启动软件指令</h1>]]></content>
      
        <categories>
            
            <category> centos7 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos7 </tag>
            
            <tag> rc.local </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The real difference between $host and $http_host]]></title>
      <url>/The-real-difference-between-$host-and-$http_host.html</url>
      <content type="html"><![CDATA[<p>Nginx中$host与$http_host的区别<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The wiki page of &quot;$host&quot; says $host and $host_addr are different only when there is no &quot;Host&quot; header or the &quot;Host&quot; header is empty. But I found when &quot;Host&quot; contains port number, $host never contains the port number while $http_host is equal to the value of &quot;Host&quot; header. </span><br><span class="line"></span><br><span class="line">That is, if &quot;Host: foo:8080&quot;, then </span><br><span class="line">$http_host = foo:8080 </span><br><span class="line">$host = foo </span><br><span class="line"></span><br><span class="line">$http_host是request里的host header </span><br><span class="line">$host是server&#123;&#125;里的server_name里的第一个</span><br><span class="line"></span><br><span class="line">&quot;192.168.160.1&quot; http_host:&quot;192.168.160.159:808&quot; host:&quot;192.168.160.159&quot; &quot;[08/Apr/2016:15:37:06 +0800]&quot; &quot;GET / HTTP/1.1&quot; &quot;304&quot; &quot;0&quot; &quot;171&quot; &quot;-&quot; &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;0.000&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> host </tag>
            
            <tag> http_host </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx启动流程]]></title>
      <url>/Nginx%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>nginx启动流程，从main函数开始,一个重要的结构体ngx_cycle_s</p>
<a id="more"></a>
<h1 id="ngx-cycle-s"><a href="#ngx-cycle-s" class="headerlink" title="ngx_cycle_s"></a>ngx_cycle_s</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0038 struct ngx_cycle_s &#123;</span><br><span class="line">0039     void                  ****conf_ctx;</span><br><span class="line">0040     ngx_pool_t               *pool;</span><br><span class="line">0041 </span><br><span class="line">0042     ngx_log_t                *log;</span><br><span class="line">0043     ngx_log_t                 new_log;</span><br><span class="line">0044 </span><br><span class="line">0045     ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */</span><br><span class="line">0046 </span><br><span class="line">0047     ngx_connection_t        **files;</span><br><span class="line">0048     ngx_connection_t         *free_connections;</span><br><span class="line">0049     ngx_uint_t                free_connection_n;</span><br><span class="line">0050 </span><br><span class="line">0051     ngx_module_t            **modules;</span><br><span class="line">0052     ngx_uint_t                modules_n;</span><br><span class="line">0053     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */</span><br><span class="line">0054 </span><br><span class="line">0055     ngx_queue_t               reusable_connections_queue;</span><br><span class="line">0056     ngx_uint_t                reusable_connections_n;</span><br><span class="line">0057 </span><br><span class="line">0058     ngx_array_t               listening;</span><br><span class="line">0059     ngx_array_t               paths;</span><br><span class="line">0060 </span><br><span class="line">0061     ngx_array_t               config_dump;</span><br><span class="line">0062     ngx_rbtree_t              config_dump_rbtree;</span><br><span class="line">0063     ngx_rbtree_node_t         config_dump_sentinel;</span><br><span class="line">0064 </span><br><span class="line">0065     ngx_list_t                open_files;</span><br><span class="line">0066     ngx_list_t                shared_memory;</span><br><span class="line">0067 </span><br><span class="line">0068     ngx_uint_t                connection_n;</span><br><span class="line">0069     ngx_uint_t                files_n;</span><br><span class="line">0070 </span><br><span class="line">0071     ngx_connection_t         *connections;</span><br><span class="line">0072     ngx_event_t              *read_events;</span><br><span class="line">0073     ngx_event_t              *write_events;</span><br><span class="line">0074 </span><br><span class="line">0075     ngx_cycle_t              *old_cycle;</span><br><span class="line">0076 </span><br><span class="line">0077     ngx_str_t                 conf_file;</span><br><span class="line">0078     ngx_str_t                 conf_param;</span><br><span class="line">0079     ngx_str_t                 conf_prefix;</span><br><span class="line">0080     ngx_str_t                 prefix;</span><br><span class="line">0081     ngx_str_t                 lock_file;</span><br><span class="line">0082     ngx_str_t                 hostname;</span><br><span class="line">0083 &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="填充ngx-cycle-t数据"><a href="#填充ngx-cycle-t数据" class="headerlink" title="填充ngx_cycle_t数据"></a>填充ngx_cycle_t数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">int ngx_cdecl</span><br><span class="line">main(int argc, char *const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_int_t         i;</span><br><span class="line">    ngx_log_t        *log;</span><br><span class="line">    ngx_cycle_t      *cycle, init_cycle;</span><br><span class="line">    ngx_core_conf_t  *ccf;</span><br><span class="line"></span><br><span class="line">    ngx_debug_init();</span><br><span class="line"></span><br><span class="line">    if (ngx_strerror_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 解析命令行参数 */</span><br><span class="line">    if (ngx_get_options(argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 显示版本号与帮助信息 */</span><br><span class="line">    if (ngx_show_version) &#123;</span><br><span class="line">        ngx_write_stderr(&quot;nginx version: &quot; NGINX_VER NGX_LINEFEED);</span><br><span class="line"></span><br><span class="line">        if (ngx_show_help) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">                &quot;Usage: nginx [-?hvVtq] [-s signal] [-c filename] &quot;</span><br><span class="line">                             &quot;[-p prefix] [-g directives]&quot; NGX_LINEFEED</span><br><span class="line">                             NGX_LINEFEED</span><br><span class="line">                &quot;Options:&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -?,-h         : this help&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -v            : show version and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -V            : show version and configure options then exit&quot;</span><br><span class="line">                                   NGX_LINEFEED</span><br><span class="line">                &quot;  -t            : test configuration and exit&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -q            : suppress non-error messages &quot;</span><br><span class="line">                                   &quot;during configuration testing&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -s signal     : send signal to a master process: &quot;</span><br><span class="line">                                   &quot;stop, quit, reopen, reload&quot; NGX_LINEFEED</span><br><span class="line">#ifdef NGX_PREFIX</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: &quot;</span><br><span class="line">                                   NGX_PREFIX &quot;)&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;  -p prefix     : set prefix path (default: NONE)&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">                &quot;  -c filename   : set configuration file (default: &quot;</span><br><span class="line">                                   NGX_CONF_PATH &quot;)&quot; NGX_LINEFEED</span><br><span class="line">                &quot;  -g directives : set global directives out of configuration &quot;</span><br><span class="line">                                   &quot;file&quot; NGX_LINEFEED NGX_LINEFEED</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_show_configure) &#123;</span><br><span class="line">            ngx_write_stderr(</span><br><span class="line">#ifdef NGX_COMPILER</span><br><span class="line">                &quot;built by &quot; NGX_COMPILER NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#if (NGX_SSL)</span><br><span class="line">#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME</span><br><span class="line">                &quot;TLS SNI support enabled&quot; NGX_LINEFEED</span><br><span class="line">#else</span><br><span class="line">                &quot;TLS SNI support disabled&quot; NGX_LINEFEED</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">                &quot;configure arguments:&quot; NGX_CONFIGURE NGX_LINEFEED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!ngx_test_config) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* TODO */ ngx_max_sockets = -1;</span><br><span class="line"></span><br><span class="line">    /* 初始化并更新时间 */</span><br><span class="line">    ngx_time_init();</span><br><span class="line"></span><br><span class="line">#if (NGX_PCRE)</span><br><span class="line">    ngx_regex_init();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ngx_pid = ngx_getpid();</span><br><span class="line"></span><br><span class="line">    /* 初始化日志信息 */</span><br><span class="line">    log = ngx_log_init(ngx_prefix);</span><br><span class="line">    if (log == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* STUB */</span><br><span class="line">#if (NGX_OPENSSL)</span><br><span class="line">    ngx_ssl_init(log);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * init_cycle-&gt;log is required for signal handlers and</span><br><span class="line">     * ngx_process_options()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 全局变量init_cycle清零，并创建改变量的内存池pool */</span><br><span class="line">    ngx_memzero(&amp;init_cycle, sizeof(ngx_cycle_t));</span><br><span class="line">    init_cycle.log = log;</span><br><span class="line">    ngx_cycle = &amp;init_cycle;</span><br><span class="line"></span><br><span class="line">    init_cycle.pool = ngx_create_pool(1024, log);</span><br><span class="line">    if (init_cycle.pool == NULL) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 保存命令行参数至全局变量ngx_os_argv、ngx_argc、ngx_argv */</span><br><span class="line">    if (ngx_save_argv(&amp;init_cycle, argc, argv) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle中的成员：prefix、conf_prefix、conf_file、conf_param 等字段 */</span><br><span class="line">    if (ngx_process_options(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化系统相关变量，如：内存页面大小ngx_pagesize、最大连接数ngx_max_sockets等 */</span><br><span class="line">    if (ngx_os_init(log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /* 初始化 CRC 表（循环冗余校验表） */</span><br><span class="line">    if (ngx_crc32_table_init() != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 通过环境变量NGINX完成socket的继承，将其保存在全局变量init_cycle的listening数组中 */</span><br><span class="line">    if (ngx_add_inherited_sockets(&amp;init_cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化每个模块module的index，并计算ngx_max_module */</span><br><span class="line">    ngx_max_module = 0;</span><br><span class="line">    for (i = 0; ngx_modules[i]; i++) &#123;</span><br><span class="line">        ngx_modules[i]-&gt;index = ngx_max_module++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 初始化全局变量init_cycle ，这里很重要 */</span><br><span class="line">    cycle = ngx_init_cycle(&amp;init_cycle);</span><br><span class="line">    if (cycle == NULL) &#123;</span><br><span class="line">        if (ngx_test_config) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test failed&quot;,</span><br><span class="line">                           init_cycle.conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_test_config) &#123;</span><br><span class="line">        if (!ngx_quiet_mode) &#123;</span><br><span class="line">            ngx_log_stderr(0, &quot;configuration file %s test is successful&quot;,</span><br><span class="line">                           cycle-&gt;conf_file.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 信号处理 */</span><br><span class="line">    if (ngx_signal) &#123;</span><br><span class="line">        return ngx_signal_process(cycle, ngx_signal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_os_status(cycle-&gt;log);</span><br><span class="line"></span><br><span class="line">    ngx_cycle = cycle;</span><br><span class="line"></span><br><span class="line">    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line">    if (ccf-&gt;master &amp;&amp; ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        ngx_process = NGX_PROCESS_MASTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if !(NGX_WIN32)</span><br><span class="line"></span><br><span class="line">    /* 初始化信号，注册相关信号 */</span><br><span class="line">    if (ngx_init_signals(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 若无socket继承，则创建守护进程，并设置守护进程标志 */</span><br><span class="line">    if (!ngx_inherited &amp;&amp; ccf-&gt;daemon) &#123;</span><br><span class="line">        if (ngx_daemon(cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_inherited) &#123;</span><br><span class="line">        ngx_daemonized = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* 记录进程ID */</span><br><span class="line">    if (ngx_create_pidfile(&amp;ccf-&gt;pid, cycle-&gt;log) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ngx_log_redirect_stderr(cycle) != NGX_OK) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (log-&gt;file-&gt;fd != ngx_stderr) &#123;</span><br><span class="line">        if (ngx_close_file(log-&gt;file-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,</span><br><span class="line">                          ngx_close_file_n &quot; built-in log failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_use_stderr = 0;</span><br><span class="line"></span><br><span class="line">    /* 进入进程处理 */</span><br><span class="line">    if (ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">        /* 单进程工作模式 */</span><br><span class="line">        ngx_single_process_cycle(cycle);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* master-worker 多进程模式工作 */</span><br><span class="line">        ngx_master_process_cycle(cycle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言结构体研究]]></title>
      <url>/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%A0%94%E7%A9%B6.html</url>
      <content type="html"><![CDATA[<p>总结一些C语言结构体中常用的知识点</p>
<a id="more"></a>
<h1 id="C-语言结构体之点运算符-和箭头运算符-gt-的区别"><a href="#C-语言结构体之点运算符-和箭头运算符-gt-的区别" class="headerlink" title="C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别"></a>C 语言结构体之点运算符( . )和箭头运算符( -&gt; )的区别</h1><blockquote>
<p>相同点：两者都是二元操作符，而且右边的操作数都是成员的名称。<br>不通点：点运算符( . )的左边操作数是一个结果为结构的表达式；</p>
<blockquote>
<p>箭头运算符( -&gt; )的左边的操作数是一个指向结构体的指针。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct          // 定义一个结构体类型：TEST</span><br><span class="line">&#123;</span><br><span class="line">    int age;            // 结构体成员：age</span><br><span class="line">&#125;TEST;</span><br><span class="line">TEST data;              // 声明一个结构体变量</span><br><span class="line">TEST *pdata;            // 声明一个指向结构体的指针</span><br><span class="line">// 访问数据操作如下：</span><br><span class="line">data.age = 24;          // 结构体变量通过点运算符( . )访问</span><br><span class="line">pdata-&gt;age = 24;        // 指向结构体的指针通过箭头运算符( -&gt; )访问</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struct </tag>
            
            <tag> c </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Faile- to-star- component-Unable-to-register-MBean]]></title>
      <url>/Failed%20to%20start%20component.html</url>
      <content type="html"><![CDATA[<p>部署springboot war包到 tomcat出现以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[]]</span><br><span class="line">Caused by: org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><blockquote>
<p>需要为每个项目配置JMX的域，  修改application.properties中的属性spring.jmx.default-domain=applicationname</p>
</blockquote>
<h1 id="spring-jmx-default-domain"><a href="#spring-jmx-default-domain" class="headerlink" title="spring.jmx.default-domain"></a>spring.jmx.default-domain</h1><blockquote>
<p>解决tomcat同时部署两个SpringBoot应用提示InstanceAlreadyExistsException</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
