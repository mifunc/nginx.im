<!DOCTYPE html>
<html lang="zh-cn">
<head>
<title>http/converting_rewrite_rules-nginx中文手册</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="None"/>
<meta name="keywords" content="example,www,server,org,html"/>
</head>
<body>
<div id="content"><h2>  转换重写规则 </h2><table width="100%"><tbody><tr><td align="left" class="notranslate"> <a href="#converting_mongrel_rules">Converting Mongrel rules</a> <br></td></tr></tbody></table><center><h4>  重定向到主站点 </h4></center><p>  在共享托管生活期间用于<i>仅</i>使用Apache的.htaccess文件配置<i>所有内容</i>的人通常会翻译以下规则： </p><blockquote class="example"><pre class="notranslate">RewriteCond  %{HTTP_HOST}  example.org
RewriteRule  (.*)          http://www.example.org$1
</pre></blockquote><p>  这样的事情： </p><blockquote class="example"><pre class="notranslate">server {
    listen       80;
    server_name  www.example.org  example.org;
    if ($http_host = example.org) {
        rewrite  (.*)  http://www.example.org$1;
    }
    ...
}
</pre></blockquote><p></p><p>  这是一种错误，繁琐且无效的方式。  正确的方法是为<code class="notranslate">example.org</code>定义一个单独的服务器： </p><blockquote class="example"><pre class="notranslate">server {
    listen       80;
    server_name  example.org;
    return       301 http://www.example.org$request_uri;
}

server {
    listen       80;
    server_name  www.example.org;
    ...
}
</pre></blockquote><p></p><blockquote class="note">  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ http://www.example.org$request_uri?;
</pre></blockquote></blockquote><p></p><p>  另一个例子。  而不是“倒置”逻辑“所有不是<code class="notranslate">example.com</code>而不是<code class="notranslate">www.example.com</code> ”： </p><blockquote class="example"><pre class="notranslate">RewriteCond  %{HTTP_HOST}  !example.com
RewriteCond  %{HTTP_HOST}  !www.example.com
RewriteRule  (.*)          http://www.example.com$1
</pre></blockquote><p>  一个人应该简单地定义<code class="notranslate">example.com</code> ， <code class="notranslate">www.example.com</code>和“其他一切”： </p><blockquote class="example"><pre class="notranslate">server {
    listen       80;
    server_name  example.com www.example.com;
    ...
}

server {
    listen       80 default_server;
    server_name  _;
    return       301 http://example.com$request_uri;
}
</pre></blockquote><p></p><blockquote class="note">  在0.9.1之前的版本上，重定向可以使用： <blockquote class="example"><pre class="notranslate">    rewrite      ^ http://example.com$request_uri?;
</pre></blockquote></blockquote><p></p><a name="converting_mongrel_rules"></a><center><h4>  转换Mongrel规则 </h4></center><p>  典型的Mongrel规则： </p><blockquote class="example"><pre class="notranslate">DocumentRoot /var/www/myapp.com/current/public

RewriteCond %{DOCUMENT_ROOT}/system/maintenance.html -f
RewriteCond %{SCRIPT_FILENAME} !maintenance.html
RewriteRule ^.*$ %{DOCUMENT_ROOT}/system/maintenance.html [L]

RewriteCond %{REQUEST_FILENAME} -f
RewriteRule ^(.*)$ $1 [QSA,L]

RewriteCond %{REQUEST_FILENAME}/index.html -f
RewriteRule ^(.*)$ $1/index.html [QSA,L]

RewriteCond %{REQUEST_FILENAME}.html -f
RewriteRule ^(.*)$ $1.html [QSA,L]

RewriteRule ^/(.*)$ balancer://mongrel_cluster%{REQUEST_URI} [P,QSA,L]
</pre></blockquote><p>  应转换为 </p><blockquote class="example"><pre class="notranslate">location / {
    root       /var/www/myapp.com/current/public;

    try_files  /system/maintenance.html
               $uri  $uri/index.html $uri.html
               @mongrel;
}

location @mongrel {
    proxy_pass  http://mongrel;
}
</pre></blockquote><p></p> 
<span></span><div style="display: none;"></div></div>
</body>
</html>