<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IM.NGINX</title>
  
  <subtitle>运维实践</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nginx.im/"/>
  <updated>2018-12-24T09:31:52.653Z</updated>
  <id>http://nginx.im/</id>
  
  <author>
    <name>IM.NGINX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CDN调度器HAProxy、Nginx、Varnish-nginx案例</title>
    <link href="http://nginx.im/nginx/web/the-cdn-scheduler-nginx-haproxy-varnish.html"/>
    <id>http://nginx.im/nginx/web/the-cdn-scheduler-nginx-haproxy-varnish.html</id>
    <published>2018-12-24T09:31:16.357Z</published>
    <updated>2018-12-24T09:31:52.653Z</updated>
    
    <content type="html"><![CDATA[<p>web,the-cdn-scheduler-nginx-haproxy-varnish,<br><a id="more"></a><br>   </p><p>CDN功能如下：<br>1、将全网IP分为若干个IP段组，分组的依据通常是运营商或者地域，目的是让相同网络环境中的用户聚集到相同的组内；<br>2、依据CDN服务器们的网络和容量，确定哪些CDN服务器适合服务哪些IP段组；<br>3、根据以上两步得到的结论，让用户去最适合他的服务器得到服务。</p><p>说白了，就是根据用户不同的来源IP把用户请求重定向到不同的CDN服务器上去。<br>那么，如何实现呢？</p><p>智能DNS是办法之一，稳定可靠且有效。<br>但至少在两个环境下它不能完全满足我们：<br>1、需要特别精细的调度时。由于大多数DNS Server不支持DNS扩展协议，所以拿不到用户的真实IP，只能根据Local DNS来调度。<br>2、访问特别频繁时。由于每次调度都将触发一次DNS，如果请求变得密集，DNS请求本身带来的开销也会相应变大；<br>3、需要根据服务器的带宽容量、连接数、负载情况、当机与否来调度时。由于DNS Server没有CDN节点服务器的信息，这种调度会变得困难。</p><p>这时候我们可以：<br>1、将用户先行引导到某一台或几台统一的服务器上去；<br>2、让它拿到用户的真实IP，计算出服务他的服务器；<br>3、通过HTTP302或其它方式把用户定位到最终服务器上。</p><p>部署在用户先访问到的那几台服务器上，负责定位IP然后重定向用户请求的那个软件，我们叫它“调度器”。</p><p><strong>HAProxy实现：</strong><br>HAProxy不支持形如0.0.0.1-0.8.255.255 cn的IP段表示方法，只支持1.1.4.0/22 “CN”的IP段表示方法。<br>1、我们需要先把IP段转化成它认识的方式；<br>a&gt; 下载iprang.c或者iprang.c本地镜像；<br>b&gt; 编译gcc -s -O3 -o iprange iprange.c；<br>c&gt; 整理IP段列表geo.txt形如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># head geo.txt"1.0.0.0","1.0.0.255","AU""1.0.1.0","1.0.3.255","CN""1.0.4.0","1.0.7.255","AU""1.0.8.0","1.0.15.255","CN""1.0.16.0","1.0.31.255","JP""1.0.32.0","1.0.63.255","CN""1.0.64.0","1.0.127.255","JP""1.0.128.0","1.0.255.255","TH""1.1.0.0","1.1.0.255","CN""1.1.1.0","1.1.1.255","AU"</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>d&gt; 输出HAProxy认识的IP段列表：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># cut -d, -f1,2,5 geo.txt | ./iprange | head1.0.0.0/24 "AU"1.0.1.0/24 "CN"1.0.2.0/23 "CN"1.0.4.0/22 "AU"1.0.8.0/21 "CN"1.0.16.0/20 "JP"1.0.32.0/19 "CN"1.0.64.0/18 "JP"1.0.128.0/17 "TH"1.1.0.0/24 "CN"1.1.1.0/24 "AU"</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>e&gt; 便于管理的目的，将整合后的IP段归类到同一个文件中：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># cut -d, -f1,2,5 geo.txt | ./iprange | sed 's/"//g' | awk -F' ' '{ print $1 &gt;&gt; $2".subnets" }'# ls *.subnetsA1.subnets  AX.subnets  BW.subnets  CX.subnets  FJ.subnets  GR.subnets  IR.subnets  LA.subnets  ML.subnets  NF.subnets  PR.subnets  SI.subnets  TK.subnets  VE.subnets# cat AU.subnets 1.0.0.0/241.0.4.0/221.1.1.0/24</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>f&gt; 把这些文件放到同一个文件夹下，我们以/etc/haproxy/conf/为例。</p><p>2、正确配置HAProxy以这些IP段为规则正确调度；<br>下面是一个haproxy.cfg的例子。配置好后重启Haproxy即可。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>global    log         127.0.0.1 local2 debug    chroot      /var/lib/haproxy    pidfile     /var/run/haproxy.pid    maxconn     8000    user        haproxy    group       haproxy    daemon    stats socket /var/lib/haproxy/statsdefaults    mode                    http    log                     global    option                  httplog    option                  dontlognull    option http-server-close    option forwardfor       except 127.0.0.0/8    option                  <a href="http://www.ttlsa.com/redis/" title="redis" target="_blank">redis</a>patch    retries                 3    timeout http-request    10s    timeout queue           1m    timeout connect         10s    timeout client          1m    timeout server          1m    timeout http-keep-alive 10s    timeout check           10s    maxconn                 8000frontend  main *:5000    acl geo_A1 src -f /etc/haproxy/conf/A1.subnets    acl geo_AX src -f /etc/haproxy/conf/AX.subnets    acl geo_BW src -f /etc/haproxy/conf/BW.subnets    acl geo_CX src -f /etc/haproxy/conf/CX.subnets    acl geo_FJ src -f /etc/haproxy/conf/FJ.subnets    ...    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=A1\ HTTP if geo_A1    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=AX\ HTTP if geo_AX    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=BW\ HTTP if geo_BW    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=CX\ HTTP if geo_CX    reqrep ^([^\ ]*)\ /(.*)\ HTTP    \1\ /\2&amp;ipfrom=FJ\ HTTP if geo_FJ    ...    default_backend             staticbackend static    server      static 127.0.0.1:6081 check</pre></div> </div><!-- [Format Time: 0.0030 seconds] --><p><strong>Nginx实现：</strong><br>Nginx可以在核心模块HttpGeoModule（http://wiki.nginx.org/HttpGeoModule）的配合下实现调度：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http{...geo $useriprang {    ranges;    default a;    0.0.0.1-0.8.255.255 a;    0.9.0.0-0.255.255.255   a;    1.0.0.0-1.0.0.255   a;    1.0.1.0-1.0.1.255   b;    1.0.2.0-1.0.3.255   b;    1.0.4.0-1.0.7.255   a;    ...    223.255.252.0-223.255.253.255   c;    223.255.254.0-223.255.254.255   a;    223.255.255.0-223.255.255.255   a;}upstream backend {    server 127.0.0.1:81;}server {    listen       80;    client_max_body_size 10240m;    location / {        proxy_redirect off;        proxy_pass http://backend$request_uri&amp;useriprang=$useriprang;        proxy_next_upstream http_502 http_504 error timeout invalid_header;        proxy_cache cache_one;        proxy_cache_key $host:$server_port$uri$is_args$args;        expires  5s;    }}...}</pre></div> </div><!-- [Format Time: 0.0012 seconds] --><p><strong>Varnish实现：</strong><br>Varnish则有两个插件可以实现调度：<br>https://github.com/cosimo/varnish-geoip （Last updated: 28/05/2013）<br>https://github.com/meetup/varnish-geoip-plugin （Last updated: 2010）</p><p>性能问题<br>如上所述，使用Haproxy、Nginx、Varnish都能快速实现这个功能。<br>其中Nginx和Varnish使用了二分法在IP表中定位用户IP，而Haproxy是逐条过滤。<br>所以在IP分得较细，IP段组较多（归类后超过1000组）时，Haproxy会出现明显的性能衰减，其余两者没有这个问题。</p><p>其它<br>本文使用的软件版本如下：<br>HAProxy1.4.22，Nginx1.2.9，Varnish3.0.4。<br>HAProxy和Varnish都是目前的最新版本。<br>本文有参考http://blog.exceliance.fr/2012/07/02/use-geoip-database-within-haproxy/<br>转自：http://blog.yikuyiku.com/?p=3851</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web,the-cdn-scheduler-nginx-haproxy-varnish,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>srcache_nginx redis 清除缓存-nginx案例</title>
    <link href="http://nginx.im/nginx/web/srcache_nginx-redis-purge-cache.html"/>
    <id>http://nginx.im/nginx/web/srcache_nginx-redis-purge-cache.html</id>
    <published>2018-12-24T09:31:16.355Z</published>
    <updated>2018-12-24T09:31:52.653Z</updated>
    
    <content type="html"><![CDATA[<p>web,srcache_nginx-redis-purge-cache,<br><a id="more"></a><br>   </p><p>srcache_nginx + redis 缓存方案，我公司业务上用到的比较多。srcache_nginx 模块相关参数介绍，可以参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》。 redis是一种高效的key-value存储。nginx更是被广泛使用的web服务器。srcache_nginx redis 构建缓存系统应用一例可以参见：http://www.ttlsa.com/html/3952.html 。有时，又需要清除缓存。那么缓存该如何清除呢？ 缓存的清除操作与nginx缓存清除大同小异。关于nginx清缓存遇到的问题可以参考下：《nginx purge更新缓存404错误》。看配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>location ~ /purge(/.*) {                set $key $1?$args;                set_md5 $redis_key $key;                redis2_query del $redis_key;                redis2_pass redis;        }</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>测试：</p><p>在删除前，缓存已经存在于redis中</p><p>清缓存操作：</p><p>验证是否还存在于redis中</p><p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/3961.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web,srcache_nginx-redis-purge-cache,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 同一个IP上配置多个HTTPS主机-nginx案例</title>
    <link href="http://nginx.im/nginx/web/multiple-https-host-nginx-with-a-ip-configuration.html"/>
    <id>http://nginx.im/nginx/web/multiple-https-host-nginx-with-a-ip-configuration.html</id>
    <published>2018-12-24T09:31:16.354Z</published>
    <updated>2018-12-24T09:31:52.653Z</updated>
    
    <content type="html"><![CDATA[<p>web,multiple-https-host-nginx-with-a-ip-configuration,<br><a id="more"></a><br>   </p><p>最近公司域名更变，同时，又要新旧域名同时运行。 那么，对于https的域名在同一个IP上如何同时存在多个虚拟主机呢？遂，查看了下nginx手册，有这么一段内容，如下：</p><p>如果在同一个IP上配置多个HTTPS主机，会出现一个很普遍的问题：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>server {    listen          443;    server_name     www.example.com;    ssl             on;    ssl_certificate www.example.com.crt;    ...}server {    listen          443;    server_name     www.example.org;    ssl             on;    ssl_certificate www.example.org.crt;    ...}</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>使用上面的配置，不论浏览器请求哪个主机，都只会收到默认主机www.example.com的证书。这是由SSL协议本身的行为引起的——先建立SSL连接，再发送HTTP请求，所以nginx建立SSL连接时不知道所请求主机的名字，因此，它只会返回默认主机的证书。</p><p>最古老的也是最稳定的解决方法就是每个HTTPS主机使用不同的IP地址：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>server {    listen          192.168.1.1:443;    server_name     www.example.com;    ssl             on;    ssl_certificate www.example.com.crt;    ...}server {    listen          192.168.1.2:443;    server_name     www.example.org;    ssl             on;    ssl_certificate www.example.org.crt;    ...}</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>那么，在同一个IP上，如何配置多个HTTPS主机呢？</p><p>nginx支持TLS协议的SNI扩展（Server Name Indication，简单地说这个扩展使得在同一个IP上可以以不同的证书serv不同的域名）。不过，SNI扩展还必须有客户端的支持，另外本地的OpenSSL必须支持它。</p><p>如果启用了SSL支持，nginx便会自动识别OpenSSL并启用SNI。是否启用SNI支持，是在编译时由当时的 ssl.h 决定的（SSL_CTRL_SET_TLSEXT_HOSTNAME），如果编译时使用的OpenSSL库支持SNI，则目标系统的OpenSSL库只要支持它就可以正常使用SNI了。</p><p>nginx在默认情况下是TLS SNI support disabled。</p><p>启用方法：</p><p>需要重新编译nginx并启用TLS。步骤如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># wget http://www.openssl.org/source/openssl-1.0.1e.tar.gz# tar zxvf openssl-1.0.1e.tar.gz # ./configure --prefix=/usr/local/nginx --with-http_ssl_module \--with-openssl=./openssl-1.0.1e \--with-openssl-opt="enable-tlsext" # make# make install</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>查看是否启用：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># /usr/local/nginx/sbin/nginx -VTLS SNI support enabled</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>这样就可以在 同一个IP上配置多个HTTPS主机了。</p><p>实例如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>server  {        listen 443;        server_name   www.ttlsa.com;        index index.html index.htm index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;        root  /data/wwwroot/www.ttlsa.com/webroot;        ssl on;        ssl_certificate "/usr/local/nginx/conf/ssl/www.ttlsa.com.public.cer";        ssl_certificate_key "/usr/local/nginx/conf/ssl/www.ttlsa.com.private.key";   ......}server  {        listen 443;        server_name   www.heytool.com;        index index.html index.htm index.php;        root  /data/wwwroot/www.heytool.com/webroot;        ssl on;        ssl_certificate "/usr/local/nginx/conf/ssl/www.heytool.com.public.cer";        ssl_certificate_key "/usr/local/nginx/conf/ssl/www.heytool.com.private.key";   ......}</pre></div> </div><!-- [Format Time: 0.0010 seconds] --><p>这样访问每个虚拟主机都正常。</p><p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/4288.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web,multiple-https-host-nginx-with-a-ip-configuration,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>apache和nginx支持SSI配置-nginx案例</title>
    <link href="http://nginx.im/nginx/web/apache-and-nginx-support-ssi-configuration.html"/>
    <id>http://nginx.im/nginx/web/apache-and-nginx-support-ssi-configuration.html</id>
    <published>2018-12-24T09:31:16.353Z</published>
    <updated>2018-12-24T09:31:52.652Z</updated>
    
    <content type="html"><![CDATA[<p>web,apache-and-nginx-support-ssi-configuration<br><a id="more"></a><br>   </p><h3><strong><span>一. 前言</span></strong></h3><p>SSI是一种类似于ASP的基于服务器的网页制作技术。将内容发送到浏览器之前，可以使用“服务器端包含 (SSI）”指令将文本、图形或应用程序信息包含到网页中。例如，可以使用 SSI 包含时间/日期戳、版权声明或供客户填写并返回的表单。对于在多个文件中重复出现的文本或图形，使用包含文件是一种简便的方法。将内容存入一个包含文件中即可，而不必将内容输入所有文件。通过一个非常简单的语句即可调用包含文件，此语句指示 Web 服务器将内容插入适当网页。而且，使用包含文件时，对内容的所有更改只需在一个地方就能完成。<br>因为包含 SSI 指令的文件要求特殊处理，所以必须为所有 SSI 文件赋予 SSI文件扩展名。默认扩展名是 .stm、.shtm 和 .shtml</p><h3><strong>二. apache配置</strong></h3><p>apache默认不支持ssi的，可以在apache下做如下设置：<br>修改Apache配置文件httpd.conf<br>1. 确认加载include.so模块，将注释去掉：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>LoadModule include_module libexec/apache2/mod_include.so</pre></div> </div><!-- [Format Time: 0.0011 seconds] --><p>2. AddType部分去掉这两段注释：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>AddType text/html .shtmlAddOutputFilter INCLUDES .shtml</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>3. Directory目录权限里面找到</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>Options Indexes FollowSymLinks增加Includes修改为：Options Indexes FollowSymLinks Includes</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>4. 重新启动Apache</p><h3><strong>三. nginx配置</strong></h3><p>1. 相关指令说明：<br>ssi<br>语法：ssi [ on | off ]<br>默认值：ssi off<br>配置段段：http, server, location, if<br>启用SSI处理。<br>[warning]注意如果启用SSI，那么Last-Modified头和Content-Length头不会传递。[/warning]</p><p>ssi_silent_errors<br>语法：ssi_silent_errors [on|off]<br>默认值：ssi_silent_errors off<br>配置段：http, server, location<br>如果在处理SSI的过程中出现“[an error occurred while processing the directive]”错误，禁止将其输出。</p><p>ssi_types<br>语法：ssi_types mime-type [mime-type …]<br>默认值：ssi_types text/html<br>配置段：http, server, location<br>默认只解析text/html类型，这个参数可以指定其他的MIME类型。</p><p>ssi_value_length<br>语法：ssi_value_length length<br>默认值：ssi_value_length 256<br>配置段：http, server, location<br>定义允许SSI使用的参数值的长度。</p><p>2. 在nginx下做如下设置：<br><br>如需转载请注明出处：http://www.ttlsa.com/html/3134.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web,apache-and-nginx-support-ssi-configuration&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx map使用方法-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/using-nginx-map-method.html"/>
    <id>http://nginx.im/nginx/nginx/using-nginx-map-method.html</id>
    <published>2018-12-24T09:31:16.349Z</published>
    <updated>2018-12-24T09:31:52.652Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,using-nginx-map-method,<br><a id="more"></a><br>   </p><p>map指令使用ngx_http_map_module模块提供的。默认情况下，nginx有加载这个模块，除非人为的 --without-http_map_module。<br>ngx_http_map_module模块可以创建变量，这些变量的值与另外的变量值相关联。允许分类或者同时映射多个值到多个不同值并储存到一个变量中，map指令用来创建变量，但是仅在变量被接受的时候执行视图映射操作，对于处理没有引用变量的请求时，这个模块并没有性能上的缺失。</p><h3><strong>一. ngx_http_map_module模块指令说明</strong></h3><p>map<br>语法: map $var1 $var2 { ... }<br>默认值: —<br>配置段: http<br>map为一个变量设置的映射表。映射表由两列组成，匹配模式和对应的值。<br>在 map 块里的参数指定了源变量值和结果值的对应关系。<br>匹配模式可以是一个简单的字符串或者正则表达式，使用正则表达式要用('~')。<br>一个正则表达式如果以 “~” 开头，表示这个正则表达式对大小写敏感。以 “~*”开头，表示这个正则表达式对大小写不敏感。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>map $http_user_agent $agent {        default "";        ~curl curl;        ~*apachebench" ab;}</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>正则表达式里可以包含命名捕获和位置捕获，这些变量可以跟结果变量一起被其它指令使用。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>map $uri $value {    /ttlsa_com                   /index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;    ~^/ttlsa_com/(?<suffix>.*)$  /boy/;    ~/fz(/.*)                    /index.php?;                           }</suffix></pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>[warning]不能在map块里面引用命名捕获或位置捕获变量。如~^/ttlsa_com/(.*)  /boy/$1; 这样会报错nginx: [emerg] unknown  variable。[/warning]如果源变量值包含特殊字符如‘~’，则要以‘\’来转义。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>map $http_referer $value {    Mozilla    111;    \~Mozilla  222;}</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>结果变量可以是一个字符串也可以是另外一个变量。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>map $num $limit {          1 $binary_remote_addr;          0 "";}</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>map指令有三个参数：<br>default ： 指定如果没有匹配结果将使用的默认值。当没有设置 default，将会用一个空的字符串作为默认的结果。<br>hostnames ： 允许用前缀或者后缀掩码指定域名作为源变量值。这个参数必须写在值映射列表的最前面。<br>include ： 包含一个或多个含有映射值的文件。</p><p>如果匹配到多个特定的变量，如掩码和正则同时匹配，那么会按照下面的顺序进行选择：<br>1. 没有掩码的字符串<br>2. 最长的带前缀的字符串，例如: “*.example.com”<br>3. 最长的带后缀的字符串，例如：“mail.*”<br>4. 按顺序第一个先匹配的正则表达式 （在配置文件中体现的顺序）<br>5. 默认值</p><p>map_hash_bucket_size<br>语法: map_hash_bucket_size size;<br>默认值: map_hash_bucket_size 32|64|128;<br>配置段: http<br>指定一个映射表中的变量在哈希表中的最大值，这个值取决于处理器的缓存。</p><p>map_hash_max_size<br>语法: map_hash_max_size size;<br>默认值: map_hash_max_size 2048;<br>配置段: http<br>设置映射表对应的哈希表的最大值。</p><h3><strong>二. 实例</strong></h3><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http {map $http_user_agent $agent {~curl curl;~*chrome chrome;}server {        listen       8080;        server_name  test.ttlsa.com;        location /hello {default_type text/plain;echo http_user_agent: $http_user_agent;echo agent: agent:$agent;}}}# curl 127.0.0.1:8080/hello  http_user_agent: curl/7.15.5 (x86_64-redhat-<a href="http://www.ttlsa.com/linux/" title="linux" target="_blank">linux</a>-gnu) libcurl/7.15.5 OpenSSL/0.9.8b zlib/1.2.3 libidn/0.6.5agent: curl</pre></div> </div><!-- [Format Time: 0.0009 seconds] --><p><br></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http {map $uri $match {        ~^/hello/(.*) http://www.ttlsa.com/;}server {        listen       8080;        server_name  test.ttlsa.com;        location /hello {                default_type text/plain;                echo uri: $uri;                echo match: $match;                echo capture: $1;                echo new: $match$1;        }}}</pre></div> </div><!-- [Format Time: 0.0008 seconds] --><p>如需转载请注明出处：http://www.ttlsa.com/html/3206.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,using-nginx-map-method,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx geo使用方法-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/using-nginx-geo-method.html"/>
    <id>http://nginx.im/nginx/nginx/using-nginx-geo-method.html</id>
    <published>2018-12-24T09:31:16.348Z</published>
    <updated>2018-12-24T09:31:52.651Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,using-nginx-geo-method,<br><a id="more"></a><br>   </p><p><span>geo指令使用ngx_http_geo_module模块提供的。默认情况下，nginx有加载这个模块，除非人为的 --without-http_geo_module。</span><br>ngx_http_geo_module模块可以用来创建变量，其值依赖于客户端IP地址。</p><h3><strong>geo指令</strong></h3><p>语法: geo [$address] $variable { ... }<br>默认值: —<br>配置段: http<br>定义从指定的变量获取客户端的IP地址。默认情况下，nginx从$remote_addr变量取得客户端IP地址，但也可以从其他变量获得。如</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>geo $remote_addr $geo {        default 0;        127.0.0.1 1;}geo $arg_ttlsa_com $geo {        default 0;        127.0.0.1 1;}</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>如果该变量的值不能代表一个合法的IP地址，那么nginx将使用地址“255.255.255.255”。<br>nginx通过CIDR或者地址段来描述地址，支持下面几个参数：<br>delete：删除指定的网络<br>default：如果客户端地址不能匹配任意一个定义的地址，nginx将使用此值。 如果使用CIDR，可以用“0.0.0.0/0”代替default。<br>include： 包含一个定义地址和值的文件，可以包含多个。<br>proxy：定义可信地址。 如果请求来自可信地址，nginx将使用其“X-Forwarded-For”头来获得地址。 相对于普通地址，可信地址是顺序检测的。<br>proxy_recursive：开启递归查找地址。 如果关闭递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中的最后一个地址来代替原始客户端地址。如果开启递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中最后一个与所有可信地址都不匹配的地址来代替原始客户端地址。<br>ranges：使用以地址段的形式定义地址，这个参数必须放在首位。为了加速装载地址库，地址应按升序定义。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>geo $country {    default        ZZ;    include        conf/geo.conf;    delete         127.0.0.0/16;    proxy          192.168.100.0/24;    proxy          2001:0db8::/32;    127.0.0.0/24   US;    127.0.0.1/32   RU;    10.1.0.0/16    RU;    192.168.1.0/24 UK;}vim conf/geo.conf10.2.0.0/16    RU;192.168.2.0/24 RU;</pre></div> </div><!-- [Format Time: 0.0007 seconds] --><p>地址段例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>geo $country {    ranges;    default                   ZZ;    127.0.0.0-127.0.0.0       US;    127.0.0.1-127.0.0.1       RU;    127.0.0.1-127.0.0.255     US;    10.1.0.0-10.1.255.255     RU;    192.168.1.0-192.168.1.255 UK;}</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>[warning]遵循最精确匹配原则，即nginx使用能最精确匹配客户端地址的值。[/warning]</p><h3><strong>适用实例</strong></h3><p>上面的例子几乎都是官网说明例子。下面举例说明便于理解该指令的用法。<br>1. 使用默认变量也就是$remote_addr</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http {#geo $remote_addr $ttlsa_com {geo $ttlsa_com {        default 0;        127.0.0.1 1;}server {        listen       8080;        server_name  test.ttlsa.com;        location /hello {default_type text/plain;echo $ttlsa_com;echo $arg_boy;}}}# curl 127.0.0.1:8080/hello?boy=默北1默北</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>2. 使用指定变量</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http {geo $arg_boy $ttlsa_com {        default 0;        127.0.0.1 1;        8.8.8.8 2;}server {        listen       8080;        server_name  test.ttlsa.com;        location /hello {default_type text/plain;echo $ttlsa_com;echo $arg_boy;}}}# curl 127.0.0.1:8080/hello?boy=8.8.8.828.8.8.8</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>3. 匹配原则</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>http {geo $arg_boy $ttlsa_com {        default 0;        127.0.0.1/24 24;        127.0.0.1/32 32;        8.8.8.8 2;}server {        listen       8080;        server_name  test.ttlsa.com;        location /hello {default_type text/plain;echo $ttlsa_com;echo $arg_boy;}}}# curl 127.0.0.1:8080/hello?boy=127.0.0.132127.0.0.1# curl 127.0.0.1:8080/hello?boy=127.0.0.1224127.0.0.12</pre></div> </div><!-- [Format Time: 0.0007 seconds] --><p>[warning]geo指令主要是根据IP来对变量进行赋值的。因此geo块下只能定义IP或网络段，否则会报错“nginx: [emerg] invalid network”。[/warning]</p><p>如需转载请注明出处：http://www.ttlsa.com/html/3203.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,using-nginx-geo-method,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>搭建nginx反向代理用做内网域名转发-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/use-nginx-proxy.html"/>
    <id>http://nginx.im/nginx/nginx/use-nginx-proxy.html</id>
    <published>2018-12-24T09:31:16.347Z</published>
    <updated>2018-12-24T09:31:52.665Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,use-nginx-proxy,<br><a id="more"></a><br>   </p><h3><strong>情景</strong></h3><p>由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。并且公司入口路由最多只能做20个端口映射。肯定以后不够用。<br>然后k兄就提议可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p><p>涉及的知识：nginx编译安装，nginx反向代理基本配置，路由端口映射知识，还有网络域名等常识。</p><p>本次实验目标是做到：在浏览器中输入xxx123.tk能访问到内网机器192.168.10.38的3000端口，输入xxx456.tk能访问到内网机器192.168.10.40的80端口。</p><h3><strong>配置步骤</strong></h3><p>服务器ubuntu 12.04</p><p><span>###更新仓库</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>apt-get update -yapt-get install wget -y</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p><span>#下载nginx和相关软件包</span></p><p>pcre是为了编译rewrite模块，zlib是为了支持gzip功能。额，这里nginx版本有点旧，因为我还要做升级nginx的实验用。大家可以装新版本。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>cd /usr/local/src wget <a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.33.tar.gz" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.33.tar.gz</a> wget <a href="http://zlib.net/zlib-1.2.8.tar.gz" target="_blank" rel="noopener">http://zlib.net/zlib-1.2.8.tar.gz</a> wget <a href="http://nginx.org/download/nginx-1.4.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.4.2.tar.gz</a> tar xf pcre-8.33.tar.gz tar xf zlib-1.2.8.tar.gz</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p><span>#安装编译环境</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre> apt-get install build-essential libtool -y</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p><span>#创建nginx用户</span></p><p>所谓的unprivileged user</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>useradd -s /bin/false -r -M -d /nonexistent www</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p><span>#开始编译安装</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>/configure --with-pcre=/usr/local/src/pcre-8.33 --with-zlib=/usr/local/src/zlib-1.2.8 --user=www --group=www \ --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module make make install</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p><span>#给文件夹授权</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>chown -R www:www /usr/local/nginx</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p><span>#修改配置文件</span><br>vim nginx.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>user www www;worker_processes 1;error_log logs/error.log;pid logs/nginx.pid;worker_rlimit_nofile 65535;events {    use epoll;    worker_connections 65535;}http {    include mime.types;    default_type application/octet-stream;    include /usr/local/nginx/conf/reverse-proxy.conf;    sendfile on;    keepalive_timeout 65;    gzip on;    client_max_body_size 50m; #缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到本地再传给用户    client_body_buffer_size 256k;    client_header_timeout 3m;    client_body_timeout 3m;    send_timeout 3m;    proxy_connect_timeout 300s; #nginx跟后端服务器连接超时时间(代理连接超时)    proxy_read_timeout 300s; #连接成功后，后端服务器响应时间(代理接收超时)    proxy_send_timeout 300s;    proxy_buffer_size 64k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小    proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置    proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘    proxy_ignore_client_abort on; #不允许代理端主动关闭连接    server {        listen 80;        server_name localhost;        location / {            root html;            index index.html index.htm;        }        error_page 500 502 503 504 /50x.html;        location = /50x.html {            root html;        }    }}</pre></div> </div><!-- [Format Time: 0.0018 seconds] --><p>编辑反向代理服务器配置文件：<br>vim /usr/local/nginx/conf/reverse-proxy.conf</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>server{    listen 80;    server_name xxx123.tk;    location / {        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://192.168.10.38:3000;    }    access_log logs/xxx123.tk_access.log;}server{    listen 80;    server_name xxx456.tk;    location / {        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://192.168.10.40:80;    }    access_log logs/xxx456.tk_access.log;}</pre></div> </div><!-- [Format Time: 0.0012 seconds] --><p>然后重新加载nginx配置文件，使之修改生效，再把xxx123.tk域名指向公司静态IP，这样就成功的做到了在浏览器中输入xxx123.tk的时候访问的内网服务器192.168.10.38的3000端口,输入xxx456.tk访问192.168.10.40的80端口的作用。<br>如果想对后端机器做负载均衡，像下面这配置就可以把对nagios.xxx123.tk的请求分发给内网的131和132这两台机器做负载均衡了。</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>upstream monitor_server {    server 192.168.0.131:80;        server 192.168.0.132:80;}server{    listen 80;    server_name nagios.xxx123.tk;    location / {        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;         proxy_pass http://monitor_server;    }    access_log logs/nagios.xxx123.tk_access.log;}</pre></div> </div><!-- [Format Time: 0.0008 seconds] --><p>额，关于负载均衡和缓存就不多说了，这里只是要起到一个简单的“域名转发”功能。<br>另外，由于http请求最后都是由反向代理服务器传递给后段的机器，所以后端的机器原来的访问日志记录的访问IP都是反向代理服务器的IP。<br>要想能记录真实IP，需要修改后端机器的日志格式，这里假设后端也是一台nginx：<br>在后端配置文件里面加入这一段即可：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>log_format access '$HTTP_X_REAL_IP - $remote_user [$time_local] "$request" ''$status $body_bytes_sent "$http_referer" ''"$http_user_agent" $HTTP_X_Forwarded_For';access_log logs/access.log access;</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>再看看原来日志的格式长什么样：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>#log_format main '$remote_addr - $remote_user [$time_local] "$request" '# '$status $body_bytes_sent "$http_referer" '# '"$http_user_agent" "$http_x_forwarded_for"';#access_log logs/access.log main;</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>看出区别了吧</p><p> </p><h3><strong>遇到的问题</strong></h3><p> </p><ul><li>之前没配置下面这段，访问时候偶尔会出现504 gateway timeout，由于偶尔出现，所以不太好排查</li></ul><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    proxy_connect_timeout 300s;    proxy_read_timeout 300s;    proxy_send_timeout 300s;    proxy_buffer_size 64k;    proxy_buffers 4 32k;    proxy_busy_buffers_size 64k;    proxy_temp_file_write_size 64k;    proxy_ignore_client_abort on;</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>报错日志：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>...upstream timed out (110: Connection timed out) while reading response header from upstream, client: ...(后面的省略）</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>从日志看来是连接超时了，网上一通乱查之后估计可能是后端服务器响应超时了，本着大胆假设，小心求证的原则，既然假设了错误原因就要做实验重现错误：那就调整代理超时参数，反过来把代理超时阀值设小（比如1ms）看会不会次次出现504。后来发现把proxy_read_timeout 这个参数设置成1ms的时候，每次访问都出现504。于是把这个参数调大，加入上面那段配置，解决问题了。</p><p>有问题可以直接EMAIL作者，当然也可以加入我们ttlsa群单独私聊或者群里发提问。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,use-nginx-proxy,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ttserver+nginx构建高并发高可用性应用-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/ttserver-nginx-1429.html"/>
    <id>http://nginx.im/nginx/nginx/ttserver-nginx-1429.html</id>
    <published>2018-12-24T09:31:16.346Z</published>
    <updated>2018-12-24T08:18:44.486Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,ttserver-nginx-1429,<br><a id="more"></a><br></p><p>ttserver+nginx构建高并发高可用性应用</p><p>ttserver一款兼容memcached协议，也可以通过HTTP协议进行数据交换，支持故障转移，高可用性，高并发的分布式key-value持久存储系统。key-value分布式存储系统的特点是查询快，存储数量大，高并发，非常适合通过主键进行查询的操作。</p><p>下面的案例是将图片以二进制的方式存入到ttserver中，并通过http方式读取图片。</p><p>一.配置nginx</p><p>nginx_upstream_check_module模块地址： https://github.com/yaoweibin/nginx_upstream_check_module</p><p>nginx需要添加nginx_upstream_check_module模块，用于对后端服务器的健康情况检测，如果后端服务器不可用，则把这台服务器移除负载均衡轮循集群，所有的请求不往这台服务器上转发，待这台服务器恢复正常后，再把这台加入到负载均衡集群。这是LB的基本功能。</p><pre># vi nginx.confuser www-data;worker_processes 8;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;error_log /var/log/nginx/error.log crit;pid /var/run/nginx.pid;worker_rlimit_nofile 65535;events {use epoll;worker_connections 65535;}http {include /etc/nginx/mime.types;default_type application/octet-stream;server_tokens off;access_log off;sendfile on;tcp_nopush on;keepalive_timeout 0;tcp_nodelay on;client_max_body_size 200m;gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 5;gzip_disable "MSIE [1-6]\.(?!.*SV1)";gzip_types text/plain application/x-javascript text/css application/xml text/javascript;include /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*;}</pre><pre># vi defaultserver {listen 80;server_name 192.168.1.213;memcached_connect_timeout 1s;location / {root /www/web/tmp;error_page 404 = @fallback;}location ~ ^/ttlsa/ttlsa_([0-9a-zA-Z]\.+)$ {set $memcached_key $1; //memcached键值add_header X-ttserver-key $memcached_key; //添加一个header信息memcached_pass ttserver;memcached_next_upstream error timeout; //当发生错误或超时时，将请求转发到upstream下一个服务器default_type text/html;error_page 404 = @fallback;}location @fallback {rewrite ^ http://www.ttlsa.com redirect;}}</pre><pre># vi upstream.confupstream ttserver {server 192.168.1.60:1978;server 192.168.1.60:1979;check interval=3000 rise=2 fall=2 timeout=1000; //interval检测周期3s一次，fall宕机标记2次失败后标记不可用}</pre><p>二.配置ttserver</p><p>需要将ttserver配置成主主结构。</p><p>ttserver的介绍，安装，配置参见： http://www.ttlsa.com/html/1220.html</p><p>三.测试</p><p>1.上传界面</p><pre># vi upload.php&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;title&gt;Upload Files&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Select files to upload&lt;/h2&gt;&lt;form enctype="multipart/form-data" action="/store.php" method="post"&gt;&lt;input type="file" name="file"&gt;&lt;br&gt;&lt;input type="submit" name="submit" value="Upload"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>2.存入ttserver</p><pre># vi store.php&lt;?phpprint_r($_FILES);echo "&lt;br&gt;";if($_FILES['file']['error'] !== 0){die('Error upload file. Error code '.$_FILES['file']['error']);}$filename=$_FILES['file']['name'];$tmpfilepath=$_FILES['file']['tmp_name'];$content=file_get_contents($tmpfilepath);echo '&lt;img src="data:image/jpeg;base64,', base64_encode($content), '"/&gt;';echo "&lt;br&gt;";$ttserver=new Memcache;$ttserver-&gt;addServer('192.168.1.60',1978);$ttserver-&gt;addServer('192.168.1.60',1979);$rt=$ttserver-&gt;set($filename,$content,0,0);if($rt){echo "存储成功!\n";}else{echo "存储失败!\n";}?&gt;</pre><p>3.结果截图</p><p>上传图片：</p><p></p><p>通过HTTP从ttserver中取图片：</p><p></p><p>存在问题：</p><p>1.二进制传输问题： 二进制数据通过非纯8-bit的传输层传输时，会出现错误。最好是经过base64_encode编码后再传输。</p><p>2.序列化问题： Tokyo Tyrant使用memcached协议连接，用php的memcached客户端读取时不会自动反序列化。可使用unserialize()函数进行反序列化操作。此问题稍后再议。</p><p>表情图片，用户头像等等场景都可以使用此种方案。比如以用户ID号作为键值等等。</p><p>如需转载请注明出处： http://www.ttlsa.com/html/1429.html</p><div></div><div><span></span></div><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,ttserver-nginx-1429,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>srcache_nginx redis 构建缓存系统应用一例-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/to-build-an-application-cache-system-of-srcache_nginx-redis.html"/>
    <id>http://nginx.im/nginx/nginx/to-build-an-application-cache-system-of-srcache_nginx-redis.html</id>
    <published>2018-12-24T09:31:16.344Z</published>
    <updated>2018-12-24T09:31:52.650Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,to-build-an-application-cache-system-of-srcache_nginx-redis,<br><a id="more"></a><br>   </p><p>srcache_nginx模块相关参数介绍，可以参见《memc_nginx+srcache_nginx+memcached构建透明的动态页面缓存》。 redis是一种高效的key-value存储。</p><p>下面举一例应用，看配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>upstream <a href="http://www.ttlsa.com/redis/" title="redis" target="_blank">redis</a> {server 127.0.0.1:6380;keepalive 512;}server {listen       80 backlog=1024 default;server_name  www.ttlsa.com;index index.html index.htm index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>;root  /data/wwwroot/www.ttlsa.com/webroot;location / {set $flag 0;if ($uri ~ /thumb/[0-9]+_160.jpg$){set $flag "${flag}1";}if ($arg_unitid = 42012){set $flag "${flag}1";}if (!-e $request_filename) {rewrite ^/(.*)$ /index.php?kohana_uri=$1 last;}}location ~ .*\.php?$ {srcache_store_private on;srcache_methods GET;srcache_response_cache_control off;if ($flag = "011"){set $key $request_uri;set_escape_uri $escaped_key $key;srcache_fetch GET /redis $key;srcache_default_expire 172800;srcache_store PUT /redis2 key=$escaped_key&amp;exptime=$srcache_expire;add_header X-flag $flag;add_header X-Cached-From $srcache_fetch_status;add_header X-Cached-Store $srcache_store_status;add_header X-Key $key;set_md5 $md5key $key;add_header X-md5-key $md5key;add_header X-Query_String $query_string;add_header X-expire $srcache_expire;}include fastcgi_params;fastcgi_pass  127.0.0.1:10080;fastcgi_index index.php;fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 128k;fastcgi_buffers 4 256k;fastcgi_busy_buffers_size 256k;fastcgi_temp_file_write_size 256k;fastcgi_intercept_errors on;fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;}location = /redis {internal;set_md5 $redis_key $args;redis_pass redis;}location = /redis2 {internal;set_unescape_uri $exptime $arg_exptime;set_unescape_uri $key $arg_key;set_md5 $key;redis2_query set $key $echo_request_body;redis2_query expire $key $exptime;redis2_pass redis;}}</pre></div> </div><!-- [Format Time: 0.0037 seconds] --><p>测试：</p><p>redis实例下：</p><p>可以记录下日志来测试加缓存前后的耗时。日志格式如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>log_format srcache_log '$remote_addr - $remote_user [$time_local] "$request" '                                '"$status" $body_bytes_sent $request_time $bytes_sent $request_length '                                '[$upstream_response_time] [$srcache_fetch_status] [$srcache_store_status] [$srcache_expire]';</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>转载请注明来自运维生存时间: http://www.ttlsa.com/html/3952.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,to-build-an-application-cache-system-of-srcache_nginx-redis,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ngx_http_headers_module模块add_header和expires指令-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/the-ngx_http_headers_module-module-add_header-and-expires-instructions.html"/>
    <id>http://nginx.im/nginx/nginx/the-ngx_http_headers_module-module-add_header-and-expires-instructions.html</id>
    <published>2018-12-24T09:31:16.343Z</published>
    <updated>2018-12-24T09:31:52.649Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,the-ngx_http_headers_module-module-add_header-and-expires-instructions,<br><a id="more"></a><br>   </p><h3><strong><span>一. 前言</span></strong></h3><p>ngx_http_headers_module模块提供了两个重要的指令add_header和expires，来添加 “Expires” 和 “Cache-Control” 头字段，对响应头添加任何域字段。add_header可以用来标示请求访问到哪台服务器上，这个也可以通过nginx模块nginx-http-footer-filter研究使用来实现。expires指令用来对浏览器本地缓存的控制。</p><h3><strong>二. add_header指令</strong></h3><p>语法: add_header name value;<br>默认值: —<br>配置段: http, server, location, if in location<br>对响应代码为200，201，204，206，301，302，303，304，或307的响应报文头字段添加任意域。如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>add_header From ttlsa.com</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><h3><strong>三. expires指令</strong></h3><p>语法: expires [modified] time;<br>expires epoch | max | off;<br>默认值: expires off;<br>配置段: http, server, location, if in location<br>在对响应代码为200，201，204，206，301，302，303，304，或307头部中是否开启对“Expires”和“Cache-Control”的增加和修改操作。<br>可以指定一个正或负的时间值，Expires头中的时间根据目前时间和指令中指定的时间的和来获得。</p><p>epoch表示自1970年一月一日00:00:01 GMT的绝对时间，max指定Expires的值为2037年12月31日23:59:59，Cache-Control的值为10 years。<br>Cache-Control头的内容随预设的时间标识指定：<br>·设置为负数的时间值:Cache-Control: no-cache。<br>·设置为正数或0的时间值：Cache-Control: max-age = #，这里#的单位为秒，在指令中指定。<br>参数off禁止修改应答头中的"Expires"和"Cache-Control"。</p><p>实例一：对图片，flash文件在浏览器本地缓存30天</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {           expires 30d; }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>实例二：对js，css文件在浏览器本地缓存1小时</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>location ~ .*\.(js|css)$ {            expires 1h; }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>如需转载请注明出处：http://www.ttlsa.com/html/3068.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,the-ngx_http_headers_module-module-add_header-and-expires-instructions,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ngx_http_core_module模块提供的变量-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/the-ngx_http_core_module-module-provides-variable.html"/>
    <id>http://nginx.im/nginx/nginx/the-ngx_http_core_module-module-provides-variable.html</id>
    <published>2018-12-24T09:31:16.342Z</published>
    <updated>2018-12-24T09:31:52.648Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,the-ngx_http_core_module-module-provides-variable,<br><a id="more"></a><br>   </p><p><span>ngx_http_core_module模块在处理请求时，会有大量的变量，这些变量可以通过访问日志来记录下来，也可以用于其它nginx模块。在我们对请求做策略如改写等等都会使用到一些变量，顺便对ngx_http_core_module模块提供的变量总结了下，如下所示：</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>参数名称注释$arg_PARAMETERHTTP 请求中某个参数的值，如/index.<a href="http://www.ttlsa.com/php/" title="php" target="_blank">php</a>?site=www.ttlsa.com，可以用$arg_site取得www.ttlsa.com这个值.$args HTTP请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中，$args表示字符串width=400&amp;height=200.$binary_remote_addr二进制格式的客户端地址。例如：\x0A\xE0B\x0E$body_bytes_sent表示在向客户端发送的http响应中，包体部分的字节数$content_length表示客户端请求头部中的Content-Length 字段$content_type表示客户端请求头部中的Content-Type 字段$cookie_COOKIE表示在客户端请求头部中的cookie 字段$document_root表示当前请求所使用的root 配置项的值$uri表示当前请求的URI，不带任何参数$document_uri与$uri 含义相同$request_uri表示客户端发来的原始请求URI，带完整的参数。$uri和$document_uri未必是用户的原始请求，在内部重定向后可能是重定向后的URI，而$request_uri 永远不会改变，始终是客户端的原始URI.$host表示客户端请求头部中的Host字段。如果Host字段不存在，则以实际处理的server（虚拟主机）名称代替。如果Host字段中带有端口，如IP:PORT，那么$host是去掉端口的，它的值为IP。$host 是全小写的。这些特性与http_HEADER中的http_host不同，http_host只取出Host头部对应的值。 $hostname表示 Nginx所在机器的名称，与 gethostbyname调用返回的值相同  $http_HEADER表示当前 HTTP请求中相应头部的值。HEADER名称全小写。例如，示请求中 Host头部对应的值 用 $http_host表 $sent_http_HEADER表示返回客户端的 HTTP响应中相应头部的值。HEADER名称全小写。例如，用 $sent_ http_content_type表示响应中 Content-Type头部对应的值  $is_args表示请求中的 URI是否带参数，如果带参数，$is_args值为 ?，如果不带参数，则是空字符串  $limit_rate表示当前连接的限速是多少，0表示无限速  $nginx_version表示当前 Nginx的版本号 $query_string请求 URI中的参数，与 $args相同，然而 $query_string是只读的不会改变  $remote_addr表示客户端的地址  $remote_port表示客户端连接使用的端口  $remote_user表示使用 Auth Basic Module时定义的用户名  $request_filename表示用户请求中的 URI经过 root或 alias转换后的文件路径  $request_body表示 HTTP请求中的包体，该参数只在 proxy_pass或 fastcgi_pass中有意义  $request_body_file表示 HTTP请求中的包体存储的临时文件名  $request_completion当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用 HTTP range访问的并不是文件的最后一块，那么其值也是空字符串。$request_method表示 HTTP请求的方法名，如 GET、PUT、POST等  $scheme表示 HTTP scheme，如在请求 https://nginx.com/中表示 https  $server_addr表示服务器地址  $server_name表示服务器名称  $server_port表示服务器端口  $server_protocol表示服务器向客户端发送响应的协议，如 HTTP/1.1或 HTTP/1.0</pre></div> </div><!-- [Format Time: 0.0029 seconds] --><p>如需转载请注明出处：http://www.ttlsa.com/html/2912.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,the-ngx_http_core_module-module-provides-variable,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>perl + fastcgi + nginx搭建-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/perl-fastcgi-nginx.html"/>
    <id>http://nginx.im/nginx/nginx/perl-fastcgi-nginx.html</id>
    <published>2018-12-24T09:31:16.340Z</published>
    <updated>2018-12-24T09:31:52.664Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,perl-fastcgi-nginx,<br><a id="more"></a><br>   </p><p>nginx + fastcgi是php下最流行的一套环境了，那perl会不会也有fastcgi呢，当然有，今天来搭建下nginx下perl的fastcgi.性能方面也不亚于php，但是现在web程序php的流行程度perl无法比拟了，性能再好也枉然，但是部分小功能可以考虑使用perl的fastcgi来搞定.进入正题.</p><h2>1. 准备软件环境：</h2><p>nginx：http://www.nginx.org<br>perl：系统自带<br>fastcgi：http://www.cpan.org/modules/by-module/FCGI/</p><p>1.1 nginx安装<br>nginx安装过无数次,这边不在重复安装过程,如果你还没有安装nginx并且不知道怎么安装nginx，那么请先参考之前的文章《nginx安装配置》</p><p>1.2 perl安装<br>一般linux都有自带perl，可以不用安装，如果确实没有，请执行：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># yum install perl</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>1.3 perl-fastcgi安装</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># cd /usr/local/src# wget http://www.cpan.org/modules/by-module/FCGI/FCGI-0.74.tar.gz# tar -xzvf FCGI-0.74.tar.gz# cd FCGI-0.74# perl Makefile.PL # make# make install</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><h2>2. nginx虚拟主机配置</h2><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>server {        listen       80;        server_name  test.ttlsa.com;        #access_log  /data/logs/nginx/test.ttlsa.com.access.log  main;        index index.html index.php index.html;        root /data/site/test.ttlsa.com;        location /         {        }        location ~ \.pl$         {            include fastcgi_params;            fastcgi_pass  127.0.0.1:8999;            #fastcgi_pass  unix:/var/run/ttlsa.com.perl.sock;            fastcgi_index index.pl;        }}</pre></div> </div><!-- [Format Time: 0.0008 seconds] --><p>如果想把tcp/ip方式改为socket方式，可以修改fastcgi-wrapper.pl.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>$socket = FCGI::OpenSocket( "127.0.0.1:8999", 10 ); #use IP sockets改为$socket = FCGI::OpenSocket( "/var/run/ttlsa.com.perl.sock", 10 ); #use IP sockets</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><h2>3. 配置脚本</h2><p>3.1 fastcgi监听脚本<br>文件路径：/usr/bin/fastcgi-wrapper.pl</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>#!/usr/bin/perluse FCGI;use Socket;use POSIX qw(setsid);require 'syscall.ph';&amp;daemonize;#this keeps the program alive or something after exec'ing perl scriptsEND() { } BEGIN() { }*CORE::GLOBAL::exit = sub { die "fakeexit\nrc=".shift()."\n"; };eval q{exit};if ($@) {    exit unless $@ =~ /^fakeexit/;};&amp;main;sub daemonize() {    chdir '/'                 or die "Can't chdir to /: $!";    defined(my $pid = fork)   or die "Can't fork: $!";    exit if $pid;    setsid                    or die "Can't start a new session: $!";    umask 0;}sub main {        $socket = FCGI::OpenSocket( "127.0.0.1:8999", 10 ); #use IP sockets        $request = FCGI::Request( \*STDIN, \*STDOUT, \*STDERR, \%req_params, $socket );        if ($request) { request_loop()};            FCGI::CloseSocket( $socket );}sub request_loop {        while( $request-&gt;Accept() &gt;= 0 ) {           #processing any STDIN input from WebServer (for CGI-POST actions)           $stdin_passthrough ='';           $req_len = 0 + $req_params{'CONTENT_LENGTH'};           if (($req_params{'REQUEST_METHOD'} eq 'POST') &amp;&amp; ($req_len != 0) ){                my $bytes_read = 0;                while ($bytes_read &lt; $req_len) {                        my $data = '';                        my $bytes = read(STDIN, $data, ($req_len - $bytes_read));                        last if ($bytes == 0 || !defined($bytes));                        $stdin_passthrough .= $data;                        $bytes_read += $bytes;                }            }            #running the cgi app            if ( (-x $req_params{SCRIPT_FILENAME}) &amp;&amp;  #can I execute this?                 (-s $req_params{SCRIPT_FILENAME}) &amp;&amp;  #Is this file empty?                 (-r $req_params{SCRIPT_FILENAME})     #can I read this file?            ){        pipe(CHILD_RD, PARENT_WR);        my $pid = open(KID_TO_READ, "-|");        unless(defined($pid)) {            print("Content-type: text/plain\r\n\r\n");                        print "Error: CGI app returned no output - ";                        print "Executing $req_params{SCRIPT_FILENAME} failed !\n";            next;        }        if ($pid &gt; 0) {            close(CHILD_RD);            print PARENT_WR $stdin_passthrough;            close(PARENT_WR);            while(my $s = <kid_to_read>) { print $s; }            close KID_TO_READ;            waitpid($pid, 0);        } else {                    foreach $key ( keys %req_params){                       $ENV{$key} = $req_params{$key};                    }                    # cd to the script's local directory                    if ($req_params{SCRIPT_FILENAME} =~ /^(.*)\/[^\/]+$/) {                            chdir $1;                    }            close(PARENT_WR);            close(STDIN);            #fcntl(CHILD_RD, F_DUPFD, 0);            syscall(&amp;SYS_dup2, fileno(CHILD_RD), 0);            #open(STDIN, "</kid_to_read></pre></div> </div><!-- [Format Time: 0.0050 seconds] --><p>3.2 fastcgi自启动服务脚本：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>文件路径：/etc/rc.d/init.d/perl-fastcgi#!/bin/sh## nginx – this script starts and stops the nginx daemon## chkconfig: - 85 15# description: Nginx is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /opt/nginx/conf/nginx.conf# pidfile: /opt/nginx/logs/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0perlfastcgi="/usr/bin/fastcgi-wrapper.pl"prog=$(basename perl)lockfile=/var/lock/subsys/perl-fastcgistart() {    [ -x $perlfastcgi ] || exit 5    echo -n $"Starting $prog: "    daemon $perlfastcgi    retval=$?    echo    [ $retval -eq 0 ] &amp;&amp; touch $lockfile    return $retval}stop() {    echo -n $"Stopping $prog: "    killproc $prog -QUIT    retval=$?    echo    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile    return $retval}restart() {    stop    start}reload() {    echo -n $”Reloading $prog: ”    killproc $nginx -HUP    RETVAL=$?    echo}force_reload() {    restart}rh_status() {    status $prog}rh_status_q() {    rh_status &gt;/dev/null 2&gt;&amp;1}case "$1" in    start)        rh_status_q &amp;&amp; exit 0        $1        ;;    stop)        rh_status_q || exit 0        $1        ;;    restart)        $1        ;;    reload)        rh_status_q || exit 7        $1        ;;    force-reload)        force_reload        ;;    status)        rh_status        ;;    condrestart|try-restart)        rh_status_q || exit 0        ;;    *)        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"        exit 2    esac</pre></div> </div><!-- [Format Time: 0.0027 seconds] --><p>3.3 设置脚本权限</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># chmod a+x /usr/bin/fastcgi-wrapper.pl# chmod a+x /etc/rc.d/init.d/perl-fastcgi</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><h2><strong>4. FastCGI测试</strong></h2><hr><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>4.1 启动nginx与fastcgi# /usr/local/nginx-1.4.2/sbin/nginx# /etc/init.d/perl-fastcgi start</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>4.2 perl测试文件：<br>文件路径/data/site/test.ttlsa.com/test.pl</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>#!/usr/bin/perlprint "Content-type:text/html\n\n";print &lt;<endofhtml><title>Perl Environment Variables</title><h1>Perl Environment Variables</h1>EndOfHTMLforeach $key (sort(keys %ENV)) {    print "$key = $ENV{$key}<br>\n";}print "</endofhtml></pre></div> </div><!-- [Format Time: 0.0005 seconds] --><h2>5. 访问测试</h2><p>5.1 访问</p><p>http://http:test.ttlsa.com/test.pl,出现内容表示OK.</p><p> </p><p><strong>6. 简单压力测试：</strong><br>6.1 使用tcp/ip方式</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>ab -n 1000 -c 10 http://test.ttlsa.com/test.pl</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>他是在是太慢了，只好用10个并发，共计100个请求来测试.</p><div><p>perl + fastcgi + tcp-ip</p></div><p>6.2 使用socket方式：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>ab -n 100000 -c 500 http://test.ttlsa.com/test.pl</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><div><p>perl + fastcgi + socket</p></div><p>很奇怪，使用tcp/ip方式，每秒就140多个请求，而使用socket方式却有5800个请求/秒。差距不是一般的大。顺便测试了一下php的fastcgi，大概请求在3000（tcp/ip方式），4800（socket方式）。</p><h2>7. 文件下载</h2><p>perl脚本下载：perl-fastcgi,fastcgi-wrapper.pl,test.perl三个文件</p><p> </p><p>转载请注明出处：<strong></strong> http://www.ttlsa.com/html/2411.html</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,perl-fastcgi-nginx,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx+set-misc-nginx-module模块说明-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx_set-misc-nginx-module-module-description.html"/>
    <id>http://nginx.im/nginx/nginx/nginx_set-misc-nginx-module-module-description.html</id>
    <published>2018-12-24T09:31:16.339Z</published>
    <updated>2018-12-24T09:31:52.664Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx_set-misc-nginx-module-module-description,<br><a id="more"></a><br>   </p><p>set-misc-nginx-module模块是标准的HttpRewriteModule指令的扩展，提供更多的功能，如URI转义与非转义、JSON引述、Hexadecimal/MD5/SHA1/Base32/Base64编码与解码、随机数等等。在后面的应用中，都将会接触使用到这个模块的。该模块是由章亦春先生开发的，他开发的其他模块应用也会使用到这个模块的。充分使用nginx非阻塞模式，对性能上有极大的提高，我个人认为很有必要去弄懂弄透nginx，通过自己去动手动脑用实例来加以验证，不断的对模块参数命令加以理解，在实际环境中应用自如。某朋友说“招运维人员，不懂nginx的一律不要。”呵呵，有点道理的。</p><p>1. set-misc-nginx-module模块指令说明：<br>set_if_empty<br>语法：set_if_empty $dst &lt;src&gt;；<br>默认值：no<br>配置段：location, location if<br>如果参数$dst是空的，则赋值为&lt;src&gt;。<br>set $a 32;<br>set_if_empty $a 56;<br>$a的值为32.<br>set $a '';<br>set $value "hello, world"<br>set_if_empty $a $value;<br>$a的值为"hello, world"。</p><p>set_quote_sql_str<br>语法：set_quote_sql_str $dst &lt;src&gt; / set_quote_sql_str $dst<br>默认值：no<br>配置段：location, location if<br>当两个参数时，该指令将引用第二个参数&lt;src&gt;值。该指令通常用于防止SQL注入。mysql字符串值引用规则和分配第一个参数结果。<br>location /test {<br>set $value "hello\n\r'\"\\";<br>set_quote_sql_str $quoted $value;</p><p>echo $quoted;<br>}<br>结果为'hello\n\r\'\"\\'。<br>当是当个参数时，该指令将修改参数变量。如：<br>location /test {<br>set $value "hello\n\r'\"\\";<br>set_quote_sql_str $value;</p><p>echo $value;<br>}<br>结果为'hello\n\r\'\"\\'。</p><p>set_quote_pgsql_str<br>语法：set_quote_pgsql_str $dst &lt;src&gt; / set_quote_pgsql_str $dst<br>默认值：no<br>配置段： location, location if<br>与set_quote_sql_str相似，但是要符合PostgreSQL的SQL字符串常量的引用规则。</p><p>set_quote_json_str<br>语法：set_quote_json_str $dst &lt;src&gt; / set_quote_json_str $dst<br>默认值：no<br>配置段：location, location if<br>当两个参数时，该指令将引用第二个参数&lt;src&gt;。JSON字符串值引用规则和分配第一个参数结果。<br>location /test {<br>set $value "hello\n\r'\"\\";<br>set_quote_json_str $quoted $value;</p><p>echo $quoted;<br>}<br>结果为："hello\n\r'\"\\"。<br>当当个参数时，该指令将修改参数变量。如：<br>location /test {<br>set $value "hello\n\r'\"\\";<br>set_quote_json_str $value;</p><p>echo $value;<br>}<br>结果为："hello\n\r'\"\\"。</p><p>set_unescape_uri<br>语法： set_unescape_uri $dst &lt;src&gt; / set_unescape_uri $dst<br>默认值： no<br>配置段：location, location if<br>当两个参数时，该指令将非转义第二个参数&lt;src&gt;的值作为URI一部分，并分配第一个参数变量$dst分配结果。如：<br>location /test {<br>set_unescape_uri $key $arg_key;<br>echo $key;<br>}<br>当请求GET /test?key=hello+world%21时，得到：hello world!。<br>注意： nginx标准的变量$arg_PARAMETER保存原始的URI参数(转义过的)，因此需要set_unescape_uri指令来非转义先。</p><p>当单个参数时，该指令将修改参数变量位置，如：<br>location /test {<br>set $key $arg_key;<br>set_unescape_uri $key;</p><p>echo $key;<br>}<br>当请求GET /test?key=hello+world%21时，得到：hello world!。</p><p>set_escape_uri<br>语法：set_escape_uri $dst &lt;src&gt; /set_escape_uri $dst<br>默认值：no<br>配置段：location, location if<br>与set_unescape_uri相似。</p><p>set_hashed_upstream<br>语法：set_hashed_upstream $dst &lt;upstream_list_name&gt; &lt;src&gt;<br>默认值：no<br>配置段：location, location if<br>参数&lt;src&gt; hash后的值，对应于&lt;upstream_list_name&gt;中的某个upstream名称。<br>upstream moon { ... }<br>upstream sun { ... }<br>upstream earth { ... }</p><p>upstream_list universe moon sun earth;</p><p>location /test {<br>set_unescape_uri $key $arg_key;<br>set $list_name universe;<br>set_hashed_upstream $backend $list_name $key;</p><p>echo $backend;<br>}<br>当请求/test?key=blah时，得到的值是 "moon", "sun", "earth"其中一个。取决于参数key。</p><p>set_encode_base32<br>语法：set_encode_base32 $dst &lt;src&gt; / set_encode_base32 $dst<br>默认值：no<br>配置段： location, location if<br>当两个参数时，该指令将对第二个参数&lt;src&gt;进行base32(hex)编码，并将结果赋值给第一个变量参数$dst。 如：<br>location /test {<br>set $raw "abcde";<br>set_encode_base32 $digest $raw;</p><p>echo $digest;<br>}<br>当请求/test时，得到：c5h66p35。<br>默认情况下，字符=用来左填充字节对齐。可以通过 set_misc_base32_padding off来禁止填充。</p><p>当单个参数时，该指令将修改参数变量位置。如：<br>location /test {<br>set $value "abcde";<br>set_encode_base32 $value;</p><p>echo $value;<br>}<br>当请求/test时，得到：c5h66p35。</p><p>set_misc_base32_padding<br>语法：set_misc_base32_padding on|off<br>默认值：on<br>配置段：http, server, server if, location, location if<br>当set_encode_base32指令以base32进行编码时，该指令控制是否以字符=来填充。</p><p>set_decode_base32<br>语法：set_decode_base32 $dst &lt;src&gt; | set_decode_base32 $dst<br>默认值：no<br>配置段： location, location if<br>与set_encode_base32相似，只不过是反过程。</p><p>set_encode_base64<br>语法： set_encode_base64 $dst &lt;src&gt; |set_encode_base64 $dst<br>默认值：no<br>配置段；location, location if<br>当两个参数时，该指令将对第二个参数&lt;src&gt;进行base64编码，并将结果赋值给第一个变量参数$dst。 如：<br>location /test {<br>set $raw "abcde";<br>set_encode_base64 $digest $raw;</p><p>echo $digest;<br>}<br>当请求/test时，得到YWJjZGU=。</p><p>当单个参数时，该指令将修改参数变量位置。如：<br>location /test {<br>set $value "abcde";<br>set_encode_base64 $value;</p><p>echo $value;<br>}<br>当请求/test时，得到YWJjZGU=。</p><p>set_decode_base64<br>语法：set_decode_base64 $dst &lt;src&gt; | set_decode_base64 $dst<br>默认值：no<br>配置段：location, location if<br>与set_encode_base64相似，只不过是反过程。</p><p>set_encode_hex<br>语法：set_encode_hex $dst &lt;src&gt; | set_encode_hex $dst<br>默认值：no<br>配置段： location, location if<br>当两个参数时，该指令将对第二个参数&lt;src&gt;进行hexadecimal编码，并将结果赋值给第一个变量参数$dst。 如：<br>location /test {<br>set $raw "章亦春";<br>set_encode_hex $digest $raw;</p><p>echo $digest;<br>}<br>当请求/test时，得到：e7aba0e4baa6e698a5。</p><p>当单个参数时，该指令将修改参数变量位置。如：<br>location /test {<br>set $value "章亦春";<br>set_encode_hex $value;</p><p>echo $value;<br>}<br>当请求/test时，得到：e7aba0e4baa6e698a5。</p><p>set_decode_hex<br>语法：set_decode_hex $dst &lt;src&gt; | set_decode_hex $dst<br>默认值：no<br>配置段： location, location if<br>与set_encode_hex相似，只不过是反过程。</p><p>set_sha1<br>语法：set_sha1 $dst &lt;src&gt; | set_sha1 $dst<br>默认值：no<br>配置段：location, location if<br>当两个参数时，该指令将对第二个参数&lt;src&gt;进行SHA-1编码，并将结果赋值给第一个变量参数$dst。 如：<br>location /test {<br>set $raw "hello";<br>set_sha1 $digest $raw;</p><p>echo $digest;<br>}<br>当请求/test，得到：aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d。</p><p>当单个参数时，该指令将修改参数变量位置。如：<br>location /test {<br>set $value "hello";<br>set_sha1 $value;</p><p>echo $value;<br>}</p><p>set_md5<br>语法：set_md5 $dst &lt;src&gt; | set_md5 $dst<br>默认值：no<br>配置段：location, location if<br>当两个参数时，该指令将对第二个参数&lt;src&gt;进行MD5编码，并将结果赋值给第一个变量参数$dst。 如：<br>location /test {<br>set $raw "hello";<br>set_sha1 $digest $raw;</p><p>echo $digest;<br>}<br>当请求/test，得到：5d41402abc4b2a76b9719d911017c592。</p><p>当单个参数时，该指令将修改参数变量位置。如：<br>location /test {<br>set $value "hello";<br>set_sha1 $value;</p><p>echo $value;<br>}</p><p>set_hmac_sha1<br>语法：set_hmac_sha1 $dst &lt;secret_key&gt; &lt;src&gt; | set_hmac_sha1 $dst<br>默认值：no<br>配置段：location, location if<br>为参数&lt;src&gt;计算HMAC-SHA1值，将结果赋值给参数变量$dst并带上密钥&lt;secret_key&gt;。如：<br>location /test {<br>set $secret 'thisisverysecretstuff';<br>set $string_to_sign 'some string we want to sign';<br>set_hmac_sha1 $signature $secret $string_to_sign;<br>set_encode_base64 $signature $signature;<br>echo $signature;<br>}<br>请求/test，得到：R/pvxzHC4NLtj7S+kXFg/NePTmk=。<br>注意：该指令依赖于OpenSSL库，因此编译nginx时，需要--with-http_ssl_module。</p><p>set_random<br>语法: set_random $res &lt;from&gt; &lt;to&gt;<br>默认值：no<br>配置段：location, location if<br>生成从&lt;from&gt;与&lt;to&gt;之间的非负数的随机数。含&lt;from&gt; &lt;to&gt;。</p><p>set_secure_random_alphanum<br>语法：set_secure_random_alphanum $res &lt;length&gt;<br>默认值：no<br>配置段：location, location if<br>生成长度为&lt;length&gt;的随机字符串。字符有[a-zA-Z0-9]。</p><p>set_secure_random_lcalpha<br>语法：set_secure_random_lcalpha $res &lt;length&gt;<br>默认值：no<br>配置段：location, location if<br>生成长度为&lt;length&gt;的随机字符串。字符有[a-z]。</p><p>set_rotate<br>语法：set_rotate $value &lt;from&gt; &lt;to&gt;<br>默认值：no<br>配置段：location, location if</p><p>set_local_today<br>语法：set_local_today $dst<br>默认值：no<br>配置段：location, location if<br>将本地的今天日期以"yyyy-mm-dd"格式赋值给参数变量$dst。</p><p>2. set-misc-nginx-module安装</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre># ./configure --prefix=/usr/local/nginx \--with-http_ssl_module \--add-module=../ngx_devel_kit \--add-module=../set-misc-nginx-module# make# make install</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>set-misc-nginx-module依赖ngx_devel_kit模块，且--add-module=ngx_devel_kit一定要早于--add-module=set-misc-nginx-module</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx_set-misc-nginx-module-module-description,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(8)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-8.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-8.html</id>
    <published>2018-12-24T09:31:16.336Z</published>
    <updated>2018-12-24T09:31:52.648Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-8<br><a id="more"></a><br>   </p><p> </p><p>与 $arg_XXX 类似，我们在 （二） 中提到过的内建变量 $cookie_XXX 变量也会在名为 XXX 的 cookie 不存在时返回特殊值“没找到”：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        content_by_<a href="http://www.ttlsa.com/monitor/lua/" title="lua" target="_blank">lua</a> '            if ngx.var.cookie_user == nil then                ngx.say("cookie user: missing")            else                ngx.say("cookie user: [", ngx.var.cookie_user, "]")            end        ';    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>利用 curl 命令行工具的 --cookie name=value 选项可以指定 name=value 为当前请求携带的 cookie（通过添加相应的 Cookie 请求头）。下面是若干次测试结果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl --cookie user=agentzh 'http://localhost:8080/test'    cookie user: [agentzh]    $ curl --cookie user= 'http://localhost:8080/test'    cookie user: []    $ curl 'http://localhost:8080/test'    cookie user: missing</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>我们看到，cookie user 不存在以及取值为空字符串这两种情况被很好地区分开了：当 cookie user 不存在时，Lua 代码中的 ngx.var.cookie_user 返回了期望的 Lua nil 值。</p><p>在 Lua 里访问未创建的 Nginx 用户变量时，在 Lua 里也会得到 nil 值，而不会像先前的例子那样直接让 Nginx 拒绝加载配置：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        content_by_lua '           ngx.say("$blah = ", ngx.var.blah)        ';    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这里假设我们并没有在当前的 nginx.conf 配置文件中创建过用户变量 $blah，然后我们在 Lua 代码中通过 ngx.var.blah 直接引用它。上面这个配置可以顺利启动，因为 Nginx 在加载配置时只会编译 content_by_lua 配置指令指定的 Lua 代码而不会实际执行它，所以 Nginx 并不知道 Lua 代码里面引用了 $blah 这个变量。于是我们在运行时也会得到 nil 值。而 ngx_lua 提供的 ngx.say 函数会自动把 Lua 的 nil 值格式化为字符串 "nil" 输出，于是访问 /test 接口的结果是：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    curl 'http://localhost:8080/test'    $blah = nil</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>这正是我们所期望的。</p><p>上面这个例子中另一个值得注意的地方是，我们在 content_by_lua 配置指令的参数中提及了 $bar 符号，但却并没有触发“变量插值”（否则 Nginx 会在启动时抱怨 $blah 未创建）。这是因为 content_by_lua 配置指令并不支持参数的“变量插值”功能。我们前面在 （一） 中提到过，配置指令的参数是否允许“变量插值”，其实取决于该指令的实现模块。</p><p>设计返回“不合法”这一特殊值的例子是困难的，因为我们前面在 （七） 中已经看到，由 set 指令创建的变量在未初始化时确实是“不合法”，但一旦尝试读取它们时，Nginx 就会自动调用其“取处理程序”，而它们的“取处理程序”会自动返回空字符串并将之缓存住。于是我们最终得到的是完全合法的空字符串。下面这个使用了 Lua 代码的例子证明了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /foo {        content_by_lua '            if ngx.var.foo == nil then                ngx.say("$foo is nil")            else                ngx.say("$foo = [", ngx.var.foo, "]")            end        ';    }    location /bar {        set $foo 32;        echo "foo = [$foo]";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>请求 /foo 接口的结果是：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/foo'    $foo = []</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>我们看到在 Lua 里面读取未初始化的 Nginx 变量 $foo 时得到的是空字符串。</p><p>最后值得一提的是，虽然前面反复指出 Nginx 变量只有字符串这一种数据类型，但这并不能阻止像 ngx_array_var 这样的第三方模块让 Nginx 变量也能存放数组类型的值。下面就是这样的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        array_split "," $arg_names to=$array;        array_map "[$array_it]" $array;        array_join " " $array to=$res;        echo $res;    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>这个例子中使用了 ngx_array_var 模块的 array_split、 array_map 和 array_join 这三条配置指令，其含义很接近 Perl 语言中的内建函数 split、map 和 join（当然，其他脚本语言也有类似的等价物）。我们来看看访问 /test 接口的结果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?names=Tom,Jim,Bob    [Tom] [Jim] [Bob]</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，使用 ngx_array_var 模块可以很方便地处理这样具有不定个数的组成元素的输入数据，例如此例中的 names URL 参数值就是由不定个数的逗号分隔的名字所组成。不过，这种类型的复杂任务通过 ngx_lua 来做通常会更灵活而且更容易维护。</p><p>至此，本系列教程对 Nginx 变量的介绍终于可以告一段落了。我们在这个过程中接触到了许多标准的和第三方的 Nginx 模块，这些模块让我们得以很轻松地构造出许多有趣的小例子，从而可以深入探究 Nginx 变量的各种行为和特性。在后续的教程中，我们还会有很多机会与这些模块打交道。</p><p>通过前面讨论过的众多例子，我们应当已经感受到 Nginx 变量在 Nginx 配置语言中所扮演的重要角色：它是获取 Nginx 中各种信息（包括当前请求的信息）的主要途径和载体，同时也是各个模块之间传递数据的主要媒介之一。在后续的教程中，我们会经常看到 Nginx 变量的身影，所以现在很好地理解它们是非常重要的。</p><p>在下一个系列的教程，即 Nginx 配置指令的执行顺序系列 中，我们将深入探讨 Nginx 配置指令的执行顺序以及请求的各个处理阶段，因为很多 Nginx 用户都搞不清楚他们书写的众多配置指令之间究竟是按照何种时间顺序执行的，也搞不懂为什么这些指令实际执行的顺序经常和配置文件里的书写顺序大相径庭。</p><p> </p><p>[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a31"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a32"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a33"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a34"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a35"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a36"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a37"]|[link_post name="nginx%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6%e8%a7%a38"]</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-8&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(7)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-7.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-7.html</id>
    <published>2018-12-24T09:31:16.335Z</published>
    <updated>2018-12-24T09:31:52.663Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-7<br><a id="more"></a><br>   </p><p>在 （一） 中我们提到过，Nginx 变量的值只有一种类型，那就是字符串，但是变量也有可能压根就不存在有意义的值。没有值的变量也有两种特殊的值：一种是“不合法”（invalid），另一种是“没找到”（not found）。</p><p>举例说来，当 Nginx 用户变量 $foo 创建了却未被赋值时，$foo 的值便是“不合法”；而如果当前请求的 URL 参数串中并没有提及 XXX 这个参数，则 $arg_XXX 内建变量的值便是“没找到”。</p><p>无论是“不合法”也好，还是“没找到”也罢，这两种 Nginx 变量所拥有的特殊值，和空字符串（""）这种取值是完全不同的，比如 JavaScript 语言中也有专门的 undefined 和 null 这两种特殊值，而 Lua 语言中也有专门的 nil 值: 它们既不等同于空字符串，也不等同于数字 0，更不是布尔值 false. 其实 SQL 语言中的 NULL 也是类似的一种东西。</p><p>虽然前面在 （一） 中我们看到，由 set 指令创建的变量未初始化就用在“变量插值”中时，效果等同于空字符串，但那是因为 set 指令为它创建的变量自动注册了一个“取处理程序”，将“不合法”的变量值转换为空字符串。为了验证这一点，我们再重新看一下 （一） 中讨论过的那个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /foo {        echo "foo = [$foo]";    }    location /bar {        set $foo 32;        echo "foo = [$foo]";    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>这里为了简单起见，省略了原先写出的外围 server 配置块。在这个例子里，我们在 /bar 接口中用 set 指令隐式地创建了 $foo 变量这个名字，然后我们在 /foo 接口中不对 $foo 进行初始化就直接使用 echo 指令输出。我们当时测试 /foo 接口的结果是</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/foo'    foo = []</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>从输出上看，未初始化的 $foo 变量确实和空字符串的效果等同。但细心的读者当时应该就已经注意到，对于上面这个请求，Nginx 的错误日志文件（一般文件名叫做 error.log）中多出一行类似下面这样的警告：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    [warn] 5765#0: *1 using uninitialized "foo" variable, ...</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>这一行警告是谁输出的呢？答案是 set 指令为 $foo 注册的“取处理程序”。当 /foo 接口中的 echo 指令实际执行的时候，它会对它的参数 "foo = [$foo]" 进行“变量插值”计算。于是，参数串中的 $foo 变量会被读取，而 Nginx 会首先检查其值容器里的取值，结果它看到了“不合法”这个特殊值，于是它这才决定继续调用 $foo 变量的“取处理程序”。于是 $foo 变量的“取处理程序”开始运行，它向 Nginx 的错误日志打印出上面那条警告消息，然后返回一个空字符串作为 $foo 的值，并从此缓存在 $foo 的值容器中。</p><p>细心的读者会注意到刚刚描述的这个过程其实就是那些支持值缓存的内建变量的工作原理，只不过 set 指令在这里借用了这套机制来处理未正确初始化的 Nginx 变量。值得一提的是，只有“不合法”这个特殊值才会触发 Nginx 调用变量的“取处理程序”，而特殊值“没找到”却不会。</p><p>上面这样的警告一般会指示出我们的 Nginx 配置中存在变量名拼写错误，抑或是在错误的场合使用了尚未初始化的变量。因为值缓存的存在，这条警告在一个请求的生命期中也不会打印多次。当然，ngx_rewrite 模块专门提供了一条 uninitialized_variable_warn 配置指令可用于禁止这条警告日志。</p><p>刚才提到，内建变量 $arg_XXX 在请求 URL 参数 XXX 并不存在时会返回特殊值“找不到”，但遗憾的是在 Nginx 原生配置语言（我们估且这么称呼它）中是不能很方便地把它和空字符串区分开来的，比如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        echo "name: [$arg_name]";    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这里我们输出 $arg_name 变量的值同时故意在请求中不提供 URL 参数 name:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test'    name: []</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，输出特殊值“找不到”的效果和空字符串是相同的。因为这一回是 Nginx 的“变量插值”引擎自动把“找不到”给忽略了。</p><p>那么我们究竟应当如何捕捉到“找不到”这种特殊值的踪影呢？换句话说，我们应当如何把它和空字符串给区分开来呢？显然，下面这个请求中，URL 参数 name 是有值的，而且其值应当是空字符串：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?name='    name: []</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>但我们却无法将之和前面完全不提供 name 参数的情况给区分开。</p><p>幸运的是，通过第三方模块 ngx_lua，我们可以轻松地在 Lua 代码中做到这一点。请看下面这个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        content_by_lua '            if ngx.var.arg_name == nil then                ngx.say("name: missing")            else                ngx.say("name: [", ngx.var.arg_name, "]")            end        ';    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这个例子和前一个例子功能上非常接近，除了我们在 /test 接口中使用了 ngx_lua 模块的 content_by_lua 配置指令，嵌入了一小段我们自己的 Lua 代码来对 Nginx 变量 $arg_name 的特殊值进行判断。在这个例子中，当 $arg_name 的值为“没找到”（或者“不合法”）时，/foo 接口会输出 name: missing 这一行结果:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    curl 'http://localhost:8080/test'    name: missing</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>因为这是我们第一次接触到 ngx_lua 模块，所以需要先简单介绍一下。ngx_lua 模块将 Lua 语言解释器（或者 LuaJIT 即时编译器）嵌入到了 Nginx 核心中，从而可以让用户在 Nginx 核心中直接运行 Lua 语言编写的程序。我们可以选择在 Nginx 不同的请求处理阶段插入我们的 Lua 代码。这些 Lua 代码既可以直接内联在 Nginx 配置文件中，也可以单独放置在外部 .lua 文件里，然后在 Nginx 配置文件中引用 .lua 文件的路径。</p><p>回到上面这个例子，我们在 Lua 代码里引用 Nginx 变量都是通过 ngx.var 这个由 ngx_lua 模块提供的 Lua 接口。比如引用 Nginx 变量 $VARIABLE 时，就在 Lua 代码里写作 ngx.var.VARIABLE 就可以了。当 Nginx 变量 $arg_name 为特殊值“没找到”（或者“不合法”）时， ngx.var.arg_name 在 Lua 世界中的值就是 nil，即 Lua 语言里的“空”（不同于 Lua 空字符串）。我们在 Lua 里输出响应体内容的时候，则使用了 ngx.say 这个 Lua 函数，也是 ngx_lua 模块提供的，功能上等价于 ngx_echo 模块的 echo 配置指令。</p><p>现在，如果我们提供空字符串取值的 name 参数，则输出就和刚才不相同了：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?name='    name: []</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>在这种情况下，Nginx 变量 $arg_name 的取值便是空字符串，这既不是“没找到”，也不是“不合法”，因此在 Lua 里，ngx.var.arg_name 就返回 Lua 空字符串（""），和刚才的 Lua nil 值就完全区分开了。</p><p>这种区分在有些应用场景下非常重要，比如有的 web service 接口会根据 name 这个 URL 参数是否存在来决定是否按 name 属性对数据集合进行过滤，而显然提供空字符串作为 name 参数的值，也会导致对数据集中取值为空串的记录进行筛选操作。</p><p>不过，标准的 $arg_XXX 变量还是有一些局限，比如我们用下面这个请求来测试刚才那个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?name'    name: missing</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>此时，$arg_name 变量仍然读出“找不到”这个特殊值，这就明显有些违反常识。此外，$arg_XXX 变量在请求 URL 中有多个同名 XXX 参数时，就只会返回最先出现的那个 XXX 参数的值，而默默忽略掉其他实例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob'    name: [Tom]</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>要解决这些局限，可以直接在 Lua 代码中使用 ngx_lua 模块提供的 ngx.req.get_uri_args 函数。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-7&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(6)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-6.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-6.html</id>
    <published>2018-12-24T09:31:16.334Z</published>
    <updated>2018-12-24T09:31:52.662Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-6<br><a id="more"></a><br>   </p><p>Nginx 内建变量用在“子请求”的上下文中时，其行为也会变得有些微妙。</p><p>前面在 （三） 中我们已经知道，许多内建变量都不是简单的“存放值的容器”，它们一般会通过注册“存取处理程序”来表现得与众不同，而它们即使有存放值的容器，也只是用于缓存“存取处理程序”的计算结果。我们之前讨论过的 $args 变量正是通过它的“取处理程序”来返回当前请求的 URL 参数串。因为当前请求也可以是“子请求”，所以在“子请求”中读取 $args，其“取处理程序”会很自然地返回当前“子请求”的参数串。我们来看这样的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo "main args: $args";        echo_location /sub "a=1&amp;b=2";    }    location /sub {        echo "sub args: $args";    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>这里在 /main 接口中，先用 echo 指令输出当前请求的 $args 变量的值，接着再用 echo_location 指令发起子请求 /sub. 这里值得注意的是，我们在 echo_location 语句中除了通过第一个参数指定“子请求”的 URI 之外，还提供了第二个参数，用以指定该“子请求”的 URL 参数串（即 a=1&amp;b=2）。最后我们定义了 /sub 接口，在里面输出了一下 $args 的值。请求 /main 接口的结果如下：</p><p>$ curl 'http://localhost:8080/main?c=3'<br>main args: c=3<br>sub args: a=1&amp;b=2</p><p>显然，当 $args 用在“主请求” /main 中时，输出的就是“主请求”的 URL 参数串，c=3；而当用在“子请求” /sub 中时，输出的则是“子请求”的参数串，a=1&amp;b=2。这种行为正符合我们的直觉。</p><p>与 $args 类似，内建变量 $uri 用在“子请求”中时，其“取处理程序”也会正确返回当前“子请求”解析过的 URI:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo "main uri: $uri";        echo_location /sub;    }    location /sub {        echo "sub uri: $uri";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>请求 /main 的结果是</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/main'    main uri: /main    sub uri: /sub</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这依然是我们所期望的。</p><p>但不幸的是，并非所有的内建变量都作用于当前请求。少数内建变量只作用于“主请求”，比如由标准模块 ngx_http_core 提供的内建变量 $request_method.</p><p>变量 $request_method 在读取时，总是会得到“主请求”的请求方法，比如 GET、POST 之类。我们来测试一下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo "main method: $request_method";        echo_location /sub;    }    location /sub {        echo "sub method: $request_method";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>在这个例子里，/main 和 /sub 接口都会分别输出 $request_method 的值。同时，我们在 /main 接口里利用 echo_location 指令发起一个到 /sub 接口的 GET “子请求”。我们现在利用 curl 命令行工具来发起一个到 /main 接口的 POST 请求：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl --data hello 'http://localhost:8080/main'    main method: POST    sub method: POST</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这里我们利用 curl 程序的 --data 选项，指定 hello 作为我们的请求体数据，同时 --data 选项会自动让发送的请求使用 POST 请求方法。测试结果证明了我们先前的预言，$request_method 变量即使在 GET “子请求” /sub 中使用，得到的值依然是“主请求” /main 的请求方法，POST.</p><p>有的读者可能觉得我们在这里下的结论有些草率，因为上例是先在“主请求”里读取（并输出）$request_method 变量，然后才发“子请求”的，所以这些读者可能认为这并不能排除 $request_method 在进入子请求之前就已经把第一次读到的值给缓存住，从而影响到后续子请求中的输出结果。不过，这样的顾虑是多余的，因为我们前面在 （五） 中也特别提到过，缓存所依赖的变量的值容器，是与当前请求绑定的，而由 ngx_echo 模块发起的“子请求”都禁用了父子请求之间的变量共享，所以在上例中，$request_method 内建变量即使真的使用了值容器作为缓存（事实上它也没有），它也不可能影响到 /sub 子请求。</p><p>为了进一步消除这部分读者的疑虑，我们不妨稍微修改一下刚才那个例子，将 /main 接口输出 $request_method 变量的时间推迟到“子请求”执行完毕之后：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo_location /sub;        echo "main method: $request_method";    }    location /sub {        echo "sub method: $request_method";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>让我们重新测试一下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl --data hello 'http://localhost:8080/main'    sub method: POST    main method: POST</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>可以看到，再次以 POST 方法请求 /main 接口的结果与原先那个例子完全一致，除了父子请求的输出顺序颠倒了过来（因为我们在本例中交换了 /main 接口中那两条输出配置指令的先后次序）。</p><p>由此可见，我们并不能通过标准的 $request_method 变量取得“子请求”的请求方法。为了达到我们最初的目的，我们需要求助于第三方模块 ngx_echo 提供的内建变量 $echo_request_method：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo "main method: $echo_request_method";        echo_location /sub;    }    location /sub {        echo "sub method: $echo_request_method";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>此时的输出终于是我们想要的了：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl --data hello 'http://localhost:8080/main'    main method: POST    sub method: GET</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，父子请求分别输出了它们各自不同的请求方法，POST 和 GET.</p><p>类似 $request_method，内建变量 $request_uri 一般也返回的是“主请求”未经解析过的 URL，毕竟“子请求”都是在 Nginx 内部发起的，并不存在所谓的“未解析的”原始形式。</p><p>如果真如前面那部分读者所担心的，内建变量的值缓存在共享变量的父子请求之间起了作用，这无疑是灾难性的。我们前面在 （五） 中已经看到 ngx_auth_request 模块发起的“子请求”是与其“父请求”共享一套变量的。下面是一个这样的可怕例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    map $uri $tag {        default     0;        /main       1;        /sub        2;    }    server {        listen 8080;        location /main {            auth_request /sub;            echo "main tag: $tag";        }        location /sub {            echo "sub tag: $tag";        }    }</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>这里我们使用久违了的 map 指令来把内建变量 $uri 的值映射到用户变量 $tag 上。当 $uri 的值为 /main 时，则赋予 $tag 值 1，当 $uri 取值 /sub 时，则赋予 $tag 值 2，其他情况都赋 0. 接着，我们在 /main 接口中先用 ngx_auth_request 模块的 auth_request 指令发起到 /sub 接口的子请求，然后再输出变量 $tag 的值。而在 /sub 接口中，我们直接输出变量 $tag. 猜猜看，如果我们访问接口 /main，将会得到什么样的输出呢？</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/main'    main tag: 2</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>咦？我们不是分明把 /main 这个值映射到 1 上的么？为什么实际输出的是 /sub 映射的结果 2 呢？</p><p>其实道理很简单，因为我们的 $tag 变量在“子请求” /sub 中首先被读取，于是在那里计算出了值 2（因为 $uri 在那里取值 /sub，而根据 map 映射规则，$tag 应当取值 2），从此就被 $tag 的值容器给缓存住了。而 auth_request 发起的“子请求”又是与“父请求”共享一套变量的，于是当 Nginx 的执行流回到“父请求”输出 $tag 变量的值时，Nginx 就直接返回缓存住的结果 2 了。这样的结果确实太意外了。</p><p>从这个例子我们再次看到，父子请求间的变量共享，实在不是一个好主意。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-6&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(5)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-5.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-5.html</id>
    <published>2018-12-24T09:31:16.333Z</published>
    <updated>2018-12-24T09:31:52.646Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-5<br><a id="more"></a><br>   </p><p>前面在 （二） 中我们已经了解到变量值容器的生命期是与请求绑定的，但是我当时有意避开了“请求”的正式定义。大家应当一直默认这里的“请求”都是指客户端发起的 HTTP 请求。其实在 Nginx 世界里有两种类型的“请求”，一种叫做“主请求”（main request），而另一种则叫做“子请求”（subrequest）。我们先来介绍一下它们。</p><p>所谓“主请求”，就是由 HTTP 客户端从 Nginx 外部发起的请求。我们前面见到的所有例子都只涉及到“主请求”，包括 （二） 中那两个使用 echo_exec 和 rewrite 指令发起“内部跳转”的例子。</p><p>而“子请求”则是由 Nginx 正在处理的请求在 Nginx 内部发起的一种级联请求。“子请求”在外观上很像 HTTP 请求，但实现上却和 HTTP 协议乃至网络通信一点儿关系都没有。它是 Nginx 内部的一种抽象调用，目的是为了方便用户把“主请求”的任务分解为多个较小粒度的“内部请求”，并发或串行地访问多个 location 接口，然后由这些 location 接口通力协作，共同完成整个“主请求”。当然，“子请求”的概念是相对的，任何一个“子请求”也可以再发起更多的“子子请求”，甚至可以玩递归调用（即自己调用自己）。当一个请求发起一个“子请求”的时候，按照 Nginx 的术语，习惯把前者称为后者的“父请求”（parent request）。值得一提的是，Apache 服务器中其实也有“子请求”的概念，所以来自 Apache 世界的读者对此应当不会感到陌生。</p><p>下面就来看一个使用了“子请求”的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        echo_location /foo;        echo_location /bar;    }    location /foo {        echo foo;    }    location /bar {        echo bar;    }</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>这里在 location /main 中，通过第三方 ngx_echo 模块的 echo_location 指令分别发起到 /foo 和 /bar 这两个接口的 GET 类型的“子请求”。由 echo_location 发起的“子请求”，其执行是按照配置书写的顺序串行处理的，即只有当 /foo 请求处理完毕之后，才会接着处理 /bar 请求。这两个“子请求”的输出会按执行顺序拼接起来，作为 /main 接口的最终输出：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/main'    foo    bar</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>我们看到，“子请求”方式的通信是在同一个虚拟主机内部进行的，所以 Nginx 核心在实现“子请求”的时候，就只调用了若干个 C 函数，完全不涉及任何网络或者 UNIX 套接字（socket）通信。我们由此可以看出“子请求”的执行效率是极高的。</p><p>回到先前对 Nginx 变量值容器的生命期的讨论，我们现在依旧可以说，它们的生命期是与当前请求相关联的。每个请求都有所有变量值容器的独立副本，只不过当前请求既可以是“主请求”，也可以是“子请求”。即便是父子请求之间，同名变量一般也不会相互干扰。让我们来通过一个小实验证明一下这个说法：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        set $var main;        echo_location /foo;        echo_location /bar;        echo "main: $var";    }    location /foo {        set $var foo;        echo "foo: $var";    }    location /bar {        set $var bar;        echo "bar: $var";    }</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>在这个例子中，我们分别在 /main，/foo 和 /bar 这三个 location 配置块中为同一名字的变量，$var，分别设置了不同的值并予以输出。特别地，我们在 /main 接口中，故意在调用过 /foo 和 /bar 这两个“子请求”之后，再输出它自己的 $var 变量的值。请求 /main 接口的结果是这样的：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/main'    foo: foo    bar: bar    main: main</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>显然，/foo 和 /bar 这两个“子请求”在处理过程中对变量 $var 各自所做的修改都丝毫没有影响到“主请求” /main. 于是这成功印证了“主请求”以及各个“子请求”都拥有不同的变量 $var 的值容器副本。</p><p>不幸的是，一些 Nginx 模块发起的“子请求”却会自动共享其“父请求”的变量值容器，比如第三方模块 ngx_auth_request. 下面是一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /main {        set $var main;        auth_request /sub;        echo "main: $var";    }    location /sub {        set $var sub;        echo "sub: $var";    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>这里我们在 /main 接口中先为 $var 变量赋初值 main，然后使用 ngx_auth_request 模块提供的配置指令 auth_request，发起一个到 /sub 接口的“子请求”，最后利用 echo 指令输出变量 $var 的值。而我们在 /sub 接口中则故意把 $var 变量的值改写成 sub. 访问 /main 接口的结果如下：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/main'    main: sub</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>我们看到，/sub 接口对 $var 变量值的修改影响到了主请求 /main. 所以 ngx_auth_request 模块发起的“子请求”确实是与其“父请求”共享一套 Nginx 变量的值容器。</p><p>对于上面这个例子，相信有读者会问：“为什么‘子请求’ /sub 的输出没有出现在最终的输出里呢？”答案很简单，那就是因为 auth_request 指令会自动忽略“子请求”的响应体，而只检查“子请求”的响应状态码。当状态码是 2XX 的时候，auth_request 指令会忽略“子请求”而让 Nginx 继续处理当前的请求，否则它就会立即中断当前（主）请求的执行，返回相应的出错页。在我们的例子中，/sub “子请求”只是使用 echo 指令作了一些输出，所以隐式地返回了指示正常的 200 状态码。</p><p>如 ngx_auth_request 模块这样父子请求共享一套 Nginx 变量的行为，虽然可以让父子请求之间的数据双向传递变得极为容易，但是对于足够复杂的配置，却也经常导致不少难于调试的诡异 bug. 因为用户时常不知道“父请求”的某个 Nginx 变量的值，其实已经在它的某个“子请求”中被意外修改了。诸如此类的因共享而导致的不好的“副作用”，让包括 ngx_echo，ngx_lua，以及 ngx_srcache 在内的许多第三方模块都选择了禁用父子请求间的变量共享。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-5&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(4)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-4.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-4.html</id>
    <published>2018-12-24T09:31:16.332Z</published>
    <updated>2018-12-24T09:31:52.647Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-4<br><a id="more"></a><br>   </p><p>在设置了“取处理程序”的情况下，Nginx 变量也可以选择将其值容器用作缓存，这样在多次读取变量的时候，就只需要调用“取处理程序”计算一次。我们下面就来看一个这样的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    map $args $foo {        default     0;        debug       1;    }    server {        listen 8080;        location /test {            set $orig_foo $foo;            set $args debug;            echo "orginal foo: $orig_foo";            echo "foo: $foo";        }    }</pre></div> </div><!-- [Format Time: 0.0006 seconds] --><p>这里首次用到了标准 ngx_map 模块的 map 配置指令，我们有必要在此介绍一下。map 在英文中除了“地图”之外，也有“映射”的意思。比方说，中学数学里讲的“函数”就是一种“映射”。而 Nginx 的这个 map 指令就可以用于定义两个 Nginx 变量之间的映射关系，或者说是函数关系。回到上面这个例子，我们用 map 指令定义了用户变量 $foo 与 $args 内建变量之间的映射关系。特别地，用数学上的函数记法 y = f(x) 来说，我们的 $args 就是“自变量” x，而 $foo 则是“因变量” y，即 $foo 的值是由 $args 的值来决定的，或者按照书写顺序可以说，我们将 $args 变量的值映射到了 $foo 变量上。</p><p>现在我们再来看 map 指令定义的映射规则：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    map $args $foo {        default     0;        debug       1;    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>花括号中第一行的 default 是一个特殊的匹配条件，即当其他条件都不匹配的时候，这个条件才匹配。当这个默认条件匹配时，就把“因变量” $foo 映射到值 0. 而花括号中第二行的意思是说，如果“自变量” $args 精确匹配了 debug 这个字符串，则把“因变量” $foo 映射到值 1. 将这两行合起来，我们就得到如下完整的映射规则：当 $args 的值等于 debug 的时候，$foo 变量的值就是 1，否则 $foo 的值就为 0.</p><p>明白了 map 指令的含义，再来看 location /test. 在那里，我们先把当前 $foo 变量的值保存在另一个用户变量 $orig_foo 中，然后再强行把 $args 的值改写为 debug，最后我们再用 echo 指令分别输出 $orig_foo 和 $foo 的值。</p><p>从逻辑上看，似乎当我们强行改写 $args 的值为 debug 之后，根据先前的 map 映射规则，$foo 变量此时的值应当自动调整为字符串 1, 而不论 $foo 原先的值是怎样的。然而测试结果并非如此：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test'    original foo: 0    foo: 0</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>第一行输出指示 $orig_foo 的值为 0，这正是我们期望的：上面这个请求并没有提供 URL 参数串，于是 $args 最初的取值就是空，再根据我们先前定义的映射规则，$foo 变量在第一次被读取时的值就应当是 0（即匹配默认的那个 default 条件）。</p><p>而第二行输出显示，在强行改写 $args 变量的值为字符串 debug 之后，$foo 的条件仍然是 0 ，这显然不符合映射规则，因为当 $args 为 debug 时，$foo 的值应当是 1. 这究竟是为什么呢？</p><p>其实原因很简单，那就是 $foo 变量在第一次读取时，根据映射规则计算出的值被缓存住了。刚才我们说过，Nginx 模块可以为其创建的变量选择使用值容器，作为其“取处理程序”计算结果的缓存。显然，ngx_map 模块认为变量间的映射计算足够昂贵，需要自动将因变量的计算结果缓存下来，这样在当前请求的处理过程中如果再次读取这个因变量，Nginx 就可以直接返回缓存住的结果，而不再调用该变量的“取处理程序”再行计算了。</p><p>为了进一步验证这一点，我们不妨在请求中直接指定 URL 参数串为 debug:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?debug'    original foo: 1    foo: 1</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，现在 $orig_foo 的值就成了 1，因为变量 $foo 在第一次被读取时，自变量 $args 的值就是 debug，于是按照映射规则，“取处理程序”计算返回的值便是 1. 而后续再读取 $foo 的值时，就总是得到被缓存住的 1 这个结果，而不论 $args 后来变成什么样了。</p><p>map 指令其实是一个比较特殊的例子，因为它可以为用户变量注册“取处理程序”，而且用户可以自己定义这个“取处理程序”的计算规则。当然，此规则在这里被限定为与另一个变量的映射关系。同时，也并非所有使用了“取处理程序”的变量都会缓存结果，例如我们前面在 （三） 中已经看到 $arg_XXX 并不会使用值容器进行缓存。</p><p>类似 ngx_map 模块，标准的 ngx_geo 等模块也一样使用了变量值的缓存机制。</p><p>在上面的例子中，我们还应当注意到 map 指令是在 server 配置块之外，也就是在最外围的 http 配置块中定义的。很多读者可能会对此感到奇怪，毕竟我们只是在 location /test 中用到了它。这倒不是因为我们不想把 map 语句直接挪到 location 配置块中，而是因为 map 指令只能在 http 块中使用！</p><p>很多 Nginx 新手都会担心如此“全局”范围的 map 设置会让访问所有虚拟主机的所有 location 接口的请求都执行一遍变量值的映射计算，然而事实并非如此。前面我们已经了解到 map 配置指令的工作原理是为用户变量注册 “取处理程序”，并且实际的映射计算是在“取处理程序”中完成的，而“取处理程序”只有在该用户变量被实际读取时才会执行（当然，因为缓存的存在，只在请求生命期中的第一次读取中才被执行），所以对于那些根本没有用到相关变量的请求来说，就根本不会执行任何的无用计算。</p><p>这种只在实际使用对象时才计算对象值的技术，在计算领域被称为“惰性求值”（lazy evaluation）。提供“惰性求值” 语义的编程语言并不多见，最经典的例子便是 Haskell. 与之相对的便是“主动求值” （eager evaluation）。我们有幸在 Nginx 中也看到了“惰性求值”的例子，但“主动求值”语义其实在 Nginx 里面更为常见，例如下面这行再普通不过的 set 语句：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    set $b "$a,$a";</pre></div> </div><!-- [Format Time: 0.0001 seconds] --><p>这里会在执行 set 规定的赋值操作时，“主动”地计算出变量 $b 的值，而不会将该求值计算延缓到变量 $b 实际被读取的时候。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-4&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(3)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-3.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-3.html</id>
    <published>2018-12-24T09:31:16.331Z</published>
    <updated>2018-12-24T09:31:52.662Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-3<br><a id="more"></a><br>   </p><p>也有一些内建变量是支持改写的，其中一个例子是 $args. 这个变量在读取时返回当前请求的 URL 参数串（即请求 URL 中问号后面的部分，如果有的话 ），而在赋值时可以直接修改参数串。我们来看一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        set $orig_args $args;        set $args "a=3&amp;b=4";        echo "original args: $orig_args";        echo "args: $args";    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>这里我们把原始的 URL 参数串先保存在 $orig_args 变量中，然后通过改写 $args 变量来修改当前的 URL 参数串，最后我们用 echo 指令分别输出 $orig_args 和 $args 变量的值。接下来我们这样来测试这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test'    original args:    args: a=3&amp;b=4    $ curl 'http://localhost:8080/test?a=0&amp;b=1&amp;c=2'    original args: a=0&amp;b=1&amp;c=2    args: a=3&amp;b=4</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>在第一次测试中，我们没有设置任何 URL 参数串，所以输出 $orig_args 变量的值时便得到空。而在第一次和第二次测试中，无论我们是否提供 URL 参数串，参数串都会在 location /test 中被强行改写成 a=3&amp;b=4.</p><p>需要特别指出的是，这里的 $args 变量和 $arg_XXX 一样，也不再使用属于自己的存放值的容器。当我们读取 $args 时，Nginx 会执行一小段代码，从 Nginx 核心中专门存放当前 URL 参数串的位置去读取数据；而当我们改写 $args 时，Nginx 会执行另一小段代码，对相同位置进行改写。Nginx 的其他部分在需要当前 URL 参数串的时候，都会从那个位置去读数据，所以我们对 $args 的修改会影响到所有部分的功能。我们来看一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        set $orig_a $arg_a;        set $args "a=5";        echo "original a: $orig_a";        echo "a: $arg_a";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>这里我们先把内建变量 $arg_a 的值，即原始请求的 URL 参数 a 的值，保存在用户变量 $orig_a 中，然后通过对内建变量 $args 进行赋值，把当前请求的参数串改写为 a=5 ，最后再用 echo 指令分别输出 $orig_a 和 $arg_a 变量的值。因为对内建变量 $args 的修改会直接导致当前请求的 URL 参数串发生变化，因此内建变量 $arg_XXX 自然也会随之变化。测试的结果证实了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?a=3'    original a: 3    a: 5</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，因为原始请求的 URL 参数串是 a=3, 所以 $arg_a 最初的值为 3, 但随后通过改写 $args 变量，将 URL 参数串又强行修改为 a=5, 所以最终 $arg_a 的值又自动变为了 5.</p><p>我们再来看一个通过修改 $args 变量影响标准的 HTTP 代理模块 ngx_proxy 的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    server {        listen 8080;        location /test {            set $args "foo=1&amp;bar=2";            proxy_pass http://127.0.0.1:8081/args;        }    }    server {        listen 8081;        location /args {            echo "args: $args";        }    }</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>这里我们在 http 配置块中定义了两个虚拟主机。第一个虚拟主机监听 8080 端口，其 /test 接口自己通过改写 $args 变量，将当前请求的 URL 参数串无条件地修改为 foo=1&amp;bar=2. 然后 /test 接口再通过 ngx_proxy 模块的 proxy_pass 指令配置了一个反向代理，指向本机的 8081 端口上的 HTTP 服务 /args. 默认情况下，ngx_proxy 模块在转发 HTTP 请求到远方 HTTP 服务的时候，会自动把当前请求的 URL 参数串也转发到远方。</p><p>而本机的 8081 端口上的 HTTP 服务正是由我们定义的第二个虚拟主机来提供的。我们在第二个虚拟主机的 location /args 中利用 echo 指令输出当前请求的 URL 参数串，以检查 /test 接口通过 ngx_proxy 模块实际转发过来的 URL 请求参数串。</p><p>我们来实际访问一下第一个虚拟主机的 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?blah=7'    args: foo=1&amp;bar=2</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>我们看到，虽然请求自己提供了 URL 参数串 blah=7，但在 location /test 中，参数串被强行改写成了 foo=1&amp;bar=2. 接着经由 proxy_pass 指令将我们被改写掉的参数串转发给了第二个虚拟主机上配置的 /args 接口，然后再把 /args 接口的 URL 参数串输出。事实证明，我们对 $args 变量的赋值操作，也成功影响到了 ngx_proxy 模块的行为。</p><p>在读取变量时执行的这段特殊代码，在 Nginx 中被称为“取处理程序”（get handler）；而改写变量时执行的这段特殊代码，则被称为“存处理程序”（set handler）。不同的 Nginx 模块一般会为它们的变量准备不同的“存取处理程序”，从而让这些变量的行为充满魔法。</p><p>其实这种技巧在计算世界并不鲜见。比如在面向对象编程中，类的设计者一般不会把类的成员变量直接暴露给类的用户，而是另行提供两个方法（method），分别用于该成员变量的读操作和写操作，这两个方法常常被称为“存取器”（accessor）。下面是 C++ 语言中的一个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    #include <string>    using namespace std;    class Person {    public:        const string get_name() {            return m_name;        }        void set_name(const string name) {            m_name = name;        }    private:        string m_name;    };</string></pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>在这个名叫 Person 的 C++ 类中，我们提供了 get_name 和 set_name 这两个公共方法，以作为私有成员变量 m_name 的“存取器”。</p><p>这样设计的好处是显而易见的。类的设计者可以在“存取器”中执行任意代码，以实现所需的业务逻辑以及“副作用”，比如自动更新与当前成员变量存在依赖关系的其他成员变量，抑或是直接修改某个与当前对象相关联的数据库表中的对应字段。而对于后一种情况，也许“存取器”所对应的成员变量压根就不存在，或者即使存在，也顶多扮演着数据缓存的角色，以缓解被代理数据库的访问压力。</p><p>与面向对象编程中的“存取器”概念相对应，Nginx 变量也是支持绑定“存取处理程序”的。Nginx 模块在创建变量时，可以选择是否为变量分配存放值的容器，以及是否自己提供与读写操作相对应的“存取处理程序”。</p><p>不是所有的 Nginx 变量都拥有存放值的容器。拥有值容器的变量在 Nginx 核心中被称为“被索引的”（indexed）；反之，则被称为“未索引的”（non-indexed）。</p><p>我们前面在 （二） 中已经知道，像 $arg_XXX 这样具有无数变种的变量群，是“未索引的”。当读取这样的变量时，其实是它的“取处理程序”在起作用，即实时扫描当前请求的 URL 参数串，提取出变量名所指定的 URL 参数的值。很多新手都会对 $arg_XXX 的实现方式产生误解，以为 Nginx 会事先解析好当前请求的所有 URL 参数，并且把相关的 $arg_XXX 变量的值都事先设置好。然而事实并非如此，Nginx 根本不会事先就解析好 URL 参数串，而是在用户读取某个 $arg_XXX 变量时，调用其“取处理程序”，即时去扫描 URL 参数串。类似地，内建变量 $cookie_XXX 也是通过它的“取处理程序”，即时去扫描 Cookie 请求头中的相关定义的。</p><p>想了解请看nginx变量使用方法详解2，下一篇nginx变量使用方法详解4</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-3&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx变量使用方法详解(2)-nginx案例</title>
    <link href="http://nginx.im/nginx/nginx/nginx-var-2.html"/>
    <id>http://nginx.im/nginx/nginx/nginx-var-2.html</id>
    <published>2018-12-24T09:31:16.329Z</published>
    <updated>2018-12-24T09:31:52.661Z</updated>
    
    <content type="html"><![CDATA[<p>nginx,nginx-var-2,<br><a id="more"></a><br>   </p><p>关于 Nginx 变量的另一个常见误区是认为变量容器的生命期，是与 location 配置块绑定的。其实不然。我们来看一个涉及“内部跳转”的例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    server {        listen 8080;        location /foo {            set $a hello;            echo_exec /bar;        }        location /bar {            echo "a = [$a]";        }    }</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>这里我们在 location /foo 中，使用第三方模块 ngx_echo 提供的 echo_exec 配置指令，发起到 location /bar 的“内部跳转”。所谓“内部跳转”，就是在处理请求的过程中，于服务器内部，从一个 location 跳转到另一个 location 的过程。这不同于利用 HTTP 状态码 301 和 302 所进行的“外部跳转”，因为后者是由 HTTP 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 URL 地址发生了变化。内部跳转和 Bourne Shell（或 Bash）中的 exec 命令很像，都是“有去无回”。另一个相近的例子是 C 语言中的 goto 语句。</p><p>既然是内部跳转，当前正在处理的请求就还是原来那个，只是当前的 location 发生了变化，所以还是原来的那一套 Nginx 变量的容器副本。对应到上例，如果我们请求的是 /foo 这个接口，那么整个工作流程是这样的：先在 location /foo 中通过 set 指令将 $a 变量的值赋为字符串 hello，然后通过 echo_exec 指令发起内部跳转，又进入到 location /bar 中，再输出 $a 变量的值。因为 $a 还是原来的 $a，所以我们可以期望得到 hello 这行输出。测试证实了这一点：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>$ curl localhost:8080/fooa = [hello]</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>但如果我们从客户端直接访问 /bar 接口，就会得到空的 $a 变量的值，因为它依赖于 location /foo 来对 $a 进行初始化。</p><p>从上面这个例子我们看到，一个请求在其处理过程中，即使经历多个不同的 location 配置块，它使用的还是同一套 Nginx 变量的副本。这里，我们也首次涉及到了“内部跳转”这个概念。值得一提的是，标准 ngx_rewrite 模块的 rewrite 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 rewrite 配置指令可以改写成下面这样的形式：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    server {        listen 8080;        location /foo {            set $a hello;            rewrite ^ /bar;        }        location /bar {            echo "a = [$a]";        }    }</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>其效果和使用 echo_exec 是完全相同的。后面我们还会专门介绍这个 rewrite 指令的更多用法，比如发起 301 和 302 这样的“外部跳转”。</p><p>从上面这个例子我们看到，Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 location 无关。</p><p>前面我们接触到的都是通过 set 指令隐式创建的 Nginx 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。既然有“用户自定义变量”，自然也就有由 Nginx 核心和各个 Nginx 模块提供的“预定义变量”，或者说“内建变量”（builtin variables）。</p><p>Nginx 内建变量最常见的用途就是获取关于请求或响应的各种信息。例如由 ngx_http_core 模块提供的内建变量 $uri，可以用来获取当前请求的 URI（经过解码，并且不含请求参数），而 $request_uri 则用来获取请求最原始的 URI （未经解码，并且包含请求参数）。请看下面这个例子：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        echo "uri = $uri";        echo "request_uri = $request_uri";    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这里为了简单起见，连 server 配置块也省略了，和前面所有示例一样，我们监听的依然是 8080 端口。在这个例子里，我们把 $uri 和 $request_uri 的值输出到响应体中去。下面我们用不同的请求来测试一下这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>$ curl 'http://localhost:8080/test'uri = /testrequest_uri = /test$ curl 'http://localhost:8080/test?a=3&amp;b=4'uri = /testrequest_uri = /test?a=3&amp;b=4$ curl 'http://localhost:8080/test/hello%20world?a=3&amp;b=4'uri = /test/hello worldrequest_uri = /test/hello%20world?a=3&amp;b=4</pre></div> </div><!-- [Format Time: 0.0005 seconds] --><p>另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 arg_ 开头的所有变量，我们估且称之为 $arg_XXX 变量群。一个例子是 $arg_name，这个变量的值是当前请求名为 name 的 URI 参数的值，而且还是未解码的原始形式的值。我们来看一个比较完整的示例：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        echo "name: $arg_name";        echo "class: $arg_class";    }</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>然后在命令行上使用各种参数组合去请求这个 /test 接口：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test'    name:     class:     $ curl 'http://localhost:8080/test?name=Tom&amp;class=3'    name: Tom    class: 3    $ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'    name: hello%20world    class: 9</pre></div> </div><!-- [Format Time: 0.0004 seconds] --><p>其实 $arg_name 不仅可以匹配 name 参数，也可以匹配 NAME 参数，抑或是 Name，等等：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?NAME=Marry'    name: Marry    class:     $ curl 'http://localhost:8080/test?Name=Jimmy'    name: Jimmy    class:</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>Nginx 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式。</p><p>如果你想对 URI 参数值中的 %XX 这样的编码序列进行解码，可以使用第三方 ngx_set_misc 模块提供的 set_unescape_uri 配置指令：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    location /test {        set_unescape_uri $name $arg_name;        set_unescape_uri $class $arg_class;        echo "name: $name";        echo "class: $class";    }</pre></div> </div><!-- [Format Time: 0.0003 seconds] --><p>现在我们再看一下效果：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>$ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'name: hello worldclass: 9</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>空格果然被解码出来了！</p><p>从这个例子我们同时可以看到，这个 set_unescape_uri 指令也像 set 指令那样，拥有自动创建 Nginx 变量的功能。后面我们还会专门介绍到 ngx_set_misc 模块。</p><p>像 $arg_XXX 这种类型的变量拥有无穷无尽种可能的名字，所以它们并不对应任何存放值的容器。而且这种变量在 Nginx 核心中是经过特别处理的，第三方 Nginx 模块是不能提供这样充满魔法的内建变量的。</p><p>类似 $arg_XXX 的内建变量还有不少，比如用来取 cookie 值的 $cookie_XXX 变量群，用来取请求头的 $http_XXX 变量群，以及用来取响应头的 $sent_http_XXX 变量群。这里就不一一介绍了，感兴趣的读者可以参考 ngx_http_core 模块的官方文档。</p><p>需要指出的是，许多内建变量都是只读的，比如我们刚才介绍的 $uri 和 $request_uri. 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>    $ curl 'http://localhost:8080/test?name=hello%20world&amp;class=9'    name: hello world    class: 9</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>这个有问题的配置会让 Nginx 在启动的时候报出一条令人匪夷所思的错误：</p><!-- Crayon Syntax Highlighter v_2.7.2_beta --><div><div><pre>[emerg] the duplicate "uri" variable in ...</pre></div> </div><!-- [Format Time: 0.0002 seconds] --><p>如果你尝试改写另外一些只读的内建变量，比如 $arg_XXX 变量，在某些 Nginx 的版本中甚至可能导致进程崩溃。</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx,nginx-var-2,&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx案例" scheme="http://nginx.im/categories/nginx%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="nginx" scheme="http://nginx.im/tags/nginx/"/>
    
  </entry>
  
</feed>
